# Automatically generated by Zserio Python extension version 2.12.0.
# Generator setup: writerCode, pubsubCode, serviceCode, sqlCode

from __future__ import annotations

import typing
import zserio

class GuidanceNameClass(zserio.Enum):
    CITY_BLOCK = 0
    COUNTY = 1
    COUNTRY = 2
    COUNTRY_SET = 3
    HAMLET = 4
    HOUSE = 5
    INTERSECTION = 6
    LICENSE_PLATE_ZONE = 7
    MUNICIPALITY = 8
    MUNICIPALITY_SUBDIVISION = 9
    NAMED_AREA = 10
    NAMED_BRIDGE = 11
    NAMED_TUNNEL = 12
    NEIGHBORHOOD = 13
    POSTAL_CODE_DISTRICT = 14
    PREFERRED_POSTAL_PLACE = 15
    POI = 16
    ROAD = 17
    ROAD_NUMBER = 18
    ROUTE = 19
    SIGNPOST = 20
    SUB_COUNTRY = 21
    SUB_COUNTRY_SET = 22
    TOLL_GATE = 23
    TOURIST_ROUTE = 24
    TRAFFIC_ZONE = 25
    ZONE = 26

    @classmethod
    def from_name(cls: typing.Type['GuidanceNameClass'], item_name: str) -> 'GuidanceNameClass':
        if item_name == 'CITY_BLOCK':
            item = GuidanceNameClass.CITY_BLOCK
        elif item_name == 'COUNTY':
            item = GuidanceNameClass.COUNTY
        elif item_name == 'COUNTRY':
            item = GuidanceNameClass.COUNTRY
        elif item_name == 'COUNTRY_SET':
            item = GuidanceNameClass.COUNTRY_SET
        elif item_name == 'HAMLET':
            item = GuidanceNameClass.HAMLET
        elif item_name == 'HOUSE':
            item = GuidanceNameClass.HOUSE
        elif item_name == 'INTERSECTION':
            item = GuidanceNameClass.INTERSECTION
        elif item_name == 'LICENSE_PLATE_ZONE':
            item = GuidanceNameClass.LICENSE_PLATE_ZONE
        elif item_name == 'MUNICIPALITY':
            item = GuidanceNameClass.MUNICIPALITY
        elif item_name == 'MUNICIPALITY_SUBDIVISION':
            item = GuidanceNameClass.MUNICIPALITY_SUBDIVISION
        elif item_name == 'NAMED_AREA':
            item = GuidanceNameClass.NAMED_AREA
        elif item_name == 'NAMED_BRIDGE':
            item = GuidanceNameClass.NAMED_BRIDGE
        elif item_name == 'NAMED_TUNNEL':
            item = GuidanceNameClass.NAMED_TUNNEL
        elif item_name == 'NEIGHBORHOOD':
            item = GuidanceNameClass.NEIGHBORHOOD
        elif item_name == 'POSTAL_CODE_DISTRICT':
            item = GuidanceNameClass.POSTAL_CODE_DISTRICT
        elif item_name == 'PREFERRED_POSTAL_PLACE':
            item = GuidanceNameClass.PREFERRED_POSTAL_PLACE
        elif item_name == 'POI':
            item = GuidanceNameClass.POI
        elif item_name == 'ROAD':
            item = GuidanceNameClass.ROAD
        elif item_name == 'ROAD_NUMBER':
            item = GuidanceNameClass.ROAD_NUMBER
        elif item_name == 'ROUTE':
            item = GuidanceNameClass.ROUTE
        elif item_name == 'SIGNPOST':
            item = GuidanceNameClass.SIGNPOST
        elif item_name == 'SUB_COUNTRY':
            item = GuidanceNameClass.SUB_COUNTRY
        elif item_name == 'SUB_COUNTRY_SET':
            item = GuidanceNameClass.SUB_COUNTRY_SET
        elif item_name == 'TOLL_GATE':
            item = GuidanceNameClass.TOLL_GATE
        elif item_name == 'TOURIST_ROUTE':
            item = GuidanceNameClass.TOURIST_ROUTE
        elif item_name == 'TRAFFIC_ZONE':
            item = GuidanceNameClass.TRAFFIC_ZONE
        elif item_name == 'ZONE':
            item = GuidanceNameClass.ZONE
        else:
            raise zserio.PythonRuntimeException(f"Enum item '{item_name}' doesn't exist in enum 'GuidanceNameClass'!")

        return item

    @classmethod
    def from_reader(cls: typing.Type['GuidanceNameClass'], reader: zserio.BitStreamReader) -> 'GuidanceNameClass':
        return cls(reader.read_bits(8))

    @classmethod
    def from_reader_packed(cls: typing.Type['GuidanceNameClass'],
                           delta_context: zserio.array.DeltaContext,
                           reader: zserio.BitStreamReader) -> 'GuidanceNameClass':
        return cls(delta_context.read(zserio.array.BitFieldArrayTraits(8),
                                      reader))

    def __hash__(self) -> int:
        result = zserio.hashcode.HASH_SEED
        result = zserio.hashcode.calc_hashcode_int32(result, self.value)
        return result

    @staticmethod
    def create_packing_context() -> zserio.array.DeltaContext:
        return zserio.array.DeltaContext()

    def init_packing_context(self, delta_context: zserio.array.DeltaContext) -> None:
        delta_context.init(zserio.array.BitFieldArrayTraits(8),
                           self.value)

    def bitsizeof(self, _bitposition: int = 0) -> int:
        return 8

    def bitsizeof_packed(self, delta_context: zserio.array.DeltaContext, _bitposition: int) -> int:
        return delta_context.bitsizeof(zserio.array.BitFieldArrayTraits(8),
                                       self.value)

    def initialize_offsets(self, bitposition: int = 0) -> int:
        return bitposition + self.bitsizeof(bitposition)

    def initialize_offsets_packed(self, delta_context: zserio.array.DeltaContext, bitposition: int) -> int:
        return bitposition + self.bitsizeof_packed(delta_context, bitposition)

    def write(self, writer: zserio.BitStreamWriter) -> None:
        writer.write_bits(self.value, 8)

    def write_packed(self, delta_context: zserio.array.DeltaContext, writer: zserio.BitStreamWriter) -> None:
        delta_context.write(zserio.array.BitFieldArrayTraits(8), writer, self.value)
