# Automatically generated by Zserio Python extension version 2.12.0.
# Generator setup: writerCode, pubsubCode, serviceCode, sqlCode

from __future__ import annotations

import typing
import apsw

import nds.smart.filestore.smart_layer_metadata_table
import nds.smart.filestore.smart_layer_tile_table

class SmartLayerTileStore:
    def __init__(self, connection: apsw.Connection, table_to_attached_db_name_relocation_map: typing.Dict[str, str] = None) -> None:
        self._connection: apsw.Connection = connection
        self._attached_db_name_list: typing.Union[typing.List[str], typing.ValuesView[str]] = []
        self._is_external: bool = True
        self._init_tables(table_to_attached_db_name_relocation_map if table_to_attached_db_name_relocation_map else {})

    @classmethod
    def from_file(cls: typing.Type['SmartLayerTileStore'], filename: str, table_to_db_filename_relocation_map: typing.Dict[str, str] = None) -> 'SmartLayerTileStore':
        connection = apsw.Connection(filename, apsw.SQLITE_OPEN_URI | apsw.SQLITE_OPEN_READWRITE | apsw.SQLITE_OPEN_CREATE)

        table_name_to_attached_db_name_map: typing.Dict[str, str] = {}
        db_filename_to_attached_db_name_map: typing.Dict[str, str] = {}
        if table_to_db_filename_relocation_map:
            cursor = connection.cursor()
            for relocated_table_name, db_filename in table_to_db_filename_relocation_map.items():
                attached_db_name = db_filename_to_attached_db_name_map.get(db_filename)
                if attached_db_name is None:
                    attached_db_name = cls.DATABASE_NAME + "_" + relocated_table_name
                    cls._attach_database(cursor, db_filename, attached_db_name)
                    db_filename_to_attached_db_name_map[db_filename] = attached_db_name

                table_name_to_attached_db_name_map[relocated_table_name] = attached_db_name

        instance = cls(connection, table_name_to_attached_db_name_map)
        instance._attached_db_name_list = db_filename_to_attached_db_name_map.values()
        instance._is_external = False

        return instance

    def close(self) -> None:
        if not self._is_external:
            try:
                self._detach_databases()
            finally:
                self._connection.close()
        self._connection = None

    @property
    def metadata_table(self) -> nds.smart.filestore.smart_layer_metadata_table.SmartLayerMetadataTable:
        return self._metadata_table_

    @property
    def tile_table(self) -> nds.smart.filestore.smart_layer_tile_table.SmartLayerTileTable:
        return self._tile_table_

    @property
    def connection(self) -> apsw.Connection:
        return self._connection

    def create_schema(self) -> None:
        has_autocommit = self._connection.getautocommit()
        if has_autocommit:
            cursor = self._connection.cursor()
            cursor.execute("BEGIN")

        self._metadata_table_.create_table()
        self._tile_table_.create_table()

        if has_autocommit:
            cursor.execute("COMMIT")

    def delete_schema(self) -> None:
        has_autocommit = self._connection.getautocommit()
        if has_autocommit:
            cursor = self._connection.cursor()
            cursor.execute("BEGIN")

        self._metadata_table_.delete_table()
        self._tile_table_.delete_table()

        if has_autocommit:
            cursor.execute("COMMIT")

    def _init_tables(self, table_name_to_attached_db_name_map: typing.Dict[str, str]) -> None:
        self._metadata_table_ = nds.smart.filestore.smart_layer_metadata_table.SmartLayerMetadataTable(
            self._connection, self.TABLE_NAME_METADATA_TABLE, table_name_to_attached_db_name_map.get(self.TABLE_NAME_METADATA_TABLE))
        self._tile_table_ = nds.smart.filestore.smart_layer_tile_table.SmartLayerTileTable(
            self._connection, self.TABLE_NAME_TILE_TABLE, table_name_to_attached_db_name_map.get(self.TABLE_NAME_TILE_TABLE))

    @staticmethod
    def _attach_database(cursor: typing.Any, db_filename: str, db_name: str) -> None:
        sql_query = "ATTACH DATABASE '"
        sql_query += db_filename
        sql_query += "' AS "
        sql_query += db_name
        cursor.execute(sql_query)

    def _detach_databases(self) -> None:
        for attached_db_name in self._attached_db_name_list:
            sql_query = "DETACH DATABASE " + attached_db_name
            cursor = self._connection.cursor()
            cursor.execute(sql_query)

    DATABASE_NAME = "SmartLayerTileStore"
    TABLE_NAME_METADATA_TABLE = "metadataTable"
    TABLE_NAME_TILE_TABLE = "tileTable"
