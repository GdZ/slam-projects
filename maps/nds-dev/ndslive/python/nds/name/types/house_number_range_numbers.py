# Automatically generated by Zserio Python extension version 2.12.0.
# Generator setup: writerCode, pubsubCode, serviceCode, sqlCode

from __future__ import annotations

import typing
import zserio

import nds.name.types.house_number
import nds.name.types.house_number_numeric
import nds.name.types.house_number_numeric_range
import nds.name.types.house_number_type

class HouseNumberRangeNumbers:
    def __init__(
            self,
            type_: nds.name.types.house_number_type.HouseNumberType,
            *,
            house_number_range_even_odd_: typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None] = None,
            house_number_range_even_odd_pattern_: typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None] = None,
            house_number_range_continuous_: typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None] = None,
            house_number_range_continuous_pattern_: typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None] = None,
            house_number_numeric_: typing.Union[typing.List[nds.name.types.house_number_numeric.HouseNumberNumeric], None] = None,
            house_number_: typing.Union[typing.List[nds.name.types.house_number.HouseNumber], None] = None) -> None:
        self._type_ = type_
        self._choice: typing.Any = None
        if house_number_range_even_odd_ is not None:
            self._choice = house_number_range_even_odd_
        if house_number_range_even_odd_pattern_ is not None:
            if self._choice != None:
                raise zserio.PythonRuntimeException("Calling constructor of choice HouseNumberRangeNumbers is ambiguous!")
            self._choice = house_number_range_even_odd_pattern_
        if house_number_range_continuous_ is not None:
            if self._choice != None:
                raise zserio.PythonRuntimeException("Calling constructor of choice HouseNumberRangeNumbers is ambiguous!")
            self._choice = house_number_range_continuous_
        if house_number_range_continuous_pattern_ is not None:
            if self._choice != None:
                raise zserio.PythonRuntimeException("Calling constructor of choice HouseNumberRangeNumbers is ambiguous!")
            self._choice = house_number_range_continuous_pattern_
        if house_number_numeric_ is not None:
            if self._choice != None:
                raise zserio.PythonRuntimeException("Calling constructor of choice HouseNumberRangeNumbers is ambiguous!")
            self._choice = zserio.array.Array(zserio.array.VarUInt32ArrayTraits(), house_number_numeric_, is_auto=True)
        if house_number_ is not None:
            if self._choice != None:
                raise zserio.PythonRuntimeException("Calling constructor of choice HouseNumberRangeNumbers is ambiguous!")
            self._choice = zserio.array.Array(zserio.array.StringArrayTraits(), house_number_, is_auto=True)

    @classmethod
    def from_reader(
            cls: typing.Type['HouseNumberRangeNumbers'],
            zserio_reader: zserio.BitStreamReader,
            type_: nds.name.types.house_number_type.HouseNumberType) -> 'HouseNumberRangeNumbers':
        self = object.__new__(cls)
        self._type_ = type_

        self.read(zserio_reader)

        return self

    @classmethod
    def from_reader_packed(
            cls: typing.Type['HouseNumberRangeNumbers'],
            zserio_context: HouseNumberRangeNumbers.ZserioPackingContext,
            zserio_reader: zserio.BitStreamReader,
            type_: nds.name.types.house_number_type.HouseNumberType) -> 'HouseNumberRangeNumbers':
        self = object.__new__(cls)
        self._type_ = type_

        self.read_packed(zserio_context, zserio_reader)

        return self

    def __eq__(self, other: object) -> bool:
        if isinstance(other, HouseNumberRangeNumbers):
            return (self._type_ == other._type_ and
                    self._choice == other._choice)

        return False

    def __hash__(self) -> int:
        result = zserio.hashcode.HASH_SEED
        result = zserio.hashcode.calc_hashcode_object(result, self._type_)
        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            result = zserio.hashcode.calc_hashcode_object(result, self._choice)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            result = zserio.hashcode.calc_hashcode_object(result, self._choice)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            result = zserio.hashcode.calc_hashcode_object(result, self._choice)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            result = zserio.hashcode.calc_hashcode_object(result, self._choice)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            result = zserio.hashcode.calc_hashcode_object(result, self._choice)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            result = zserio.hashcode.calc_hashcode_object(result, self._choice)
        else:
            pass

        return result

    @property
    def type(self) -> nds.name.types.house_number_type.HouseNumberType:
        return self._type_

    @property
    def house_number_range_even_odd(self) -> typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None]:
        return self._choice

    @house_number_range_even_odd.setter
    def house_number_range_even_odd(self, house_number_range_even_odd_: typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None]) -> None:
        self._choice = house_number_range_even_odd_

    @property
    def house_number_range_even_odd_pattern(self) -> typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None]:
        return self._choice

    @house_number_range_even_odd_pattern.setter
    def house_number_range_even_odd_pattern(self, house_number_range_even_odd_pattern_: typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None]) -> None:
        self._choice = house_number_range_even_odd_pattern_

    @property
    def house_number_range_continuous(self) -> typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None]:
        return self._choice

    @house_number_range_continuous.setter
    def house_number_range_continuous(self, house_number_range_continuous_: typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None]) -> None:
        self._choice = house_number_range_continuous_

    @property
    def house_number_range_continuous_pattern(self) -> typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None]:
        return self._choice

    @house_number_range_continuous_pattern.setter
    def house_number_range_continuous_pattern(self, house_number_range_continuous_pattern_: typing.Union[nds.name.types.house_number_numeric_range.HouseNumberNumericRange, None]) -> None:
        self._choice = house_number_range_continuous_pattern_

    @property
    def house_number_numeric(self) -> typing.List[nds.name.types.house_number_numeric.HouseNumberNumeric]:
        return self._choice.raw_array

    @house_number_numeric.setter
    def house_number_numeric(self, house_number_numeric_: typing.List[nds.name.types.house_number_numeric.HouseNumberNumeric]) -> None:
        self._choice = zserio.array.Array(zserio.array.VarUInt32ArrayTraits(), house_number_numeric_, is_auto=True)

    @property
    def house_number(self) -> typing.List[nds.name.types.house_number.HouseNumber]:
        return self._choice.raw_array

    @house_number.setter
    def house_number(self, house_number_: typing.List[nds.name.types.house_number.HouseNumber]) -> None:
        self._choice = zserio.array.Array(zserio.array.StringArrayTraits(), house_number_, is_auto=True)

    @property
    def choice_tag(self) -> int:
        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            return self.CHOICE_HOUSE_NUMBER_RANGE_EVEN_ODD
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            return self.CHOICE_HOUSE_NUMBER_RANGE_EVEN_ODD_PATTERN
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            return self.CHOICE_HOUSE_NUMBER_RANGE_CONTINUOUS
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            return self.CHOICE_HOUSE_NUMBER_RANGE_CONTINUOUS_PATTERN
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            return self.CHOICE_HOUSE_NUMBER_NUMERIC
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            return self.CHOICE_HOUSE_NUMBER
        else:
            return self.UNDEFINED_CHOICE

    def init_packing_context(self, zserio_context: HouseNumberRangeNumbers.ZserioPackingContext) -> None:
        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            self._choice.init_packing_context(zserio_context.house_number_range_even_odd)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            self._choice.init_packing_context(zserio_context.house_number_range_even_odd_pattern)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            self._choice.init_packing_context(zserio_context.house_number_range_continuous)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            self._choice.init_packing_context(zserio_context.house_number_range_continuous_pattern)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            pass
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            pass
        else:
            raise zserio.PythonRuntimeException("No match in choice HouseNumberRangeNumbers!")

    def bitsizeof(self, bitposition: int = 0) -> int:
        end_bitposition = bitposition

        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            end_bitposition += self._choice.bitsizeof(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            end_bitposition += self._choice.bitsizeof(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            end_bitposition += self._choice.bitsizeof(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            end_bitposition += self._choice.bitsizeof(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            end_bitposition += self._choice.bitsizeof(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            end_bitposition += self._choice.bitsizeof(end_bitposition)
        else:
            raise zserio.PythonRuntimeException("No match in choice HouseNumberRangeNumbers!")

        return end_bitposition - bitposition

    def bitsizeof_packed(self, zserio_context: HouseNumberRangeNumbers.ZserioPackingContext,
                         bitposition: int = 0) -> int:
        end_bitposition = bitposition

        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            end_bitposition += self._choice.bitsizeof_packed(zserio_context.house_number_range_even_odd, end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            end_bitposition += self._choice.bitsizeof_packed(zserio_context.house_number_range_even_odd_pattern, end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            end_bitposition += self._choice.bitsizeof_packed(zserio_context.house_number_range_continuous, end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            end_bitposition += self._choice.bitsizeof_packed(zserio_context.house_number_range_continuous_pattern, end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            end_bitposition += self._choice.bitsizeof_packed(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            end_bitposition += self._choice.bitsizeof(end_bitposition)
        else:
            raise zserio.PythonRuntimeException("No match in choice HouseNumberRangeNumbers!")

        return end_bitposition - bitposition

    def initialize_offsets(self, bitposition: int = 0) -> int:
        end_bitposition = bitposition

        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            end_bitposition = self._choice.initialize_offsets(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            end_bitposition = self._choice.initialize_offsets(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            end_bitposition = self._choice.initialize_offsets(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            end_bitposition = self._choice.initialize_offsets(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            end_bitposition = self._choice.initialize_offsets(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            end_bitposition = self._choice.initialize_offsets(end_bitposition)
        else:
            raise zserio.PythonRuntimeException("No match in choice HouseNumberRangeNumbers!")

        return end_bitposition

    def initialize_offsets_packed(self, zserio_context: HouseNumberRangeNumbers.ZserioPackingContext,
                                  bitposition: int) -> int:
        end_bitposition = bitposition

        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            end_bitposition = self._choice.initialize_offsets_packed(zserio_context.house_number_range_even_odd, end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            end_bitposition = self._choice.initialize_offsets_packed(zserio_context.house_number_range_even_odd_pattern, end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            end_bitposition = self._choice.initialize_offsets_packed(zserio_context.house_number_range_continuous, end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            end_bitposition = self._choice.initialize_offsets_packed(zserio_context.house_number_range_continuous_pattern, end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            end_bitposition = self._choice.initialize_offsets_packed(end_bitposition)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            end_bitposition = self._choice.initialize_offsets(end_bitposition)
        else:
            raise zserio.PythonRuntimeException("No match in choice HouseNumberRangeNumbers!")

        return end_bitposition

    def read(self, zserio_reader: zserio.BitStreamReader) -> None:
        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            self._choice = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.from_reader(zserio_reader, False, True)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            self._choice = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.from_reader(zserio_reader, True, True)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            self._choice = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.from_reader(zserio_reader, False, False)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            self._choice = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.from_reader(zserio_reader, True, False)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            self._choice = zserio.array.Array.from_reader(zserio.array.VarUInt32ArrayTraits(), zserio_reader, is_auto=True)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            self._choice = zserio.array.Array.from_reader(zserio.array.StringArrayTraits(), zserio_reader, is_auto=True)
        else:
            raise zserio.PythonRuntimeException("No match in choice HouseNumberRangeNumbers!")

    def read_packed(self, zserio_context: HouseNumberRangeNumbers.ZserioPackingContext,
                    zserio_reader: zserio.BitStreamReader) -> None:
        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            self._choice = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.from_reader_packed(zserio_context.house_number_range_even_odd, zserio_reader, False, True)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            self._choice = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.from_reader_packed(zserio_context.house_number_range_even_odd_pattern, zserio_reader, True, True)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            self._choice = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.from_reader_packed(zserio_context.house_number_range_continuous, zserio_reader, False, False)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            self._choice = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.from_reader_packed(zserio_context.house_number_range_continuous_pattern, zserio_reader, True, False)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            self._choice = zserio.array.Array.from_reader_packed(zserio.array.VarUInt32ArrayTraits(), zserio_reader, is_auto=True)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            self._choice = zserio.array.Array.from_reader(zserio.array.StringArrayTraits(), zserio_reader, is_auto=True)
        else:
            raise zserio.PythonRuntimeException("No match in choice HouseNumberRangeNumbers!")

    def write(self, zserio_writer: zserio.BitStreamWriter) -> None:
        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            # check parameters
            if self._choice.has_pattern != (False):
                raise zserio.PythonRuntimeException("Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeEvenOdd: "
                                                    f"{self._choice.has_pattern} != {False}!")
            if self._choice.is_even_odd != (True):
                raise zserio.PythonRuntimeException("Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeEvenOdd: "
                                                    f"{self._choice.is_even_odd} != {True}!")
            self._choice.write(zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            # check parameters
            if self._choice.has_pattern != (True):
                raise zserio.PythonRuntimeException("Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeEvenOddPattern: "
                                                    f"{self._choice.has_pattern} != {True}!")
            if self._choice.is_even_odd != (True):
                raise zserio.PythonRuntimeException("Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeEvenOddPattern: "
                                                    f"{self._choice.is_even_odd} != {True}!")
            self._choice.write(zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            # check parameters
            if self._choice.has_pattern != (False):
                raise zserio.PythonRuntimeException("Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeContinuous: "
                                                    f"{self._choice.has_pattern} != {False}!")
            if self._choice.is_even_odd != (False):
                raise zserio.PythonRuntimeException("Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeContinuous: "
                                                    f"{self._choice.is_even_odd} != {False}!")
            self._choice.write(zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            # check parameters
            if self._choice.has_pattern != (True):
                raise zserio.PythonRuntimeException("Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeContinuousPattern: "
                                                    f"{self._choice.has_pattern} != {True}!")
            if self._choice.is_even_odd != (False):
                raise zserio.PythonRuntimeException("Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeContinuousPattern: "
                                                    f"{self._choice.is_even_odd} != {False}!")
            self._choice.write(zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            self._choice.write(zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            self._choice.write(zserio_writer)
        else:
            raise zserio.PythonRuntimeException("No match in choice HouseNumberRangeNumbers!")

    def write_packed(self, zserio_context: HouseNumberRangeNumbers.ZserioPackingContext,
                     zserio_writer: zserio.BitStreamWriter) -> None:
        selector = self._type_

        if selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD):
            # check parameters
            if self._choice.has_pattern != (False):
                raise zserio.PythonRuntimeException("Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeEvenOdd: "
                                                    f"{self._choice.has_pattern} != {False}!")
            if self._choice.is_even_odd != (True):
                raise zserio.PythonRuntimeException("Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeEvenOdd: "
                                                    f"{self._choice.is_even_odd} != {True}!")
            self._choice.write_packed(zserio_context.house_number_range_even_odd, zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_EVEN_ODD_PATTERN):
            # check parameters
            if self._choice.has_pattern != (True):
                raise zserio.PythonRuntimeException("Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeEvenOddPattern: "
                                                    f"{self._choice.has_pattern} != {True}!")
            if self._choice.is_even_odd != (True):
                raise zserio.PythonRuntimeException("Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeEvenOddPattern: "
                                                    f"{self._choice.is_even_odd} != {True}!")
            self._choice.write_packed(zserio_context.house_number_range_even_odd_pattern, zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS):
            # check parameters
            if self._choice.has_pattern != (False):
                raise zserio.PythonRuntimeException("Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeContinuous: "
                                                    f"{self._choice.has_pattern} != {False}!")
            if self._choice.is_even_odd != (False):
                raise zserio.PythonRuntimeException("Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeContinuous: "
                                                    f"{self._choice.is_even_odd} != {False}!")
            self._choice.write_packed(zserio_context.house_number_range_continuous, zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.RANGE_CONTINUOUS_PATTERN):
            # check parameters
            if self._choice.has_pattern != (True):
                raise zserio.PythonRuntimeException("Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeContinuousPattern: "
                                                    f"{self._choice.has_pattern} != {True}!")
            if self._choice.is_even_odd != (False):
                raise zserio.PythonRuntimeException("Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeContinuousPattern: "
                                                    f"{self._choice.is_even_odd} != {False}!")
            self._choice.write_packed(zserio_context.house_number_range_continuous_pattern, zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_NUMERIC):
            self._choice.write_packed(zserio_writer)
        elif selector == (nds.name.types.house_number_type.HouseNumberType.LIST_STRING):
            self._choice.write(zserio_writer)
        else:
            raise zserio.PythonRuntimeException("No match in choice HouseNumberRangeNumbers!")

    class ZserioPackingContext:
        def __init__(self):
            self._house_number_range_even_odd_ = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.ZserioPackingContext()
            self._house_number_range_even_odd_pattern_ = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.ZserioPackingContext()
            self._house_number_range_continuous_ = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.ZserioPackingContext()
            self._house_number_range_continuous_pattern_ = nds.name.types.house_number_numeric_range.HouseNumberNumericRange.ZserioPackingContext()

        @property
        def house_number_range_even_odd(self):
            return self._house_number_range_even_odd_

        @property
        def house_number_range_even_odd_pattern(self):
            return self._house_number_range_even_odd_pattern_

        @property
        def house_number_range_continuous(self):
            return self._house_number_range_continuous_

        @property
        def house_number_range_continuous_pattern(self):
            return self._house_number_range_continuous_pattern_

    CHOICE_HOUSE_NUMBER_RANGE_EVEN_ODD = 0
    CHOICE_HOUSE_NUMBER_RANGE_EVEN_ODD_PATTERN = 1
    CHOICE_HOUSE_NUMBER_RANGE_CONTINUOUS = 2
    CHOICE_HOUSE_NUMBER_RANGE_CONTINUOUS_PATTERN = 3
    CHOICE_HOUSE_NUMBER_NUMERIC = 4
    CHOICE_HOUSE_NUMBER = 5
    UNDEFINED_CHOICE = -1
