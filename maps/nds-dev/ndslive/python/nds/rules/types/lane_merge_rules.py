# Automatically generated by Zserio Python extension version 2.12.0.
# Generator setup: writerCode, pubsubCode, serviceCode, sqlCode

from __future__ import annotations

import typing
import zserio

class LaneMergeRules:
    def __init__(
            self,
            yield_to_ongoing_lane_: bool = bool(),
            yield_to_curb_: bool = bool(),
            yield_to_traffic_ahead_: bool = bool(),
            no_divider_yield_to_curb_: bool = bool()) -> None:
        self._yield_to_ongoing_lane_ = yield_to_ongoing_lane_
        self._yield_to_curb_ = yield_to_curb_
        self._yield_to_traffic_ahead_ = yield_to_traffic_ahead_
        self._no_divider_yield_to_curb_ = no_divider_yield_to_curb_

    @classmethod
    def from_reader(
            cls: typing.Type['LaneMergeRules'],
            zserio_reader: zserio.BitStreamReader) -> 'LaneMergeRules':
        self = object.__new__(cls)

        self.read(zserio_reader)

        return self

    def __eq__(self, other: object) -> bool:
        if isinstance(other, LaneMergeRules):
            return ((self._yield_to_ongoing_lane_ == other._yield_to_ongoing_lane_) and
                    (self._yield_to_curb_ == other._yield_to_curb_) and
                    (self._yield_to_traffic_ahead_ == other._yield_to_traffic_ahead_) and
                    (self._no_divider_yield_to_curb_ == other._no_divider_yield_to_curb_))

        return False

    def __hash__(self) -> int:
        result = zserio.hashcode.HASH_SEED
        result = zserio.hashcode.calc_hashcode_bool(result, self._yield_to_ongoing_lane_)
        result = zserio.hashcode.calc_hashcode_bool(result, self._yield_to_curb_)
        result = zserio.hashcode.calc_hashcode_bool(result, self._yield_to_traffic_ahead_)
        result = zserio.hashcode.calc_hashcode_bool(result, self._no_divider_yield_to_curb_)

        return result

    @property
    def yield_to_ongoing_lane(self) -> bool:
        return self._yield_to_ongoing_lane_

    @yield_to_ongoing_lane.setter
    def yield_to_ongoing_lane(self, yield_to_ongoing_lane_: bool) -> None:
        self._yield_to_ongoing_lane_ = yield_to_ongoing_lane_

    @property
    def yield_to_curb(self) -> bool:
        return self._yield_to_curb_

    @yield_to_curb.setter
    def yield_to_curb(self, yield_to_curb_: bool) -> None:
        self._yield_to_curb_ = yield_to_curb_

    @property
    def yield_to_traffic_ahead(self) -> bool:
        return self._yield_to_traffic_ahead_

    @yield_to_traffic_ahead.setter
    def yield_to_traffic_ahead(self, yield_to_traffic_ahead_: bool) -> None:
        self._yield_to_traffic_ahead_ = yield_to_traffic_ahead_

    @property
    def no_divider_yield_to_curb(self) -> bool:
        return self._no_divider_yield_to_curb_

    @no_divider_yield_to_curb.setter
    def no_divider_yield_to_curb(self, no_divider_yield_to_curb_: bool) -> None:
        self._no_divider_yield_to_curb_ = no_divider_yield_to_curb_

    def bitsizeof(self, bitposition: int = 0) -> int:
        end_bitposition = bitposition
        end_bitposition += 1
        end_bitposition += 1
        end_bitposition += 1
        end_bitposition += 1

        return end_bitposition - bitposition

    def initialize_offsets(self, bitposition: int = 0) -> int:
        end_bitposition = bitposition
        end_bitposition += 1
        end_bitposition += 1
        end_bitposition += 1
        end_bitposition += 1

        return end_bitposition

    def read(self, zserio_reader: zserio.BitStreamReader) -> None:
        self._yield_to_ongoing_lane_ = zserio_reader.read_bool()
        self._yield_to_curb_ = zserio_reader.read_bool()
        self._yield_to_traffic_ahead_ = zserio_reader.read_bool()
        self._no_divider_yield_to_curb_ = zserio_reader.read_bool()

    def write(self, zserio_writer: zserio.BitStreamWriter) -> None:
        zserio_writer.write_bool(self._yield_to_ongoing_lane_)
        zserio_writer.write_bool(self._yield_to_curb_)
        zserio_writer.write_bool(self._yield_to_traffic_ahead_)
        zserio_writer.write_bool(self._no_divider_yield_to_curb_)
