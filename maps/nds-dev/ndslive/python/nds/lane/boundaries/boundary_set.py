# Automatically generated by Zserio Python extension version 2.12.0.
# Generator setup: writerCode, pubsubCode, serviceCode, sqlCode

from __future__ import annotations

import typing
import zserio

import nds.lane.boundaries.boundary_element_id
import nds.lane.boundaries.boundary_reference_with_position
import nds.lane.reference.types.lane_geometry_position

class BoundarySet:
    def __init__(
            self,
            has_geometry_: bool,
            start_position_: nds.lane.reference.types.lane_geometry_position.LaneGeometryPosition = nds.lane.reference.types.lane_geometry_position.LaneGeometryPosition(),
            boundaries_with_start_position_: typing.Optional[typing.List[nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition]] = None,
            boundary_types_: typing.Optional[typing.List[nds.lane.boundaries.boundary_element_id.BoundaryElementId]] = None) -> None:
        self._has_geometry_ = has_geometry_
        self._start_position_ = start_position_
        if boundaries_with_start_position_ is None:
            self._boundaries_with_start_position_ = None
        else:
            self._boundaries_with_start_position_ = zserio.array.Array(zserio.array.ObjectArrayTraits(self._ZserioElementFactory_boundaries_with_start_position()), boundaries_with_start_position_, is_auto=True)
        if boundary_types_ is None:
            self._boundary_types_ = None
        else:
            self._boundary_types_ = zserio.array.Array(zserio.array.VarUInt16ArrayTraits(), boundary_types_, is_auto=True)

    @classmethod
    def from_reader(
            cls: typing.Type['BoundarySet'],
            zserio_reader: zserio.BitStreamReader,
            has_geometry_: bool) -> 'BoundarySet':
        self = object.__new__(cls)
        self._has_geometry_ = has_geometry_

        self.read(zserio_reader)

        return self

    @classmethod
    def from_reader_packed(
            cls: typing.Type['BoundarySet'],
            zserio_context: BoundarySet.ZserioPackingContext,
            zserio_reader: zserio.BitStreamReader,
            has_geometry_: bool) -> 'BoundarySet':
        self = object.__new__(cls)
        self._has_geometry_ = has_geometry_

        self.read_packed(zserio_context, zserio_reader)

        return self

    def __eq__(self, other: object) -> bool:
        if isinstance(other, BoundarySet):
            return (self._has_geometry_ == other._has_geometry_ and
                    (self._start_position_ == other._start_position_) and
                    (not other.is_boundaries_with_start_position_used() if not self.is_boundaries_with_start_position_used() else (self._boundaries_with_start_position_ == other._boundaries_with_start_position_)) and
                    (not other.is_boundary_types_used() if not self.is_boundary_types_used() else (self._boundary_types_ == other._boundary_types_)))

        return False

    def __hash__(self) -> int:
        result = zserio.hashcode.HASH_SEED
        result = zserio.hashcode.calc_hashcode_bool(result, self._has_geometry_)
        result = zserio.hashcode.calc_hashcode_int64(result, self._start_position_)
        if self.is_boundaries_with_start_position_used():
            result = zserio.hashcode.calc_hashcode_object(result, self._boundaries_with_start_position_)
        if self.is_boundary_types_used():
            result = zserio.hashcode.calc_hashcode_object(result, self._boundary_types_)

        return result

    @property
    def has_geometry(self) -> bool:
        return self._has_geometry_

    @property
    def start_position(self) -> nds.lane.reference.types.lane_geometry_position.LaneGeometryPosition:
        return self._start_position_

    @start_position.setter
    def start_position(self, start_position_: nds.lane.reference.types.lane_geometry_position.LaneGeometryPosition) -> None:
        self._start_position_ = start_position_

    @property
    def boundaries_with_start_position(self) -> typing.Optional[typing.List[nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition]]:
        return None if self._boundaries_with_start_position_ is None else self._boundaries_with_start_position_.raw_array

    @boundaries_with_start_position.setter
    def boundaries_with_start_position(self, boundaries_with_start_position_: typing.Optional[typing.List[nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition]]) -> None:
        if boundaries_with_start_position_ is None:
            self._boundaries_with_start_position_ = None
        else:
            self._boundaries_with_start_position_ = zserio.array.Array(zserio.array.ObjectArrayTraits(self._ZserioElementFactory_boundaries_with_start_position()), boundaries_with_start_position_, is_auto=True)

    def is_boundaries_with_start_position_used(self) -> bool:
        return self._has_geometry_

    def is_boundaries_with_start_position_set(self) -> bool:
        return not self._boundaries_with_start_position_ is None

    def reset_boundaries_with_start_position(self) -> None:
        self._boundaries_with_start_position_ = None

    @property
    def boundary_types(self) -> typing.Optional[typing.List[nds.lane.boundaries.boundary_element_id.BoundaryElementId]]:
        return None if self._boundary_types_ is None else self._boundary_types_.raw_array

    @boundary_types.setter
    def boundary_types(self, boundary_types_: typing.Optional[typing.List[nds.lane.boundaries.boundary_element_id.BoundaryElementId]]) -> None:
        if boundary_types_ is None:
            self._boundary_types_ = None
        else:
            self._boundary_types_ = zserio.array.Array(zserio.array.VarUInt16ArrayTraits(), boundary_types_, is_auto=True)

    def is_boundary_types_used(self) -> bool:
        return not self._has_geometry_

    def is_boundary_types_set(self) -> bool:
        return not self._boundary_types_ is None

    def reset_boundary_types(self) -> None:
        self._boundary_types_ = None

    def init_packing_context(self, zserio_context: BoundarySet.ZserioPackingContext) -> None:
        zserio_context.start_position.init(zserio.array.VarSizeArrayTraits(), self._start_position_)

    def bitsizeof(self, bitposition: int = 0) -> int:
        end_bitposition = bitposition
        end_bitposition += zserio.bitsizeof.bitsizeof_varsize(self._start_position_)
        if self.is_boundaries_with_start_position_used():
            end_bitposition += self._boundaries_with_start_position_.bitsizeof(end_bitposition)
        if self.is_boundary_types_used():
            end_bitposition += self._boundary_types_.bitsizeof(end_bitposition)

        return end_bitposition - bitposition

    def bitsizeof_packed(self, zserio_context: BoundarySet.ZserioPackingContext, bitposition: int = 0) -> int:
        end_bitposition = bitposition
        end_bitposition += zserio_context.start_position.bitsizeof(zserio.array.VarSizeArrayTraits(), self._start_position_)
        if self.is_boundaries_with_start_position_used():
            end_bitposition += self._boundaries_with_start_position_.bitsizeof_packed(end_bitposition)
        if self.is_boundary_types_used():
            end_bitposition += self._boundary_types_.bitsizeof_packed(end_bitposition)

        return end_bitposition - bitposition

    def initialize_offsets(self, bitposition: int = 0) -> int:
        end_bitposition = bitposition
        end_bitposition += zserio.bitsizeof.bitsizeof_varsize(self._start_position_)
        if self.is_boundaries_with_start_position_used():
            end_bitposition = self._boundaries_with_start_position_.initialize_offsets(end_bitposition)
        if self.is_boundary_types_used():
            end_bitposition = self._boundary_types_.initialize_offsets(end_bitposition)

        return end_bitposition

    def initialize_offsets_packed(self, zserio_context: BoundarySet.ZserioPackingContext, bitposition: int) -> int:
        end_bitposition = bitposition
        end_bitposition += zserio_context.start_position.bitsizeof(zserio.array.VarSizeArrayTraits(), self._start_position_)
        if self.is_boundaries_with_start_position_used():
            end_bitposition = self._boundaries_with_start_position_.initialize_offsets_packed(end_bitposition)
        if self.is_boundary_types_used():
            end_bitposition = self._boundary_types_.initialize_offsets_packed(end_bitposition)

        return end_bitposition

    def read(self, zserio_reader: zserio.BitStreamReader) -> None:
        self._start_position_ = zserio_reader.read_varsize()
        if self.is_boundaries_with_start_position_used():
            self._boundaries_with_start_position_ = zserio.array.Array.from_reader(zserio.array.ObjectArrayTraits(self._ZserioElementFactory_boundaries_with_start_position()), zserio_reader, is_auto=True)
        else:
            self._boundaries_with_start_position_ = None
        if self.is_boundary_types_used():
            self._boundary_types_ = zserio.array.Array.from_reader(zserio.array.VarUInt16ArrayTraits(), zserio_reader, is_auto=True)
        else:
            self._boundary_types_ = None

    def read_packed(self, zserio_context: BoundarySet.ZserioPackingContext, zserio_reader: zserio.BitStreamReader) -> None:
        self._start_position_ = zserio_context.start_position.read(zserio.array.VarSizeArrayTraits(), zserio_reader)

        if self.is_boundaries_with_start_position_used():
            self._boundaries_with_start_position_ = zserio.array.Array.from_reader_packed(zserio.array.ObjectArrayTraits(self._ZserioElementFactory_boundaries_with_start_position()), zserio_reader, is_auto=True)
        else:
            self._boundaries_with_start_position_ = None

        if self.is_boundary_types_used():
            self._boundary_types_ = zserio.array.Array.from_reader_packed(zserio.array.VarUInt16ArrayTraits(), zserio_reader, is_auto=True)
        else:
            self._boundary_types_ = None

    def write(self, zserio_writer: zserio.BitStreamWriter) -> None:
        zserio_writer.write_varsize(self._start_position_)
        if self.is_boundaries_with_start_position_used():
            self._boundaries_with_start_position_.write(zserio_writer)
        if self.is_boundary_types_used():
            self._boundary_types_.write(zserio_writer)

    def write_packed(self, zserio_context: BoundarySet.ZserioPackingContext,
                     zserio_writer: zserio.BitStreamWriter) -> None:
        zserio_context.start_position.write(zserio.array.VarSizeArrayTraits(), zserio_writer, self._start_position_)

        if self.is_boundaries_with_start_position_used():
            self._boundaries_with_start_position_.write_packed(zserio_writer)

        if self.is_boundary_types_used():
            self._boundary_types_.write_packed(zserio_writer)

    class ZserioPackingContext:
        def __init__(self):
            self._start_position_ = zserio.array.DeltaContext()

        @property
        def start_position(self):
            return self._start_position_

    class _ZserioElementFactory_boundaries_with_start_position:
        IS_OBJECT_PACKABLE = True

        @staticmethod
        def create(zserio_reader: zserio.BitStreamReader, zserio_index: int) -> nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition:
            del zserio_index
            return nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition.from_reader(zserio_reader)

        @staticmethod
        def create_packing_context() -> nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition.ZserioPackingContext:
            return nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition.ZserioPackingContext()

        @staticmethod
        def create_packed(zserio_context: nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition.ZserioPackingContext,
                          zserio_reader: zserio.BitStreamReader, zserio_index: int) -> nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition:
            del zserio_index
            return nds.lane.boundaries.boundary_reference_with_position.BoundaryReferenceWithPosition.from_reader_packed(zserio_context, zserio_reader)
