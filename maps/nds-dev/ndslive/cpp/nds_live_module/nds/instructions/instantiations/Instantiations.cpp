/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsTransitionAttributeMetadata.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsTransitionAttributeMetadata::InstructionsTransitionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

InstructionsTransitionAttributeMetadata::InstructionsTransitionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

InstructionsTransitionAttributeMetadata::InstructionsTransitionAttributeMetadata(InstructionsTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

InstructionsTransitionAttributeMetadata::InstructionsTransitionAttributeMetadata(::zserio::PropagateAllocatorT,
        const InstructionsTransitionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::instructions::attributes::InstructionsTransitionAttributeType>& InstructionsTransitionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::instructions::attributes::InstructionsTransitionAttributeType>& InstructionsTransitionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void InstructionsTransitionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::instructions::attributes::InstructionsTransitionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void InstructionsTransitionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::instructions::attributes::InstructionsTransitionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& InstructionsTransitionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& InstructionsTransitionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void InstructionsTransitionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void InstructionsTransitionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& InstructionsTransitionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& InstructionsTransitionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void InstructionsTransitionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void InstructionsTransitionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void InstructionsTransitionAttributeMetadata::initPackingContext(InstructionsTransitionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t InstructionsTransitionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeMetadata::bitSizeOf(InstructionsTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t InstructionsTransitionAttributeMetadata::initializeOffsets(InstructionsTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool InstructionsTransitionAttributeMetadata::operator==(const InstructionsTransitionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t InstructionsTransitionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void InstructionsTransitionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void InstructionsTransitionAttributeMetadata::write(InstructionsTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void InstructionsTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(InstructionsTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(InstructionsTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& array,
        ::nds::instructions::properties::InstructionsPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

InstructionsTransitionAttributeMetadata::ZserioArrayType_availableAttributes InstructionsTransitionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

InstructionsTransitionAttributeMetadata::ZserioArrayType_availableAttributes InstructionsTransitionAttributeMetadata::readAvailableAttributes(InstructionsTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
InstructionsTransitionAttributeMetadata::ZserioArrayType_availableProperties InstructionsTransitionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

InstructionsTransitionAttributeMetadata::ZserioArrayType_availableProperties InstructionsTransitionAttributeMetadata::readAvailableProperties(InstructionsTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection InstructionsTransitionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection InstructionsTransitionAttributeMetadata::readAvailableConditions(InstructionsTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsLaneTransitionAttributeMetadata.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsLaneTransitionAttributeMetadata::InstructionsLaneTransitionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

InstructionsLaneTransitionAttributeMetadata::InstructionsLaneTransitionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

InstructionsLaneTransitionAttributeMetadata::InstructionsLaneTransitionAttributeMetadata(InstructionsLaneTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

InstructionsLaneTransitionAttributeMetadata::InstructionsLaneTransitionAttributeMetadata(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>& InstructionsLaneTransitionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>& InstructionsLaneTransitionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void InstructionsLaneTransitionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void InstructionsLaneTransitionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& InstructionsLaneTransitionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& InstructionsLaneTransitionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void InstructionsLaneTransitionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void InstructionsLaneTransitionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& InstructionsLaneTransitionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& InstructionsLaneTransitionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void InstructionsLaneTransitionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void InstructionsLaneTransitionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void InstructionsLaneTransitionAttributeMetadata::initPackingContext(InstructionsLaneTransitionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t InstructionsLaneTransitionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeMetadata::bitSizeOf(InstructionsLaneTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t InstructionsLaneTransitionAttributeMetadata::initializeOffsets(InstructionsLaneTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool InstructionsLaneTransitionAttributeMetadata::operator==(const InstructionsLaneTransitionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t InstructionsLaneTransitionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void InstructionsLaneTransitionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void InstructionsLaneTransitionAttributeMetadata::write(InstructionsLaneTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void InstructionsLaneTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(InstructionsLaneTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(InstructionsLaneTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::instructions::properties::InstructionsPropertyType>& array,
        ::nds::instructions::properties::InstructionsPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

InstructionsLaneTransitionAttributeMetadata::ZserioArrayType_availableAttributes InstructionsLaneTransitionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

InstructionsLaneTransitionAttributeMetadata::ZserioArrayType_availableAttributes InstructionsLaneTransitionAttributeMetadata::readAvailableAttributes(InstructionsLaneTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
InstructionsLaneTransitionAttributeMetadata::ZserioArrayType_availableProperties InstructionsLaneTransitionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

InstructionsLaneTransitionAttributeMetadata::ZserioArrayType_availableProperties InstructionsLaneTransitionAttributeMetadata::readAvailableProperties(InstructionsLaneTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection InstructionsLaneTransitionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection InstructionsLaneTransitionAttributeMetadata::readAvailableConditions(InstructionsLaneTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsTransitionAttributeMapList.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsTransitionAttributeMapList::InstructionsTransitionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

InstructionsTransitionAttributeMapList::InstructionsTransitionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

InstructionsTransitionAttributeMapList::InstructionsTransitionAttributeMapList(InstructionsTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

InstructionsTransitionAttributeMapList::InstructionsTransitionAttributeMapList(const InstructionsTransitionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeMapList& InstructionsTransitionAttributeMapList::operator=(const InstructionsTransitionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeMapList::InstructionsTransitionAttributeMapList(InstructionsTransitionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeMapList& InstructionsTransitionAttributeMapList::operator=(InstructionsTransitionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeMapList::InstructionsTransitionAttributeMapList(::zserio::PropagateAllocatorT,
        const InstructionsTransitionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void InstructionsTransitionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsTransitionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsTransitionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift InstructionsTransitionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'InstructionsTransitionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t InstructionsTransitionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void InstructionsTransitionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::instructions::instantiations::InstructionsTransitionAttributeMapListHeader& InstructionsTransitionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::instructions::instantiations::InstructionsTransitionAttributeMapListHeader& InstructionsTransitionAttributeMapList::getHeader() const
{
    return m_header_;
}

void InstructionsTransitionAttributeMapList::setHeader(const ::nds::instructions::instantiations::InstructionsTransitionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void InstructionsTransitionAttributeMapList::setHeader(::nds::instructions::instantiations::InstructionsTransitionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeMap>& InstructionsTransitionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeMap>& InstructionsTransitionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void InstructionsTransitionAttributeMapList::setMaps(const ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void InstructionsTransitionAttributeMapList::setMaps(::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void InstructionsTransitionAttributeMapList::initPackingContext(InstructionsTransitionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t InstructionsTransitionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeMapList::bitSizeOf(InstructionsTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsTransitionAttributeMapList::initializeOffsets(InstructionsTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsTransitionAttributeMapList::operator==(const InstructionsTransitionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t InstructionsTransitionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void InstructionsTransitionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field InstructionsTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void InstructionsTransitionAttributeMapList::write(InstructionsTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field InstructionsTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void InstructionsTransitionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(InstructionsTransitionAttributeMapList& owner,
        ::nds::instructions::instantiations::InstructionsTransitionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void InstructionsTransitionAttributeMapList::ZserioElementFactory_maps::create(InstructionsTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void InstructionsTransitionAttributeMapList::ZserioElementFactory_maps::create(InstructionsTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeMap>& array,
        ::nds::instructions::instantiations::InstructionsTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t InstructionsTransitionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t InstructionsTransitionAttributeMapList::readNumMaps(InstructionsTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::instructions::instantiations::InstructionsTransitionAttributeMapListHeader InstructionsTransitionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::instantiations::InstructionsTransitionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::instructions::instantiations::InstructionsTransitionAttributeMapListHeader InstructionsTransitionAttributeMapList::readHeader(InstructionsTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::instantiations::InstructionsTransitionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
InstructionsTransitionAttributeMapList::ZserioArrayType_maps InstructionsTransitionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

InstructionsTransitionAttributeMapList::ZserioArrayType_maps InstructionsTransitionAttributeMapList::readMaps(InstructionsTransitionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsLaneTransitionAttributeMapList.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsLaneTransitionAttributeMapList::InstructionsLaneTransitionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

InstructionsLaneTransitionAttributeMapList::InstructionsLaneTransitionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

InstructionsLaneTransitionAttributeMapList::InstructionsLaneTransitionAttributeMapList(InstructionsLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

InstructionsLaneTransitionAttributeMapList::InstructionsLaneTransitionAttributeMapList(const InstructionsLaneTransitionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeMapList& InstructionsLaneTransitionAttributeMapList::operator=(const InstructionsLaneTransitionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeMapList::InstructionsLaneTransitionAttributeMapList(InstructionsLaneTransitionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeMapList& InstructionsLaneTransitionAttributeMapList::operator=(InstructionsLaneTransitionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeMapList::InstructionsLaneTransitionAttributeMapList(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void InstructionsLaneTransitionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsLaneTransitionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsLaneTransitionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift InstructionsLaneTransitionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'InstructionsLaneTransitionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t InstructionsLaneTransitionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void InstructionsLaneTransitionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMapListHeader& InstructionsLaneTransitionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMapListHeader& InstructionsLaneTransitionAttributeMapList::getHeader() const
{
    return m_header_;
}

void InstructionsLaneTransitionAttributeMapList::setHeader(const ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void InstructionsLaneTransitionAttributeMapList::setHeader(::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMap>& InstructionsLaneTransitionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMap>& InstructionsLaneTransitionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void InstructionsLaneTransitionAttributeMapList::setMaps(const ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void InstructionsLaneTransitionAttributeMapList::setMaps(::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void InstructionsLaneTransitionAttributeMapList::initPackingContext(InstructionsLaneTransitionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t InstructionsLaneTransitionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeMapList::bitSizeOf(InstructionsLaneTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsLaneTransitionAttributeMapList::initializeOffsets(InstructionsLaneTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsLaneTransitionAttributeMapList::operator==(const InstructionsLaneTransitionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t InstructionsLaneTransitionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void InstructionsLaneTransitionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field InstructionsLaneTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeMapList::write(InstructionsLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field InstructionsLaneTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(InstructionsLaneTransitionAttributeMapList& owner,
        ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void InstructionsLaneTransitionAttributeMapList::ZserioElementFactory_maps::create(InstructionsLaneTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void InstructionsLaneTransitionAttributeMapList::ZserioElementFactory_maps::create(InstructionsLaneTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMap>& array,
        ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t InstructionsLaneTransitionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t InstructionsLaneTransitionAttributeMapList::readNumMaps(InstructionsLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMapListHeader InstructionsLaneTransitionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMapListHeader InstructionsLaneTransitionAttributeMapList::readHeader(InstructionsLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
InstructionsLaneTransitionAttributeMapList::ZserioArrayType_maps InstructionsLaneTransitionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

InstructionsLaneTransitionAttributeMapList::ZserioArrayType_maps InstructionsLaneTransitionAttributeMapList::readMaps(InstructionsLaneTransitionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsTransitionAttributeMapListHeader.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsTransitionAttributeMapListHeader::InstructionsTransitionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

InstructionsTransitionAttributeMapListHeader::InstructionsTransitionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

InstructionsTransitionAttributeMapListHeader::InstructionsTransitionAttributeMapListHeader(InstructionsTransitionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

InstructionsTransitionAttributeMapListHeader::InstructionsTransitionAttributeMapListHeader(const InstructionsTransitionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeMapListHeader& InstructionsTransitionAttributeMapListHeader::operator=(const InstructionsTransitionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeMapListHeader::InstructionsTransitionAttributeMapListHeader(InstructionsTransitionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeMapListHeader& InstructionsTransitionAttributeMapListHeader::operator=(InstructionsTransitionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeMapListHeader::InstructionsTransitionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const InstructionsTransitionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void InstructionsTransitionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool InstructionsTransitionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t InstructionsTransitionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'InstructionsTransitionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::instructions::attributes::InstructionsTransitionAttributeType>& InstructionsTransitionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::instructions::attributes::InstructionsTransitionAttributeType>& InstructionsTransitionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void InstructionsTransitionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::instructions::attributes::InstructionsTransitionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void InstructionsTransitionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::instructions::attributes::InstructionsTransitionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& InstructionsTransitionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& InstructionsTransitionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void InstructionsTransitionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void InstructionsTransitionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void InstructionsTransitionAttributeMapListHeader::initPackingContext(InstructionsTransitionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t InstructionsTransitionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeMapListHeader::bitSizeOf(InstructionsTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsTransitionAttributeMapListHeader::initializeOffsets(InstructionsTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsTransitionAttributeMapListHeader::operator==(const InstructionsTransitionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t InstructionsTransitionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void InstructionsTransitionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void InstructionsTransitionAttributeMapListHeader::write(InstructionsTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void InstructionsTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(InstructionsTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(InstructionsTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

InstructionsTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode InstructionsTransitionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

InstructionsTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode InstructionsTransitionAttributeMapListHeader::readAttributeTypeCode(InstructionsTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
InstructionsTransitionAttributeMapListHeader::ZserioArrayType_conditionType InstructionsTransitionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

InstructionsTransitionAttributeMapListHeader::ZserioArrayType_conditionType InstructionsTransitionAttributeMapListHeader::readConditionType(InstructionsTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsLaneTransitionAttributeMapListHeader.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsLaneTransitionAttributeMapListHeader::InstructionsLaneTransitionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

InstructionsLaneTransitionAttributeMapListHeader::InstructionsLaneTransitionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

InstructionsLaneTransitionAttributeMapListHeader::InstructionsLaneTransitionAttributeMapListHeader(InstructionsLaneTransitionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

InstructionsLaneTransitionAttributeMapListHeader::InstructionsLaneTransitionAttributeMapListHeader(const InstructionsLaneTransitionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeMapListHeader& InstructionsLaneTransitionAttributeMapListHeader::operator=(const InstructionsLaneTransitionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeMapListHeader::InstructionsLaneTransitionAttributeMapListHeader(InstructionsLaneTransitionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeMapListHeader& InstructionsLaneTransitionAttributeMapListHeader::operator=(InstructionsLaneTransitionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeMapListHeader::InstructionsLaneTransitionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void InstructionsLaneTransitionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool InstructionsLaneTransitionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t InstructionsLaneTransitionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'InstructionsLaneTransitionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>& InstructionsLaneTransitionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>& InstructionsLaneTransitionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void InstructionsLaneTransitionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void InstructionsLaneTransitionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& InstructionsLaneTransitionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& InstructionsLaneTransitionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void InstructionsLaneTransitionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void InstructionsLaneTransitionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void InstructionsLaneTransitionAttributeMapListHeader::initPackingContext(InstructionsLaneTransitionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t InstructionsLaneTransitionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeMapListHeader::bitSizeOf(InstructionsLaneTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsLaneTransitionAttributeMapListHeader::initializeOffsets(InstructionsLaneTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsLaneTransitionAttributeMapListHeader::operator==(const InstructionsLaneTransitionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t InstructionsLaneTransitionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void InstructionsLaneTransitionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeMapListHeader::write(InstructionsLaneTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(InstructionsLaneTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(InstructionsLaneTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

InstructionsLaneTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode InstructionsLaneTransitionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

InstructionsLaneTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode InstructionsLaneTransitionAttributeMapListHeader::readAttributeTypeCode(InstructionsLaneTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
InstructionsLaneTransitionAttributeMapListHeader::ZserioArrayType_conditionType InstructionsLaneTransitionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

InstructionsLaneTransitionAttributeMapListHeader::ZserioArrayType_conditionType InstructionsLaneTransitionAttributeMapListHeader::readConditionType(InstructionsLaneTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsLaneTransitionAttributeMap.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsLaneTransitionAttributeMap::InstructionsLaneTransitionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::instructions::attributes::InstructionsLaneTransitionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

InstructionsLaneTransitionAttributeMap::InstructionsLaneTransitionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

InstructionsLaneTransitionAttributeMap::InstructionsLaneTransitionAttributeMap(InstructionsLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

InstructionsLaneTransitionAttributeMap::InstructionsLaneTransitionAttributeMap(const InstructionsLaneTransitionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeMap& InstructionsLaneTransitionAttributeMap::operator=(const InstructionsLaneTransitionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeMap::InstructionsLaneTransitionAttributeMap(InstructionsLaneTransitionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeMap& InstructionsLaneTransitionAttributeMap::operator=(InstructionsLaneTransitionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeMap::InstructionsLaneTransitionAttributeMap(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void InstructionsLaneTransitionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsLaneTransitionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsLaneTransitionAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift InstructionsLaneTransitionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'InstructionsLaneTransitionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeType InstructionsLaneTransitionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void InstructionsLaneTransitionAttributeMap::setAttributeTypeCode(::nds::instructions::attributes::InstructionsLaneTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator InstructionsLaneTransitionAttributeMap::getFeature() const
{
    return m_feature_;
}

void InstructionsLaneTransitionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& InstructionsLaneTransitionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& InstructionsLaneTransitionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void InstructionsLaneTransitionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void InstructionsLaneTransitionAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& InstructionsLaneTransitionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& InstructionsLaneTransitionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void InstructionsLaneTransitionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void InstructionsLaneTransitionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& InstructionsLaneTransitionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& InstructionsLaneTransitionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void InstructionsLaneTransitionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void InstructionsLaneTransitionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator InstructionsLaneTransitionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void InstructionsLaneTransitionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttribute>& InstructionsLaneTransitionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttribute>& InstructionsLaneTransitionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void InstructionsLaneTransitionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void InstructionsLaneTransitionAttributeMap::setAttributeValues(::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& InstructionsLaneTransitionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& InstructionsLaneTransitionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void InstructionsLaneTransitionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void InstructionsLaneTransitionAttributeMap::setAttributeProperties(::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& InstructionsLaneTransitionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& InstructionsLaneTransitionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void InstructionsLaneTransitionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void InstructionsLaneTransitionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void InstructionsLaneTransitionAttributeMap::initPackingContext(InstructionsLaneTransitionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t InstructionsLaneTransitionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeMap::bitSizeOf(InstructionsLaneTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsLaneTransitionAttributeMap::initializeOffsets(InstructionsLaneTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsLaneTransitionAttributeMap::operator==(const InstructionsLaneTransitionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t InstructionsLaneTransitionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void InstructionsLaneTransitionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeMap::write(InstructionsLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(InstructionsLaneTransitionAttributeMap&,
        ::nds::lane::reference::types::LaneGroupTransitionReference& element, size_t)
{
    element.initializeChildren();
}

void InstructionsLaneTransitionAttributeMap::ZserioElementFactory_featureReferences::create(InstructionsLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeMap::ZserioElementFactory_featureReferences::create(InstructionsLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& array,
        ::nds::lane::reference::types::LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(InstructionsLaneTransitionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void InstructionsLaneTransitionAttributeMap::ZserioElementFactory_featureValidities::create(InstructionsLaneTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void InstructionsLaneTransitionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(InstructionsLaneTransitionAttributeMap& owner,
        ::nds::instructions::instantiations::InstructionsLaneTransitionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(owner.getAttributeTypeCode()));
}

void InstructionsLaneTransitionAttributeMap::ZserioElementFactory_attributeValues::create(InstructionsLaneTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void InstructionsLaneTransitionAttributeMap::ZserioElementFactory_attributeValues::create(InstructionsLaneTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttribute>& array,
        ::nds::instructions::instantiations::InstructionsLaneTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void InstructionsLaneTransitionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(InstructionsLaneTransitionAttributeMap&,
        ::nds::instructions::instantiations::InstructionsPropertyList& element, size_t)
{
    element.initializeChildren();
}

void InstructionsLaneTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(InstructionsLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(InstructionsLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& array,
        ::nds::instructions::instantiations::InstructionsPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(InstructionsLaneTransitionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void InstructionsLaneTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(InstructionsLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(InstructionsLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeType InstructionsLaneTransitionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(in);
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeType InstructionsLaneTransitionAttributeMap::readAttributeTypeCode(InstructionsLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator InstructionsLaneTransitionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator InstructionsLaneTransitionAttributeMap::readFeature(InstructionsLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsLaneTransitionAttributeMap::ZserioArrayType_featureReferences InstructionsLaneTransitionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

InstructionsLaneTransitionAttributeMap::ZserioArrayType_featureReferences InstructionsLaneTransitionAttributeMap::readFeatureReferences(InstructionsLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
InstructionsLaneTransitionAttributeMap::ZserioArrayType_featureValidities InstructionsLaneTransitionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
InstructionsLaneTransitionAttributeMap::ZserioArrayType_featureValuePtr InstructionsLaneTransitionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

InstructionsLaneTransitionAttributeMap::ZserioArrayType_featureValuePtr InstructionsLaneTransitionAttributeMap::readFeatureValuePtr(InstructionsLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator InstructionsLaneTransitionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator InstructionsLaneTransitionAttributeMap::readAttribute(InstructionsLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsLaneTransitionAttributeMap::ZserioArrayType_attributeValues InstructionsLaneTransitionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

InstructionsLaneTransitionAttributeMap::ZserioArrayType_attributeValues InstructionsLaneTransitionAttributeMap::readAttributeValues(InstructionsLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
InstructionsLaneTransitionAttributeMap::ZserioArrayType_attributeProperties InstructionsLaneTransitionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

InstructionsLaneTransitionAttributeMap::ZserioArrayType_attributeProperties InstructionsLaneTransitionAttributeMap::readAttributeProperties(InstructionsLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
InstructionsLaneTransitionAttributeMap::ZserioArrayType_attributeConditions InstructionsLaneTransitionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

InstructionsLaneTransitionAttributeMap::ZserioArrayType_attributeConditions InstructionsLaneTransitionAttributeMap::readAttributeConditions(InstructionsLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsTransitionAttributeMap.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsTransitionAttributeMap::InstructionsTransitionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::instructions::attributes::InstructionsTransitionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

InstructionsTransitionAttributeMap::InstructionsTransitionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

InstructionsTransitionAttributeMap::InstructionsTransitionAttributeMap(InstructionsTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

InstructionsTransitionAttributeMap::InstructionsTransitionAttributeMap(const InstructionsTransitionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeMap& InstructionsTransitionAttributeMap::operator=(const InstructionsTransitionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeMap::InstructionsTransitionAttributeMap(InstructionsTransitionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeMap& InstructionsTransitionAttributeMap::operator=(InstructionsTransitionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeMap::InstructionsTransitionAttributeMap(::zserio::PropagateAllocatorT,
        const InstructionsTransitionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void InstructionsTransitionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsTransitionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsTransitionAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift InstructionsTransitionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'InstructionsTransitionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::instructions::attributes::InstructionsTransitionAttributeType InstructionsTransitionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void InstructionsTransitionAttributeMap::setAttributeTypeCode(::nds::instructions::attributes::InstructionsTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator InstructionsTransitionAttributeMap::getFeature() const
{
    return m_feature_;
}

void InstructionsTransitionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::TransitionReference>& InstructionsTransitionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::TransitionReference>& InstructionsTransitionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void InstructionsTransitionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::TransitionReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void InstructionsTransitionAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::TransitionReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& InstructionsTransitionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& InstructionsTransitionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void InstructionsTransitionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void InstructionsTransitionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& InstructionsTransitionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& InstructionsTransitionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void InstructionsTransitionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void InstructionsTransitionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator InstructionsTransitionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void InstructionsTransitionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttribute>& InstructionsTransitionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttribute>& InstructionsTransitionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void InstructionsTransitionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void InstructionsTransitionAttributeMap::setAttributeValues(::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& InstructionsTransitionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& InstructionsTransitionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void InstructionsTransitionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void InstructionsTransitionAttributeMap::setAttributeProperties(::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& InstructionsTransitionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& InstructionsTransitionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void InstructionsTransitionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void InstructionsTransitionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void InstructionsTransitionAttributeMap::initPackingContext(InstructionsTransitionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t InstructionsTransitionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeMap::bitSizeOf(InstructionsTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsTransitionAttributeMap::initializeOffsets(InstructionsTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsTransitionAttributeMap::operator==(const InstructionsTransitionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t InstructionsTransitionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void InstructionsTransitionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void InstructionsTransitionAttributeMap::write(InstructionsTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void InstructionsTransitionAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(InstructionsTransitionAttributeMap&,
        ::nds::road::reference::types::TransitionReference& element, size_t)
{
    element.initializeChildren();
}

void InstructionsTransitionAttributeMap::ZserioElementFactory_featureReferences::create(InstructionsTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsTransitionAttributeMap::ZserioElementFactory_featureReferences::create(InstructionsTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::nds::road::reference::types::TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void InstructionsTransitionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(InstructionsTransitionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void InstructionsTransitionAttributeMap::ZserioElementFactory_featureValidities::create(InstructionsTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void InstructionsTransitionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(InstructionsTransitionAttributeMap& owner,
        ::nds::instructions::instantiations::InstructionsTransitionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(owner.getAttributeTypeCode()));
}

void InstructionsTransitionAttributeMap::ZserioElementFactory_attributeValues::create(InstructionsTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void InstructionsTransitionAttributeMap::ZserioElementFactory_attributeValues::create(InstructionsTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttribute>& array,
        ::nds::instructions::instantiations::InstructionsTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void InstructionsTransitionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(InstructionsTransitionAttributeMap&,
        ::nds::instructions::instantiations::InstructionsPropertyList& element, size_t)
{
    element.initializeChildren();
}

void InstructionsTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(InstructionsTransitionAttributeMap&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(InstructionsTransitionAttributeMap&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsPropertyList>& array,
        ::nds::instructions::instantiations::InstructionsPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void InstructionsTransitionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(InstructionsTransitionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void InstructionsTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(InstructionsTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(InstructionsTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::instructions::attributes::InstructionsTransitionAttributeType InstructionsTransitionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::instructions::attributes::InstructionsTransitionAttributeType>(in);
}

::nds::instructions::attributes::InstructionsTransitionAttributeType InstructionsTransitionAttributeMap::readAttributeTypeCode(InstructionsTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::instructions::attributes::InstructionsTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator InstructionsTransitionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator InstructionsTransitionAttributeMap::readFeature(InstructionsTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsTransitionAttributeMap::ZserioArrayType_featureReferences InstructionsTransitionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

InstructionsTransitionAttributeMap::ZserioArrayType_featureReferences InstructionsTransitionAttributeMap::readFeatureReferences(InstructionsTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
InstructionsTransitionAttributeMap::ZserioArrayType_featureValidities InstructionsTransitionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
InstructionsTransitionAttributeMap::ZserioArrayType_featureValuePtr InstructionsTransitionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

InstructionsTransitionAttributeMap::ZserioArrayType_featureValuePtr InstructionsTransitionAttributeMap::readFeatureValuePtr(InstructionsTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator InstructionsTransitionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator InstructionsTransitionAttributeMap::readAttribute(InstructionsTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsTransitionAttributeMap::ZserioArrayType_attributeValues InstructionsTransitionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

InstructionsTransitionAttributeMap::ZserioArrayType_attributeValues InstructionsTransitionAttributeMap::readAttributeValues(InstructionsTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
InstructionsTransitionAttributeMap::ZserioArrayType_attributeProperties InstructionsTransitionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

InstructionsTransitionAttributeMap::ZserioArrayType_attributeProperties InstructionsTransitionAttributeMap::readAttributeProperties(InstructionsTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
InstructionsTransitionAttributeMap::ZserioArrayType_attributeConditions InstructionsTransitionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

InstructionsTransitionAttributeMap::ZserioArrayType_attributeConditions InstructionsTransitionAttributeMap::readAttributeConditions(InstructionsTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsTransitionAttribute.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsTransitionAttribute::InstructionsTransitionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

InstructionsTransitionAttribute::InstructionsTransitionAttribute(::zserio::BitStreamReader& in,
        ::nds::instructions::attributes::InstructionsTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

InstructionsTransitionAttribute::InstructionsTransitionAttribute(InstructionsTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::instructions::attributes::InstructionsTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

InstructionsTransitionAttribute::InstructionsTransitionAttribute(const InstructionsTransitionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttribute& InstructionsTransitionAttribute::operator=(const InstructionsTransitionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttribute::InstructionsTransitionAttribute(InstructionsTransitionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttribute& InstructionsTransitionAttribute::operator=(InstructionsTransitionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttribute::InstructionsTransitionAttribute(::zserio::PropagateAllocatorT,
        const InstructionsTransitionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void InstructionsTransitionAttribute::initialize(
        ::nds::instructions::attributes::InstructionsTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsTransitionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsTransitionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()));
}

::nds::instructions::attributes::InstructionsTransitionAttributeType InstructionsTransitionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'InstructionsTransitionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::instructions::attributes::InstructionsTransitionAttributeValue& InstructionsTransitionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::instructions::attributes::InstructionsTransitionAttributeValue& InstructionsTransitionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void InstructionsTransitionAttribute::setAttributeValue(const ::nds::instructions::attributes::InstructionsTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void InstructionsTransitionAttribute::setAttributeValue(::nds::instructions::attributes::InstructionsTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void InstructionsTransitionAttribute::initPackingContext(InstructionsTransitionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t InstructionsTransitionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttribute::bitSizeOf(InstructionsTransitionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t InstructionsTransitionAttribute::initializeOffsets(InstructionsTransitionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool InstructionsTransitionAttribute::operator==(const InstructionsTransitionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t InstructionsTransitionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void InstructionsTransitionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field InstructionsTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void InstructionsTransitionAttribute::write(InstructionsTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field InstructionsTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::instructions::attributes::InstructionsTransitionAttributeValue InstructionsTransitionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::attributes::InstructionsTransitionAttributeValue(in, static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::instructions::attributes::InstructionsTransitionAttributeValue InstructionsTransitionAttribute::readAttributeValue(InstructionsTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::attributes::InstructionsTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsLaneTransitionAttribute.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsLaneTransitionAttribute::InstructionsLaneTransitionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

InstructionsLaneTransitionAttribute::InstructionsLaneTransitionAttribute(::zserio::BitStreamReader& in,
        ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

InstructionsLaneTransitionAttribute::InstructionsLaneTransitionAttribute(InstructionsLaneTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

InstructionsLaneTransitionAttribute::InstructionsLaneTransitionAttribute(const InstructionsLaneTransitionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttribute& InstructionsLaneTransitionAttribute::operator=(const InstructionsLaneTransitionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttribute::InstructionsLaneTransitionAttribute(InstructionsLaneTransitionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttribute& InstructionsLaneTransitionAttribute::operator=(InstructionsLaneTransitionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttribute::InstructionsLaneTransitionAttribute(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void InstructionsLaneTransitionAttribute::initialize(
        ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsLaneTransitionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsLaneTransitionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()));
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeType InstructionsLaneTransitionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'InstructionsLaneTransitionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue& InstructionsLaneTransitionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue& InstructionsLaneTransitionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void InstructionsLaneTransitionAttribute::setAttributeValue(const ::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void InstructionsLaneTransitionAttribute::setAttributeValue(::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void InstructionsLaneTransitionAttribute::initPackingContext(InstructionsLaneTransitionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t InstructionsLaneTransitionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttribute::bitSizeOf(InstructionsLaneTransitionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t InstructionsLaneTransitionAttribute::initializeOffsets(InstructionsLaneTransitionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool InstructionsLaneTransitionAttribute::operator==(const InstructionsLaneTransitionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t InstructionsLaneTransitionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void InstructionsLaneTransitionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field InstructionsLaneTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void InstructionsLaneTransitionAttribute::write(InstructionsLaneTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field InstructionsLaneTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue InstructionsLaneTransitionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue(in, static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue InstructionsLaneTransitionAttribute::readAttributeValue(InstructionsLaneTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsProperty.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsProperty::InstructionsProperty(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_propertyTypeCode_(allocator),
        m_propertyValue_(allocator)
{
}

InstructionsProperty::InstructionsProperty(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(in, allocator)),
        m_propertyValue_(readPropertyValue(in, allocator))
{
}

InstructionsProperty::InstructionsProperty(InstructionsProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(context, in, allocator)),
        m_propertyValue_(readPropertyValue(context, in, allocator))
{
}

InstructionsProperty::InstructionsProperty(const InstructionsProperty& other) :
        m_propertyTypeCode_(other.m_propertyTypeCode_),
        m_propertyValue_(other.m_propertyValue_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

InstructionsProperty& InstructionsProperty::operator=(const InstructionsProperty& other)
{
    m_propertyTypeCode_ = other.m_propertyTypeCode_;
    m_propertyValue_ = other.m_propertyValue_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

InstructionsProperty::InstructionsProperty(InstructionsProperty&& other) :
        m_propertyTypeCode_(::std::move(other.m_propertyTypeCode_)),
        m_propertyValue_(::std::move(other.m_propertyValue_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

InstructionsProperty& InstructionsProperty::operator=(InstructionsProperty&& other)
{
    m_propertyTypeCode_ = ::std::move(other.m_propertyTypeCode_);
    m_propertyValue_ = ::std::move(other.m_propertyValue_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

InstructionsProperty::InstructionsProperty(::zserio::PropagateAllocatorT,
        const InstructionsProperty& other, const allocator_type& allocator) :
        m_propertyTypeCode_(::zserio::allocatorPropagatingCopy(other.m_propertyTypeCode_, allocator)),
        m_propertyValue_(::zserio::allocatorPropagatingCopy(other.m_propertyValue_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void InstructionsProperty::initializeChildren()
{
    m_propertyValue_.initialize(getPropertyTypeCode());

    m_areChildrenInitialized = true;
}

::nds::instructions::properties::InstructionsPropertyType& InstructionsProperty::getPropertyTypeCode()
{
    return m_propertyTypeCode_;
}

const ::nds::instructions::properties::InstructionsPropertyType& InstructionsProperty::getPropertyTypeCode() const
{
    return m_propertyTypeCode_;
}

void InstructionsProperty::setPropertyTypeCode(const ::nds::instructions::properties::InstructionsPropertyType& propertyTypeCode_)
{
    m_propertyTypeCode_ = propertyTypeCode_;
}

void InstructionsProperty::setPropertyTypeCode(::nds::instructions::properties::InstructionsPropertyType&& propertyTypeCode_)
{
    m_propertyTypeCode_ = ::std::move(propertyTypeCode_);
}

::nds::instructions::properties::InstructionsPropertyValue& InstructionsProperty::getPropertyValue()
{
    return m_propertyValue_;
}

const ::nds::instructions::properties::InstructionsPropertyValue& InstructionsProperty::getPropertyValue() const
{
    return m_propertyValue_;
}

void InstructionsProperty::setPropertyValue(const ::nds::instructions::properties::InstructionsPropertyValue& propertyValue_)
{
    m_propertyValue_ = propertyValue_;
}

void InstructionsProperty::setPropertyValue(::nds::instructions::properties::InstructionsPropertyValue&& propertyValue_)
{
    m_propertyValue_ = ::std::move(propertyValue_);
}

void InstructionsProperty::initPackingContext(InstructionsProperty::ZserioPackingContext& context) const
{
    m_propertyTypeCode_.initPackingContext(context.getPropertyTypeCode());
    m_propertyValue_.initPackingContext(context.getPropertyValue());
}

size_t InstructionsProperty::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsProperty::bitSizeOf(InstructionsProperty::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(context.getPropertyValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsProperty::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t InstructionsProperty::initializeOffsets(InstructionsProperty::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(context.getPropertyValue(), endBitPosition);

    return endBitPosition;
}

bool InstructionsProperty::operator==(const InstructionsProperty& other) const
{
    if (this != &other)
    {
        return
                (m_propertyTypeCode_ == other.m_propertyTypeCode_) &&
                (m_propertyValue_ == other.m_propertyValue_);
    }

    return true;
}

uint32_t InstructionsProperty::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_propertyTypeCode_);
    result = ::zserio::calcHashCode(result, m_propertyValue_);

    return result;
}

void InstructionsProperty::write(::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field InstructionsProperty.propertyValue!");
    }
    m_propertyValue_.write(out);
}

void InstructionsProperty::write(InstructionsProperty::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(context.getPropertyTypeCode(), out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field InstructionsProperty.propertyValue!");
    }
    m_propertyValue_.write(context.getPropertyValue(), out);
}

::nds::instructions::properties::InstructionsPropertyType InstructionsProperty::readPropertyTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::properties::InstructionsPropertyType(in, allocator);
}

::nds::instructions::properties::InstructionsPropertyType InstructionsProperty::readPropertyTypeCode(InstructionsProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::properties::InstructionsPropertyType(context.getPropertyTypeCode(), in, allocator);
}
::nds::instructions::properties::InstructionsPropertyValue InstructionsProperty::readPropertyValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::properties::InstructionsPropertyValue(in, getPropertyTypeCode(), allocator);
}

::nds::instructions::properties::InstructionsPropertyValue InstructionsProperty::readPropertyValue(InstructionsProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::properties::InstructionsPropertyValue(context.getPropertyValue(), in, getPropertyTypeCode(), allocator);
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsTransitionAttributeSet.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsTransitionAttributeSet::InstructionsTransitionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

InstructionsTransitionAttributeSet::InstructionsTransitionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

InstructionsTransitionAttributeSet::InstructionsTransitionAttributeSet(InstructionsTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

InstructionsTransitionAttributeSet::InstructionsTransitionAttributeSet(::zserio::PropagateAllocatorT,
        const InstructionsTransitionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void InstructionsTransitionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t InstructionsTransitionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void InstructionsTransitionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionFullAttribute>& InstructionsTransitionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionFullAttribute>& InstructionsTransitionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void InstructionsTransitionAttributeSet::setAttributes(const ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void InstructionsTransitionAttributeSet::setAttributes(::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void InstructionsTransitionAttributeSet::initPackingContext(InstructionsTransitionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t InstructionsTransitionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeSet::bitSizeOf(InstructionsTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsTransitionAttributeSet::initializeOffsets(InstructionsTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsTransitionAttributeSet::operator==(const InstructionsTransitionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t InstructionsTransitionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void InstructionsTransitionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void InstructionsTransitionAttributeSet::write(InstructionsTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void InstructionsTransitionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(InstructionsTransitionAttributeSet&,
        ::nds::instructions::instantiations::InstructionsTransitionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void InstructionsTransitionAttributeSet::ZserioElementFactory_attributes::create(InstructionsTransitionAttributeSet&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsTransitionAttributeSet::ZserioElementFactory_attributes::create(InstructionsTransitionAttributeSet&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionFullAttribute>& array,
        ::nds::instructions::instantiations::InstructionsTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t InstructionsTransitionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t InstructionsTransitionAttributeSet::readNumEntries(InstructionsTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsTransitionAttributeSet::ZserioArrayType_attributes InstructionsTransitionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

InstructionsTransitionAttributeSet::ZserioArrayType_attributes InstructionsTransitionAttributeSet::readAttributes(InstructionsTransitionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsLaneTransitionAttributeSet.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsLaneTransitionAttributeSet::InstructionsLaneTransitionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

InstructionsLaneTransitionAttributeSet::InstructionsLaneTransitionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

InstructionsLaneTransitionAttributeSet::InstructionsLaneTransitionAttributeSet(InstructionsLaneTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

InstructionsLaneTransitionAttributeSet::InstructionsLaneTransitionAttributeSet(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void InstructionsLaneTransitionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t InstructionsLaneTransitionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void InstructionsLaneTransitionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionFullAttribute>& InstructionsLaneTransitionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionFullAttribute>& InstructionsLaneTransitionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void InstructionsLaneTransitionAttributeSet::setAttributes(const ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void InstructionsLaneTransitionAttributeSet::setAttributes(::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void InstructionsLaneTransitionAttributeSet::initPackingContext(InstructionsLaneTransitionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t InstructionsLaneTransitionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeSet::bitSizeOf(InstructionsLaneTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsLaneTransitionAttributeSet::initializeOffsets(InstructionsLaneTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsLaneTransitionAttributeSet::operator==(const InstructionsLaneTransitionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t InstructionsLaneTransitionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void InstructionsLaneTransitionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeSet::write(InstructionsLaneTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(InstructionsLaneTransitionAttributeSet&,
        ::nds::instructions::instantiations::InstructionsLaneTransitionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void InstructionsLaneTransitionAttributeSet::ZserioElementFactory_attributes::create(InstructionsLaneTransitionAttributeSet&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeSet::ZserioElementFactory_attributes::create(InstructionsLaneTransitionAttributeSet&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionFullAttribute>& array,
        ::nds::instructions::instantiations::InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t InstructionsLaneTransitionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t InstructionsLaneTransitionAttributeSet::readNumEntries(InstructionsLaneTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsLaneTransitionAttributeSet::ZserioArrayType_attributes InstructionsLaneTransitionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

InstructionsLaneTransitionAttributeSet::ZserioArrayType_attributes InstructionsLaneTransitionAttributeSet::readAttributes(InstructionsLaneTransitionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsTransitionFullAttribute.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsTransitionFullAttribute::InstructionsTransitionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::instructions::attributes::InstructionsTransitionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

InstructionsTransitionFullAttribute::InstructionsTransitionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

InstructionsTransitionFullAttribute::InstructionsTransitionFullAttribute(InstructionsTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

InstructionsTransitionFullAttribute::InstructionsTransitionFullAttribute(const InstructionsTransitionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

InstructionsTransitionFullAttribute& InstructionsTransitionFullAttribute::operator=(const InstructionsTransitionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

InstructionsTransitionFullAttribute::InstructionsTransitionFullAttribute(InstructionsTransitionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

InstructionsTransitionFullAttribute& InstructionsTransitionFullAttribute::operator=(InstructionsTransitionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

InstructionsTransitionFullAttribute::InstructionsTransitionFullAttribute(::zserio::PropagateAllocatorT,
        const InstructionsTransitionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void InstructionsTransitionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::instructions::attributes::InstructionsTransitionAttributeType InstructionsTransitionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void InstructionsTransitionFullAttribute::setAttributeTypeCode(::nds::instructions::attributes::InstructionsTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::instructions::attributes::InstructionsTransitionAttributeValue& InstructionsTransitionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::instructions::attributes::InstructionsTransitionAttributeValue& InstructionsTransitionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void InstructionsTransitionFullAttribute::setAttributeValue(const ::nds::instructions::attributes::InstructionsTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void InstructionsTransitionFullAttribute::setAttributeValue(::nds::instructions::attributes::InstructionsTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::instructions::instantiations::InstructionsPropertyList& InstructionsTransitionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::instructions::instantiations::InstructionsPropertyList& InstructionsTransitionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void InstructionsTransitionFullAttribute::setProperties(const ::nds::instructions::instantiations::InstructionsPropertyList& properties_)
{
    m_properties_ = properties_;
}

void InstructionsTransitionFullAttribute::setProperties(::nds::instructions::instantiations::InstructionsPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool InstructionsTransitionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool InstructionsTransitionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void InstructionsTransitionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& InstructionsTransitionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& InstructionsTransitionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void InstructionsTransitionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void InstructionsTransitionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool InstructionsTransitionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool InstructionsTransitionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void InstructionsTransitionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void InstructionsTransitionFullAttribute::initPackingContext(InstructionsTransitionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t InstructionsTransitionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionFullAttribute::bitSizeOf(InstructionsTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t InstructionsTransitionFullAttribute::initializeOffsets(InstructionsTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool InstructionsTransitionFullAttribute::operator==(const InstructionsTransitionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t InstructionsTransitionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void InstructionsTransitionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field InstructionsTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void InstructionsTransitionFullAttribute::write(InstructionsTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field InstructionsTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::instructions::attributes::InstructionsTransitionAttributeType InstructionsTransitionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::instructions::attributes::InstructionsTransitionAttributeType>(in);
}

::nds::instructions::attributes::InstructionsTransitionAttributeType InstructionsTransitionFullAttribute::readAttributeTypeCode(InstructionsTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::instructions::attributes::InstructionsTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::instructions::attributes::InstructionsTransitionAttributeValue InstructionsTransitionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::attributes::InstructionsTransitionAttributeValue(in, static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::instructions::attributes::InstructionsTransitionAttributeValue InstructionsTransitionFullAttribute::readAttributeValue(InstructionsTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::attributes::InstructionsTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList> InstructionsTransitionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList>(::nds::instructions::instantiations::InstructionsPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList> InstructionsTransitionFullAttribute::readProperties(InstructionsTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList>(::nds::instructions::instantiations::InstructionsPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> InstructionsTransitionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> InstructionsTransitionFullAttribute::readConditions(InstructionsTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsLaneTransitionFullAttribute.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsLaneTransitionFullAttribute::InstructionsLaneTransitionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::instructions::attributes::InstructionsLaneTransitionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

InstructionsLaneTransitionFullAttribute::InstructionsLaneTransitionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

InstructionsLaneTransitionFullAttribute::InstructionsLaneTransitionFullAttribute(InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

InstructionsLaneTransitionFullAttribute::InstructionsLaneTransitionFullAttribute(const InstructionsLaneTransitionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

InstructionsLaneTransitionFullAttribute& InstructionsLaneTransitionFullAttribute::operator=(const InstructionsLaneTransitionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

InstructionsLaneTransitionFullAttribute::InstructionsLaneTransitionFullAttribute(InstructionsLaneTransitionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

InstructionsLaneTransitionFullAttribute& InstructionsLaneTransitionFullAttribute::operator=(InstructionsLaneTransitionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

InstructionsLaneTransitionFullAttribute::InstructionsLaneTransitionFullAttribute(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void InstructionsLaneTransitionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeType InstructionsLaneTransitionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void InstructionsLaneTransitionFullAttribute::setAttributeTypeCode(::nds::instructions::attributes::InstructionsLaneTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue& InstructionsLaneTransitionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue& InstructionsLaneTransitionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void InstructionsLaneTransitionFullAttribute::setAttributeValue(const ::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void InstructionsLaneTransitionFullAttribute::setAttributeValue(::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::instructions::instantiations::InstructionsPropertyList& InstructionsLaneTransitionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::instructions::instantiations::InstructionsPropertyList& InstructionsLaneTransitionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void InstructionsLaneTransitionFullAttribute::setProperties(const ::nds::instructions::instantiations::InstructionsPropertyList& properties_)
{
    m_properties_ = properties_;
}

void InstructionsLaneTransitionFullAttribute::setProperties(::nds::instructions::instantiations::InstructionsPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool InstructionsLaneTransitionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool InstructionsLaneTransitionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void InstructionsLaneTransitionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& InstructionsLaneTransitionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& InstructionsLaneTransitionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void InstructionsLaneTransitionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void InstructionsLaneTransitionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool InstructionsLaneTransitionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool InstructionsLaneTransitionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void InstructionsLaneTransitionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void InstructionsLaneTransitionFullAttribute::initPackingContext(InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t InstructionsLaneTransitionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionFullAttribute::bitSizeOf(InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t InstructionsLaneTransitionFullAttribute::initializeOffsets(InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool InstructionsLaneTransitionFullAttribute::operator==(const InstructionsLaneTransitionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t InstructionsLaneTransitionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void InstructionsLaneTransitionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field InstructionsLaneTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void InstructionsLaneTransitionFullAttribute::write(InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field InstructionsLaneTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeType InstructionsLaneTransitionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(in);
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeType InstructionsLaneTransitionFullAttribute::readAttributeTypeCode(InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue InstructionsLaneTransitionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue(in, static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue InstructionsLaneTransitionFullAttribute::readAttributeValue(InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::attributes::InstructionsLaneTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList> InstructionsLaneTransitionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList>(::nds::instructions::instantiations::InstructionsPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList> InstructionsLaneTransitionFullAttribute::readProperties(InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList>(::nds::instructions::instantiations::InstructionsPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> InstructionsLaneTransitionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> InstructionsLaneTransitionFullAttribute::readConditions(InstructionsLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsPropertyList.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsPropertyList::InstructionsPropertyList(const allocator_type&) noexcept :
        m_numProperties_(uint8_t()),
        m_property_(::zserio::NullOpt)
{
}

InstructionsPropertyList::InstructionsPropertyList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(in)),
        m_property_(readProperty(in, allocator))
{
}

InstructionsPropertyList::InstructionsPropertyList(InstructionsPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(context, in)),
        m_property_(readProperty(context, in, allocator))
{
}

InstructionsPropertyList::InstructionsPropertyList(::zserio::PropagateAllocatorT,
        const InstructionsPropertyList& other, const allocator_type& allocator) :
        m_numProperties_(::zserio::allocatorPropagatingCopy(other.m_numProperties_, allocator)),
        m_property_(::zserio::allocatorPropagatingCopy(other.m_property_, allocator))
{
}

void InstructionsPropertyList::initializeChildren()
{
    if (getNumProperties() > 0)
        m_property_.value().initializeElements(*this);
}

uint8_t InstructionsPropertyList::getNumProperties() const
{
    return m_numProperties_;
}

void InstructionsPropertyList::setNumProperties(uint8_t numProperties_)
{
    m_numProperties_ = numProperties_;
}

::zserio::vector<::nds::instructions::instantiations::InstructionsProperty>& InstructionsPropertyList::getProperty()
{
    return m_property_.value().getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsProperty>& InstructionsPropertyList::getProperty() const
{
    return m_property_.value().getRawArray();
}

void InstructionsPropertyList::setProperty(const ::zserio::vector<::nds::instructions::instantiations::InstructionsProperty>& property_)
{
    m_property_ = ZserioArrayType_property(property_);
}

void InstructionsPropertyList::setProperty(::zserio::vector<::nds::instructions::instantiations::InstructionsProperty>&& property_)
{
    m_property_ = ZserioArrayType_property(std::move(property_));
}

bool InstructionsPropertyList::isPropertyUsed() const
{
    return (getNumProperties() > 0);
}

bool InstructionsPropertyList::isPropertySet() const
{
    return m_property_.hasValue();
}

void InstructionsPropertyList::resetProperty()
{
    m_property_.reset();
}

void InstructionsPropertyList::initPackingContext(InstructionsPropertyList::ZserioPackingContext& context) const
{
    context.getNumProperties().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
}

size_t InstructionsPropertyList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsPropertyList::bitSizeOf(InstructionsPropertyList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsPropertyList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t InstructionsPropertyList::initializeOffsets(InstructionsPropertyList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool InstructionsPropertyList::operator==(const InstructionsPropertyList& other) const
{
    if (this != &other)
    {
        return
                (m_numProperties_ == other.m_numProperties_) &&
                (!isPropertyUsed() ? !other.isPropertyUsed() : (m_property_ == other.m_property_));
    }

    return true;
}

uint32_t InstructionsPropertyList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numProperties_);
    if (isPropertyUsed())
        result = ::zserio::calcHashCode(result, m_property_);

    return result;
}

void InstructionsPropertyList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numProperties_, UINT8_C(8));

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void InstructionsPropertyList::write(InstructionsPropertyList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumProperties().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numProperties_);

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void InstructionsPropertyList::ZserioArrayExpressions_property::initializeElement(InstructionsPropertyList&,
        ::nds::instructions::instantiations::InstructionsProperty& element, size_t)
{
    element.initializeChildren();
}

void InstructionsPropertyList::ZserioElementFactory_property::create(InstructionsPropertyList&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsProperty>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsPropertyList::ZserioElementFactory_property::create(InstructionsPropertyList&        ,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsProperty>& array,
        ::nds::instructions::instantiations::InstructionsProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t InstructionsPropertyList::readNumProperties(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t InstructionsPropertyList::readNumProperties(InstructionsPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumProperties().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::zserio::InplaceOptionalHolder<InstructionsPropertyList::ZserioArrayType_property> InstructionsPropertyList::readProperty(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<InstructionsPropertyList::ZserioArrayType_property> InstructionsPropertyList::readProperty(InstructionsPropertyList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsLaneTransitionAttributeSetMap.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsLaneTransitionAttributeSetMap::InstructionsLaneTransitionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

InstructionsLaneTransitionAttributeSetMap::InstructionsLaneTransitionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

InstructionsLaneTransitionAttributeSetMap::InstructionsLaneTransitionAttributeSetMap(InstructionsLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

InstructionsLaneTransitionAttributeSetMap::InstructionsLaneTransitionAttributeSetMap(const InstructionsLaneTransitionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeSetMap& InstructionsLaneTransitionAttributeSetMap::operator=(const InstructionsLaneTransitionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeSetMap::InstructionsLaneTransitionAttributeSetMap(InstructionsLaneTransitionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeSetMap& InstructionsLaneTransitionAttributeSetMap::operator=(InstructionsLaneTransitionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeSetMap::InstructionsLaneTransitionAttributeSetMap(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void InstructionsLaneTransitionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsLaneTransitionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsLaneTransitionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift InstructionsLaneTransitionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'InstructionsLaneTransitionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSet& InstructionsLaneTransitionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSet& InstructionsLaneTransitionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void InstructionsLaneTransitionAttributeSetMap::setAttributeSet(const ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void InstructionsLaneTransitionAttributeSetMap::setAttributeSet(::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator InstructionsLaneTransitionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void InstructionsLaneTransitionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& InstructionsLaneTransitionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& InstructionsLaneTransitionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void InstructionsLaneTransitionAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void InstructionsLaneTransitionAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& InstructionsLaneTransitionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& InstructionsLaneTransitionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void InstructionsLaneTransitionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void InstructionsLaneTransitionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void InstructionsLaneTransitionAttributeSetMap::initPackingContext(InstructionsLaneTransitionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t InstructionsLaneTransitionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeSetMap::bitSizeOf(InstructionsLaneTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsLaneTransitionAttributeSetMap::initializeOffsets(InstructionsLaneTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsLaneTransitionAttributeSetMap::operator==(const InstructionsLaneTransitionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t InstructionsLaneTransitionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void InstructionsLaneTransitionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void InstructionsLaneTransitionAttributeSetMap::write(InstructionsLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void InstructionsLaneTransitionAttributeSetMap::ZserioArrayExpressions_references::initializeElement(InstructionsLaneTransitionAttributeSetMap&,
        ::nds::lane::reference::types::LaneGroupTransitionReference& element, size_t)
{
    element.initializeChildren();
}

void InstructionsLaneTransitionAttributeSetMap::ZserioElementFactory_references::create(InstructionsLaneTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeSetMap::ZserioElementFactory_references::create(InstructionsLaneTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& array,
        ::nds::lane::reference::types::LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void InstructionsLaneTransitionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(InstructionsLaneTransitionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void InstructionsLaneTransitionAttributeSetMap::ZserioElementFactory_validities::create(InstructionsLaneTransitionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSet InstructionsLaneTransitionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSet(in, allocator);
}

::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSet InstructionsLaneTransitionAttributeSetMap::readAttributeSet(InstructionsLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator InstructionsLaneTransitionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator InstructionsLaneTransitionAttributeSetMap::readFeature(InstructionsLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsLaneTransitionAttributeSetMap::ZserioArrayType_references InstructionsLaneTransitionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

InstructionsLaneTransitionAttributeSetMap::ZserioArrayType_references InstructionsLaneTransitionAttributeSetMap::readReferences(InstructionsLaneTransitionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
InstructionsLaneTransitionAttributeSetMap::ZserioArrayType_validities InstructionsLaneTransitionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsTransitionAttributeSetMap.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsTransitionAttributeSetMap::InstructionsTransitionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

InstructionsTransitionAttributeSetMap::InstructionsTransitionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

InstructionsTransitionAttributeSetMap::InstructionsTransitionAttributeSetMap(InstructionsTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

InstructionsTransitionAttributeSetMap::InstructionsTransitionAttributeSetMap(const InstructionsTransitionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeSetMap& InstructionsTransitionAttributeSetMap::operator=(const InstructionsTransitionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeSetMap::InstructionsTransitionAttributeSetMap(InstructionsTransitionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeSetMap& InstructionsTransitionAttributeSetMap::operator=(InstructionsTransitionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeSetMap::InstructionsTransitionAttributeSetMap(::zserio::PropagateAllocatorT,
        const InstructionsTransitionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void InstructionsTransitionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsTransitionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsTransitionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift InstructionsTransitionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'InstructionsTransitionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::instructions::instantiations::InstructionsTransitionAttributeSet& InstructionsTransitionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::instructions::instantiations::InstructionsTransitionAttributeSet& InstructionsTransitionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void InstructionsTransitionAttributeSetMap::setAttributeSet(const ::nds::instructions::instantiations::InstructionsTransitionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void InstructionsTransitionAttributeSetMap::setAttributeSet(::nds::instructions::instantiations::InstructionsTransitionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator InstructionsTransitionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void InstructionsTransitionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::TransitionReference>& InstructionsTransitionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::TransitionReference>& InstructionsTransitionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void InstructionsTransitionAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::TransitionReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void InstructionsTransitionAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::TransitionReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& InstructionsTransitionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& InstructionsTransitionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void InstructionsTransitionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void InstructionsTransitionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void InstructionsTransitionAttributeSetMap::initPackingContext(InstructionsTransitionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t InstructionsTransitionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeSetMap::bitSizeOf(InstructionsTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsTransitionAttributeSetMap::initializeOffsets(InstructionsTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsTransitionAttributeSetMap::operator==(const InstructionsTransitionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t InstructionsTransitionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void InstructionsTransitionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void InstructionsTransitionAttributeSetMap::write(InstructionsTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void InstructionsTransitionAttributeSetMap::ZserioArrayExpressions_references::initializeElement(InstructionsTransitionAttributeSetMap&,
        ::nds::road::reference::types::TransitionReference& element, size_t)
{
    element.initializeChildren();
}

void InstructionsTransitionAttributeSetMap::ZserioElementFactory_references::create(InstructionsTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void InstructionsTransitionAttributeSetMap::ZserioElementFactory_references::create(InstructionsTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::nds::road::reference::types::TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void InstructionsTransitionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(InstructionsTransitionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void InstructionsTransitionAttributeSetMap::ZserioElementFactory_validities::create(InstructionsTransitionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::instructions::instantiations::InstructionsTransitionAttributeSet InstructionsTransitionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::instructions::instantiations::InstructionsTransitionAttributeSet(in, allocator);
}

::nds::instructions::instantiations::InstructionsTransitionAttributeSet InstructionsTransitionAttributeSetMap::readAttributeSet(InstructionsTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::instructions::instantiations::InstructionsTransitionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator InstructionsTransitionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator InstructionsTransitionAttributeSetMap::readFeature(InstructionsTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsTransitionAttributeSetMap::ZserioArrayType_references InstructionsTransitionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

InstructionsTransitionAttributeSetMap::ZserioArrayType_references InstructionsTransitionAttributeSetMap::readReferences(InstructionsTransitionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
InstructionsTransitionAttributeSetMap::ZserioArrayType_validities InstructionsTransitionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsLaneTransitionAttributeSetList.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsLaneTransitionAttributeSetList::InstructionsLaneTransitionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

InstructionsLaneTransitionAttributeSetList::InstructionsLaneTransitionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

InstructionsLaneTransitionAttributeSetList::InstructionsLaneTransitionAttributeSetList(InstructionsLaneTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

InstructionsLaneTransitionAttributeSetList::InstructionsLaneTransitionAttributeSetList(const InstructionsLaneTransitionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeSetList& InstructionsLaneTransitionAttributeSetList::operator=(const InstructionsLaneTransitionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeSetList::InstructionsLaneTransitionAttributeSetList(InstructionsLaneTransitionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeSetList& InstructionsLaneTransitionAttributeSetList::operator=(InstructionsLaneTransitionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeSetList::InstructionsLaneTransitionAttributeSetList(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void InstructionsLaneTransitionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsLaneTransitionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsLaneTransitionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift InstructionsLaneTransitionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'InstructionsLaneTransitionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t InstructionsLaneTransitionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void InstructionsLaneTransitionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSetMap>& InstructionsLaneTransitionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSetMap>& InstructionsLaneTransitionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void InstructionsLaneTransitionAttributeSetList::setSets(const ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void InstructionsLaneTransitionAttributeSetList::setSets(::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void InstructionsLaneTransitionAttributeSetList::initPackingContext(InstructionsLaneTransitionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t InstructionsLaneTransitionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeSetList::bitSizeOf(InstructionsLaneTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsLaneTransitionAttributeSetList::initializeOffsets(InstructionsLaneTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsLaneTransitionAttributeSetList::operator==(const InstructionsLaneTransitionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t InstructionsLaneTransitionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void InstructionsLaneTransitionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeSetList::write(InstructionsLaneTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsLaneTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void InstructionsLaneTransitionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(InstructionsLaneTransitionAttributeSetList& owner,
        ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void InstructionsLaneTransitionAttributeSetList::ZserioElementFactory_sets::create(InstructionsLaneTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void InstructionsLaneTransitionAttributeSetList::ZserioElementFactory_sets::create(InstructionsLaneTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSetMap>& array,
        ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t InstructionsLaneTransitionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t InstructionsLaneTransitionAttributeSetList::readNumAttributeSets(InstructionsLaneTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsLaneTransitionAttributeSetList::ZserioArrayType_sets InstructionsLaneTransitionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

InstructionsLaneTransitionAttributeSetList::ZserioArrayType_sets InstructionsLaneTransitionAttributeSetList::readSets(InstructionsLaneTransitionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/instantiations/InstructionsTransitionAttributeSetList.h>

namespace nds
{
namespace instructions
{
namespace instantiations
{

InstructionsTransitionAttributeSetList::InstructionsTransitionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

InstructionsTransitionAttributeSetList::InstructionsTransitionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

InstructionsTransitionAttributeSetList::InstructionsTransitionAttributeSetList(InstructionsTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

InstructionsTransitionAttributeSetList::InstructionsTransitionAttributeSetList(const InstructionsTransitionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeSetList& InstructionsTransitionAttributeSetList::operator=(const InstructionsTransitionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeSetList::InstructionsTransitionAttributeSetList(InstructionsTransitionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeSetList& InstructionsTransitionAttributeSetList::operator=(InstructionsTransitionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeSetList::InstructionsTransitionAttributeSetList(::zserio::PropagateAllocatorT,
        const InstructionsTransitionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void InstructionsTransitionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool InstructionsTransitionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void InstructionsTransitionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift InstructionsTransitionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'InstructionsTransitionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t InstructionsTransitionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void InstructionsTransitionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeSetMap>& InstructionsTransitionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeSetMap>& InstructionsTransitionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void InstructionsTransitionAttributeSetList::setSets(const ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void InstructionsTransitionAttributeSetList::setSets(::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void InstructionsTransitionAttributeSetList::initPackingContext(InstructionsTransitionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t InstructionsTransitionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeSetList::bitSizeOf(InstructionsTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t InstructionsTransitionAttributeSetList::initializeOffsets(InstructionsTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool InstructionsTransitionAttributeSetList::operator==(const InstructionsTransitionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t InstructionsTransitionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void InstructionsTransitionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void InstructionsTransitionAttributeSetList::write(InstructionsTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field InstructionsTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void InstructionsTransitionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(InstructionsTransitionAttributeSetList& owner,
        ::nds::instructions::instantiations::InstructionsTransitionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void InstructionsTransitionAttributeSetList::ZserioElementFactory_sets::create(InstructionsTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void InstructionsTransitionAttributeSetList::ZserioElementFactory_sets::create(InstructionsTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::instructions::instantiations::InstructionsTransitionAttributeSetMap>& array,
        ::nds::instructions::instantiations::InstructionsTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t InstructionsTransitionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t InstructionsTransitionAttributeSetList::readNumAttributeSets(InstructionsTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
InstructionsTransitionAttributeSetList::ZserioArrayType_sets InstructionsTransitionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

InstructionsTransitionAttributeSetList::ZserioArrayType_sets InstructionsTransitionAttributeSetList::readSets(InstructionsTransitionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace instructions
} // namespace nds
