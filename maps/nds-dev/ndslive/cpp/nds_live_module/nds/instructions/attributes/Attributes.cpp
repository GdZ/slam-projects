/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/instructions/attributes/InstructionsTransitionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for InstructionsTransitionAttributeType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::instructions::attributes::InstructionsTransitionAttributeType>::names;
constexpr ::std::array<::nds::instructions::attributes::InstructionsTransitionAttributeType, 4> EnumTraits<::nds::instructions::attributes::InstructionsTransitionAttributeType>::values;
constexpr const char* EnumTraits<::nds::instructions::attributes::InstructionsTransitionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::instructions::attributes::InstructionsTransitionAttributeType value)
{
    switch (value)
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        return 0;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return 1;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        return 2;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration InstructionsTransitionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsTransitionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::instructions::attributes::InstructionsTransitionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::instructions::attributes::InstructionsTransitionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
        return static_cast<::nds::instructions::attributes::InstructionsTransitionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration InstructionsTransitionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::instructions::attributes::InstructionsTransitionAttributeType>(::nds::instructions::attributes::InstructionsTransitionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::instructions::attributes::InstructionsTransitionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::instructions::attributes::InstructionsTransitionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::instructions::attributes::InstructionsTransitionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::instructions::attributes::InstructionsTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::instructions::attributes::InstructionsTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::instructions::attributes::InstructionsTransitionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::instructions::attributes::InstructionsTransitionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsTransitionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::instructions::attributes::InstructionsTransitionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::instructions::attributes::InstructionsTransitionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsTransitionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::instructions::attributes::InstructionsTransitionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::instructions::attributes::InstructionsTransitionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsTransitionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/instructions/attributes/InstructionsLaneTransitionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for InstructionsLaneTransitionAttributeType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::names;
constexpr ::std::array<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType, 4> EnumTraits<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::values;
constexpr const char* EnumTraits<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::instructions::attributes::InstructionsLaneTransitionAttributeType value)
{
    switch (value)
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        return 0;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return 1;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        return 2;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration InstructionsLaneTransitionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::instructions::attributes::InstructionsLaneTransitionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
        return static_cast<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration InstructionsLaneTransitionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(::nds::instructions::attributes::InstructionsLaneTransitionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::instructions::attributes::InstructionsLaneTransitionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::instructions::attributes::InstructionsLaneTransitionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::instructions::attributes::InstructionsLaneTransitionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::instructions::attributes::InstructionsLaneTransitionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/attributes/InstructionsTransitionAttributeValue.h>

namespace nds
{
namespace instructions
{
namespace attributes
{

InstructionsTransitionAttributeValue::InstructionsTransitionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

InstructionsTransitionAttributeValue::InstructionsTransitionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::instructions::attributes::InstructionsTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

InstructionsTransitionAttributeValue::InstructionsTransitionAttributeValue(InstructionsTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::instructions::attributes::InstructionsTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

InstructionsTransitionAttributeValue::InstructionsTransitionAttributeValue(const InstructionsTransitionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeValue& InstructionsTransitionAttributeValue::operator=(const InstructionsTransitionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeValue::InstructionsTransitionAttributeValue(InstructionsTransitionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

InstructionsTransitionAttributeValue& InstructionsTransitionAttributeValue::operator=(InstructionsTransitionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsTransitionAttributeValue::InstructionsTransitionAttributeValue(::zserio::PropagateAllocatorT,
        const InstructionsTransitionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void InstructionsTransitionAttributeValue::initialize(
        ::nds::instructions::attributes::InstructionsTransitionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool InstructionsTransitionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::instructions::attributes::InstructionsTransitionAttributeType InstructionsTransitionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'InstructionsTransitionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::instructions::types::SignpostImage& InstructionsTransitionAttributeValue::getSignpostImage()
{
    return m_objectChoice.get<::nds::instructions::types::SignpostImage>();
}

const ::nds::instructions::types::SignpostImage& InstructionsTransitionAttributeValue::getSignpostImage() const
{
    return m_objectChoice.get<::nds::instructions::types::SignpostImage>();
}

void InstructionsTransitionAttributeValue::setSignpostImage(const ::nds::instructions::types::SignpostImage& signpostImage_)
{
    m_objectChoice = signpostImage_;
}

void InstructionsTransitionAttributeValue::setSignpostImage(::nds::instructions::types::SignpostImage&& signpostImage_)
{
    m_objectChoice = ::std::move(signpostImage_);
}

::nds::instructions::types::SignpostInstruction& InstructionsTransitionAttributeValue::getSignpostInstruction()
{
    return m_objectChoice.get<::nds::instructions::types::SignpostInstruction>();
}

const ::nds::instructions::types::SignpostInstruction& InstructionsTransitionAttributeValue::getSignpostInstruction() const
{
    return m_objectChoice.get<::nds::instructions::types::SignpostInstruction>();
}

void InstructionsTransitionAttributeValue::setSignpostInstruction(const ::nds::instructions::types::SignpostInstruction& signpostInstruction_)
{
    m_objectChoice = signpostInstruction_;
}

void InstructionsTransitionAttributeValue::setSignpostInstruction(::nds::instructions::types::SignpostInstruction&& signpostInstruction_)
{
    m_objectChoice = ::std::move(signpostInstruction_);
}

::nds::instructions::types::LaneInstruction& InstructionsTransitionAttributeValue::getLaneInstruction()
{
    return m_objectChoice.get<::nds::instructions::types::LaneInstruction>();
}

const ::nds::instructions::types::LaneInstruction& InstructionsTransitionAttributeValue::getLaneInstruction() const
{
    return m_objectChoice.get<::nds::instructions::types::LaneInstruction>();
}

void InstructionsTransitionAttributeValue::setLaneInstruction(const ::nds::instructions::types::LaneInstruction& laneInstruction_)
{
    m_objectChoice = laneInstruction_;
}

void InstructionsTransitionAttributeValue::setLaneInstruction(::nds::instructions::types::LaneInstruction&& laneInstruction_)
{
    m_objectChoice = ::std::move(laneInstruction_);
}

::nds::instructions::types::JunctionView& InstructionsTransitionAttributeValue::getJunctionView()
{
    return m_objectChoice.get<::nds::instructions::types::JunctionView>();
}

const ::nds::instructions::types::JunctionView& InstructionsTransitionAttributeValue::getJunctionView() const
{
    return m_objectChoice.get<::nds::instructions::types::JunctionView>();
}

void InstructionsTransitionAttributeValue::setJunctionView(const ::nds::instructions::types::JunctionView& junctionView_)
{
    m_objectChoice = junctionView_;
}

void InstructionsTransitionAttributeValue::setJunctionView(::nds::instructions::types::JunctionView&& junctionView_)
{
    m_objectChoice = ::std::move(junctionView_);
}

InstructionsTransitionAttributeValue::ChoiceTag InstructionsTransitionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        return CHOICE_signpostImage;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return CHOICE_signpostInstruction;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        return CHOICE_laneInstruction;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        return CHOICE_junctionView;
    default:
        return UNDEFINED_CHOICE;
    }
}

void InstructionsTransitionAttributeValue::initPackingContext(InstructionsTransitionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        m_objectChoice.get<::nds::instructions::types::SignpostImage>().initPackingContext(context.getSignpostImage());
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().initPackingContext(context.getSignpostInstruction());
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::LaneInstruction>().initPackingContext(context.getLaneInstruction());
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        m_objectChoice.get<::nds::instructions::types::JunctionView>().initPackingContext(context.getJunctionView());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }
}

size_t InstructionsTransitionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::SignpostImage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().bitSizeOf(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::LaneInstruction>().bitSizeOf(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::JunctionView>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeValue::bitSizeOf(InstructionsTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::SignpostImage>().bitSizeOf(context.getSignpostImage(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().bitSizeOf(context.getSignpostInstruction(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::LaneInstruction>().bitSizeOf(context.getLaneInstruction(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::JunctionView>().bitSizeOf(context.getJunctionView(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsTransitionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::SignpostImage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().initializeOffsets(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::LaneInstruction>().initializeOffsets(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::JunctionView>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }

    return endBitPosition;
}

size_t InstructionsTransitionAttributeValue::initializeOffsets(InstructionsTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::SignpostImage>().initializeOffsets(context.getSignpostImage(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().initializeOffsets(context.getSignpostInstruction(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::LaneInstruction>().initializeOffsets(context.getLaneInstruction(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::JunctionView>().initializeOffsets(context.getJunctionView(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }

    return endBitPosition;
}

bool InstructionsTransitionAttributeValue::operator==(const InstructionsTransitionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::instructions::types::SignpostImage>() == other.m_objectChoice.get<::nds::instructions::types::SignpostImage>());
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::instructions::types::SignpostInstruction>() == other.m_objectChoice.get<::nds::instructions::types::SignpostInstruction>());
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::instructions::types::LaneInstruction>() == other.m_objectChoice.get<::nds::instructions::types::LaneInstruction>());
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::instructions::types::JunctionView>() == other.m_objectChoice.get<::nds::instructions::types::JunctionView>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }
}

uint32_t InstructionsTransitionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::instructions::types::SignpostImage>());
            break;
        case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::instructions::types::SignpostInstruction>());
            break;
        case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::instructions::types::LaneInstruction>());
            break;
        case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::instructions::types::JunctionView>());
            break;
        default:
            break;
        }
    }

    return result;
}

void InstructionsTransitionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        m_objectChoice.get<::nds::instructions::types::SignpostImage>().write(out);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().write(out);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::LaneInstruction>().write(out);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        m_objectChoice.get<::nds::instructions::types::JunctionView>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }
}

void InstructionsTransitionAttributeValue::write(InstructionsTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        m_objectChoice.get<::nds::instructions::types::SignpostImage>().write(context.getSignpostImage(), out);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().write(context.getSignpostInstruction(), out);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::LaneInstruction>().write(context.getLaneInstruction(), out);
        break;
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        m_objectChoice.get<::nds::instructions::types::JunctionView>().write(context.getJunctionView(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> InstructionsTransitionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        return ::zserio::AnyHolder<>(::nds::instructions::types::SignpostImage(in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return ::zserio::AnyHolder<>(::nds::instructions::types::SignpostInstruction(in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        return ::zserio::AnyHolder<>(::nds::instructions::types::LaneInstruction(in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        return ::zserio::AnyHolder<>(::nds::instructions::types::JunctionView(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> InstructionsTransitionAttributeValue::readObject(InstructionsTransitionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        return ::zserio::AnyHolder<>(::nds::instructions::types::SignpostImage(context.getSignpostImage(), in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return ::zserio::AnyHolder<>(::nds::instructions::types::SignpostInstruction(context.getSignpostInstruction(), in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        return ::zserio::AnyHolder<>(::nds::instructions::types::LaneInstruction(context.getLaneInstruction(), in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        return ::zserio::AnyHolder<>(::nds::instructions::types::JunctionView(context.getJunctionView(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> InstructionsTransitionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_IMAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::instructions::types::SignpostImage>(m_objectChoice, allocator);
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return ::zserio::allocatorPropagatingCopy<::nds::instructions::types::SignpostInstruction>(m_objectChoice, allocator);
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::LANE_INSTRUCTION:
        return ::zserio::allocatorPropagatingCopy<::nds::instructions::types::LaneInstruction>(m_objectChoice, allocator);
    case ::nds::instructions::attributes::InstructionsTransitionAttributeType::JUNCTION_VIEW:
        return ::zserio::allocatorPropagatingCopy<::nds::instructions::types::JunctionView>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsTransitionAttributeValue!");
    }
}

} // namespace attributes
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/instructions/attributes/InstructionsLaneTransitionAttributeValue.h>

namespace nds
{
namespace instructions
{
namespace attributes
{

InstructionsLaneTransitionAttributeValue::InstructionsLaneTransitionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

InstructionsLaneTransitionAttributeValue::InstructionsLaneTransitionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

InstructionsLaneTransitionAttributeValue::InstructionsLaneTransitionAttributeValue(InstructionsLaneTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

InstructionsLaneTransitionAttributeValue::InstructionsLaneTransitionAttributeValue(const InstructionsLaneTransitionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeValue& InstructionsLaneTransitionAttributeValue::operator=(const InstructionsLaneTransitionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeValue::InstructionsLaneTransitionAttributeValue(InstructionsLaneTransitionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

InstructionsLaneTransitionAttributeValue& InstructionsLaneTransitionAttributeValue::operator=(InstructionsLaneTransitionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

InstructionsLaneTransitionAttributeValue::InstructionsLaneTransitionAttributeValue(::zserio::PropagateAllocatorT,
        const InstructionsLaneTransitionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void InstructionsLaneTransitionAttributeValue::initialize(
        ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool InstructionsLaneTransitionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::instructions::attributes::InstructionsLaneTransitionAttributeType InstructionsLaneTransitionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'InstructionsLaneTransitionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::instructions::types::SignpostImage& InstructionsLaneTransitionAttributeValue::getSignpostImage()
{
    return m_objectChoice.get<::nds::instructions::types::SignpostImage>();
}

const ::nds::instructions::types::SignpostImage& InstructionsLaneTransitionAttributeValue::getSignpostImage() const
{
    return m_objectChoice.get<::nds::instructions::types::SignpostImage>();
}

void InstructionsLaneTransitionAttributeValue::setSignpostImage(const ::nds::instructions::types::SignpostImage& signpostImage_)
{
    m_objectChoice = signpostImage_;
}

void InstructionsLaneTransitionAttributeValue::setSignpostImage(::nds::instructions::types::SignpostImage&& signpostImage_)
{
    m_objectChoice = ::std::move(signpostImage_);
}

::nds::instructions::types::SignpostInstruction& InstructionsLaneTransitionAttributeValue::getSignpostInstruction()
{
    return m_objectChoice.get<::nds::instructions::types::SignpostInstruction>();
}

const ::nds::instructions::types::SignpostInstruction& InstructionsLaneTransitionAttributeValue::getSignpostInstruction() const
{
    return m_objectChoice.get<::nds::instructions::types::SignpostInstruction>();
}

void InstructionsLaneTransitionAttributeValue::setSignpostInstruction(const ::nds::instructions::types::SignpostInstruction& signpostInstruction_)
{
    m_objectChoice = signpostInstruction_;
}

void InstructionsLaneTransitionAttributeValue::setSignpostInstruction(::nds::instructions::types::SignpostInstruction&& signpostInstruction_)
{
    m_objectChoice = ::std::move(signpostInstruction_);
}

::nds::instructions::types::LaneInstruction& InstructionsLaneTransitionAttributeValue::getLaneInstruction()
{
    return m_objectChoice.get<::nds::instructions::types::LaneInstruction>();
}

const ::nds::instructions::types::LaneInstruction& InstructionsLaneTransitionAttributeValue::getLaneInstruction() const
{
    return m_objectChoice.get<::nds::instructions::types::LaneInstruction>();
}

void InstructionsLaneTransitionAttributeValue::setLaneInstruction(const ::nds::instructions::types::LaneInstruction& laneInstruction_)
{
    m_objectChoice = laneInstruction_;
}

void InstructionsLaneTransitionAttributeValue::setLaneInstruction(::nds::instructions::types::LaneInstruction&& laneInstruction_)
{
    m_objectChoice = ::std::move(laneInstruction_);
}

::nds::instructions::types::JunctionView& InstructionsLaneTransitionAttributeValue::getJunctionView()
{
    return m_objectChoice.get<::nds::instructions::types::JunctionView>();
}

const ::nds::instructions::types::JunctionView& InstructionsLaneTransitionAttributeValue::getJunctionView() const
{
    return m_objectChoice.get<::nds::instructions::types::JunctionView>();
}

void InstructionsLaneTransitionAttributeValue::setJunctionView(const ::nds::instructions::types::JunctionView& junctionView_)
{
    m_objectChoice = junctionView_;
}

void InstructionsLaneTransitionAttributeValue::setJunctionView(::nds::instructions::types::JunctionView&& junctionView_)
{
    m_objectChoice = ::std::move(junctionView_);
}

InstructionsLaneTransitionAttributeValue::ChoiceTag InstructionsLaneTransitionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        return CHOICE_signpostImage;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return CHOICE_signpostInstruction;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        return CHOICE_laneInstruction;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        return CHOICE_junctionView;
    default:
        return UNDEFINED_CHOICE;
    }
}

void InstructionsLaneTransitionAttributeValue::initPackingContext(InstructionsLaneTransitionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        m_objectChoice.get<::nds::instructions::types::SignpostImage>().initPackingContext(context.getSignpostImage());
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().initPackingContext(context.getSignpostInstruction());
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::LaneInstruction>().initPackingContext(context.getLaneInstruction());
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        m_objectChoice.get<::nds::instructions::types::JunctionView>().initPackingContext(context.getJunctionView());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }
}

size_t InstructionsLaneTransitionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::SignpostImage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().bitSizeOf(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::LaneInstruction>().bitSizeOf(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::JunctionView>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeValue::bitSizeOf(InstructionsLaneTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::SignpostImage>().bitSizeOf(context.getSignpostImage(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().bitSizeOf(context.getSignpostInstruction(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::LaneInstruction>().bitSizeOf(context.getLaneInstruction(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        endBitPosition += m_objectChoice.get<::nds::instructions::types::JunctionView>().bitSizeOf(context.getJunctionView(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsLaneTransitionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::SignpostImage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().initializeOffsets(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::LaneInstruction>().initializeOffsets(endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::JunctionView>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }

    return endBitPosition;
}

size_t InstructionsLaneTransitionAttributeValue::initializeOffsets(InstructionsLaneTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::SignpostImage>().initializeOffsets(context.getSignpostImage(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().initializeOffsets(context.getSignpostInstruction(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::LaneInstruction>().initializeOffsets(context.getLaneInstruction(), endBitPosition);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        endBitPosition = m_objectChoice.get<::nds::instructions::types::JunctionView>().initializeOffsets(context.getJunctionView(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }

    return endBitPosition;
}

bool InstructionsLaneTransitionAttributeValue::operator==(const InstructionsLaneTransitionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::instructions::types::SignpostImage>() == other.m_objectChoice.get<::nds::instructions::types::SignpostImage>());
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::instructions::types::SignpostInstruction>() == other.m_objectChoice.get<::nds::instructions::types::SignpostInstruction>());
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::instructions::types::LaneInstruction>() == other.m_objectChoice.get<::nds::instructions::types::LaneInstruction>());
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::instructions::types::JunctionView>() == other.m_objectChoice.get<::nds::instructions::types::JunctionView>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }
}

uint32_t InstructionsLaneTransitionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::instructions::types::SignpostImage>());
            break;
        case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::instructions::types::SignpostInstruction>());
            break;
        case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::instructions::types::LaneInstruction>());
            break;
        case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::instructions::types::JunctionView>());
            break;
        default:
            break;
        }
    }

    return result;
}

void InstructionsLaneTransitionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        m_objectChoice.get<::nds::instructions::types::SignpostImage>().write(out);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().write(out);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::LaneInstruction>().write(out);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        m_objectChoice.get<::nds::instructions::types::JunctionView>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }
}

void InstructionsLaneTransitionAttributeValue::write(InstructionsLaneTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        m_objectChoice.get<::nds::instructions::types::SignpostImage>().write(context.getSignpostImage(), out);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::SignpostInstruction>().write(context.getSignpostInstruction(), out);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        m_objectChoice.get<::nds::instructions::types::LaneInstruction>().write(context.getLaneInstruction(), out);
        break;
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        m_objectChoice.get<::nds::instructions::types::JunctionView>().write(context.getJunctionView(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> InstructionsLaneTransitionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        return ::zserio::AnyHolder<>(::nds::instructions::types::SignpostImage(in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return ::zserio::AnyHolder<>(::nds::instructions::types::SignpostInstruction(in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        return ::zserio::AnyHolder<>(::nds::instructions::types::LaneInstruction(in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        return ::zserio::AnyHolder<>(::nds::instructions::types::JunctionView(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> InstructionsLaneTransitionAttributeValue::readObject(InstructionsLaneTransitionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        return ::zserio::AnyHolder<>(::nds::instructions::types::SignpostImage(context.getSignpostImage(), in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return ::zserio::AnyHolder<>(::nds::instructions::types::SignpostInstruction(context.getSignpostInstruction(), in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        return ::zserio::AnyHolder<>(::nds::instructions::types::LaneInstruction(context.getLaneInstruction(), in, allocator), allocator);
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        return ::zserio::AnyHolder<>(::nds::instructions::types::JunctionView(context.getJunctionView(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> InstructionsLaneTransitionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_IMAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::instructions::types::SignpostImage>(m_objectChoice, allocator);
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::SIGNPOST_INSTRUCTION:
        return ::zserio::allocatorPropagatingCopy<::nds::instructions::types::SignpostInstruction>(m_objectChoice, allocator);
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::LANE_INSTRUCTION:
        return ::zserio::allocatorPropagatingCopy<::nds::instructions::types::LaneInstruction>(m_objectChoice, allocator);
    case ::nds::instructions::attributes::InstructionsLaneTransitionAttributeType::JUNCTION_VIEW:
        return ::zserio::allocatorPropagatingCopy<::nds::instructions::types::JunctionView>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice InstructionsLaneTransitionAttributeValue!");
    }
}

} // namespace attributes
} // namespace instructions
} // namespace nds
