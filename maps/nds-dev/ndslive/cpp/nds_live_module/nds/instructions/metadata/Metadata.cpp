/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/instructions/metadata/RoadInstructionsLayerContent.h>

namespace nds
{
namespace instructions
{
namespace metadata
{

RoadInstructionsLayerContent::RoadInstructionsLayerContent(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

RoadInstructionsLayerContent::RoadInstructionsLayerContent(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

RoadInstructionsLayerContent::RoadInstructionsLayerContent(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'RoadInstructionsLayerContent' out of bounds: ") << value << "!";
}

void RoadInstructionsLayerContent::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::RoadInstructionsLayerContent::underlying_type>>(m_value);
}

size_t RoadInstructionsLayerContent::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t RoadInstructionsLayerContent::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::RoadInstructionsLayerContent::underlying_type>>(m_value);
}

size_t RoadInstructionsLayerContent::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t RoadInstructionsLayerContent::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t RoadInstructionsLayerContent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void RoadInstructionsLayerContent::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void RoadInstructionsLayerContent::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::RoadInstructionsLayerContent::underlying_type>>(out, m_value);
}

::zserio::string<> RoadInstructionsLayerContent::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == RoadInstructionsLayerContent::Values::TRANSITION_MAPS)
        result += result.empty() ? "TRANSITION_MAPS" : " | TRANSITION_MAPS";
    if ((*this & RoadInstructionsLayerContent::Values::TRANSITION_SETS) == RoadInstructionsLayerContent::Values::TRANSITION_SETS)
        result += result.empty() ? "TRANSITION_SETS" : " | TRANSITION_SETS";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

RoadInstructionsLayerContent::underlying_type RoadInstructionsLayerContent::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

RoadInstructionsLayerContent::underlying_type RoadInstructionsLayerContent::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::RoadInstructionsLayerContent::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/instructions/metadata/LaneInstructionsLayerContent.h>

namespace nds
{
namespace instructions
{
namespace metadata
{

LaneInstructionsLayerContent::LaneInstructionsLayerContent(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

LaneInstructionsLayerContent::LaneInstructionsLayerContent(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

LaneInstructionsLayerContent::LaneInstructionsLayerContent(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'LaneInstructionsLayerContent' out of bounds: ") << value << "!";
}

void LaneInstructionsLayerContent::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::LaneInstructionsLayerContent::underlying_type>>(m_value);
}

size_t LaneInstructionsLayerContent::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t LaneInstructionsLayerContent::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::LaneInstructionsLayerContent::underlying_type>>(m_value);
}

size_t LaneInstructionsLayerContent::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t LaneInstructionsLayerContent::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t LaneInstructionsLayerContent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void LaneInstructionsLayerContent::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void LaneInstructionsLayerContent::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::LaneInstructionsLayerContent::underlying_type>>(out, m_value);
}

::zserio::string<> LaneInstructionsLayerContent::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS)
        result += result.empty() ? "LANE_TRANSITION_MAPS" : " | LANE_TRANSITION_MAPS";
    if ((*this & LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
        result += result.empty() ? "LANE_TRANSITION_SETS" : " | LANE_TRANSITION_SETS";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

LaneInstructionsLayerContent::underlying_type LaneInstructionsLayerContent::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

LaneInstructionsLayerContent::underlying_type LaneInstructionsLayerContent::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::LaneInstructionsLayerContent::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/instructions/metadata/InstructionsImageLayerContent.h>

namespace nds
{
namespace instructions
{
namespace metadata
{

InstructionsImageLayerContent::InstructionsImageLayerContent(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

InstructionsImageLayerContent::InstructionsImageLayerContent(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

InstructionsImageLayerContent::InstructionsImageLayerContent(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'InstructionsImageLayerContent' out of bounds: ") << value << "!";
}

void InstructionsImageLayerContent::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::InstructionsImageLayerContent::underlying_type>>(m_value);
}

size_t InstructionsImageLayerContent::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t InstructionsImageLayerContent::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::InstructionsImageLayerContent::underlying_type>>(m_value);
}

size_t InstructionsImageLayerContent::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t InstructionsImageLayerContent::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t InstructionsImageLayerContent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void InstructionsImageLayerContent::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void InstructionsImageLayerContent::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::InstructionsImageLayerContent::underlying_type>>(out, m_value);
}

::zserio::string<> InstructionsImageLayerContent::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & InstructionsImageLayerContent::Values::SIGNPOSTS) == InstructionsImageLayerContent::Values::SIGNPOSTS)
        result += result.empty() ? "SIGNPOSTS" : " | SIGNPOSTS";
    if ((*this & InstructionsImageLayerContent::Values::JUNCTION_VIEW) == InstructionsImageLayerContent::Values::JUNCTION_VIEW)
        result += result.empty() ? "JUNCTION_VIEW" : " | JUNCTION_VIEW";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

InstructionsImageLayerContent::underlying_type InstructionsImageLayerContent::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

InstructionsImageLayerContent::underlying_type InstructionsImageLayerContent::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::instructions::metadata::InstructionsImageLayerContent::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/instructions/metadata/RoadInstructionsLayerMetadata.h>
#include <nds/instructions/metadata/RoadInstructionsLayerContent.h>

namespace nds
{
namespace instructions
{
namespace metadata
{

RoadInstructionsLayerMetadata::RoadInstructionsLayerMetadata(const allocator_type& allocator) noexcept :
        m_content_(::nds::instructions::metadata::RoadInstructionsLayerContent()),
        m_transitionMetadata_(::zserio::NullOpt),
        m_coveredRoadTypes_(allocator),
        m_globalImageReferences_(bool()),
        m_availableLanguages_(allocator)
{
}

RoadInstructionsLayerMetadata::RoadInstructionsLayerMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_content_(readContent(in)),
        m_transitionMetadata_(readTransitionMetadata(in, allocator)),
        m_coveredRoadTypes_(readCoveredRoadTypes(in, allocator)),
        m_globalImageReferences_(readGlobalImageReferences(in)),
        m_availableLanguages_(readAvailableLanguages(in, allocator))
{
}

RoadInstructionsLayerMetadata::RoadInstructionsLayerMetadata(RoadInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_content_(readContent(context, in)),
        m_transitionMetadata_(readTransitionMetadata(context, in, allocator)),
        m_coveredRoadTypes_(readCoveredRoadTypes(context, in, allocator)),
        m_globalImageReferences_(readGlobalImageReferences(in)),
        m_availableLanguages_(readAvailableLanguages(context, in, allocator))
{
}

RoadInstructionsLayerMetadata::RoadInstructionsLayerMetadata(::zserio::PropagateAllocatorT,
        const RoadInstructionsLayerMetadata& other, const allocator_type& allocator) :
        m_content_(::zserio::allocatorPropagatingCopy(other.m_content_, allocator)),
        m_transitionMetadata_(::zserio::allocatorPropagatingCopy(other.m_transitionMetadata_, allocator)),
        m_coveredRoadTypes_(::zserio::allocatorPropagatingCopy(other.m_coveredRoadTypes_, allocator)),
        m_globalImageReferences_(::zserio::allocatorPropagatingCopy(other.m_globalImageReferences_, allocator)),
        m_availableLanguages_(::zserio::allocatorPropagatingCopy(other.m_availableLanguages_, allocator))
{
}

::nds::instructions::metadata::RoadInstructionsLayerContent RoadInstructionsLayerMetadata::getContent() const
{
    return m_content_;
}

void RoadInstructionsLayerMetadata::setContent(::nds::instructions::metadata::RoadInstructionsLayerContent content_)
{
    m_content_ = content_;
}

::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata& RoadInstructionsLayerMetadata::getTransitionMetadata()
{
    return m_transitionMetadata_.value();
}

const ::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata& RoadInstructionsLayerMetadata::getTransitionMetadata() const
{
    return m_transitionMetadata_.value();
}

void RoadInstructionsLayerMetadata::setTransitionMetadata(const ::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata& transitionMetadata_)
{
    m_transitionMetadata_ = transitionMetadata_;
}

void RoadInstructionsLayerMetadata::setTransitionMetadata(::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata&& transitionMetadata_)
{
    m_transitionMetadata_ = ::std::move(transitionMetadata_);
}

bool RoadInstructionsLayerMetadata::isTransitionMetadataUsed() const
{
    return ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS);
}

bool RoadInstructionsLayerMetadata::isTransitionMetadataSet() const
{
    return m_transitionMetadata_.hasValue();
}

void RoadInstructionsLayerMetadata::resetTransitionMetadata()
{
    m_transitionMetadata_.reset();
}

::zserio::vector<::nds::core::types::RoadType>& RoadInstructionsLayerMetadata::getCoveredRoadTypes()
{
    return m_coveredRoadTypes_.getRawArray();
}

const ::zserio::vector<::nds::core::types::RoadType>& RoadInstructionsLayerMetadata::getCoveredRoadTypes() const
{
    return m_coveredRoadTypes_.getRawArray();
}

void RoadInstructionsLayerMetadata::setCoveredRoadTypes(const ::zserio::vector<::nds::core::types::RoadType>& coveredRoadTypes_)
{
    m_coveredRoadTypes_ = ZserioArrayType_coveredRoadTypes(coveredRoadTypes_);
}

void RoadInstructionsLayerMetadata::setCoveredRoadTypes(::zserio::vector<::nds::core::types::RoadType>&& coveredRoadTypes_)
{
    m_coveredRoadTypes_ = ZserioArrayType_coveredRoadTypes(std::move(coveredRoadTypes_));
}

bool RoadInstructionsLayerMetadata::getGlobalImageReferences() const
{
    return m_globalImageReferences_;
}

void RoadInstructionsLayerMetadata::setGlobalImageReferences(bool globalImageReferences_)
{
    m_globalImageReferences_ = globalImageReferences_;
}

::nds::core::language::AvailableLanguages& RoadInstructionsLayerMetadata::getAvailableLanguages()
{
    return m_availableLanguages_;
}

const ::nds::core::language::AvailableLanguages& RoadInstructionsLayerMetadata::getAvailableLanguages() const
{
    return m_availableLanguages_;
}

void RoadInstructionsLayerMetadata::setAvailableLanguages(const ::nds::core::language::AvailableLanguages& availableLanguages_)
{
    m_availableLanguages_ = availableLanguages_;
}

void RoadInstructionsLayerMetadata::setAvailableLanguages(::nds::core::language::AvailableLanguages&& availableLanguages_)
{
    m_availableLanguages_ = ::std::move(availableLanguages_);
}

void RoadInstructionsLayerMetadata::initPackingContext(RoadInstructionsLayerMetadata::ZserioPackingContext& context) const
{
    m_content_.initPackingContext(context.getContent());
    if ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS)
    {
        m_transitionMetadata_.value().initPackingContext(context.getTransitionMetadata());
    }
    m_availableLanguages_.initPackingContext(context.getAvailableLanguages());
}

size_t RoadInstructionsLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS)
    {
        endBitPosition += m_transitionMetadata_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += m_coveredRoadTypes_.bitSizeOf(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_availableLanguages_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadInstructionsLayerMetadata::bitSizeOf(RoadInstructionsLayerMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(context.getContent(), endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS)
    {
        endBitPosition += m_transitionMetadata_.value().bitSizeOf(context.getTransitionMetadata(), endBitPosition);
    }
    endBitPosition += m_coveredRoadTypes_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_availableLanguages_.bitSizeOf(context.getAvailableLanguages(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadInstructionsLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS)
    {
        endBitPosition = m_transitionMetadata_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = m_coveredRoadTypes_.initializeOffsets(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_availableLanguages_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadInstructionsLayerMetadata::initializeOffsets(RoadInstructionsLayerMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(context.getContent(), endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS)
    {
        endBitPosition = m_transitionMetadata_.value().initializeOffsets(context.getTransitionMetadata(), endBitPosition);
    }
    endBitPosition = m_coveredRoadTypes_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_availableLanguages_.initializeOffsets(context.getAvailableLanguages(), endBitPosition);

    return endBitPosition;
}

bool RoadInstructionsLayerMetadata::operator==(const RoadInstructionsLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_content_ == other.m_content_) &&
                (!isTransitionMetadataUsed() ? !other.isTransitionMetadataUsed() : (m_transitionMetadata_ == other.m_transitionMetadata_)) &&
                (m_coveredRoadTypes_ == other.m_coveredRoadTypes_) &&
                (m_globalImageReferences_ == other.m_globalImageReferences_) &&
                (m_availableLanguages_ == other.m_availableLanguages_);
    }

    return true;
}

uint32_t RoadInstructionsLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_content_);
    if (isTransitionMetadataUsed())
        result = ::zserio::calcHashCode(result, m_transitionMetadata_);
    result = ::zserio::calcHashCode(result, m_coveredRoadTypes_);
    result = ::zserio::calcHashCode(result, m_globalImageReferences_);
    result = ::zserio::calcHashCode(result, m_availableLanguages_);

    return result;
}

void RoadInstructionsLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_content_.write(out);
    if ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS)
    {
        m_transitionMetadata_.value().write(out);
    }
    m_coveredRoadTypes_.write(*this, out);
    out.writeBool(m_globalImageReferences_);
    m_availableLanguages_.write(out);
}

void RoadInstructionsLayerMetadata::write(RoadInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_content_.write(context.getContent(), out);
    if ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS)
    {
        m_transitionMetadata_.value().write(context.getTransitionMetadata(), out);
    }
    m_coveredRoadTypes_.writePacked(*this, out);
    out.writeBool(m_globalImageReferences_);
    m_availableLanguages_.write(context.getAvailableLanguages(), out);
}

void RoadInstructionsLayerMetadata::ZserioElementFactory_coveredRoadTypes::create(RoadInstructionsLayerMetadata&        ,
        ::zserio::vector<::nds::core::types::RoadType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoadInstructionsLayerMetadata::ZserioElementFactory_coveredRoadTypes::create(RoadInstructionsLayerMetadata&        ,
        ::zserio::vector<::nds::core::types::RoadType>& array,
        ::nds::core::types::RoadType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::instructions::metadata::RoadInstructionsLayerContent RoadInstructionsLayerMetadata::readContent(::zserio::BitStreamReader& in)
{
    return ::nds::instructions::metadata::RoadInstructionsLayerContent(in);
}

::nds::instructions::metadata::RoadInstructionsLayerContent RoadInstructionsLayerMetadata::readContent(RoadInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::instructions::metadata::RoadInstructionsLayerContent(context.getContent(), in);
}
::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata> RoadInstructionsLayerMetadata::readTransitionMetadata(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS)
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata>(::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata> RoadInstructionsLayerMetadata::readTransitionMetadata(RoadInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if ((getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS) == ::nds::instructions::metadata::RoadInstructionsLayerContent::Values::TRANSITION_SETS)
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata>(::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata(context.getTransitionMetadata(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsTransitionAttributeMetadata>(::zserio::NullOpt);
}
RoadInstructionsLayerMetadata::ZserioArrayType_coveredRoadTypes RoadInstructionsLayerMetadata::readCoveredRoadTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_coveredRoadTypes readField(allocator);
    readField.read(*this, in);

    return readField;
}

RoadInstructionsLayerMetadata::ZserioArrayType_coveredRoadTypes RoadInstructionsLayerMetadata::readCoveredRoadTypes(RoadInstructionsLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_coveredRoadTypes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
bool RoadInstructionsLayerMetadata::readGlobalImageReferences(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::core::language::AvailableLanguages RoadInstructionsLayerMetadata::readAvailableLanguages(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::language::AvailableLanguages(in, allocator);
}

::nds::core::language::AvailableLanguages RoadInstructionsLayerMetadata::readAvailableLanguages(RoadInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::language::AvailableLanguages(context.getAvailableLanguages(), in, allocator);
}

} // namespace metadata
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/instructions/metadata/LaneInstructionsLayerMetadata.h>
#include <nds/instructions/metadata/LaneInstructionsLayerContent.h>

namespace nds
{
namespace instructions
{
namespace metadata
{

LaneInstructionsLayerMetadata::LaneInstructionsLayerMetadata(const allocator_type& allocator) noexcept :
        m_content_(::nds::instructions::metadata::LaneInstructionsLayerContent()),
        m_laneTransitionAttributeMetadata_(::zserio::NullOpt),
        m_coveredLaneTypes_(allocator),
        m_globalImageReferences_(bool()),
        m_availableLanguages_(allocator)
{
}

LaneInstructionsLayerMetadata::LaneInstructionsLayerMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_content_(readContent(in)),
        m_laneTransitionAttributeMetadata_(readLaneTransitionAttributeMetadata(in, allocator)),
        m_coveredLaneTypes_(readCoveredLaneTypes(in, allocator)),
        m_globalImageReferences_(readGlobalImageReferences(in)),
        m_availableLanguages_(readAvailableLanguages(in, allocator))
{
}

LaneInstructionsLayerMetadata::LaneInstructionsLayerMetadata(LaneInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_content_(readContent(context, in)),
        m_laneTransitionAttributeMetadata_(readLaneTransitionAttributeMetadata(context, in, allocator)),
        m_coveredLaneTypes_(readCoveredLaneTypes(context, in, allocator)),
        m_globalImageReferences_(readGlobalImageReferences(in)),
        m_availableLanguages_(readAvailableLanguages(context, in, allocator))
{
}

LaneInstructionsLayerMetadata::LaneInstructionsLayerMetadata(::zserio::PropagateAllocatorT,
        const LaneInstructionsLayerMetadata& other, const allocator_type& allocator) :
        m_content_(::zserio::allocatorPropagatingCopy(other.m_content_, allocator)),
        m_laneTransitionAttributeMetadata_(::zserio::allocatorPropagatingCopy(other.m_laneTransitionAttributeMetadata_, allocator)),
        m_coveredLaneTypes_(::zserio::allocatorPropagatingCopy(other.m_coveredLaneTypes_, allocator)),
        m_globalImageReferences_(::zserio::allocatorPropagatingCopy(other.m_globalImageReferences_, allocator)),
        m_availableLanguages_(::zserio::allocatorPropagatingCopy(other.m_availableLanguages_, allocator))
{
}

::nds::instructions::metadata::LaneInstructionsLayerContent LaneInstructionsLayerMetadata::getContent() const
{
    return m_content_;
}

void LaneInstructionsLayerMetadata::setContent(::nds::instructions::metadata::LaneInstructionsLayerContent content_)
{
    m_content_ = content_;
}

::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata& LaneInstructionsLayerMetadata::getLaneTransitionAttributeMetadata()
{
    return m_laneTransitionAttributeMetadata_.value();
}

const ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata& LaneInstructionsLayerMetadata::getLaneTransitionAttributeMetadata() const
{
    return m_laneTransitionAttributeMetadata_.value();
}

void LaneInstructionsLayerMetadata::setLaneTransitionAttributeMetadata(const ::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata& laneTransitionAttributeMetadata_)
{
    m_laneTransitionAttributeMetadata_ = laneTransitionAttributeMetadata_;
}

void LaneInstructionsLayerMetadata::setLaneTransitionAttributeMetadata(::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata&& laneTransitionAttributeMetadata_)
{
    m_laneTransitionAttributeMetadata_ = ::std::move(laneTransitionAttributeMetadata_);
}

bool LaneInstructionsLayerMetadata::isLaneTransitionAttributeMetadataUsed() const
{
    return ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS);
}

bool LaneInstructionsLayerMetadata::isLaneTransitionAttributeMetadataSet() const
{
    return m_laneTransitionAttributeMetadata_.hasValue();
}

void LaneInstructionsLayerMetadata::resetLaneTransitionAttributeMetadata()
{
    m_laneTransitionAttributeMetadata_.reset();
}

::zserio::vector<::nds::core::types::LaneType>& LaneInstructionsLayerMetadata::getCoveredLaneTypes()
{
    return m_coveredLaneTypes_.getRawArray();
}

const ::zserio::vector<::nds::core::types::LaneType>& LaneInstructionsLayerMetadata::getCoveredLaneTypes() const
{
    return m_coveredLaneTypes_.getRawArray();
}

void LaneInstructionsLayerMetadata::setCoveredLaneTypes(const ::zserio::vector<::nds::core::types::LaneType>& coveredLaneTypes_)
{
    m_coveredLaneTypes_ = ZserioArrayType_coveredLaneTypes(coveredLaneTypes_);
}

void LaneInstructionsLayerMetadata::setCoveredLaneTypes(::zserio::vector<::nds::core::types::LaneType>&& coveredLaneTypes_)
{
    m_coveredLaneTypes_ = ZserioArrayType_coveredLaneTypes(std::move(coveredLaneTypes_));
}

bool LaneInstructionsLayerMetadata::getGlobalImageReferences() const
{
    return m_globalImageReferences_;
}

void LaneInstructionsLayerMetadata::setGlobalImageReferences(bool globalImageReferences_)
{
    m_globalImageReferences_ = globalImageReferences_;
}

::nds::core::language::AvailableLanguages& LaneInstructionsLayerMetadata::getAvailableLanguages()
{
    return m_availableLanguages_;
}

const ::nds::core::language::AvailableLanguages& LaneInstructionsLayerMetadata::getAvailableLanguages() const
{
    return m_availableLanguages_;
}

void LaneInstructionsLayerMetadata::setAvailableLanguages(const ::nds::core::language::AvailableLanguages& availableLanguages_)
{
    m_availableLanguages_ = availableLanguages_;
}

void LaneInstructionsLayerMetadata::setAvailableLanguages(::nds::core::language::AvailableLanguages&& availableLanguages_)
{
    m_availableLanguages_ = ::std::move(availableLanguages_);
}

void LaneInstructionsLayerMetadata::initPackingContext(LaneInstructionsLayerMetadata::ZserioPackingContext& context) const
{
    m_content_.initPackingContext(context.getContent());
    if ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
    {
        m_laneTransitionAttributeMetadata_.value().initPackingContext(context.getLaneTransitionAttributeMetadata());
    }
    m_availableLanguages_.initPackingContext(context.getAvailableLanguages());
}

size_t LaneInstructionsLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
    {
        endBitPosition += m_laneTransitionAttributeMetadata_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += m_coveredLaneTypes_.bitSizeOf(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_availableLanguages_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneInstructionsLayerMetadata::bitSizeOf(LaneInstructionsLayerMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(context.getContent(), endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
    {
        endBitPosition += m_laneTransitionAttributeMetadata_.value().bitSizeOf(context.getLaneTransitionAttributeMetadata(), endBitPosition);
    }
    endBitPosition += m_coveredLaneTypes_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_availableLanguages_.bitSizeOf(context.getAvailableLanguages(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneInstructionsLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
    {
        endBitPosition = m_laneTransitionAttributeMetadata_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = m_coveredLaneTypes_.initializeOffsets(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_availableLanguages_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneInstructionsLayerMetadata::initializeOffsets(LaneInstructionsLayerMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(context.getContent(), endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
    {
        endBitPosition = m_laneTransitionAttributeMetadata_.value().initializeOffsets(context.getLaneTransitionAttributeMetadata(), endBitPosition);
    }
    endBitPosition = m_coveredLaneTypes_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_availableLanguages_.initializeOffsets(context.getAvailableLanguages(), endBitPosition);

    return endBitPosition;
}

bool LaneInstructionsLayerMetadata::operator==(const LaneInstructionsLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_content_ == other.m_content_) &&
                (!isLaneTransitionAttributeMetadataUsed() ? !other.isLaneTransitionAttributeMetadataUsed() : (m_laneTransitionAttributeMetadata_ == other.m_laneTransitionAttributeMetadata_)) &&
                (m_coveredLaneTypes_ == other.m_coveredLaneTypes_) &&
                (m_globalImageReferences_ == other.m_globalImageReferences_) &&
                (m_availableLanguages_ == other.m_availableLanguages_);
    }

    return true;
}

uint32_t LaneInstructionsLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_content_);
    if (isLaneTransitionAttributeMetadataUsed())
        result = ::zserio::calcHashCode(result, m_laneTransitionAttributeMetadata_);
    result = ::zserio::calcHashCode(result, m_coveredLaneTypes_);
    result = ::zserio::calcHashCode(result, m_globalImageReferences_);
    result = ::zserio::calcHashCode(result, m_availableLanguages_);

    return result;
}

void LaneInstructionsLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_content_.write(out);
    if ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
    {
        m_laneTransitionAttributeMetadata_.value().write(out);
    }
    m_coveredLaneTypes_.write(*this, out);
    out.writeBool(m_globalImageReferences_);
    m_availableLanguages_.write(out);
}

void LaneInstructionsLayerMetadata::write(LaneInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_content_.write(context.getContent(), out);
    if ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
    {
        m_laneTransitionAttributeMetadata_.value().write(context.getLaneTransitionAttributeMetadata(), out);
    }
    m_coveredLaneTypes_.writePacked(*this, out);
    out.writeBool(m_globalImageReferences_);
    m_availableLanguages_.write(context.getAvailableLanguages(), out);
}

void LaneInstructionsLayerMetadata::ZserioElementFactory_coveredLaneTypes::create(LaneInstructionsLayerMetadata&        ,
        ::zserio::vector<::nds::core::types::LaneType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneInstructionsLayerMetadata::ZserioElementFactory_coveredLaneTypes::create(LaneInstructionsLayerMetadata&        ,
        ::zserio::vector<::nds::core::types::LaneType>& array,
        ::nds::core::types::LaneType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::instructions::metadata::LaneInstructionsLayerContent LaneInstructionsLayerMetadata::readContent(::zserio::BitStreamReader& in)
{
    return ::nds::instructions::metadata::LaneInstructionsLayerContent(in);
}

::nds::instructions::metadata::LaneInstructionsLayerContent LaneInstructionsLayerMetadata::readContent(LaneInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::instructions::metadata::LaneInstructionsLayerContent(context.getContent(), in);
}
::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata> LaneInstructionsLayerMetadata::readLaneTransitionAttributeMetadata(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata>(::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata> LaneInstructionsLayerMetadata::readLaneTransitionAttributeMetadata(LaneInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if ((getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_MAPS || (getContent() & ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS) == ::nds::instructions::metadata::LaneInstructionsLayerContent::Values::LANE_TRANSITION_SETS)
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata>(::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata(context.getLaneTransitionAttributeMetadata(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::instantiations::InstructionsLaneTransitionAttributeMetadata>(::zserio::NullOpt);
}
LaneInstructionsLayerMetadata::ZserioArrayType_coveredLaneTypes LaneInstructionsLayerMetadata::readCoveredLaneTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_coveredLaneTypes readField(allocator);
    readField.read(*this, in);

    return readField;
}

LaneInstructionsLayerMetadata::ZserioArrayType_coveredLaneTypes LaneInstructionsLayerMetadata::readCoveredLaneTypes(LaneInstructionsLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_coveredLaneTypes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
bool LaneInstructionsLayerMetadata::readGlobalImageReferences(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::core::language::AvailableLanguages LaneInstructionsLayerMetadata::readAvailableLanguages(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::language::AvailableLanguages(in, allocator);
}

::nds::core::language::AvailableLanguages LaneInstructionsLayerMetadata::readAvailableLanguages(LaneInstructionsLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::language::AvailableLanguages(context.getAvailableLanguages(), in, allocator);
}

} // namespace metadata
} // namespace instructions
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/instructions/metadata/InstructionsImageLayerMetadata.h>
#include <nds/instructions/metadata/InstructionsImageLayerContent.h>

namespace nds
{
namespace instructions
{
namespace metadata
{

InstructionsImageLayerMetadata::InstructionsImageLayerMetadata(const allocator_type&) noexcept :
        m_content_(::nds::instructions::metadata::InstructionsImageLayerContent()),
        m_junctionViewAbstractionLevel_(::zserio::NullOpt)
{
}

InstructionsImageLayerMetadata::InstructionsImageLayerMetadata(::zserio::BitStreamReader& in, const allocator_type&) :
        m_content_(readContent(in)),
        m_junctionViewAbstractionLevel_(readJunctionViewAbstractionLevel(in))
{
}

InstructionsImageLayerMetadata::InstructionsImageLayerMetadata(InstructionsImageLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_content_(readContent(context, in)),
        m_junctionViewAbstractionLevel_(readJunctionViewAbstractionLevel(context, in))
{
}

InstructionsImageLayerMetadata::InstructionsImageLayerMetadata(::zserio::PropagateAllocatorT,
        const InstructionsImageLayerMetadata& other, const allocator_type& allocator) :
        m_content_(::zserio::allocatorPropagatingCopy(other.m_content_, allocator)),
        m_junctionViewAbstractionLevel_(::zserio::allocatorPropagatingCopy(other.m_junctionViewAbstractionLevel_, allocator))
{
}

::nds::instructions::metadata::InstructionsImageLayerContent InstructionsImageLayerMetadata::getContent() const
{
    return m_content_;
}

void InstructionsImageLayerMetadata::setContent(::nds::instructions::metadata::InstructionsImageLayerContent content_)
{
    m_content_ = content_;
}

::nds::instructions::types::JunctionViewAbstractionLevel InstructionsImageLayerMetadata::getJunctionViewAbstractionLevel() const
{
    return m_junctionViewAbstractionLevel_.value();
}

void InstructionsImageLayerMetadata::setJunctionViewAbstractionLevel(::nds::instructions::types::JunctionViewAbstractionLevel junctionViewAbstractionLevel_)
{
    m_junctionViewAbstractionLevel_ = junctionViewAbstractionLevel_;
}

bool InstructionsImageLayerMetadata::isJunctionViewAbstractionLevelUsed() const
{
    return ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW);
}

bool InstructionsImageLayerMetadata::isJunctionViewAbstractionLevelSet() const
{
    return m_junctionViewAbstractionLevel_.hasValue();
}

void InstructionsImageLayerMetadata::resetJunctionViewAbstractionLevel()
{
    m_junctionViewAbstractionLevel_.reset();
}

void InstructionsImageLayerMetadata::initPackingContext(InstructionsImageLayerMetadata::ZserioPackingContext& context) const
{
    m_content_.initPackingContext(context.getContent());
    if ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW)
    {
        ::zserio::initPackingContext(context.getJunctionViewAbstractionLevel(), m_junctionViewAbstractionLevel_.value());
    }
}

size_t InstructionsImageLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW)
    {
        endBitPosition += ::zserio::bitSizeOf(m_junctionViewAbstractionLevel_.value());
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsImageLayerMetadata::bitSizeOf(InstructionsImageLayerMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(context.getContent(), endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW)
    {
        endBitPosition += ::zserio::bitSizeOf(context.getJunctionViewAbstractionLevel(), m_junctionViewAbstractionLevel_.value());
    }

    return endBitPosition - bitPosition;
}

size_t InstructionsImageLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW)
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_junctionViewAbstractionLevel_.value());
    }

    return endBitPosition;
}

size_t InstructionsImageLayerMetadata::initializeOffsets(InstructionsImageLayerMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(context.getContent(), endBitPosition);
    if ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW)
    {
        endBitPosition = ::zserio::initializeOffsets(context.getJunctionViewAbstractionLevel(), endBitPosition,
        m_junctionViewAbstractionLevel_.value());
    }

    return endBitPosition;
}

bool InstructionsImageLayerMetadata::operator==(const InstructionsImageLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_content_ == other.m_content_) &&
                (!isJunctionViewAbstractionLevelUsed() ? !other.isJunctionViewAbstractionLevelUsed() : (m_junctionViewAbstractionLevel_ == other.m_junctionViewAbstractionLevel_));
    }

    return true;
}

uint32_t InstructionsImageLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_content_);
    if (isJunctionViewAbstractionLevelUsed())
        result = ::zserio::calcHashCode(result, m_junctionViewAbstractionLevel_);

    return result;
}

void InstructionsImageLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_content_.write(out);
    if ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW)
    {
        ::zserio::write(out, m_junctionViewAbstractionLevel_.value());
    }
}

void InstructionsImageLayerMetadata::write(InstructionsImageLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_content_.write(context.getContent(), out);
    if ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW)
    {
        ::zserio::write(context.getJunctionViewAbstractionLevel(), out, m_junctionViewAbstractionLevel_.value());
    }
}

::nds::instructions::metadata::InstructionsImageLayerContent InstructionsImageLayerMetadata::readContent(::zserio::BitStreamReader& in)
{
    return ::nds::instructions::metadata::InstructionsImageLayerContent(in);
}

::nds::instructions::metadata::InstructionsImageLayerContent InstructionsImageLayerMetadata::readContent(InstructionsImageLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::instructions::metadata::InstructionsImageLayerContent(context.getContent(), in);
}
::zserio::InplaceOptionalHolder<::nds::instructions::types::JunctionViewAbstractionLevel> InstructionsImageLayerMetadata::readJunctionViewAbstractionLevel(::zserio::BitStreamReader& in)
{
    if ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW)
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::types::JunctionViewAbstractionLevel>(::zserio::read<::nds::instructions::types::JunctionViewAbstractionLevel>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::types::JunctionViewAbstractionLevel>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::instructions::types::JunctionViewAbstractionLevel> InstructionsImageLayerMetadata::readJunctionViewAbstractionLevel(InstructionsImageLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if ((getContent() & ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW) == ::nds::instructions::metadata::InstructionsImageLayerContent::Values::JUNCTION_VIEW)
    {
        return ::zserio::InplaceOptionalHolder<::nds::instructions::types::JunctionViewAbstractionLevel>(::zserio::read<::nds::instructions::types::JunctionViewAbstractionLevel>(context.getJunctionViewAbstractionLevel(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::instructions::types::JunctionViewAbstractionLevel>(::zserio::NullOpt);
}

} // namespace metadata
} // namespace instructions
} // namespace nds
