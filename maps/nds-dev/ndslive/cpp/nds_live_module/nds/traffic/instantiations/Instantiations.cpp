/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadRangeAttributeMetadata.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadRangeAttributeMetadata::TrafficRoadRangeAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

TrafficRoadRangeAttributeMetadata::TrafficRoadRangeAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

TrafficRoadRangeAttributeMetadata::TrafficRoadRangeAttributeMetadata(TrafficRoadRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

TrafficRoadRangeAttributeMetadata::TrafficRoadRangeAttributeMetadata(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::traffic::attributes::TrafficRoadRangeAttributeType>& TrafficRoadRangeAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::traffic::attributes::TrafficRoadRangeAttributeType>& TrafficRoadRangeAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void TrafficRoadRangeAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::traffic::attributes::TrafficRoadRangeAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void TrafficRoadRangeAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::traffic::attributes::TrafficRoadRangeAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& TrafficRoadRangeAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& TrafficRoadRangeAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void TrafficRoadRangeAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void TrafficRoadRangeAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::traffic::properties::TrafficPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& TrafficRoadRangeAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& TrafficRoadRangeAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void TrafficRoadRangeAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void TrafficRoadRangeAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void TrafficRoadRangeAttributeMetadata::initPackingContext(TrafficRoadRangeAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t TrafficRoadRangeAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeMetadata::bitSizeOf(TrafficRoadRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadRangeAttributeMetadata::initializeOffsets(TrafficRoadRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool TrafficRoadRangeAttributeMetadata::operator==(const TrafficRoadRangeAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t TrafficRoadRangeAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void TrafficRoadRangeAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void TrafficRoadRangeAttributeMetadata::write(TrafficRoadRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void TrafficRoadRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(TrafficRoadRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(TrafficRoadRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& array,
        ::nds::traffic::properties::TrafficPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

TrafficRoadRangeAttributeMetadata::ZserioArrayType_availableAttributes TrafficRoadRangeAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

TrafficRoadRangeAttributeMetadata::ZserioArrayType_availableAttributes TrafficRoadRangeAttributeMetadata::readAvailableAttributes(TrafficRoadRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
TrafficRoadRangeAttributeMetadata::ZserioArrayType_availableProperties TrafficRoadRangeAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

TrafficRoadRangeAttributeMetadata::ZserioArrayType_availableProperties TrafficRoadRangeAttributeMetadata::readAvailableProperties(TrafficRoadRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection TrafficRoadRangeAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection TrafficRoadRangeAttributeMetadata::readAvailableConditions(TrafficRoadRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficLaneRangeAttributeMetadata.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficLaneRangeAttributeMetadata::TrafficLaneRangeAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

TrafficLaneRangeAttributeMetadata::TrafficLaneRangeAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

TrafficLaneRangeAttributeMetadata::TrafficLaneRangeAttributeMetadata(TrafficLaneRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

TrafficLaneRangeAttributeMetadata::TrafficLaneRangeAttributeMetadata(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::traffic::attributes::TrafficLaneRangeAttributeType>& TrafficLaneRangeAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::traffic::attributes::TrafficLaneRangeAttributeType>& TrafficLaneRangeAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void TrafficLaneRangeAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::traffic::attributes::TrafficLaneRangeAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void TrafficLaneRangeAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::traffic::attributes::TrafficLaneRangeAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& TrafficLaneRangeAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& TrafficLaneRangeAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void TrafficLaneRangeAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void TrafficLaneRangeAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::traffic::properties::TrafficPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& TrafficLaneRangeAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& TrafficLaneRangeAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void TrafficLaneRangeAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void TrafficLaneRangeAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void TrafficLaneRangeAttributeMetadata::initPackingContext(TrafficLaneRangeAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t TrafficLaneRangeAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeMetadata::bitSizeOf(TrafficLaneRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TrafficLaneRangeAttributeMetadata::initializeOffsets(TrafficLaneRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool TrafficLaneRangeAttributeMetadata::operator==(const TrafficLaneRangeAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t TrafficLaneRangeAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void TrafficLaneRangeAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void TrafficLaneRangeAttributeMetadata::write(TrafficLaneRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void TrafficLaneRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(TrafficLaneRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficLaneRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(TrafficLaneRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& array,
        ::nds::traffic::properties::TrafficPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

TrafficLaneRangeAttributeMetadata::ZserioArrayType_availableAttributes TrafficLaneRangeAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

TrafficLaneRangeAttributeMetadata::ZserioArrayType_availableAttributes TrafficLaneRangeAttributeMetadata::readAvailableAttributes(TrafficLaneRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
TrafficLaneRangeAttributeMetadata::ZserioArrayType_availableProperties TrafficLaneRangeAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

TrafficLaneRangeAttributeMetadata::ZserioArrayType_availableProperties TrafficLaneRangeAttributeMetadata::readAvailableProperties(TrafficLaneRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection TrafficLaneRangeAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection TrafficLaneRangeAttributeMetadata::readAvailableConditions(TrafficLaneRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficDisplayLineRangeAttributeMetadata.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficDisplayLineRangeAttributeMetadata::TrafficDisplayLineRangeAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

TrafficDisplayLineRangeAttributeMetadata::TrafficDisplayLineRangeAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

TrafficDisplayLineRangeAttributeMetadata::TrafficDisplayLineRangeAttributeMetadata(TrafficDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

TrafficDisplayLineRangeAttributeMetadata::TrafficDisplayLineRangeAttributeMetadata(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>& TrafficDisplayLineRangeAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>& TrafficDisplayLineRangeAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void TrafficDisplayLineRangeAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& TrafficDisplayLineRangeAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& TrafficDisplayLineRangeAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void TrafficDisplayLineRangeAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::traffic::properties::TrafficPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& TrafficDisplayLineRangeAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& TrafficDisplayLineRangeAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void TrafficDisplayLineRangeAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void TrafficDisplayLineRangeAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void TrafficDisplayLineRangeAttributeMetadata::initPackingContext(TrafficDisplayLineRangeAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t TrafficDisplayLineRangeAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeMetadata::bitSizeOf(TrafficDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TrafficDisplayLineRangeAttributeMetadata::initializeOffsets(TrafficDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool TrafficDisplayLineRangeAttributeMetadata::operator==(const TrafficDisplayLineRangeAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t TrafficDisplayLineRangeAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void TrafficDisplayLineRangeAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void TrafficDisplayLineRangeAttributeMetadata::write(TrafficDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void TrafficDisplayLineRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(TrafficDisplayLineRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(TrafficDisplayLineRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& array,
        ::nds::traffic::properties::TrafficPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

TrafficDisplayLineRangeAttributeMetadata::ZserioArrayType_availableAttributes TrafficDisplayLineRangeAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

TrafficDisplayLineRangeAttributeMetadata::ZserioArrayType_availableAttributes TrafficDisplayLineRangeAttributeMetadata::readAvailableAttributes(TrafficDisplayLineRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
TrafficDisplayLineRangeAttributeMetadata::ZserioArrayType_availableProperties TrafficDisplayLineRangeAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

TrafficDisplayLineRangeAttributeMetadata::ZserioArrayType_availableProperties TrafficDisplayLineRangeAttributeMetadata::readAvailableProperties(TrafficDisplayLineRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection TrafficDisplayLineRangeAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection TrafficDisplayLineRangeAttributeMetadata::readAvailableConditions(TrafficDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficTransitionAttributeMetadata.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficTransitionAttributeMetadata::TrafficTransitionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

TrafficTransitionAttributeMetadata::TrafficTransitionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

TrafficTransitionAttributeMetadata::TrafficTransitionAttributeMetadata(TrafficTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

TrafficTransitionAttributeMetadata::TrafficTransitionAttributeMetadata(::zserio::PropagateAllocatorT,
        const TrafficTransitionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::traffic::attributes::TrafficTransitionAttributeType>& TrafficTransitionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::traffic::attributes::TrafficTransitionAttributeType>& TrafficTransitionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void TrafficTransitionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::traffic::attributes::TrafficTransitionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void TrafficTransitionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::traffic::attributes::TrafficTransitionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& TrafficTransitionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& TrafficTransitionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void TrafficTransitionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void TrafficTransitionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::traffic::properties::TrafficPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& TrafficTransitionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& TrafficTransitionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void TrafficTransitionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void TrafficTransitionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void TrafficTransitionAttributeMetadata::initPackingContext(TrafficTransitionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t TrafficTransitionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeMetadata::bitSizeOf(TrafficTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TrafficTransitionAttributeMetadata::initializeOffsets(TrafficTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool TrafficTransitionAttributeMetadata::operator==(const TrafficTransitionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t TrafficTransitionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void TrafficTransitionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void TrafficTransitionAttributeMetadata::write(TrafficTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void TrafficTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(TrafficTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(TrafficTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::traffic::properties::TrafficPropertyType>& array,
        ::nds::traffic::properties::TrafficPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

TrafficTransitionAttributeMetadata::ZserioArrayType_availableAttributes TrafficTransitionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

TrafficTransitionAttributeMetadata::ZserioArrayType_availableAttributes TrafficTransitionAttributeMetadata::readAvailableAttributes(TrafficTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
TrafficTransitionAttributeMetadata::ZserioArrayType_availableProperties TrafficTransitionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

TrafficTransitionAttributeMetadata::ZserioArrayType_availableProperties TrafficTransitionAttributeMetadata::readAvailableProperties(TrafficTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection TrafficTransitionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection TrafficTransitionAttributeMetadata::readAvailableConditions(TrafficTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadRangeAttributeMapList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadRangeAttributeMapList::TrafficRoadRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

TrafficRoadRangeAttributeMapList::TrafficRoadRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

TrafficRoadRangeAttributeMapList::TrafficRoadRangeAttributeMapList(TrafficRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

TrafficRoadRangeAttributeMapList::TrafficRoadRangeAttributeMapList(const TrafficRoadRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeMapList& TrafficRoadRangeAttributeMapList::operator=(const TrafficRoadRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeMapList::TrafficRoadRangeAttributeMapList(TrafficRoadRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeMapList& TrafficRoadRangeAttributeMapList::operator=(TrafficRoadRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeMapList::TrafficRoadRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficRoadRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void TrafficRoadRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader& TrafficRoadRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader& TrafficRoadRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void TrafficRoadRangeAttributeMapList::setHeader(const ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void TrafficRoadRangeAttributeMapList::setHeader(::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeMap>& TrafficRoadRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeMap>& TrafficRoadRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void TrafficRoadRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void TrafficRoadRangeAttributeMapList::setMaps(::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void TrafficRoadRangeAttributeMapList::initPackingContext(TrafficRoadRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t TrafficRoadRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeMapList::bitSizeOf(TrafficRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadRangeAttributeMapList::initializeOffsets(TrafficRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadRangeAttributeMapList::operator==(const TrafficRoadRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t TrafficRoadRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void TrafficRoadRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeMapList::write(TrafficRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(TrafficRoadRangeAttributeMapList& owner,
        ::nds::traffic::instantiations::TrafficRoadRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeMap>& array,
        ::nds::traffic::instantiations::TrafficRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficRoadRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficRoadRangeAttributeMapList::readNumMaps(TrafficRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader TrafficRoadRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader TrafficRoadRangeAttributeMapList::readHeader(TrafficRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
TrafficRoadRangeAttributeMapList::ZserioArrayType_maps TrafficRoadRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficRoadRangeAttributeMapList::ZserioArrayType_maps TrafficRoadRangeAttributeMapList::readMaps(TrafficRoadRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficIndirectRoadRangeAttributeMapList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficIndirectRoadRangeAttributeMapList::TrafficIndirectRoadRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

TrafficIndirectRoadRangeAttributeMapList::TrafficIndirectRoadRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

TrafficIndirectRoadRangeAttributeMapList::TrafficIndirectRoadRangeAttributeMapList(TrafficIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

TrafficIndirectRoadRangeAttributeMapList::TrafficIndirectRoadRangeAttributeMapList(const TrafficIndirectRoadRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectRoadRangeAttributeMapList& TrafficIndirectRoadRangeAttributeMapList::operator=(const TrafficIndirectRoadRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectRoadRangeAttributeMapList::TrafficIndirectRoadRangeAttributeMapList(TrafficIndirectRoadRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectRoadRangeAttributeMapList& TrafficIndirectRoadRangeAttributeMapList::operator=(TrafficIndirectRoadRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectRoadRangeAttributeMapList::TrafficIndirectRoadRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const TrafficIndirectRoadRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficIndirectRoadRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficIndirectRoadRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficIndirectRoadRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficIndirectRoadRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficIndirectRoadRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficIndirectRoadRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void TrafficIndirectRoadRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader& TrafficIndirectRoadRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader& TrafficIndirectRoadRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void TrafficIndirectRoadRangeAttributeMapList::setHeader(const ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void TrafficIndirectRoadRangeAttributeMapList::setHeader(::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeMap>& TrafficIndirectRoadRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeMap>& TrafficIndirectRoadRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void TrafficIndirectRoadRangeAttributeMapList::setMaps(::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void TrafficIndirectRoadRangeAttributeMapList::initPackingContext(TrafficIndirectRoadRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t TrafficIndirectRoadRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectRoadRangeAttributeMapList::bitSizeOf(TrafficIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectRoadRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficIndirectRoadRangeAttributeMapList::initializeOffsets(TrafficIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficIndirectRoadRangeAttributeMapList::operator==(const TrafficIndirectRoadRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t TrafficIndirectRoadRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void TrafficIndirectRoadRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficIndirectRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficIndirectRoadRangeAttributeMapList::write(TrafficIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficIndirectRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficIndirectRoadRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(TrafficIndirectRoadRangeAttributeMapList& owner,
        ::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficIndirectRoadRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficIndirectRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficIndirectRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeMap>& array,
        ::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficIndirectRoadRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficIndirectRoadRangeAttributeMapList::readNumMaps(TrafficIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader TrafficIndirectRoadRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader TrafficIndirectRoadRangeAttributeMapList::readHeader(TrafficIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
TrafficIndirectRoadRangeAttributeMapList::ZserioArrayType_maps TrafficIndirectRoadRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficIndirectRoadRangeAttributeMapList::ZserioArrayType_maps TrafficIndirectRoadRangeAttributeMapList::readMaps(TrafficIndirectRoadRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadLocationRangeAttributeMapList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadLocationRangeAttributeMapList::TrafficRoadLocationRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

TrafficRoadLocationRangeAttributeMapList::TrafficRoadLocationRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

TrafficRoadLocationRangeAttributeMapList::TrafficRoadLocationRangeAttributeMapList(TrafficRoadLocationRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

TrafficRoadLocationRangeAttributeMapList::TrafficRoadLocationRangeAttributeMapList(const TrafficRoadLocationRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationRangeAttributeMapList& TrafficRoadLocationRangeAttributeMapList::operator=(const TrafficRoadLocationRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationRangeAttributeMapList::TrafficRoadLocationRangeAttributeMapList(TrafficRoadLocationRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationRangeAttributeMapList& TrafficRoadLocationRangeAttributeMapList::operator=(TrafficRoadLocationRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationRangeAttributeMapList::TrafficRoadLocationRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const TrafficRoadLocationRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadLocationRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadLocationRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadLocationRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadLocationRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadLocationRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficRoadLocationRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void TrafficRoadLocationRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader& TrafficRoadLocationRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader& TrafficRoadLocationRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void TrafficRoadLocationRangeAttributeMapList::setHeader(const ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void TrafficRoadLocationRangeAttributeMapList::setHeader(::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeMap>& TrafficRoadLocationRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeMap>& TrafficRoadLocationRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void TrafficRoadLocationRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void TrafficRoadLocationRangeAttributeMapList::setMaps(::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void TrafficRoadLocationRangeAttributeMapList::initPackingContext(TrafficRoadLocationRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t TrafficRoadLocationRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationRangeAttributeMapList::bitSizeOf(TrafficRoadLocationRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadLocationRangeAttributeMapList::initializeOffsets(TrafficRoadLocationRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadLocationRangeAttributeMapList::operator==(const TrafficRoadLocationRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t TrafficRoadLocationRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void TrafficRoadLocationRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficRoadLocationRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficRoadLocationRangeAttributeMapList::write(TrafficRoadLocationRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficRoadLocationRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficRoadLocationRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(TrafficRoadLocationRangeAttributeMapList& owner,
        ::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadLocationRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficRoadLocationRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficRoadLocationRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeMap>& array,
        ::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficRoadLocationRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficRoadLocationRangeAttributeMapList::readNumMaps(TrafficRoadLocationRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader TrafficRoadLocationRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader TrafficRoadLocationRangeAttributeMapList::readHeader(TrafficRoadLocationRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
TrafficRoadLocationRangeAttributeMapList::ZserioArrayType_maps TrafficRoadLocationRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficRoadLocationRangeAttributeMapList::ZserioArrayType_maps TrafficRoadLocationRangeAttributeMapList::readMaps(TrafficRoadLocationRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficLaneRangeAttributeMapList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficLaneRangeAttributeMapList::TrafficLaneRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

TrafficLaneRangeAttributeMapList::TrafficLaneRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

TrafficLaneRangeAttributeMapList::TrafficLaneRangeAttributeMapList(TrafficLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

TrafficLaneRangeAttributeMapList::TrafficLaneRangeAttributeMapList(const TrafficLaneRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeMapList& TrafficLaneRangeAttributeMapList::operator=(const TrafficLaneRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeMapList::TrafficLaneRangeAttributeMapList(TrafficLaneRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeMapList& TrafficLaneRangeAttributeMapList::operator=(TrafficLaneRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeMapList::TrafficLaneRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficLaneRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficLaneRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficLaneRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficLaneRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficLaneRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficLaneRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void TrafficLaneRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader& TrafficLaneRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader& TrafficLaneRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void TrafficLaneRangeAttributeMapList::setHeader(const ::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void TrafficLaneRangeAttributeMapList::setHeader(::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeMap>& TrafficLaneRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeMap>& TrafficLaneRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void TrafficLaneRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void TrafficLaneRangeAttributeMapList::setMaps(::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void TrafficLaneRangeAttributeMapList::initPackingContext(TrafficLaneRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t TrafficLaneRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeMapList::bitSizeOf(TrafficLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLaneRangeAttributeMapList::initializeOffsets(TrafficLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLaneRangeAttributeMapList::operator==(const TrafficLaneRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t TrafficLaneRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void TrafficLaneRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeMapList::write(TrafficLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(TrafficLaneRangeAttributeMapList& owner,
        ::nds::traffic::instantiations::TrafficLaneRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficLaneRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficLaneRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeMap>& array,
        ::nds::traffic::instantiations::TrafficLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficLaneRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficLaneRangeAttributeMapList::readNumMaps(TrafficLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader TrafficLaneRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader TrafficLaneRangeAttributeMapList::readHeader(TrafficLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
TrafficLaneRangeAttributeMapList::ZserioArrayType_maps TrafficLaneRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficLaneRangeAttributeMapList::ZserioArrayType_maps TrafficLaneRangeAttributeMapList::readMaps(TrafficLaneRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficIndirectLaneRangeAttributeMapList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficIndirectLaneRangeAttributeMapList::TrafficIndirectLaneRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

TrafficIndirectLaneRangeAttributeMapList::TrafficIndirectLaneRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

TrafficIndirectLaneRangeAttributeMapList::TrafficIndirectLaneRangeAttributeMapList(TrafficIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

TrafficIndirectLaneRangeAttributeMapList::TrafficIndirectLaneRangeAttributeMapList(const TrafficIndirectLaneRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectLaneRangeAttributeMapList& TrafficIndirectLaneRangeAttributeMapList::operator=(const TrafficIndirectLaneRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectLaneRangeAttributeMapList::TrafficIndirectLaneRangeAttributeMapList(TrafficIndirectLaneRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectLaneRangeAttributeMapList& TrafficIndirectLaneRangeAttributeMapList::operator=(TrafficIndirectLaneRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectLaneRangeAttributeMapList::TrafficIndirectLaneRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const TrafficIndirectLaneRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficIndirectLaneRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficIndirectLaneRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficIndirectLaneRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficIndirectLaneRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficIndirectLaneRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficIndirectLaneRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void TrafficIndirectLaneRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader& TrafficIndirectLaneRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader& TrafficIndirectLaneRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void TrafficIndirectLaneRangeAttributeMapList::setHeader(const ::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void TrafficIndirectLaneRangeAttributeMapList::setHeader(::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeMap>& TrafficIndirectLaneRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeMap>& TrafficIndirectLaneRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void TrafficIndirectLaneRangeAttributeMapList::setMaps(::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void TrafficIndirectLaneRangeAttributeMapList::initPackingContext(TrafficIndirectLaneRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t TrafficIndirectLaneRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectLaneRangeAttributeMapList::bitSizeOf(TrafficIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectLaneRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficIndirectLaneRangeAttributeMapList::initializeOffsets(TrafficIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficIndirectLaneRangeAttributeMapList::operator==(const TrafficIndirectLaneRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t TrafficIndirectLaneRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void TrafficIndirectLaneRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficIndirectLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficIndirectLaneRangeAttributeMapList::write(TrafficIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficIndirectLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficIndirectLaneRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(TrafficIndirectLaneRangeAttributeMapList& owner,
        ::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficIndirectLaneRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficIndirectLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficIndirectLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeMap>& array,
        ::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficIndirectLaneRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficIndirectLaneRangeAttributeMapList::readNumMaps(TrafficIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader TrafficIndirectLaneRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader TrafficIndirectLaneRangeAttributeMapList::readHeader(TrafficIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficLaneRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
TrafficIndirectLaneRangeAttributeMapList::ZserioArrayType_maps TrafficIndirectLaneRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficIndirectLaneRangeAttributeMapList::ZserioArrayType_maps TrafficIndirectLaneRangeAttributeMapList::readMaps(TrafficIndirectLaneRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficTransitionAttributeMapList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficTransitionAttributeMapList::TrafficTransitionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

TrafficTransitionAttributeMapList::TrafficTransitionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

TrafficTransitionAttributeMapList::TrafficTransitionAttributeMapList(TrafficTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

TrafficTransitionAttributeMapList::TrafficTransitionAttributeMapList(const TrafficTransitionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeMapList& TrafficTransitionAttributeMapList::operator=(const TrafficTransitionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeMapList::TrafficTransitionAttributeMapList(TrafficTransitionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeMapList& TrafficTransitionAttributeMapList::operator=(TrafficTransitionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeMapList::TrafficTransitionAttributeMapList(::zserio::PropagateAllocatorT,
        const TrafficTransitionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficTransitionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficTransitionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficTransitionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficTransitionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficTransitionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficTransitionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void TrafficTransitionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader& TrafficTransitionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader& TrafficTransitionAttributeMapList::getHeader() const
{
    return m_header_;
}

void TrafficTransitionAttributeMapList::setHeader(const ::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void TrafficTransitionAttributeMapList::setHeader(::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeMap>& TrafficTransitionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeMap>& TrafficTransitionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void TrafficTransitionAttributeMapList::setMaps(const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void TrafficTransitionAttributeMapList::setMaps(::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void TrafficTransitionAttributeMapList::initPackingContext(TrafficTransitionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t TrafficTransitionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeMapList::bitSizeOf(TrafficTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficTransitionAttributeMapList::initializeOffsets(TrafficTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficTransitionAttributeMapList::operator==(const TrafficTransitionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t TrafficTransitionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void TrafficTransitionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficTransitionAttributeMapList::write(TrafficTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficTransitionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(TrafficTransitionAttributeMapList& owner,
        ::nds::traffic::instantiations::TrafficTransitionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficTransitionAttributeMapList::ZserioElementFactory_maps::create(TrafficTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficTransitionAttributeMapList::ZserioElementFactory_maps::create(TrafficTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeMap>& array,
        ::nds::traffic::instantiations::TrafficTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficTransitionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficTransitionAttributeMapList::readNumMaps(TrafficTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader TrafficTransitionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader TrafficTransitionAttributeMapList::readHeader(TrafficTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
TrafficTransitionAttributeMapList::ZserioArrayType_maps TrafficTransitionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficTransitionAttributeMapList::ZserioArrayType_maps TrafficTransitionAttributeMapList::readMaps(TrafficTransitionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadLocationTransitionAttributeMapList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadLocationTransitionAttributeMapList::TrafficRoadLocationTransitionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

TrafficRoadLocationTransitionAttributeMapList::TrafficRoadLocationTransitionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

TrafficRoadLocationTransitionAttributeMapList::TrafficRoadLocationTransitionAttributeMapList(TrafficRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

TrafficRoadLocationTransitionAttributeMapList::TrafficRoadLocationTransitionAttributeMapList(const TrafficRoadLocationTransitionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationTransitionAttributeMapList& TrafficRoadLocationTransitionAttributeMapList::operator=(const TrafficRoadLocationTransitionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationTransitionAttributeMapList::TrafficRoadLocationTransitionAttributeMapList(TrafficRoadLocationTransitionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationTransitionAttributeMapList& TrafficRoadLocationTransitionAttributeMapList::operator=(TrafficRoadLocationTransitionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationTransitionAttributeMapList::TrafficRoadLocationTransitionAttributeMapList(::zserio::PropagateAllocatorT,
        const TrafficRoadLocationTransitionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadLocationTransitionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadLocationTransitionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadLocationTransitionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadLocationTransitionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadLocationTransitionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficRoadLocationTransitionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void TrafficRoadLocationTransitionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader& TrafficRoadLocationTransitionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader& TrafficRoadLocationTransitionAttributeMapList::getHeader() const
{
    return m_header_;
}

void TrafficRoadLocationTransitionAttributeMapList::setHeader(const ::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void TrafficRoadLocationTransitionAttributeMapList::setHeader(::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeMap>& TrafficRoadLocationTransitionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeMap>& TrafficRoadLocationTransitionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeMapList::setMaps(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void TrafficRoadLocationTransitionAttributeMapList::setMaps(::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void TrafficRoadLocationTransitionAttributeMapList::initPackingContext(TrafficRoadLocationTransitionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t TrafficRoadLocationTransitionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationTransitionAttributeMapList::bitSizeOf(TrafficRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationTransitionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadLocationTransitionAttributeMapList::initializeOffsets(TrafficRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadLocationTransitionAttributeMapList::operator==(const TrafficRoadLocationTransitionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t TrafficRoadLocationTransitionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void TrafficRoadLocationTransitionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficRoadLocationTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficRoadLocationTransitionAttributeMapList::write(TrafficRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficRoadLocationTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficRoadLocationTransitionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(TrafficRoadLocationTransitionAttributeMapList& owner,
        ::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadLocationTransitionAttributeMapList::ZserioElementFactory_maps::create(TrafficRoadLocationTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeMapList::ZserioElementFactory_maps::create(TrafficRoadLocationTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeMap>& array,
        ::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficRoadLocationTransitionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficRoadLocationTransitionAttributeMapList::readNumMaps(TrafficRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader TrafficRoadLocationTransitionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader TrafficRoadLocationTransitionAttributeMapList::readHeader(TrafficRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficTransitionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
TrafficRoadLocationTransitionAttributeMapList::ZserioArrayType_maps TrafficRoadLocationTransitionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficRoadLocationTransitionAttributeMapList::ZserioArrayType_maps TrafficRoadLocationTransitionAttributeMapList::readMaps(TrafficRoadLocationTransitionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficDisplayLineRangeAttributeMapList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficDisplayLineRangeAttributeMapList::TrafficDisplayLineRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

TrafficDisplayLineRangeAttributeMapList::TrafficDisplayLineRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

TrafficDisplayLineRangeAttributeMapList::TrafficDisplayLineRangeAttributeMapList(TrafficDisplayLineRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

TrafficDisplayLineRangeAttributeMapList::TrafficDisplayLineRangeAttributeMapList(const TrafficDisplayLineRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeMapList& TrafficDisplayLineRangeAttributeMapList::operator=(const TrafficDisplayLineRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeMapList::TrafficDisplayLineRangeAttributeMapList(TrafficDisplayLineRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeMapList& TrafficDisplayLineRangeAttributeMapList::operator=(TrafficDisplayLineRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeMapList::TrafficDisplayLineRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficDisplayLineRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficDisplayLineRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficDisplayLineRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficDisplayLineRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficDisplayLineRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficDisplayLineRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void TrafficDisplayLineRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMapListHeader& TrafficDisplayLineRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMapListHeader& TrafficDisplayLineRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void TrafficDisplayLineRangeAttributeMapList::setHeader(const ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void TrafficDisplayLineRangeAttributeMapList::setHeader(::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMap>& TrafficDisplayLineRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMap>& TrafficDisplayLineRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void TrafficDisplayLineRangeAttributeMapList::setMaps(::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void TrafficDisplayLineRangeAttributeMapList::initPackingContext(TrafficDisplayLineRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t TrafficDisplayLineRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeMapList::bitSizeOf(TrafficDisplayLineRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficDisplayLineRangeAttributeMapList::initializeOffsets(TrafficDisplayLineRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficDisplayLineRangeAttributeMapList::operator==(const TrafficDisplayLineRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t TrafficDisplayLineRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void TrafficDisplayLineRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficDisplayLineRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeMapList::write(TrafficDisplayLineRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field TrafficDisplayLineRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(TrafficDisplayLineRangeAttributeMapList& owner,
        ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficDisplayLineRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficDisplayLineRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMapList::ZserioElementFactory_maps::create(TrafficDisplayLineRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMap>& array,
        ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficDisplayLineRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficDisplayLineRangeAttributeMapList::readNumMaps(TrafficDisplayLineRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMapListHeader TrafficDisplayLineRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMapListHeader TrafficDisplayLineRangeAttributeMapList::readHeader(TrafficDisplayLineRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
TrafficDisplayLineRangeAttributeMapList::ZserioArrayType_maps TrafficDisplayLineRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficDisplayLineRangeAttributeMapList::ZserioArrayType_maps TrafficDisplayLineRangeAttributeMapList::readMaps(TrafficDisplayLineRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadRangeAttributeMapListHeader.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadRangeAttributeMapListHeader::TrafficRoadRangeAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

TrafficRoadRangeAttributeMapListHeader::TrafficRoadRangeAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

TrafficRoadRangeAttributeMapListHeader::TrafficRoadRangeAttributeMapListHeader(TrafficRoadRangeAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

TrafficRoadRangeAttributeMapListHeader::TrafficRoadRangeAttributeMapListHeader(const TrafficRoadRangeAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeMapListHeader& TrafficRoadRangeAttributeMapListHeader::operator=(const TrafficRoadRangeAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeMapListHeader::TrafficRoadRangeAttributeMapListHeader(TrafficRoadRangeAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeMapListHeader& TrafficRoadRangeAttributeMapListHeader::operator=(TrafficRoadRangeAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeMapListHeader::TrafficRoadRangeAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void TrafficRoadRangeAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool TrafficRoadRangeAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t TrafficRoadRangeAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'TrafficRoadRangeAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::traffic::attributes::TrafficRoadRangeAttributeType>& TrafficRoadRangeAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::traffic::attributes::TrafficRoadRangeAttributeType>& TrafficRoadRangeAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void TrafficRoadRangeAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::traffic::attributes::TrafficRoadRangeAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void TrafficRoadRangeAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::traffic::attributes::TrafficRoadRangeAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& TrafficRoadRangeAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& TrafficRoadRangeAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void TrafficRoadRangeAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void TrafficRoadRangeAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void TrafficRoadRangeAttributeMapListHeader::initPackingContext(TrafficRoadRangeAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t TrafficRoadRangeAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeMapListHeader::bitSizeOf(TrafficRoadRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadRangeAttributeMapListHeader::initializeOffsets(TrafficRoadRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadRangeAttributeMapListHeader::operator==(const TrafficRoadRangeAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t TrafficRoadRangeAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void TrafficRoadRangeAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeMapListHeader::write(TrafficRoadRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(TrafficRoadRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(TrafficRoadRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

TrafficRoadRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode TrafficRoadRangeAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficRoadRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode TrafficRoadRangeAttributeMapListHeader::readAttributeTypeCode(TrafficRoadRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
TrafficRoadRangeAttributeMapListHeader::ZserioArrayType_conditionType TrafficRoadRangeAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficRoadRangeAttributeMapListHeader::ZserioArrayType_conditionType TrafficRoadRangeAttributeMapListHeader::readConditionType(TrafficRoadRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficLaneRangeAttributeMapListHeader.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficLaneRangeAttributeMapListHeader::TrafficLaneRangeAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

TrafficLaneRangeAttributeMapListHeader::TrafficLaneRangeAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

TrafficLaneRangeAttributeMapListHeader::TrafficLaneRangeAttributeMapListHeader(TrafficLaneRangeAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

TrafficLaneRangeAttributeMapListHeader::TrafficLaneRangeAttributeMapListHeader(const TrafficLaneRangeAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeMapListHeader& TrafficLaneRangeAttributeMapListHeader::operator=(const TrafficLaneRangeAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeMapListHeader::TrafficLaneRangeAttributeMapListHeader(TrafficLaneRangeAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeMapListHeader& TrafficLaneRangeAttributeMapListHeader::operator=(TrafficLaneRangeAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeMapListHeader::TrafficLaneRangeAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void TrafficLaneRangeAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool TrafficLaneRangeAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t TrafficLaneRangeAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'TrafficLaneRangeAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::traffic::attributes::TrafficLaneRangeAttributeType>& TrafficLaneRangeAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::traffic::attributes::TrafficLaneRangeAttributeType>& TrafficLaneRangeAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void TrafficLaneRangeAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::traffic::attributes::TrafficLaneRangeAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void TrafficLaneRangeAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::traffic::attributes::TrafficLaneRangeAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& TrafficLaneRangeAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& TrafficLaneRangeAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void TrafficLaneRangeAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void TrafficLaneRangeAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void TrafficLaneRangeAttributeMapListHeader::initPackingContext(TrafficLaneRangeAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t TrafficLaneRangeAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeMapListHeader::bitSizeOf(TrafficLaneRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLaneRangeAttributeMapListHeader::initializeOffsets(TrafficLaneRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLaneRangeAttributeMapListHeader::operator==(const TrafficLaneRangeAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t TrafficLaneRangeAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void TrafficLaneRangeAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeMapListHeader::write(TrafficLaneRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(TrafficLaneRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficLaneRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(TrafficLaneRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

TrafficLaneRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode TrafficLaneRangeAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficLaneRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode TrafficLaneRangeAttributeMapListHeader::readAttributeTypeCode(TrafficLaneRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
TrafficLaneRangeAttributeMapListHeader::ZserioArrayType_conditionType TrafficLaneRangeAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficLaneRangeAttributeMapListHeader::ZserioArrayType_conditionType TrafficLaneRangeAttributeMapListHeader::readConditionType(TrafficLaneRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficTransitionAttributeMapListHeader.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficTransitionAttributeMapListHeader::TrafficTransitionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

TrafficTransitionAttributeMapListHeader::TrafficTransitionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

TrafficTransitionAttributeMapListHeader::TrafficTransitionAttributeMapListHeader(TrafficTransitionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

TrafficTransitionAttributeMapListHeader::TrafficTransitionAttributeMapListHeader(const TrafficTransitionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeMapListHeader& TrafficTransitionAttributeMapListHeader::operator=(const TrafficTransitionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeMapListHeader::TrafficTransitionAttributeMapListHeader(TrafficTransitionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeMapListHeader& TrafficTransitionAttributeMapListHeader::operator=(TrafficTransitionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeMapListHeader::TrafficTransitionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const TrafficTransitionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void TrafficTransitionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool TrafficTransitionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t TrafficTransitionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'TrafficTransitionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::traffic::attributes::TrafficTransitionAttributeType>& TrafficTransitionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::traffic::attributes::TrafficTransitionAttributeType>& TrafficTransitionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void TrafficTransitionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::traffic::attributes::TrafficTransitionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void TrafficTransitionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::traffic::attributes::TrafficTransitionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& TrafficTransitionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& TrafficTransitionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void TrafficTransitionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void TrafficTransitionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void TrafficTransitionAttributeMapListHeader::initPackingContext(TrafficTransitionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t TrafficTransitionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeMapListHeader::bitSizeOf(TrafficTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficTransitionAttributeMapListHeader::initializeOffsets(TrafficTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficTransitionAttributeMapListHeader::operator==(const TrafficTransitionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t TrafficTransitionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void TrafficTransitionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void TrafficTransitionAttributeMapListHeader::write(TrafficTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void TrafficTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(TrafficTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(TrafficTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

TrafficTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode TrafficTransitionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode TrafficTransitionAttributeMapListHeader::readAttributeTypeCode(TrafficTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
TrafficTransitionAttributeMapListHeader::ZserioArrayType_conditionType TrafficTransitionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficTransitionAttributeMapListHeader::ZserioArrayType_conditionType TrafficTransitionAttributeMapListHeader::readConditionType(TrafficTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficDisplayLineRangeAttributeMapListHeader.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficDisplayLineRangeAttributeMapListHeader::TrafficDisplayLineRangeAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

TrafficDisplayLineRangeAttributeMapListHeader::TrafficDisplayLineRangeAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

TrafficDisplayLineRangeAttributeMapListHeader::TrafficDisplayLineRangeAttributeMapListHeader(TrafficDisplayLineRangeAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

TrafficDisplayLineRangeAttributeMapListHeader::TrafficDisplayLineRangeAttributeMapListHeader(const TrafficDisplayLineRangeAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeMapListHeader& TrafficDisplayLineRangeAttributeMapListHeader::operator=(const TrafficDisplayLineRangeAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeMapListHeader::TrafficDisplayLineRangeAttributeMapListHeader(TrafficDisplayLineRangeAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeMapListHeader& TrafficDisplayLineRangeAttributeMapListHeader::operator=(TrafficDisplayLineRangeAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeMapListHeader::TrafficDisplayLineRangeAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void TrafficDisplayLineRangeAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool TrafficDisplayLineRangeAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t TrafficDisplayLineRangeAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'TrafficDisplayLineRangeAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>& TrafficDisplayLineRangeAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>& TrafficDisplayLineRangeAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void TrafficDisplayLineRangeAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& TrafficDisplayLineRangeAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& TrafficDisplayLineRangeAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void TrafficDisplayLineRangeAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void TrafficDisplayLineRangeAttributeMapListHeader::initPackingContext(TrafficDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t TrafficDisplayLineRangeAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeMapListHeader::bitSizeOf(TrafficDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficDisplayLineRangeAttributeMapListHeader::initializeOffsets(TrafficDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficDisplayLineRangeAttributeMapListHeader::operator==(const TrafficDisplayLineRangeAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t TrafficDisplayLineRangeAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void TrafficDisplayLineRangeAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeMapListHeader::write(TrafficDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(TrafficDisplayLineRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(TrafficDisplayLineRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

TrafficDisplayLineRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode TrafficDisplayLineRangeAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficDisplayLineRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode TrafficDisplayLineRangeAttributeMapListHeader::readAttributeTypeCode(TrafficDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
TrafficDisplayLineRangeAttributeMapListHeader::ZserioArrayType_conditionType TrafficDisplayLineRangeAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

TrafficDisplayLineRangeAttributeMapListHeader::ZserioArrayType_conditionType TrafficDisplayLineRangeAttributeMapListHeader::readConditionType(TrafficDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadRangeAttributeMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadRangeAttributeMap::TrafficRoadRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficRoadRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

TrafficRoadRangeAttributeMap::TrafficRoadRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

TrafficRoadRangeAttributeMap::TrafficRoadRangeAttributeMap(TrafficRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

TrafficRoadRangeAttributeMap::TrafficRoadRangeAttributeMap(const TrafficRoadRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeMap& TrafficRoadRangeAttributeMap::operator=(const TrafficRoadRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeMap::TrafficRoadRangeAttributeMap(TrafficRoadRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeMap& TrafficRoadRangeAttributeMap::operator=(TrafficRoadRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeMap::TrafficRoadRangeAttributeMap(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficRoadRangeAttributeMap::setAttributeTypeCode(::nds::traffic::attributes::TrafficRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator TrafficRoadRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void TrafficRoadRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& TrafficRoadRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& TrafficRoadRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void TrafficRoadRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void TrafficRoadRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& TrafficRoadRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& TrafficRoadRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void TrafficRoadRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void TrafficRoadRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficRoadRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficRoadRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void TrafficRoadRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void TrafficRoadRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator TrafficRoadRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void TrafficRoadRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& TrafficRoadRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& TrafficRoadRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void TrafficRoadRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void TrafficRoadRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficRoadRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficRoadRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void TrafficRoadRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void TrafficRoadRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficRoadRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficRoadRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void TrafficRoadRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void TrafficRoadRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void TrafficRoadRangeAttributeMap::initPackingContext(TrafficRoadRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t TrafficRoadRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeMap::bitSizeOf(TrafficRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadRangeAttributeMap::initializeOffsets(TrafficRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadRangeAttributeMap::operator==(const TrafficRoadRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t TrafficRoadRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void TrafficRoadRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeMap::write(TrafficRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficRoadRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(TrafficRoadRangeAttributeMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(TrafficRoadRangeAttributeMap& owner,
        ::nds::traffic::instantiations::TrafficRoadRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(owner.getAttributeTypeCode()));
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& array,
        ::nds::traffic::instantiations::TrafficRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficRoadRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(TrafficRoadRangeAttributeMap&,
        ::nds::traffic::instantiations::TrafficPropertyList& element, size_t)
{
    element.initializeChildren();
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::nds::traffic::instantiations::TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficRoadRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(TrafficRoadRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(in);
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadRangeAttributeMap::readAttributeTypeCode(TrafficRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator TrafficRoadRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficRoadRangeAttributeMap::readFeature(TrafficRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadRangeAttributeMap::ZserioArrayType_featureReferences TrafficRoadRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadRangeAttributeMap::ZserioArrayType_featureReferences TrafficRoadRangeAttributeMap::readFeatureReferences(TrafficRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficRoadRangeAttributeMap::ZserioArrayType_featureValidities TrafficRoadRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadRangeAttributeMap::ZserioArrayType_featureValidities TrafficRoadRangeAttributeMap::readFeatureValidities(TrafficRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficRoadRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficRoadRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficRoadRangeAttributeMap::readFeatureValuePtr(TrafficRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator TrafficRoadRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator TrafficRoadRangeAttributeMap::readAttribute(TrafficRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadRangeAttributeMap::ZserioArrayType_attributeValues TrafficRoadRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficRoadRangeAttributeMap::ZserioArrayType_attributeValues TrafficRoadRangeAttributeMap::readAttributeValues(TrafficRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficRoadRangeAttributeMap::ZserioArrayType_attributeProperties TrafficRoadRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficRoadRangeAttributeMap::ZserioArrayType_attributeProperties TrafficRoadRangeAttributeMap::readAttributeProperties(TrafficRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficRoadRangeAttributeMap::ZserioArrayType_attributeConditions TrafficRoadRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficRoadRangeAttributeMap::ZserioArrayType_attributeConditions TrafficRoadRangeAttributeMap::readAttributeConditions(TrafficRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficIndirectRoadRangeAttributeMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficIndirectRoadRangeAttributeMap::TrafficIndirectRoadRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficRoadRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

TrafficIndirectRoadRangeAttributeMap::TrafficIndirectRoadRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

TrafficIndirectRoadRangeAttributeMap::TrafficIndirectRoadRangeAttributeMap(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

TrafficIndirectRoadRangeAttributeMap::TrafficIndirectRoadRangeAttributeMap(const TrafficIndirectRoadRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectRoadRangeAttributeMap& TrafficIndirectRoadRangeAttributeMap::operator=(const TrafficIndirectRoadRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectRoadRangeAttributeMap::TrafficIndirectRoadRangeAttributeMap(TrafficIndirectRoadRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectRoadRangeAttributeMap& TrafficIndirectRoadRangeAttributeMap::operator=(TrafficIndirectRoadRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectRoadRangeAttributeMap::TrafficIndirectRoadRangeAttributeMap(::zserio::PropagateAllocatorT,
        const TrafficIndirectRoadRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficIndirectRoadRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficIndirectRoadRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficIndirectRoadRangeAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficIndirectRoadRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficIndirectRoadRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficIndirectRoadRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficIndirectRoadRangeAttributeMap::setAttributeTypeCode(::nds::traffic::attributes::TrafficRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator TrafficIndirectRoadRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void TrafficIndirectRoadRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& TrafficIndirectRoadRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& TrafficIndirectRoadRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void TrafficIndirectRoadRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& TrafficIndirectRoadRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& TrafficIndirectRoadRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void TrafficIndirectRoadRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficIndirectRoadRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficIndirectRoadRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void TrafficIndirectRoadRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator TrafficIndirectRoadRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void TrafficIndirectRoadRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& TrafficIndirectRoadRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& TrafficIndirectRoadRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void TrafficIndirectRoadRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficIndirectRoadRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficIndirectRoadRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void TrafficIndirectRoadRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficIndirectRoadRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficIndirectRoadRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void TrafficIndirectRoadRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void TrafficIndirectRoadRangeAttributeMap::initPackingContext(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t TrafficIndirectRoadRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectRoadRangeAttributeMap::bitSizeOf(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectRoadRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficIndirectRoadRangeAttributeMap::initializeOffsets(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficIndirectRoadRangeAttributeMap::operator==(const TrafficIndirectRoadRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t TrafficIndirectRoadRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void TrafficIndirectRoadRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficIndirectRoadRangeAttributeMap::write(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficIndirectRoadRangeAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(TrafficIndirectRoadRangeAttributeMap&,
        ::nds::road::reference::types::RoadReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::nds::road::reference::types::RoadReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(TrafficIndirectRoadRangeAttributeMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficIndirectRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficIndirectRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(TrafficIndirectRoadRangeAttributeMap& owner,
        ::nds::traffic::instantiations::TrafficRoadRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(owner.getAttributeTypeCode()));
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficIndirectRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficIndirectRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& array,
        ::nds::traffic::instantiations::TrafficRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(TrafficIndirectRoadRangeAttributeMap&,
        ::nds::traffic::instantiations::TrafficPropertyList& element, size_t)
{
    element.initializeChildren();
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::nds::traffic::instantiations::TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(TrafficIndirectRoadRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficIndirectRoadRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(in);
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficIndirectRoadRangeAttributeMap::readAttributeTypeCode(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator TrafficIndirectRoadRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficIndirectRoadRangeAttributeMap::readFeature(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_featureReferences TrafficIndirectRoadRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_featureReferences TrafficIndirectRoadRangeAttributeMap::readFeatureReferences(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_featureValidities TrafficIndirectRoadRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_featureValidities TrafficIndirectRoadRangeAttributeMap::readFeatureValidities(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficIndirectRoadRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficIndirectRoadRangeAttributeMap::readFeatureValuePtr(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator TrafficIndirectRoadRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator TrafficIndirectRoadRangeAttributeMap::readAttribute(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_attributeValues TrafficIndirectRoadRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_attributeValues TrafficIndirectRoadRangeAttributeMap::readAttributeValues(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_attributeProperties TrafficIndirectRoadRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_attributeProperties TrafficIndirectRoadRangeAttributeMap::readAttributeProperties(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_attributeConditions TrafficIndirectRoadRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficIndirectRoadRangeAttributeMap::ZserioArrayType_attributeConditions TrafficIndirectRoadRangeAttributeMap::readAttributeConditions(TrafficIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadLocationRangeAttributeMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadLocationRangeAttributeMap::TrafficRoadLocationRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficRoadRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

TrafficRoadLocationRangeAttributeMap::TrafficRoadLocationRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

TrafficRoadLocationRangeAttributeMap::TrafficRoadLocationRangeAttributeMap(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

TrafficRoadLocationRangeAttributeMap::TrafficRoadLocationRangeAttributeMap(const TrafficRoadLocationRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationRangeAttributeMap& TrafficRoadLocationRangeAttributeMap::operator=(const TrafficRoadLocationRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationRangeAttributeMap::TrafficRoadLocationRangeAttributeMap(TrafficRoadLocationRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationRangeAttributeMap& TrafficRoadLocationRangeAttributeMap::operator=(TrafficRoadLocationRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationRangeAttributeMap::TrafficRoadLocationRangeAttributeMap(::zserio::PropagateAllocatorT,
        const TrafficRoadLocationRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadLocationRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadLocationRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadLocationRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadLocationRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadLocationRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadLocationRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficRoadLocationRangeAttributeMap::setAttributeTypeCode(::nds::traffic::attributes::TrafficRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator TrafficRoadLocationRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void TrafficRoadLocationRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::location::RoadLocationReference>& TrafficRoadLocationRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& TrafficRoadLocationRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void TrafficRoadLocationRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void TrafficRoadLocationRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::location::RoadLocationReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& TrafficRoadLocationRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& TrafficRoadLocationRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void TrafficRoadLocationRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void TrafficRoadLocationRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficRoadLocationRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficRoadLocationRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void TrafficRoadLocationRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void TrafficRoadLocationRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator TrafficRoadLocationRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void TrafficRoadLocationRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& TrafficRoadLocationRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& TrafficRoadLocationRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void TrafficRoadLocationRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void TrafficRoadLocationRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficRoadLocationRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficRoadLocationRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void TrafficRoadLocationRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void TrafficRoadLocationRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficRoadLocationRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficRoadLocationRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void TrafficRoadLocationRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void TrafficRoadLocationRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void TrafficRoadLocationRangeAttributeMap::initPackingContext(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t TrafficRoadLocationRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationRangeAttributeMap::bitSizeOf(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadLocationRangeAttributeMap::initializeOffsets(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadLocationRangeAttributeMap::operator==(const TrafficRoadLocationRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t TrafficRoadLocationRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void TrafficRoadLocationRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficRoadLocationRangeAttributeMap::write(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& array,
        ::nds::road::reference::location::RoadLocationReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(TrafficRoadLocationRangeAttributeMap& owner,
        ::nds::road::reference::location::RoadLocationRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficRoadLocationRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficRoadLocationRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& array,
        ::nds::road::reference::location::RoadLocationRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(TrafficRoadLocationRangeAttributeMap& owner,
        ::nds::traffic::instantiations::TrafficRoadRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(owner.getAttributeTypeCode()));
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficRoadLocationRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficRoadLocationRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttribute>& array,
        ::nds::traffic::instantiations::TrafficRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(TrafficRoadLocationRangeAttributeMap&,
        ::nds::traffic::instantiations::TrafficPropertyList& element, size_t)
{
    element.initializeChildren();
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::nds::traffic::instantiations::TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(TrafficRoadLocationRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadLocationRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadLocationRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(in);
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadLocationRangeAttributeMap::readAttributeTypeCode(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator TrafficRoadLocationRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficRoadLocationRangeAttributeMap::readFeature(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadLocationRangeAttributeMap::ZserioArrayType_featureReferences TrafficRoadLocationRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadLocationRangeAttributeMap::ZserioArrayType_featureReferences TrafficRoadLocationRangeAttributeMap::readFeatureReferences(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficRoadLocationRangeAttributeMap::ZserioArrayType_featureValidities TrafficRoadLocationRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadLocationRangeAttributeMap::ZserioArrayType_featureValidities TrafficRoadLocationRangeAttributeMap::readFeatureValidities(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficRoadLocationRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficRoadLocationRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadLocationRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficRoadLocationRangeAttributeMap::readFeatureValuePtr(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator TrafficRoadLocationRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator TrafficRoadLocationRangeAttributeMap::readAttribute(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadLocationRangeAttributeMap::ZserioArrayType_attributeValues TrafficRoadLocationRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficRoadLocationRangeAttributeMap::ZserioArrayType_attributeValues TrafficRoadLocationRangeAttributeMap::readAttributeValues(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficRoadLocationRangeAttributeMap::ZserioArrayType_attributeProperties TrafficRoadLocationRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficRoadLocationRangeAttributeMap::ZserioArrayType_attributeProperties TrafficRoadLocationRangeAttributeMap::readAttributeProperties(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficRoadLocationRangeAttributeMap::ZserioArrayType_attributeConditions TrafficRoadLocationRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficRoadLocationRangeAttributeMap::ZserioArrayType_attributeConditions TrafficRoadLocationRangeAttributeMap::readAttributeConditions(TrafficRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficLaneRangeAttributeMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficLaneRangeAttributeMap::TrafficLaneRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficLaneRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

TrafficLaneRangeAttributeMap::TrafficLaneRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

TrafficLaneRangeAttributeMap::TrafficLaneRangeAttributeMap(TrafficLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

TrafficLaneRangeAttributeMap::TrafficLaneRangeAttributeMap(const TrafficLaneRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeMap& TrafficLaneRangeAttributeMap::operator=(const TrafficLaneRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeMap::TrafficLaneRangeAttributeMap(TrafficLaneRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeMap& TrafficLaneRangeAttributeMap::operator=(TrafficLaneRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeMap::TrafficLaneRangeAttributeMap(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficLaneRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficLaneRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficLaneRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficLaneRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficLaneRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficLaneRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficLaneRangeAttributeMap::setAttributeTypeCode(::nds::traffic::attributes::TrafficLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator TrafficLaneRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void TrafficLaneRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& TrafficLaneRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& TrafficLaneRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void TrafficLaneRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void TrafficLaneRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& TrafficLaneRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& TrafficLaneRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void TrafficLaneRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void TrafficLaneRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficLaneRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficLaneRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void TrafficLaneRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void TrafficLaneRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator TrafficLaneRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void TrafficLaneRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& TrafficLaneRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& TrafficLaneRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void TrafficLaneRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void TrafficLaneRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficLaneRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficLaneRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void TrafficLaneRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void TrafficLaneRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficLaneRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficLaneRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void TrafficLaneRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void TrafficLaneRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void TrafficLaneRangeAttributeMap::initPackingContext(TrafficLaneRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t TrafficLaneRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeMap::bitSizeOf(TrafficLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLaneRangeAttributeMap::initializeOffsets(TrafficLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLaneRangeAttributeMap::operator==(const TrafficLaneRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t TrafficLaneRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void TrafficLaneRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeMap::write(TrafficLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficLaneRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(TrafficLaneRangeAttributeMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficLaneRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(TrafficLaneRangeAttributeMap& owner,
        ::nds::traffic::instantiations::TrafficLaneRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(owner.getAttributeTypeCode()));
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& array,
        ::nds::traffic::instantiations::TrafficLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficLaneRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(TrafficLaneRangeAttributeMap&,
        ::nds::traffic::instantiations::TrafficPropertyList& element, size_t)
{
    element.initializeChildren();
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::nds::traffic::instantiations::TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficLaneRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(TrafficLaneRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficLaneRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(in);
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficLaneRangeAttributeMap::readAttributeTypeCode(TrafficLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator TrafficLaneRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficLaneRangeAttributeMap::readFeature(TrafficLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficLaneRangeAttributeMap::ZserioArrayType_featureReferences TrafficLaneRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficLaneRangeAttributeMap::ZserioArrayType_featureReferences TrafficLaneRangeAttributeMap::readFeatureReferences(TrafficLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficLaneRangeAttributeMap::ZserioArrayType_featureValidities TrafficLaneRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficLaneRangeAttributeMap::ZserioArrayType_featureValidities TrafficLaneRangeAttributeMap::readFeatureValidities(TrafficLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficLaneRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficLaneRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficLaneRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficLaneRangeAttributeMap::readFeatureValuePtr(TrafficLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator TrafficLaneRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator TrafficLaneRangeAttributeMap::readAttribute(TrafficLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficLaneRangeAttributeMap::ZserioArrayType_attributeValues TrafficLaneRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficLaneRangeAttributeMap::ZserioArrayType_attributeValues TrafficLaneRangeAttributeMap::readAttributeValues(TrafficLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficLaneRangeAttributeMap::ZserioArrayType_attributeProperties TrafficLaneRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficLaneRangeAttributeMap::ZserioArrayType_attributeProperties TrafficLaneRangeAttributeMap::readAttributeProperties(TrafficLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficLaneRangeAttributeMap::ZserioArrayType_attributeConditions TrafficLaneRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficLaneRangeAttributeMap::ZserioArrayType_attributeConditions TrafficLaneRangeAttributeMap::readAttributeConditions(TrafficLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficIndirectLaneRangeAttributeMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficIndirectLaneRangeAttributeMap::TrafficIndirectLaneRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficLaneRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

TrafficIndirectLaneRangeAttributeMap::TrafficIndirectLaneRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

TrafficIndirectLaneRangeAttributeMap::TrafficIndirectLaneRangeAttributeMap(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

TrafficIndirectLaneRangeAttributeMap::TrafficIndirectLaneRangeAttributeMap(const TrafficIndirectLaneRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectLaneRangeAttributeMap& TrafficIndirectLaneRangeAttributeMap::operator=(const TrafficIndirectLaneRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectLaneRangeAttributeMap::TrafficIndirectLaneRangeAttributeMap(TrafficIndirectLaneRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectLaneRangeAttributeMap& TrafficIndirectLaneRangeAttributeMap::operator=(TrafficIndirectLaneRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectLaneRangeAttributeMap::TrafficIndirectLaneRangeAttributeMap(::zserio::PropagateAllocatorT,
        const TrafficIndirectLaneRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficIndirectLaneRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficIndirectLaneRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficIndirectLaneRangeAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficIndirectLaneRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficIndirectLaneRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficIndirectLaneRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficIndirectLaneRangeAttributeMap::setAttributeTypeCode(::nds::traffic::attributes::TrafficLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator TrafficIndirectLaneRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void TrafficIndirectLaneRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& TrafficIndirectLaneRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& TrafficIndirectLaneRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void TrafficIndirectLaneRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& TrafficIndirectLaneRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& TrafficIndirectLaneRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void TrafficIndirectLaneRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficIndirectLaneRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficIndirectLaneRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void TrafficIndirectLaneRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator TrafficIndirectLaneRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void TrafficIndirectLaneRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& TrafficIndirectLaneRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& TrafficIndirectLaneRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void TrafficIndirectLaneRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficIndirectLaneRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficIndirectLaneRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void TrafficIndirectLaneRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficIndirectLaneRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficIndirectLaneRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void TrafficIndirectLaneRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void TrafficIndirectLaneRangeAttributeMap::initPackingContext(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t TrafficIndirectLaneRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectLaneRangeAttributeMap::bitSizeOf(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectLaneRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficIndirectLaneRangeAttributeMap::initializeOffsets(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficIndirectLaneRangeAttributeMap::operator==(const TrafficIndirectLaneRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t TrafficIndirectLaneRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void TrafficIndirectLaneRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficIndirectLaneRangeAttributeMap::write(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficIndirectLaneRangeAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(TrafficIndirectLaneRangeAttributeMap&,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(TrafficIndirectLaneRangeAttributeMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficIndirectLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficIndirectLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(TrafficIndirectLaneRangeAttributeMap& owner,
        ::nds::traffic::instantiations::TrafficLaneRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(owner.getAttributeTypeCode()));
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficIndirectLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficIndirectLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttribute>& array,
        ::nds::traffic::instantiations::TrafficLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(TrafficIndirectLaneRangeAttributeMap&,
        ::nds::traffic::instantiations::TrafficPropertyList& element, size_t)
{
    element.initializeChildren();
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::nds::traffic::instantiations::TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(TrafficIndirectLaneRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficIndirectLaneRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(in);
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficIndirectLaneRangeAttributeMap::readAttributeTypeCode(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator TrafficIndirectLaneRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficIndirectLaneRangeAttributeMap::readFeature(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_featureReferences TrafficIndirectLaneRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_featureReferences TrafficIndirectLaneRangeAttributeMap::readFeatureReferences(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_featureValidities TrafficIndirectLaneRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_featureValidities TrafficIndirectLaneRangeAttributeMap::readFeatureValidities(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficIndirectLaneRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficIndirectLaneRangeAttributeMap::readFeatureValuePtr(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator TrafficIndirectLaneRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator TrafficIndirectLaneRangeAttributeMap::readAttribute(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_attributeValues TrafficIndirectLaneRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_attributeValues TrafficIndirectLaneRangeAttributeMap::readAttributeValues(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_attributeProperties TrafficIndirectLaneRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_attributeProperties TrafficIndirectLaneRangeAttributeMap::readAttributeProperties(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_attributeConditions TrafficIndirectLaneRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficIndirectLaneRangeAttributeMap::ZserioArrayType_attributeConditions TrafficIndirectLaneRangeAttributeMap::readAttributeConditions(TrafficIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficTransitionAttributeMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficTransitionAttributeMap::TrafficTransitionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficTransitionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

TrafficTransitionAttributeMap::TrafficTransitionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

TrafficTransitionAttributeMap::TrafficTransitionAttributeMap(TrafficTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

TrafficTransitionAttributeMap::TrafficTransitionAttributeMap(const TrafficTransitionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeMap& TrafficTransitionAttributeMap::operator=(const TrafficTransitionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeMap::TrafficTransitionAttributeMap(TrafficTransitionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeMap& TrafficTransitionAttributeMap::operator=(TrafficTransitionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeMap::TrafficTransitionAttributeMap(::zserio::PropagateAllocatorT,
        const TrafficTransitionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficTransitionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficTransitionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficTransitionAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficTransitionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficTransitionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficTransitionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficTransitionAttributeMap::setAttributeTypeCode(::nds::traffic::attributes::TrafficTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator TrafficTransitionAttributeMap::getFeature() const
{
    return m_feature_;
}

void TrafficTransitionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::TransitionReference>& TrafficTransitionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::TransitionReference>& TrafficTransitionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void TrafficTransitionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::TransitionReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void TrafficTransitionAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::TransitionReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& TrafficTransitionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& TrafficTransitionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void TrafficTransitionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void TrafficTransitionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficTransitionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficTransitionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void TrafficTransitionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void TrafficTransitionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator TrafficTransitionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void TrafficTransitionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& TrafficTransitionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& TrafficTransitionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void TrafficTransitionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void TrafficTransitionAttributeMap::setAttributeValues(::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficTransitionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficTransitionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void TrafficTransitionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void TrafficTransitionAttributeMap::setAttributeProperties(::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficTransitionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficTransitionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void TrafficTransitionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void TrafficTransitionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void TrafficTransitionAttributeMap::initPackingContext(TrafficTransitionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t TrafficTransitionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeMap::bitSizeOf(TrafficTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficTransitionAttributeMap::initializeOffsets(TrafficTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficTransitionAttributeMap::operator==(const TrafficTransitionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t TrafficTransitionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void TrafficTransitionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficTransitionAttributeMap::write(TrafficTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficTransitionAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(TrafficTransitionAttributeMap&,
        ::nds::road::reference::types::TransitionReference& element, size_t)
{
    element.initializeChildren();
}

void TrafficTransitionAttributeMap::ZserioElementFactory_featureReferences::create(TrafficTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficTransitionAttributeMap::ZserioElementFactory_featureReferences::create(TrafficTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::nds::road::reference::types::TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficTransitionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(TrafficTransitionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficTransitionAttributeMap::ZserioElementFactory_featureValidities::create(TrafficTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficTransitionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(TrafficTransitionAttributeMap& owner,
        ::nds::traffic::instantiations::TrafficTransitionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(owner.getAttributeTypeCode()));
}

void TrafficTransitionAttributeMap::ZserioElementFactory_attributeValues::create(TrafficTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficTransitionAttributeMap::ZserioElementFactory_attributeValues::create(TrafficTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& array,
        ::nds::traffic::instantiations::TrafficTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficTransitionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(TrafficTransitionAttributeMap&,
        ::nds::traffic::instantiations::TrafficPropertyList& element, size_t)
{
    element.initializeChildren();
}

void TrafficTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficTransitionAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficTransitionAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::nds::traffic::instantiations::TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficTransitionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(TrafficTransitionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void TrafficTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficTransitionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficTransitionAttributeType>(in);
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficTransitionAttributeMap::readAttributeTypeCode(TrafficTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator TrafficTransitionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficTransitionAttributeMap::readFeature(TrafficTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficTransitionAttributeMap::ZserioArrayType_featureReferences TrafficTransitionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficTransitionAttributeMap::ZserioArrayType_featureReferences TrafficTransitionAttributeMap::readFeatureReferences(TrafficTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficTransitionAttributeMap::ZserioArrayType_featureValidities TrafficTransitionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficTransitionAttributeMap::ZserioArrayType_featureValuePtr TrafficTransitionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficTransitionAttributeMap::ZserioArrayType_featureValuePtr TrafficTransitionAttributeMap::readFeatureValuePtr(TrafficTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator TrafficTransitionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator TrafficTransitionAttributeMap::readAttribute(TrafficTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficTransitionAttributeMap::ZserioArrayType_attributeValues TrafficTransitionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficTransitionAttributeMap::ZserioArrayType_attributeValues TrafficTransitionAttributeMap::readAttributeValues(TrafficTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficTransitionAttributeMap::ZserioArrayType_attributeProperties TrafficTransitionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficTransitionAttributeMap::ZserioArrayType_attributeProperties TrafficTransitionAttributeMap::readAttributeProperties(TrafficTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficTransitionAttributeMap::ZserioArrayType_attributeConditions TrafficTransitionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficTransitionAttributeMap::ZserioArrayType_attributeConditions TrafficTransitionAttributeMap::readAttributeConditions(TrafficTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadLocationTransitionAttributeMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadLocationTransitionAttributeMap::TrafficRoadLocationTransitionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficTransitionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

TrafficRoadLocationTransitionAttributeMap::TrafficRoadLocationTransitionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

TrafficRoadLocationTransitionAttributeMap::TrafficRoadLocationTransitionAttributeMap(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

TrafficRoadLocationTransitionAttributeMap::TrafficRoadLocationTransitionAttributeMap(const TrafficRoadLocationTransitionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationTransitionAttributeMap& TrafficRoadLocationTransitionAttributeMap::operator=(const TrafficRoadLocationTransitionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationTransitionAttributeMap::TrafficRoadLocationTransitionAttributeMap(TrafficRoadLocationTransitionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationTransitionAttributeMap& TrafficRoadLocationTransitionAttributeMap::operator=(TrafficRoadLocationTransitionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationTransitionAttributeMap::TrafficRoadLocationTransitionAttributeMap(::zserio::PropagateAllocatorT,
        const TrafficRoadLocationTransitionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadLocationTransitionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadLocationTransitionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadLocationTransitionAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadLocationTransitionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadLocationTransitionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficRoadLocationTransitionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficRoadLocationTransitionAttributeMap::setAttributeTypeCode(::nds::traffic::attributes::TrafficTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator TrafficRoadLocationTransitionAttributeMap::getFeature() const
{
    return m_feature_;
}

void TrafficRoadLocationTransitionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& TrafficRoadLocationTransitionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& TrafficRoadLocationTransitionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void TrafficRoadLocationTransitionAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& TrafficRoadLocationTransitionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& TrafficRoadLocationTransitionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void TrafficRoadLocationTransitionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficRoadLocationTransitionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficRoadLocationTransitionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void TrafficRoadLocationTransitionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator TrafficRoadLocationTransitionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void TrafficRoadLocationTransitionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& TrafficRoadLocationTransitionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& TrafficRoadLocationTransitionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void TrafficRoadLocationTransitionAttributeMap::setAttributeValues(::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficRoadLocationTransitionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficRoadLocationTransitionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void TrafficRoadLocationTransitionAttributeMap::setAttributeProperties(::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficRoadLocationTransitionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficRoadLocationTransitionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void TrafficRoadLocationTransitionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void TrafficRoadLocationTransitionAttributeMap::initPackingContext(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t TrafficRoadLocationTransitionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationTransitionAttributeMap::bitSizeOf(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationTransitionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadLocationTransitionAttributeMap::initializeOffsets(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadLocationTransitionAttributeMap::operator==(const TrafficRoadLocationTransitionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t TrafficRoadLocationTransitionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void TrafficRoadLocationTransitionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficRoadLocationTransitionAttributeMap::write(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficRoadLocationTransitionAttributeMap::ZserioElementFactory_featureReferences::create(TrafficRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeMap::ZserioElementFactory_featureReferences::create(TrafficRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& array,
        ::nds::road::reference::location::RoadLocationTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(TrafficRoadLocationTransitionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadLocationTransitionAttributeMap::ZserioElementFactory_featureValidities::create(TrafficRoadLocationTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(TrafficRoadLocationTransitionAttributeMap& owner,
        ::nds::traffic::instantiations::TrafficTransitionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(owner.getAttributeTypeCode()));
}

void TrafficRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeValues::create(TrafficRoadLocationTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeValues::create(TrafficRoadLocationTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttribute>& array,
        ::nds::traffic::instantiations::TrafficTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(TrafficRoadLocationTransitionAttributeMap&,
        ::nds::traffic::instantiations::TrafficPropertyList& element, size_t)
{
    element.initializeChildren();
}

void TrafficRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::nds::traffic::instantiations::TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(TrafficRoadLocationTransitionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void TrafficRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficRoadLocationTransitionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficTransitionAttributeType>(in);
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficRoadLocationTransitionAttributeMap::readAttributeTypeCode(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator TrafficRoadLocationTransitionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficRoadLocationTransitionAttributeMap::readFeature(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_featureReferences TrafficRoadLocationTransitionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_featureReferences TrafficRoadLocationTransitionAttributeMap::readFeatureReferences(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_featureValidities TrafficRoadLocationTransitionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_featureValuePtr TrafficRoadLocationTransitionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_featureValuePtr TrafficRoadLocationTransitionAttributeMap::readFeatureValuePtr(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator TrafficRoadLocationTransitionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator TrafficRoadLocationTransitionAttributeMap::readAttribute(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_attributeValues TrafficRoadLocationTransitionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_attributeValues TrafficRoadLocationTransitionAttributeMap::readAttributeValues(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_attributeProperties TrafficRoadLocationTransitionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_attributeProperties TrafficRoadLocationTransitionAttributeMap::readAttributeProperties(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_attributeConditions TrafficRoadLocationTransitionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficRoadLocationTransitionAttributeMap::ZserioArrayType_attributeConditions TrafficRoadLocationTransitionAttributeMap::readAttributeConditions(TrafficRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficDisplayLineRangeAttributeMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficDisplayLineRangeAttributeMap::TrafficDisplayLineRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

TrafficDisplayLineRangeAttributeMap::TrafficDisplayLineRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

TrafficDisplayLineRangeAttributeMap::TrafficDisplayLineRangeAttributeMap(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

TrafficDisplayLineRangeAttributeMap::TrafficDisplayLineRangeAttributeMap(const TrafficDisplayLineRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeMap& TrafficDisplayLineRangeAttributeMap::operator=(const TrafficDisplayLineRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeMap::TrafficDisplayLineRangeAttributeMap(TrafficDisplayLineRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeMap& TrafficDisplayLineRangeAttributeMap::operator=(TrafficDisplayLineRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeMap::TrafficDisplayLineRangeAttributeMap(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficDisplayLineRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficDisplayLineRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficDisplayLineRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficDisplayLineRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficDisplayLineRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType TrafficDisplayLineRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficDisplayLineRangeAttributeMap::setAttributeTypeCode(::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator TrafficDisplayLineRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void TrafficDisplayLineRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::display::reference::types::DisplayLineReference>& TrafficDisplayLineRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& TrafficDisplayLineRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void TrafficDisplayLineRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::display::reference::types::DisplayLineReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& TrafficDisplayLineRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& TrafficDisplayLineRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void TrafficDisplayLineRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficDisplayLineRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& TrafficDisplayLineRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void TrafficDisplayLineRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator TrafficDisplayLineRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void TrafficDisplayLineRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttribute>& TrafficDisplayLineRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttribute>& TrafficDisplayLineRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void TrafficDisplayLineRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficDisplayLineRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& TrafficDisplayLineRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void TrafficDisplayLineRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficDisplayLineRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& TrafficDisplayLineRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void TrafficDisplayLineRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void TrafficDisplayLineRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void TrafficDisplayLineRangeAttributeMap::initPackingContext(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t TrafficDisplayLineRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeMap::bitSizeOf(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficDisplayLineRangeAttributeMap::initializeOffsets(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficDisplayLineRangeAttributeMap::operator==(const TrafficDisplayLineRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t TrafficDisplayLineRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void TrafficDisplayLineRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeMap::write(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_featureReferences::create(TrafficDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::nds::display::reference::types::DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(TrafficDisplayLineRangeAttributeMap& owner,
        ::nds::display::reference::types::DisplayLineRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficDisplayLineRangeAttributeMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_featureValidities::create(TrafficDisplayLineRangeAttributeMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& array,
        ::nds::display::reference::types::DisplayLineRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(TrafficDisplayLineRangeAttributeMap& owner,
        ::nds::traffic::instantiations::TrafficDisplayLineRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(owner.getAttributeTypeCode()));
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficDisplayLineRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_attributeValues::create(TrafficDisplayLineRangeAttributeMap&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttribute>& array,
        ::nds::traffic::instantiations::TrafficDisplayLineRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(TrafficDisplayLineRangeAttributeMap&,
        ::nds::traffic::instantiations::TrafficPropertyList& element, size_t)
{
    element.initializeChildren();
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_attributeProperties::create(TrafficDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficPropertyList>& array,
        ::nds::traffic::instantiations::TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(TrafficDisplayLineRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeMap::ZserioElementFactory_attributeConditions::create(TrafficDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType TrafficDisplayLineRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(in);
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType TrafficDisplayLineRangeAttributeMap::readAttributeTypeCode(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator TrafficDisplayLineRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficDisplayLineRangeAttributeMap::readFeature(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficDisplayLineRangeAttributeMap::ZserioArrayType_featureReferences TrafficDisplayLineRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficDisplayLineRangeAttributeMap::ZserioArrayType_featureReferences TrafficDisplayLineRangeAttributeMap::readFeatureReferences(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficDisplayLineRangeAttributeMap::ZserioArrayType_featureValidities TrafficDisplayLineRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficDisplayLineRangeAttributeMap::ZserioArrayType_featureValidities TrafficDisplayLineRangeAttributeMap::readFeatureValidities(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficDisplayLineRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficDisplayLineRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficDisplayLineRangeAttributeMap::ZserioArrayType_featureValuePtr TrafficDisplayLineRangeAttributeMap::readFeatureValuePtr(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator TrafficDisplayLineRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator TrafficDisplayLineRangeAttributeMap::readAttribute(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficDisplayLineRangeAttributeMap::ZserioArrayType_attributeValues TrafficDisplayLineRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficDisplayLineRangeAttributeMap::ZserioArrayType_attributeValues TrafficDisplayLineRangeAttributeMap::readAttributeValues(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficDisplayLineRangeAttributeMap::ZserioArrayType_attributeProperties TrafficDisplayLineRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficDisplayLineRangeAttributeMap::ZserioArrayType_attributeProperties TrafficDisplayLineRangeAttributeMap::readAttributeProperties(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
TrafficDisplayLineRangeAttributeMap::ZserioArrayType_attributeConditions TrafficDisplayLineRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

TrafficDisplayLineRangeAttributeMap::ZserioArrayType_attributeConditions TrafficDisplayLineRangeAttributeMap::readAttributeConditions(TrafficDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadRangeAttribute.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadRangeAttribute::TrafficRoadRangeAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

TrafficRoadRangeAttribute::TrafficRoadRangeAttribute(::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficRoadRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

TrafficRoadRangeAttribute::TrafficRoadRangeAttribute(TrafficRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficRoadRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

TrafficRoadRangeAttribute::TrafficRoadRangeAttribute(const TrafficRoadRangeAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttribute& TrafficRoadRangeAttribute::operator=(const TrafficRoadRangeAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttribute::TrafficRoadRangeAttribute(TrafficRoadRangeAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttribute& TrafficRoadRangeAttribute::operator=(TrafficRoadRangeAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttribute::TrafficRoadRangeAttribute(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void TrafficRoadRangeAttribute::initialize(
        ::nds::traffic::attributes::TrafficRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadRangeAttribute::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadRangeAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()));
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadRangeAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'TrafficRoadRangeAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::traffic::attributes::TrafficRoadRangeAttributeValue& TrafficRoadRangeAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::traffic::attributes::TrafficRoadRangeAttributeValue& TrafficRoadRangeAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void TrafficRoadRangeAttribute::setAttributeValue(const ::nds::traffic::attributes::TrafficRoadRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void TrafficRoadRangeAttribute::setAttributeValue(::nds::traffic::attributes::TrafficRoadRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void TrafficRoadRangeAttribute::initPackingContext(TrafficRoadRangeAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t TrafficRoadRangeAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttribute::bitSizeOf(TrafficRoadRangeAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadRangeAttribute::initializeOffsets(TrafficRoadRangeAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool TrafficRoadRangeAttribute::operator==(const TrafficRoadRangeAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t TrafficRoadRangeAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void TrafficRoadRangeAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficRoadRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void TrafficRoadRangeAttribute::write(TrafficRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficRoadRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::traffic::attributes::TrafficRoadRangeAttributeValue TrafficRoadRangeAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficRoadRangeAttributeValue(in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::traffic::attributes::TrafficRoadRangeAttributeValue TrafficRoadRangeAttribute::readAttributeValue(TrafficRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficRoadRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficLaneRangeAttribute.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficLaneRangeAttribute::TrafficLaneRangeAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

TrafficLaneRangeAttribute::TrafficLaneRangeAttribute(::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficLaneRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

TrafficLaneRangeAttribute::TrafficLaneRangeAttribute(TrafficLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficLaneRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

TrafficLaneRangeAttribute::TrafficLaneRangeAttribute(const TrafficLaneRangeAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttribute& TrafficLaneRangeAttribute::operator=(const TrafficLaneRangeAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttribute::TrafficLaneRangeAttribute(TrafficLaneRangeAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttribute& TrafficLaneRangeAttribute::operator=(TrafficLaneRangeAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttribute::TrafficLaneRangeAttribute(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void TrafficLaneRangeAttribute::initialize(
        ::nds::traffic::attributes::TrafficLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficLaneRangeAttribute::isInitialized() const
{
    return m_isInitialized;
}

void TrafficLaneRangeAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()));
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficLaneRangeAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'TrafficLaneRangeAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::traffic::attributes::TrafficLaneRangeAttributeValue& TrafficLaneRangeAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::traffic::attributes::TrafficLaneRangeAttributeValue& TrafficLaneRangeAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void TrafficLaneRangeAttribute::setAttributeValue(const ::nds::traffic::attributes::TrafficLaneRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void TrafficLaneRangeAttribute::setAttributeValue(::nds::traffic::attributes::TrafficLaneRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void TrafficLaneRangeAttribute::initPackingContext(TrafficLaneRangeAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t TrafficLaneRangeAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttribute::bitSizeOf(TrafficLaneRangeAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TrafficLaneRangeAttribute::initializeOffsets(TrafficLaneRangeAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool TrafficLaneRangeAttribute::operator==(const TrafficLaneRangeAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t TrafficLaneRangeAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void TrafficLaneRangeAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficLaneRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void TrafficLaneRangeAttribute::write(TrafficLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficLaneRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::traffic::attributes::TrafficLaneRangeAttributeValue TrafficLaneRangeAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficLaneRangeAttributeValue(in, static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::traffic::attributes::TrafficLaneRangeAttributeValue TrafficLaneRangeAttribute::readAttributeValue(TrafficLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficLaneRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficTransitionAttribute.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficTransitionAttribute::TrafficTransitionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

TrafficTransitionAttribute::TrafficTransitionAttribute(::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

TrafficTransitionAttribute::TrafficTransitionAttribute(TrafficTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

TrafficTransitionAttribute::TrafficTransitionAttribute(const TrafficTransitionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttribute& TrafficTransitionAttribute::operator=(const TrafficTransitionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttribute::TrafficTransitionAttribute(TrafficTransitionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttribute& TrafficTransitionAttribute::operator=(TrafficTransitionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttribute::TrafficTransitionAttribute(::zserio::PropagateAllocatorT,
        const TrafficTransitionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void TrafficTransitionAttribute::initialize(
        ::nds::traffic::attributes::TrafficTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficTransitionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void TrafficTransitionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()));
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficTransitionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'TrafficTransitionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::traffic::attributes::TrafficTransitionAttributeValue& TrafficTransitionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::traffic::attributes::TrafficTransitionAttributeValue& TrafficTransitionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void TrafficTransitionAttribute::setAttributeValue(const ::nds::traffic::attributes::TrafficTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void TrafficTransitionAttribute::setAttributeValue(::nds::traffic::attributes::TrafficTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void TrafficTransitionAttribute::initPackingContext(TrafficTransitionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t TrafficTransitionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttribute::bitSizeOf(TrafficTransitionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TrafficTransitionAttribute::initializeOffsets(TrafficTransitionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool TrafficTransitionAttribute::operator==(const TrafficTransitionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t TrafficTransitionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void TrafficTransitionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void TrafficTransitionAttribute::write(TrafficTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::traffic::attributes::TrafficTransitionAttributeValue TrafficTransitionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficTransitionAttributeValue(in, static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::traffic::attributes::TrafficTransitionAttributeValue TrafficTransitionAttribute::readAttributeValue(TrafficTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficDisplayLineRangeAttribute.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficDisplayLineRangeAttribute::TrafficDisplayLineRangeAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

TrafficDisplayLineRangeAttribute::TrafficDisplayLineRangeAttribute(::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

TrafficDisplayLineRangeAttribute::TrafficDisplayLineRangeAttribute(TrafficDisplayLineRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

TrafficDisplayLineRangeAttribute::TrafficDisplayLineRangeAttribute(const TrafficDisplayLineRangeAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttribute& TrafficDisplayLineRangeAttribute::operator=(const TrafficDisplayLineRangeAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttribute::TrafficDisplayLineRangeAttribute(TrafficDisplayLineRangeAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttribute& TrafficDisplayLineRangeAttribute::operator=(TrafficDisplayLineRangeAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttribute::TrafficDisplayLineRangeAttribute(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void TrafficDisplayLineRangeAttribute::initialize(
        ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficDisplayLineRangeAttribute::isInitialized() const
{
    return m_isInitialized;
}

void TrafficDisplayLineRangeAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()));
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType TrafficDisplayLineRangeAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'TrafficDisplayLineRangeAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue& TrafficDisplayLineRangeAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue& TrafficDisplayLineRangeAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void TrafficDisplayLineRangeAttribute::setAttributeValue(const ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void TrafficDisplayLineRangeAttribute::setAttributeValue(::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void TrafficDisplayLineRangeAttribute::initPackingContext(TrafficDisplayLineRangeAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t TrafficDisplayLineRangeAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttribute::bitSizeOf(TrafficDisplayLineRangeAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TrafficDisplayLineRangeAttribute::initializeOffsets(TrafficDisplayLineRangeAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool TrafficDisplayLineRangeAttribute::operator==(const TrafficDisplayLineRangeAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t TrafficDisplayLineRangeAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void TrafficDisplayLineRangeAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficDisplayLineRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void TrafficDisplayLineRangeAttribute::write(TrafficDisplayLineRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficDisplayLineRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue TrafficDisplayLineRangeAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue(in, static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue TrafficDisplayLineRangeAttribute::readAttributeValue(TrafficDisplayLineRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficProperty.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficProperty::TrafficProperty(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_propertyTypeCode_(allocator),
        m_propertyValue_(allocator)
{
}

TrafficProperty::TrafficProperty(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(in, allocator)),
        m_propertyValue_(readPropertyValue(in, allocator))
{
}

TrafficProperty::TrafficProperty(TrafficProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(context, in, allocator)),
        m_propertyValue_(readPropertyValue(context, in, allocator))
{
}

TrafficProperty::TrafficProperty(const TrafficProperty& other) :
        m_propertyTypeCode_(other.m_propertyTypeCode_),
        m_propertyValue_(other.m_propertyValue_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficProperty& TrafficProperty::operator=(const TrafficProperty& other)
{
    m_propertyTypeCode_ = other.m_propertyTypeCode_;
    m_propertyValue_ = other.m_propertyValue_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficProperty::TrafficProperty(TrafficProperty&& other) :
        m_propertyTypeCode_(::std::move(other.m_propertyTypeCode_)),
        m_propertyValue_(::std::move(other.m_propertyValue_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficProperty& TrafficProperty::operator=(TrafficProperty&& other)
{
    m_propertyTypeCode_ = ::std::move(other.m_propertyTypeCode_);
    m_propertyValue_ = ::std::move(other.m_propertyValue_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficProperty::TrafficProperty(::zserio::PropagateAllocatorT,
        const TrafficProperty& other, const allocator_type& allocator) :
        m_propertyTypeCode_(::zserio::allocatorPropagatingCopy(other.m_propertyTypeCode_, allocator)),
        m_propertyValue_(::zserio::allocatorPropagatingCopy(other.m_propertyValue_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void TrafficProperty::initializeChildren()
{
    m_propertyValue_.initialize(getPropertyTypeCode());

    m_areChildrenInitialized = true;
}

::nds::traffic::properties::TrafficPropertyType& TrafficProperty::getPropertyTypeCode()
{
    return m_propertyTypeCode_;
}

const ::nds::traffic::properties::TrafficPropertyType& TrafficProperty::getPropertyTypeCode() const
{
    return m_propertyTypeCode_;
}

void TrafficProperty::setPropertyTypeCode(const ::nds::traffic::properties::TrafficPropertyType& propertyTypeCode_)
{
    m_propertyTypeCode_ = propertyTypeCode_;
}

void TrafficProperty::setPropertyTypeCode(::nds::traffic::properties::TrafficPropertyType&& propertyTypeCode_)
{
    m_propertyTypeCode_ = ::std::move(propertyTypeCode_);
}

::nds::traffic::properties::TrafficPropertyValue& TrafficProperty::getPropertyValue()
{
    return m_propertyValue_;
}

const ::nds::traffic::properties::TrafficPropertyValue& TrafficProperty::getPropertyValue() const
{
    return m_propertyValue_;
}

void TrafficProperty::setPropertyValue(const ::nds::traffic::properties::TrafficPropertyValue& propertyValue_)
{
    m_propertyValue_ = propertyValue_;
}

void TrafficProperty::setPropertyValue(::nds::traffic::properties::TrafficPropertyValue&& propertyValue_)
{
    m_propertyValue_ = ::std::move(propertyValue_);
}

void TrafficProperty::initPackingContext(TrafficProperty::ZserioPackingContext& context) const
{
    m_propertyTypeCode_.initPackingContext(context.getPropertyTypeCode());
    m_propertyValue_.initPackingContext(context.getPropertyValue());
}

size_t TrafficProperty::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficProperty::bitSizeOf(TrafficProperty::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(context.getPropertyValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficProperty::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TrafficProperty::initializeOffsets(TrafficProperty::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(context.getPropertyValue(), endBitPosition);

    return endBitPosition;
}

bool TrafficProperty::operator==(const TrafficProperty& other) const
{
    if (this != &other)
    {
        return
                (m_propertyTypeCode_ == other.m_propertyTypeCode_) &&
                (m_propertyValue_ == other.m_propertyValue_);
    }

    return true;
}

uint32_t TrafficProperty::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_propertyTypeCode_);
    result = ::zserio::calcHashCode(result, m_propertyValue_);

    return result;
}

void TrafficProperty::write(::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field TrafficProperty.propertyValue!");
    }
    m_propertyValue_.write(out);
}

void TrafficProperty::write(TrafficProperty::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(context.getPropertyTypeCode(), out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field TrafficProperty.propertyValue!");
    }
    m_propertyValue_.write(context.getPropertyValue(), out);
}

::nds::traffic::properties::TrafficPropertyType TrafficProperty::readPropertyTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::properties::TrafficPropertyType(in, allocator);
}

::nds::traffic::properties::TrafficPropertyType TrafficProperty::readPropertyTypeCode(TrafficProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::properties::TrafficPropertyType(context.getPropertyTypeCode(), in, allocator);
}
::nds::traffic::properties::TrafficPropertyValue TrafficProperty::readPropertyValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::properties::TrafficPropertyValue(in, getPropertyTypeCode(), allocator);
}

::nds::traffic::properties::TrafficPropertyValue TrafficProperty::readPropertyValue(TrafficProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::properties::TrafficPropertyValue(context.getPropertyValue(), in, getPropertyTypeCode(), allocator);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadRangeAttributeSet.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadRangeAttributeSet::TrafficRoadRangeAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

TrafficRoadRangeAttributeSet::TrafficRoadRangeAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

TrafficRoadRangeAttributeSet::TrafficRoadRangeAttributeSet(TrafficRoadRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

TrafficRoadRangeAttributeSet::TrafficRoadRangeAttributeSet(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void TrafficRoadRangeAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t TrafficRoadRangeAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void TrafficRoadRangeAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeFullAttribute>& TrafficRoadRangeAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeFullAttribute>& TrafficRoadRangeAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void TrafficRoadRangeAttributeSet::setAttributes(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void TrafficRoadRangeAttributeSet::setAttributes(::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void TrafficRoadRangeAttributeSet::initPackingContext(TrafficRoadRangeAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t TrafficRoadRangeAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeSet::bitSizeOf(TrafficRoadRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadRangeAttributeSet::initializeOffsets(TrafficRoadRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadRangeAttributeSet::operator==(const TrafficRoadRangeAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t TrafficRoadRangeAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void TrafficRoadRangeAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeSet::write(TrafficRoadRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeSet::ZserioArrayExpressions_attributes::initializeElement(TrafficRoadRangeAttributeSet&,
        ::nds::traffic::instantiations::TrafficRoadRangeFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void TrafficRoadRangeAttributeSet::ZserioElementFactory_attributes::create(TrafficRoadRangeAttributeSet&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadRangeAttributeSet::ZserioElementFactory_attributes::create(TrafficRoadRangeAttributeSet&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeFullAttribute>& array,
        ::nds::traffic::instantiations::TrafficRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t TrafficRoadRangeAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficRoadRangeAttributeSet::readNumEntries(TrafficRoadRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadRangeAttributeSet::ZserioArrayType_attributes TrafficRoadRangeAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

TrafficRoadRangeAttributeSet::ZserioArrayType_attributes TrafficRoadRangeAttributeSet::readAttributes(TrafficRoadRangeAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficLaneRangeAttributeSet.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficLaneRangeAttributeSet::TrafficLaneRangeAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

TrafficLaneRangeAttributeSet::TrafficLaneRangeAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

TrafficLaneRangeAttributeSet::TrafficLaneRangeAttributeSet(TrafficLaneRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

TrafficLaneRangeAttributeSet::TrafficLaneRangeAttributeSet(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void TrafficLaneRangeAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t TrafficLaneRangeAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void TrafficLaneRangeAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeFullAttribute>& TrafficLaneRangeAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeFullAttribute>& TrafficLaneRangeAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void TrafficLaneRangeAttributeSet::setAttributes(const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void TrafficLaneRangeAttributeSet::setAttributes(::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void TrafficLaneRangeAttributeSet::initPackingContext(TrafficLaneRangeAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t TrafficLaneRangeAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeSet::bitSizeOf(TrafficLaneRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLaneRangeAttributeSet::initializeOffsets(TrafficLaneRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLaneRangeAttributeSet::operator==(const TrafficLaneRangeAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t TrafficLaneRangeAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void TrafficLaneRangeAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeSet::write(TrafficLaneRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeSet::ZserioArrayExpressions_attributes::initializeElement(TrafficLaneRangeAttributeSet&,
        ::nds::traffic::instantiations::TrafficLaneRangeFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void TrafficLaneRangeAttributeSet::ZserioElementFactory_attributes::create(TrafficLaneRangeAttributeSet&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficLaneRangeAttributeSet::ZserioElementFactory_attributes::create(TrafficLaneRangeAttributeSet&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeFullAttribute>& array,
        ::nds::traffic::instantiations::TrafficLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t TrafficLaneRangeAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficLaneRangeAttributeSet::readNumEntries(TrafficLaneRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficLaneRangeAttributeSet::ZserioArrayType_attributes TrafficLaneRangeAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

TrafficLaneRangeAttributeSet::ZserioArrayType_attributes TrafficLaneRangeAttributeSet::readAttributes(TrafficLaneRangeAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficTransitionAttributeSet.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficTransitionAttributeSet::TrafficTransitionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

TrafficTransitionAttributeSet::TrafficTransitionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

TrafficTransitionAttributeSet::TrafficTransitionAttributeSet(TrafficTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

TrafficTransitionAttributeSet::TrafficTransitionAttributeSet(::zserio::PropagateAllocatorT,
        const TrafficTransitionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void TrafficTransitionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t TrafficTransitionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void TrafficTransitionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficTransitionFullAttribute>& TrafficTransitionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionFullAttribute>& TrafficTransitionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void TrafficTransitionAttributeSet::setAttributes(const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void TrafficTransitionAttributeSet::setAttributes(::zserio::vector<::nds::traffic::instantiations::TrafficTransitionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void TrafficTransitionAttributeSet::initPackingContext(TrafficTransitionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t TrafficTransitionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeSet::bitSizeOf(TrafficTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficTransitionAttributeSet::initializeOffsets(TrafficTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficTransitionAttributeSet::operator==(const TrafficTransitionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t TrafficTransitionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void TrafficTransitionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void TrafficTransitionAttributeSet::write(TrafficTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void TrafficTransitionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(TrafficTransitionAttributeSet&,
        ::nds::traffic::instantiations::TrafficTransitionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void TrafficTransitionAttributeSet::ZserioElementFactory_attributes::create(TrafficTransitionAttributeSet&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficTransitionAttributeSet::ZserioElementFactory_attributes::create(TrafficTransitionAttributeSet&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionFullAttribute>& array,
        ::nds::traffic::instantiations::TrafficTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t TrafficTransitionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficTransitionAttributeSet::readNumEntries(TrafficTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficTransitionAttributeSet::ZserioArrayType_attributes TrafficTransitionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

TrafficTransitionAttributeSet::ZserioArrayType_attributes TrafficTransitionAttributeSet::readAttributes(TrafficTransitionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficDisplayLineRangeAttributeSet.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficDisplayLineRangeAttributeSet::TrafficDisplayLineRangeAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

TrafficDisplayLineRangeAttributeSet::TrafficDisplayLineRangeAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

TrafficDisplayLineRangeAttributeSet::TrafficDisplayLineRangeAttributeSet(TrafficDisplayLineRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

TrafficDisplayLineRangeAttributeSet::TrafficDisplayLineRangeAttributeSet(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void TrafficDisplayLineRangeAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t TrafficDisplayLineRangeAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void TrafficDisplayLineRangeAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeFullAttribute>& TrafficDisplayLineRangeAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeFullAttribute>& TrafficDisplayLineRangeAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void TrafficDisplayLineRangeAttributeSet::setAttributes(const ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void TrafficDisplayLineRangeAttributeSet::setAttributes(::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void TrafficDisplayLineRangeAttributeSet::initPackingContext(TrafficDisplayLineRangeAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t TrafficDisplayLineRangeAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeSet::bitSizeOf(TrafficDisplayLineRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficDisplayLineRangeAttributeSet::initializeOffsets(TrafficDisplayLineRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficDisplayLineRangeAttributeSet::operator==(const TrafficDisplayLineRangeAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t TrafficDisplayLineRangeAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void TrafficDisplayLineRangeAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeSet::write(TrafficDisplayLineRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeSet::ZserioArrayExpressions_attributes::initializeElement(TrafficDisplayLineRangeAttributeSet&,
        ::nds::traffic::instantiations::TrafficDisplayLineRangeFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void TrafficDisplayLineRangeAttributeSet::ZserioElementFactory_attributes::create(TrafficDisplayLineRangeAttributeSet&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeSet::ZserioElementFactory_attributes::create(TrafficDisplayLineRangeAttributeSet&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeFullAttribute>& array,
        ::nds::traffic::instantiations::TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t TrafficDisplayLineRangeAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficDisplayLineRangeAttributeSet::readNumEntries(TrafficDisplayLineRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficDisplayLineRangeAttributeSet::ZserioArrayType_attributes TrafficDisplayLineRangeAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

TrafficDisplayLineRangeAttributeSet::ZserioArrayType_attributes TrafficDisplayLineRangeAttributeSet::readAttributes(TrafficDisplayLineRangeAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadRangeFullAttribute.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadRangeFullAttribute::TrafficRoadRangeFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficRoadRangeAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

TrafficRoadRangeFullAttribute::TrafficRoadRangeFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

TrafficRoadRangeFullAttribute::TrafficRoadRangeFullAttribute(TrafficRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

TrafficRoadRangeFullAttribute::TrafficRoadRangeFullAttribute(const TrafficRoadRangeFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficRoadRangeFullAttribute& TrafficRoadRangeFullAttribute::operator=(const TrafficRoadRangeFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficRoadRangeFullAttribute::TrafficRoadRangeFullAttribute(TrafficRoadRangeFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficRoadRangeFullAttribute& TrafficRoadRangeFullAttribute::operator=(TrafficRoadRangeFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficRoadRangeFullAttribute::TrafficRoadRangeFullAttribute(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void TrafficRoadRangeFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadRangeFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficRoadRangeFullAttribute::setAttributeTypeCode(::nds::traffic::attributes::TrafficRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::traffic::attributes::TrafficRoadRangeAttributeValue& TrafficRoadRangeFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::traffic::attributes::TrafficRoadRangeAttributeValue& TrafficRoadRangeFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void TrafficRoadRangeFullAttribute::setAttributeValue(const ::nds::traffic::attributes::TrafficRoadRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void TrafficRoadRangeFullAttribute::setAttributeValue(::nds::traffic::attributes::TrafficRoadRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::traffic::instantiations::TrafficPropertyList& TrafficRoadRangeFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::traffic::instantiations::TrafficPropertyList& TrafficRoadRangeFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void TrafficRoadRangeFullAttribute::setProperties(const ::nds::traffic::instantiations::TrafficPropertyList& properties_)
{
    m_properties_ = properties_;
}

void TrafficRoadRangeFullAttribute::setProperties(::nds::traffic::instantiations::TrafficPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool TrafficRoadRangeFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool TrafficRoadRangeFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void TrafficRoadRangeFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& TrafficRoadRangeFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& TrafficRoadRangeFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void TrafficRoadRangeFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void TrafficRoadRangeFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool TrafficRoadRangeFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool TrafficRoadRangeFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void TrafficRoadRangeFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void TrafficRoadRangeFullAttribute::initPackingContext(TrafficRoadRangeFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t TrafficRoadRangeFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeFullAttribute::bitSizeOf(TrafficRoadRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t TrafficRoadRangeFullAttribute::initializeOffsets(TrafficRoadRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool TrafficRoadRangeFullAttribute::operator==(const TrafficRoadRangeFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t TrafficRoadRangeFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void TrafficRoadRangeFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficRoadRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void TrafficRoadRangeFullAttribute::write(TrafficRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficRoadRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadRangeFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(in);
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadRangeFullAttribute::readAttributeTypeCode(TrafficRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::traffic::attributes::TrafficRoadRangeAttributeValue TrafficRoadRangeFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficRoadRangeAttributeValue(in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::traffic::attributes::TrafficRoadRangeAttributeValue TrafficRoadRangeFullAttribute::readAttributeValue(TrafficRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficRoadRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList> TrafficRoadRangeFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::nds::traffic::instantiations::TrafficPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList> TrafficRoadRangeFullAttribute::readProperties(TrafficRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::nds::traffic::instantiations::TrafficPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> TrafficRoadRangeFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> TrafficRoadRangeFullAttribute::readConditions(TrafficRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficLaneRangeFullAttribute.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficLaneRangeFullAttribute::TrafficLaneRangeFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficLaneRangeAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

TrafficLaneRangeFullAttribute::TrafficLaneRangeFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

TrafficLaneRangeFullAttribute::TrafficLaneRangeFullAttribute(TrafficLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

TrafficLaneRangeFullAttribute::TrafficLaneRangeFullAttribute(const TrafficLaneRangeFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficLaneRangeFullAttribute& TrafficLaneRangeFullAttribute::operator=(const TrafficLaneRangeFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficLaneRangeFullAttribute::TrafficLaneRangeFullAttribute(TrafficLaneRangeFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficLaneRangeFullAttribute& TrafficLaneRangeFullAttribute::operator=(TrafficLaneRangeFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficLaneRangeFullAttribute::TrafficLaneRangeFullAttribute(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void TrafficLaneRangeFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficLaneRangeFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficLaneRangeFullAttribute::setAttributeTypeCode(::nds::traffic::attributes::TrafficLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::traffic::attributes::TrafficLaneRangeAttributeValue& TrafficLaneRangeFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::traffic::attributes::TrafficLaneRangeAttributeValue& TrafficLaneRangeFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void TrafficLaneRangeFullAttribute::setAttributeValue(const ::nds::traffic::attributes::TrafficLaneRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void TrafficLaneRangeFullAttribute::setAttributeValue(::nds::traffic::attributes::TrafficLaneRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::traffic::instantiations::TrafficPropertyList& TrafficLaneRangeFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::traffic::instantiations::TrafficPropertyList& TrafficLaneRangeFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void TrafficLaneRangeFullAttribute::setProperties(const ::nds::traffic::instantiations::TrafficPropertyList& properties_)
{
    m_properties_ = properties_;
}

void TrafficLaneRangeFullAttribute::setProperties(::nds::traffic::instantiations::TrafficPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool TrafficLaneRangeFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool TrafficLaneRangeFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void TrafficLaneRangeFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& TrafficLaneRangeFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& TrafficLaneRangeFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void TrafficLaneRangeFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void TrafficLaneRangeFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool TrafficLaneRangeFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool TrafficLaneRangeFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void TrafficLaneRangeFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void TrafficLaneRangeFullAttribute::initPackingContext(TrafficLaneRangeFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t TrafficLaneRangeFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeFullAttribute::bitSizeOf(TrafficLaneRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t TrafficLaneRangeFullAttribute::initializeOffsets(TrafficLaneRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool TrafficLaneRangeFullAttribute::operator==(const TrafficLaneRangeFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t TrafficLaneRangeFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void TrafficLaneRangeFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficLaneRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void TrafficLaneRangeFullAttribute::write(TrafficLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficLaneRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficLaneRangeFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(in);
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficLaneRangeFullAttribute::readAttributeTypeCode(TrafficLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::traffic::attributes::TrafficLaneRangeAttributeValue TrafficLaneRangeFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficLaneRangeAttributeValue(in, static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::traffic::attributes::TrafficLaneRangeAttributeValue TrafficLaneRangeFullAttribute::readAttributeValue(TrafficLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficLaneRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList> TrafficLaneRangeFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::nds::traffic::instantiations::TrafficPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList> TrafficLaneRangeFullAttribute::readProperties(TrafficLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::nds::traffic::instantiations::TrafficPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> TrafficLaneRangeFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> TrafficLaneRangeFullAttribute::readConditions(TrafficLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficTransitionFullAttribute.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficTransitionFullAttribute::TrafficTransitionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficTransitionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

TrafficTransitionFullAttribute::TrafficTransitionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

TrafficTransitionFullAttribute::TrafficTransitionFullAttribute(TrafficTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

TrafficTransitionFullAttribute::TrafficTransitionFullAttribute(const TrafficTransitionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficTransitionFullAttribute& TrafficTransitionFullAttribute::operator=(const TrafficTransitionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficTransitionFullAttribute::TrafficTransitionFullAttribute(TrafficTransitionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficTransitionFullAttribute& TrafficTransitionFullAttribute::operator=(TrafficTransitionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficTransitionFullAttribute::TrafficTransitionFullAttribute(::zserio::PropagateAllocatorT,
        const TrafficTransitionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void TrafficTransitionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficTransitionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficTransitionFullAttribute::setAttributeTypeCode(::nds::traffic::attributes::TrafficTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::traffic::attributes::TrafficTransitionAttributeValue& TrafficTransitionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::traffic::attributes::TrafficTransitionAttributeValue& TrafficTransitionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void TrafficTransitionFullAttribute::setAttributeValue(const ::nds::traffic::attributes::TrafficTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void TrafficTransitionFullAttribute::setAttributeValue(::nds::traffic::attributes::TrafficTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::traffic::instantiations::TrafficPropertyList& TrafficTransitionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::traffic::instantiations::TrafficPropertyList& TrafficTransitionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void TrafficTransitionFullAttribute::setProperties(const ::nds::traffic::instantiations::TrafficPropertyList& properties_)
{
    m_properties_ = properties_;
}

void TrafficTransitionFullAttribute::setProperties(::nds::traffic::instantiations::TrafficPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool TrafficTransitionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool TrafficTransitionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void TrafficTransitionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& TrafficTransitionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& TrafficTransitionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void TrafficTransitionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void TrafficTransitionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool TrafficTransitionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool TrafficTransitionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void TrafficTransitionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void TrafficTransitionFullAttribute::initPackingContext(TrafficTransitionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t TrafficTransitionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionFullAttribute::bitSizeOf(TrafficTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t TrafficTransitionFullAttribute::initializeOffsets(TrafficTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool TrafficTransitionFullAttribute::operator==(const TrafficTransitionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t TrafficTransitionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void TrafficTransitionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void TrafficTransitionFullAttribute::write(TrafficTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficTransitionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficTransitionAttributeType>(in);
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficTransitionFullAttribute::readAttributeTypeCode(TrafficTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::traffic::attributes::TrafficTransitionAttributeValue TrafficTransitionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficTransitionAttributeValue(in, static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::traffic::attributes::TrafficTransitionAttributeValue TrafficTransitionFullAttribute::readAttributeValue(TrafficTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList> TrafficTransitionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::nds::traffic::instantiations::TrafficPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList> TrafficTransitionFullAttribute::readProperties(TrafficTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::nds::traffic::instantiations::TrafficPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> TrafficTransitionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> TrafficTransitionFullAttribute::readConditions(TrafficTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficDisplayLineRangeFullAttribute.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficDisplayLineRangeFullAttribute::TrafficDisplayLineRangeFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

TrafficDisplayLineRangeFullAttribute::TrafficDisplayLineRangeFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

TrafficDisplayLineRangeFullAttribute::TrafficDisplayLineRangeFullAttribute(TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

TrafficDisplayLineRangeFullAttribute::TrafficDisplayLineRangeFullAttribute(const TrafficDisplayLineRangeFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficDisplayLineRangeFullAttribute& TrafficDisplayLineRangeFullAttribute::operator=(const TrafficDisplayLineRangeFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficDisplayLineRangeFullAttribute::TrafficDisplayLineRangeFullAttribute(TrafficDisplayLineRangeFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficDisplayLineRangeFullAttribute& TrafficDisplayLineRangeFullAttribute::operator=(TrafficDisplayLineRangeFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficDisplayLineRangeFullAttribute::TrafficDisplayLineRangeFullAttribute(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void TrafficDisplayLineRangeFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType TrafficDisplayLineRangeFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void TrafficDisplayLineRangeFullAttribute::setAttributeTypeCode(::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue& TrafficDisplayLineRangeFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue& TrafficDisplayLineRangeFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void TrafficDisplayLineRangeFullAttribute::setAttributeValue(const ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void TrafficDisplayLineRangeFullAttribute::setAttributeValue(::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::traffic::instantiations::TrafficPropertyList& TrafficDisplayLineRangeFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::traffic::instantiations::TrafficPropertyList& TrafficDisplayLineRangeFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void TrafficDisplayLineRangeFullAttribute::setProperties(const ::nds::traffic::instantiations::TrafficPropertyList& properties_)
{
    m_properties_ = properties_;
}

void TrafficDisplayLineRangeFullAttribute::setProperties(::nds::traffic::instantiations::TrafficPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool TrafficDisplayLineRangeFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool TrafficDisplayLineRangeFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void TrafficDisplayLineRangeFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& TrafficDisplayLineRangeFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& TrafficDisplayLineRangeFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void TrafficDisplayLineRangeFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void TrafficDisplayLineRangeFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool TrafficDisplayLineRangeFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool TrafficDisplayLineRangeFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void TrafficDisplayLineRangeFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void TrafficDisplayLineRangeFullAttribute::initPackingContext(TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t TrafficDisplayLineRangeFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeFullAttribute::bitSizeOf(TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t TrafficDisplayLineRangeFullAttribute::initializeOffsets(TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool TrafficDisplayLineRangeFullAttribute::operator==(const TrafficDisplayLineRangeFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t TrafficDisplayLineRangeFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void TrafficDisplayLineRangeFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficDisplayLineRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void TrafficDisplayLineRangeFullAttribute::write(TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TrafficDisplayLineRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType TrafficDisplayLineRangeFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(in);
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType TrafficDisplayLineRangeFullAttribute::readAttributeTypeCode(TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue TrafficDisplayLineRangeFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue(in, static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue TrafficDisplayLineRangeFullAttribute::readAttributeValue(TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList> TrafficDisplayLineRangeFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::nds::traffic::instantiations::TrafficPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList> TrafficDisplayLineRangeFullAttribute::readProperties(TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::nds::traffic::instantiations::TrafficPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::traffic::instantiations::TrafficPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> TrafficDisplayLineRangeFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> TrafficDisplayLineRangeFullAttribute::readConditions(TrafficDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficPropertyList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficPropertyList::TrafficPropertyList(const allocator_type&) noexcept :
        m_numProperties_(uint8_t()),
        m_property_(::zserio::NullOpt)
{
}

TrafficPropertyList::TrafficPropertyList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(in)),
        m_property_(readProperty(in, allocator))
{
}

TrafficPropertyList::TrafficPropertyList(TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(context, in)),
        m_property_(readProperty(context, in, allocator))
{
}

TrafficPropertyList::TrafficPropertyList(::zserio::PropagateAllocatorT,
        const TrafficPropertyList& other, const allocator_type& allocator) :
        m_numProperties_(::zserio::allocatorPropagatingCopy(other.m_numProperties_, allocator)),
        m_property_(::zserio::allocatorPropagatingCopy(other.m_property_, allocator))
{
}

void TrafficPropertyList::initializeChildren()
{
    if (getNumProperties() > 0)
        m_property_.value().initializeElements(*this);
}

uint8_t TrafficPropertyList::getNumProperties() const
{
    return m_numProperties_;
}

void TrafficPropertyList::setNumProperties(uint8_t numProperties_)
{
    m_numProperties_ = numProperties_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficProperty>& TrafficPropertyList::getProperty()
{
    return m_property_.value().getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficProperty>& TrafficPropertyList::getProperty() const
{
    return m_property_.value().getRawArray();
}

void TrafficPropertyList::setProperty(const ::zserio::vector<::nds::traffic::instantiations::TrafficProperty>& property_)
{
    m_property_ = ZserioArrayType_property(property_);
}

void TrafficPropertyList::setProperty(::zserio::vector<::nds::traffic::instantiations::TrafficProperty>&& property_)
{
    m_property_ = ZserioArrayType_property(std::move(property_));
}

bool TrafficPropertyList::isPropertyUsed() const
{
    return (getNumProperties() > 0);
}

bool TrafficPropertyList::isPropertySet() const
{
    return m_property_.hasValue();
}

void TrafficPropertyList::resetProperty()
{
    m_property_.reset();
}

void TrafficPropertyList::initPackingContext(TrafficPropertyList::ZserioPackingContext& context) const
{
    context.getNumProperties().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
}

size_t TrafficPropertyList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficPropertyList::bitSizeOf(TrafficPropertyList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficPropertyList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t TrafficPropertyList::initializeOffsets(TrafficPropertyList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool TrafficPropertyList::operator==(const TrafficPropertyList& other) const
{
    if (this != &other)
    {
        return
                (m_numProperties_ == other.m_numProperties_) &&
                (!isPropertyUsed() ? !other.isPropertyUsed() : (m_property_ == other.m_property_));
    }

    return true;
}

uint32_t TrafficPropertyList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numProperties_);
    if (isPropertyUsed())
        result = ::zserio::calcHashCode(result, m_property_);

    return result;
}

void TrafficPropertyList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numProperties_, UINT8_C(8));

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void TrafficPropertyList::write(TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumProperties().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numProperties_);

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void TrafficPropertyList::ZserioArrayExpressions_property::initializeElement(TrafficPropertyList&,
        ::nds::traffic::instantiations::TrafficProperty& element, size_t)
{
    element.initializeChildren();
}

void TrafficPropertyList::ZserioElementFactory_property::create(TrafficPropertyList&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficProperty>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficPropertyList::ZserioElementFactory_property::create(TrafficPropertyList&        ,
        ::zserio::vector<::nds::traffic::instantiations::TrafficProperty>& array,
        ::nds::traffic::instantiations::TrafficProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t TrafficPropertyList::readNumProperties(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t TrafficPropertyList::readNumProperties(TrafficPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumProperties().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::zserio::InplaceOptionalHolder<TrafficPropertyList::ZserioArrayType_property> TrafficPropertyList::readProperty(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<TrafficPropertyList::ZserioArrayType_property> TrafficPropertyList::readProperty(TrafficPropertyList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadRangeAttributeSetMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadRangeAttributeSetMap::TrafficRoadRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

TrafficRoadRangeAttributeSetMap::TrafficRoadRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficRoadRangeAttributeSetMap::TrafficRoadRangeAttributeSetMap(TrafficRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

TrafficRoadRangeAttributeSetMap::TrafficRoadRangeAttributeSetMap(const TrafficRoadRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeSetMap& TrafficRoadRangeAttributeSetMap::operator=(const TrafficRoadRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeSetMap::TrafficRoadRangeAttributeSetMap(TrafficRoadRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeSetMap& TrafficRoadRangeAttributeSetMap::operator=(TrafficRoadRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeSetMap::TrafficRoadRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeSet& TrafficRoadRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet& TrafficRoadRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void TrafficRoadRangeAttributeSetMap::setAttributeSet(const ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void TrafficRoadRangeAttributeSetMap::setAttributeSet(::nds::traffic::instantiations::TrafficRoadRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator TrafficRoadRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void TrafficRoadRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& TrafficRoadRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& TrafficRoadRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void TrafficRoadRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void TrafficRoadRangeAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& TrafficRoadRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& TrafficRoadRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void TrafficRoadRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void TrafficRoadRangeAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void TrafficRoadRangeAttributeSetMap::initPackingContext(TrafficRoadRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t TrafficRoadRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeSetMap::bitSizeOf(TrafficRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadRangeAttributeSetMap::initializeOffsets(TrafficRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadRangeAttributeSetMap::operator==(const TrafficRoadRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t TrafficRoadRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void TrafficRoadRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeSetMap::write(TrafficRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficRoadRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(TrafficRoadRangeAttributeSetMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeSet TrafficRoadRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet(in, allocator);
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeSet TrafficRoadRangeAttributeSetMap::readAttributeSet(TrafficRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator TrafficRoadRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficRoadRangeAttributeSetMap::readFeature(TrafficRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadRangeAttributeSetMap::ZserioArrayType_references TrafficRoadRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadRangeAttributeSetMap::ZserioArrayType_references TrafficRoadRangeAttributeSetMap::readReferences(TrafficRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficRoadRangeAttributeSetMap::ZserioArrayType_validities TrafficRoadRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadRangeAttributeSetMap::ZserioArrayType_validities TrafficRoadRangeAttributeSetMap::readValidities(TrafficRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficIndirectRoadRangeAttributeSetMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficIndirectRoadRangeAttributeSetMap::TrafficIndirectRoadRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

TrafficIndirectRoadRangeAttributeSetMap::TrafficIndirectRoadRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficIndirectRoadRangeAttributeSetMap::TrafficIndirectRoadRangeAttributeSetMap(TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

TrafficIndirectRoadRangeAttributeSetMap::TrafficIndirectRoadRangeAttributeSetMap(const TrafficIndirectRoadRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectRoadRangeAttributeSetMap& TrafficIndirectRoadRangeAttributeSetMap::operator=(const TrafficIndirectRoadRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectRoadRangeAttributeSetMap::TrafficIndirectRoadRangeAttributeSetMap(TrafficIndirectRoadRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectRoadRangeAttributeSetMap& TrafficIndirectRoadRangeAttributeSetMap::operator=(TrafficIndirectRoadRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectRoadRangeAttributeSetMap::TrafficIndirectRoadRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const TrafficIndirectRoadRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficIndirectRoadRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficIndirectRoadRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficIndirectRoadRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficIndirectRoadRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficIndirectRoadRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeSet& TrafficIndirectRoadRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet& TrafficIndirectRoadRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void TrafficIndirectRoadRangeAttributeSetMap::setAttributeSet(const ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void TrafficIndirectRoadRangeAttributeSetMap::setAttributeSet(::nds::traffic::instantiations::TrafficRoadRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator TrafficIndirectRoadRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void TrafficIndirectRoadRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& TrafficIndirectRoadRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& TrafficIndirectRoadRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void TrafficIndirectRoadRangeAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& TrafficIndirectRoadRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& TrafficIndirectRoadRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void TrafficIndirectRoadRangeAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void TrafficIndirectRoadRangeAttributeSetMap::initPackingContext(TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t TrafficIndirectRoadRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectRoadRangeAttributeSetMap::bitSizeOf(TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectRoadRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficIndirectRoadRangeAttributeSetMap::initializeOffsets(TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficIndirectRoadRangeAttributeSetMap::operator==(const TrafficIndirectRoadRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t TrafficIndirectRoadRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void TrafficIndirectRoadRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficIndirectRoadRangeAttributeSetMap::write(TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficIndirectRoadRangeAttributeSetMap::ZserioArrayExpressions_references::initializeElement(TrafficIndirectRoadRangeAttributeSetMap&,
        ::nds::road::reference::types::RoadReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void TrafficIndirectRoadRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficIndirectRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficIndirectRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::nds::road::reference::types::RoadReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(TrafficIndirectRoadRangeAttributeSetMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficIndirectRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficIndirectRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficIndirectRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeSet TrafficIndirectRoadRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet(in, allocator);
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeSet TrafficIndirectRoadRangeAttributeSetMap::readAttributeSet(TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator TrafficIndirectRoadRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficIndirectRoadRangeAttributeSetMap::readFeature(TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficIndirectRoadRangeAttributeSetMap::ZserioArrayType_references TrafficIndirectRoadRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectRoadRangeAttributeSetMap::ZserioArrayType_references TrafficIndirectRoadRangeAttributeSetMap::readReferences(TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficIndirectRoadRangeAttributeSetMap::ZserioArrayType_validities TrafficIndirectRoadRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectRoadRangeAttributeSetMap::ZserioArrayType_validities TrafficIndirectRoadRangeAttributeSetMap::readValidities(TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadLocationRangeAttributeSetMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadLocationRangeAttributeSetMap::TrafficRoadLocationRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

TrafficRoadLocationRangeAttributeSetMap::TrafficRoadLocationRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficRoadLocationRangeAttributeSetMap::TrafficRoadLocationRangeAttributeSetMap(TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

TrafficRoadLocationRangeAttributeSetMap::TrafficRoadLocationRangeAttributeSetMap(const TrafficRoadLocationRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationRangeAttributeSetMap& TrafficRoadLocationRangeAttributeSetMap::operator=(const TrafficRoadLocationRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationRangeAttributeSetMap::TrafficRoadLocationRangeAttributeSetMap(TrafficRoadLocationRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationRangeAttributeSetMap& TrafficRoadLocationRangeAttributeSetMap::operator=(TrafficRoadLocationRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationRangeAttributeSetMap::TrafficRoadLocationRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const TrafficRoadLocationRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadLocationRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadLocationRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadLocationRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadLocationRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadLocationRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeSet& TrafficRoadLocationRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet& TrafficRoadLocationRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void TrafficRoadLocationRangeAttributeSetMap::setAttributeSet(const ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void TrafficRoadLocationRangeAttributeSetMap::setAttributeSet(::nds::traffic::instantiations::TrafficRoadRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator TrafficRoadLocationRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void TrafficRoadLocationRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::location::RoadLocationReference>& TrafficRoadLocationRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& TrafficRoadLocationRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void TrafficRoadLocationRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void TrafficRoadLocationRangeAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::location::RoadLocationReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& TrafficRoadLocationRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& TrafficRoadLocationRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void TrafficRoadLocationRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void TrafficRoadLocationRangeAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void TrafficRoadLocationRangeAttributeSetMap::initPackingContext(TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t TrafficRoadLocationRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationRangeAttributeSetMap::bitSizeOf(TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadLocationRangeAttributeSetMap::initializeOffsets(TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadLocationRangeAttributeSetMap::operator==(const TrafficRoadLocationRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t TrafficRoadLocationRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void TrafficRoadLocationRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficRoadLocationRangeAttributeSetMap::write(TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficRoadLocationRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficRoadLocationRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadLocationRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficRoadLocationRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& array,
        ::nds::road::reference::location::RoadLocationReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficRoadLocationRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(TrafficRoadLocationRangeAttributeSetMap& owner,
        ::nds::road::reference::location::RoadLocationRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadLocationRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficRoadLocationRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadLocationRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficRoadLocationRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& array,
        ::nds::road::reference::location::RoadLocationRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeSet TrafficRoadLocationRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet(in, allocator);
}

::nds::traffic::instantiations::TrafficRoadRangeAttributeSet TrafficRoadLocationRangeAttributeSetMap::readAttributeSet(TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficRoadRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator TrafficRoadLocationRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficRoadLocationRangeAttributeSetMap::readFeature(TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadLocationRangeAttributeSetMap::ZserioArrayType_references TrafficRoadLocationRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadLocationRangeAttributeSetMap::ZserioArrayType_references TrafficRoadLocationRangeAttributeSetMap::readReferences(TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficRoadLocationRangeAttributeSetMap::ZserioArrayType_validities TrafficRoadLocationRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadLocationRangeAttributeSetMap::ZserioArrayType_validities TrafficRoadLocationRangeAttributeSetMap::readValidities(TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficLaneRangeAttributeSetMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficLaneRangeAttributeSetMap::TrafficLaneRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

TrafficLaneRangeAttributeSetMap::TrafficLaneRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficLaneRangeAttributeSetMap::TrafficLaneRangeAttributeSetMap(TrafficLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

TrafficLaneRangeAttributeSetMap::TrafficLaneRangeAttributeSetMap(const TrafficLaneRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeSetMap& TrafficLaneRangeAttributeSetMap::operator=(const TrafficLaneRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeSetMap::TrafficLaneRangeAttributeSetMap(TrafficLaneRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeSetMap& TrafficLaneRangeAttributeSetMap::operator=(TrafficLaneRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeSetMap::TrafficLaneRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficLaneRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficLaneRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficLaneRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficLaneRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficLaneRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeSet& TrafficLaneRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::traffic::instantiations::TrafficLaneRangeAttributeSet& TrafficLaneRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void TrafficLaneRangeAttributeSetMap::setAttributeSet(const ::nds::traffic::instantiations::TrafficLaneRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void TrafficLaneRangeAttributeSetMap::setAttributeSet(::nds::traffic::instantiations::TrafficLaneRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator TrafficLaneRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void TrafficLaneRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& TrafficLaneRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& TrafficLaneRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void TrafficLaneRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void TrafficLaneRangeAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& TrafficLaneRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& TrafficLaneRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void TrafficLaneRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void TrafficLaneRangeAttributeSetMap::setValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void TrafficLaneRangeAttributeSetMap::initPackingContext(TrafficLaneRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t TrafficLaneRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeSetMap::bitSizeOf(TrafficLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLaneRangeAttributeSetMap::initializeOffsets(TrafficLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLaneRangeAttributeSetMap::operator==(const TrafficLaneRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t TrafficLaneRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void TrafficLaneRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeSetMap::write(TrafficLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficLaneRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficLaneRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(TrafficLaneRangeAttributeSetMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeSet TrafficLaneRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficLaneRangeAttributeSet(in, allocator);
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeSet TrafficLaneRangeAttributeSetMap::readAttributeSet(TrafficLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficLaneRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator TrafficLaneRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficLaneRangeAttributeSetMap::readFeature(TrafficLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficLaneRangeAttributeSetMap::ZserioArrayType_references TrafficLaneRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficLaneRangeAttributeSetMap::ZserioArrayType_references TrafficLaneRangeAttributeSetMap::readReferences(TrafficLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficLaneRangeAttributeSetMap::ZserioArrayType_validities TrafficLaneRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficLaneRangeAttributeSetMap::ZserioArrayType_validities TrafficLaneRangeAttributeSetMap::readValidities(TrafficLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficIndirectLaneRangeAttributeSetMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficIndirectLaneRangeAttributeSetMap::TrafficIndirectLaneRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

TrafficIndirectLaneRangeAttributeSetMap::TrafficIndirectLaneRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficIndirectLaneRangeAttributeSetMap::TrafficIndirectLaneRangeAttributeSetMap(TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

TrafficIndirectLaneRangeAttributeSetMap::TrafficIndirectLaneRangeAttributeSetMap(const TrafficIndirectLaneRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectLaneRangeAttributeSetMap& TrafficIndirectLaneRangeAttributeSetMap::operator=(const TrafficIndirectLaneRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectLaneRangeAttributeSetMap::TrafficIndirectLaneRangeAttributeSetMap(TrafficIndirectLaneRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectLaneRangeAttributeSetMap& TrafficIndirectLaneRangeAttributeSetMap::operator=(TrafficIndirectLaneRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectLaneRangeAttributeSetMap::TrafficIndirectLaneRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const TrafficIndirectLaneRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficIndirectLaneRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficIndirectLaneRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficIndirectLaneRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficIndirectLaneRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficIndirectLaneRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeSet& TrafficIndirectLaneRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::traffic::instantiations::TrafficLaneRangeAttributeSet& TrafficIndirectLaneRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void TrafficIndirectLaneRangeAttributeSetMap::setAttributeSet(const ::nds::traffic::instantiations::TrafficLaneRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void TrafficIndirectLaneRangeAttributeSetMap::setAttributeSet(::nds::traffic::instantiations::TrafficLaneRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator TrafficIndirectLaneRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void TrafficIndirectLaneRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& TrafficIndirectLaneRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& TrafficIndirectLaneRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void TrafficIndirectLaneRangeAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& TrafficIndirectLaneRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& TrafficIndirectLaneRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void TrafficIndirectLaneRangeAttributeSetMap::setValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void TrafficIndirectLaneRangeAttributeSetMap::initPackingContext(TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t TrafficIndirectLaneRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectLaneRangeAttributeSetMap::bitSizeOf(TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectLaneRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficIndirectLaneRangeAttributeSetMap::initializeOffsets(TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficIndirectLaneRangeAttributeSetMap::operator==(const TrafficIndirectLaneRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t TrafficIndirectLaneRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void TrafficIndirectLaneRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficIndirectLaneRangeAttributeSetMap::write(TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficIndirectLaneRangeAttributeSetMap::ZserioArrayExpressions_references::initializeElement(TrafficIndirectLaneRangeAttributeSetMap&,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void TrafficIndirectLaneRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficIndirectLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficIndirectLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(TrafficIndirectLaneRangeAttributeSetMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficIndirectLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficIndirectLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficIndirectLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeSet TrafficIndirectLaneRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficLaneRangeAttributeSet(in, allocator);
}

::nds::traffic::instantiations::TrafficLaneRangeAttributeSet TrafficIndirectLaneRangeAttributeSetMap::readAttributeSet(TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficLaneRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator TrafficIndirectLaneRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficIndirectLaneRangeAttributeSetMap::readFeature(TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficIndirectLaneRangeAttributeSetMap::ZserioArrayType_references TrafficIndirectLaneRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectLaneRangeAttributeSetMap::ZserioArrayType_references TrafficIndirectLaneRangeAttributeSetMap::readReferences(TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficIndirectLaneRangeAttributeSetMap::ZserioArrayType_validities TrafficIndirectLaneRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficIndirectLaneRangeAttributeSetMap::ZserioArrayType_validities TrafficIndirectLaneRangeAttributeSetMap::readValidities(TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficTransitionAttributeSetMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficTransitionAttributeSetMap::TrafficTransitionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

TrafficTransitionAttributeSetMap::TrafficTransitionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficTransitionAttributeSetMap::TrafficTransitionAttributeSetMap(TrafficTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficTransitionAttributeSetMap::TrafficTransitionAttributeSetMap(const TrafficTransitionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeSetMap& TrafficTransitionAttributeSetMap::operator=(const TrafficTransitionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeSetMap::TrafficTransitionAttributeSetMap(TrafficTransitionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeSetMap& TrafficTransitionAttributeSetMap::operator=(TrafficTransitionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeSetMap::TrafficTransitionAttributeSetMap(::zserio::PropagateAllocatorT,
        const TrafficTransitionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficTransitionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficTransitionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficTransitionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficTransitionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficTransitionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::instantiations::TrafficTransitionAttributeSet& TrafficTransitionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::traffic::instantiations::TrafficTransitionAttributeSet& TrafficTransitionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void TrafficTransitionAttributeSetMap::setAttributeSet(const ::nds::traffic::instantiations::TrafficTransitionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void TrafficTransitionAttributeSetMap::setAttributeSet(::nds::traffic::instantiations::TrafficTransitionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator TrafficTransitionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void TrafficTransitionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::TransitionReference>& TrafficTransitionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::TransitionReference>& TrafficTransitionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void TrafficTransitionAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::TransitionReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void TrafficTransitionAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::TransitionReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& TrafficTransitionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& TrafficTransitionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void TrafficTransitionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void TrafficTransitionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void TrafficTransitionAttributeSetMap::initPackingContext(TrafficTransitionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t TrafficTransitionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeSetMap::bitSizeOf(TrafficTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficTransitionAttributeSetMap::initializeOffsets(TrafficTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficTransitionAttributeSetMap::operator==(const TrafficTransitionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t TrafficTransitionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void TrafficTransitionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void TrafficTransitionAttributeSetMap::write(TrafficTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void TrafficTransitionAttributeSetMap::ZserioArrayExpressions_references::initializeElement(TrafficTransitionAttributeSetMap&,
        ::nds::road::reference::types::TransitionReference& element, size_t)
{
    element.initializeChildren();
}

void TrafficTransitionAttributeSetMap::ZserioElementFactory_references::create(TrafficTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficTransitionAttributeSetMap::ZserioElementFactory_references::create(TrafficTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::nds::road::reference::types::TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficTransitionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(TrafficTransitionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficTransitionAttributeSetMap::ZserioElementFactory_validities::create(TrafficTransitionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::traffic::instantiations::TrafficTransitionAttributeSet TrafficTransitionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficTransitionAttributeSet(in, allocator);
}

::nds::traffic::instantiations::TrafficTransitionAttributeSet TrafficTransitionAttributeSetMap::readAttributeSet(TrafficTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficTransitionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator TrafficTransitionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficTransitionAttributeSetMap::readFeature(TrafficTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficTransitionAttributeSetMap::ZserioArrayType_references TrafficTransitionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficTransitionAttributeSetMap::ZserioArrayType_references TrafficTransitionAttributeSetMap::readReferences(TrafficTransitionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficTransitionAttributeSetMap::ZserioArrayType_validities TrafficTransitionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadLocationTransitionAttributeSetMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadLocationTransitionAttributeSetMap::TrafficRoadLocationTransitionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

TrafficRoadLocationTransitionAttributeSetMap::TrafficRoadLocationTransitionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficRoadLocationTransitionAttributeSetMap::TrafficRoadLocationTransitionAttributeSetMap(TrafficRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficRoadLocationTransitionAttributeSetMap::TrafficRoadLocationTransitionAttributeSetMap(const TrafficRoadLocationTransitionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationTransitionAttributeSetMap& TrafficRoadLocationTransitionAttributeSetMap::operator=(const TrafficRoadLocationTransitionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationTransitionAttributeSetMap::TrafficRoadLocationTransitionAttributeSetMap(TrafficRoadLocationTransitionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationTransitionAttributeSetMap& TrafficRoadLocationTransitionAttributeSetMap::operator=(TrafficRoadLocationTransitionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationTransitionAttributeSetMap::TrafficRoadLocationTransitionAttributeSetMap(::zserio::PropagateAllocatorT,
        const TrafficRoadLocationTransitionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadLocationTransitionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadLocationTransitionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadLocationTransitionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadLocationTransitionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadLocationTransitionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::instantiations::TrafficTransitionAttributeSet& TrafficRoadLocationTransitionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::traffic::instantiations::TrafficTransitionAttributeSet& TrafficRoadLocationTransitionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void TrafficRoadLocationTransitionAttributeSetMap::setAttributeSet(const ::nds::traffic::instantiations::TrafficTransitionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void TrafficRoadLocationTransitionAttributeSetMap::setAttributeSet(::nds::traffic::instantiations::TrafficTransitionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator TrafficRoadLocationTransitionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void TrafficRoadLocationTransitionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& TrafficRoadLocationTransitionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& TrafficRoadLocationTransitionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void TrafficRoadLocationTransitionAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& TrafficRoadLocationTransitionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& TrafficRoadLocationTransitionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void TrafficRoadLocationTransitionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void TrafficRoadLocationTransitionAttributeSetMap::initPackingContext(TrafficRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t TrafficRoadLocationTransitionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationTransitionAttributeSetMap::bitSizeOf(TrafficRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationTransitionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadLocationTransitionAttributeSetMap::initializeOffsets(TrafficRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadLocationTransitionAttributeSetMap::operator==(const TrafficRoadLocationTransitionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t TrafficRoadLocationTransitionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void TrafficRoadLocationTransitionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void TrafficRoadLocationTransitionAttributeSetMap::write(TrafficRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void TrafficRoadLocationTransitionAttributeSetMap::ZserioElementFactory_references::create(TrafficRoadLocationTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeSetMap::ZserioElementFactory_references::create(TrafficRoadLocationTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& array,
        ::nds::road::reference::location::RoadLocationTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(TrafficRoadLocationTransitionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadLocationTransitionAttributeSetMap::ZserioElementFactory_validities::create(TrafficRoadLocationTransitionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::traffic::instantiations::TrafficTransitionAttributeSet TrafficRoadLocationTransitionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficTransitionAttributeSet(in, allocator);
}

::nds::traffic::instantiations::TrafficTransitionAttributeSet TrafficRoadLocationTransitionAttributeSetMap::readAttributeSet(TrafficRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficTransitionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator TrafficRoadLocationTransitionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficRoadLocationTransitionAttributeSetMap::readFeature(TrafficRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadLocationTransitionAttributeSetMap::ZserioArrayType_references TrafficRoadLocationTransitionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficRoadLocationTransitionAttributeSetMap::ZserioArrayType_references TrafficRoadLocationTransitionAttributeSetMap::readReferences(TrafficRoadLocationTransitionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficRoadLocationTransitionAttributeSetMap::ZserioArrayType_validities TrafficRoadLocationTransitionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficDisplayLineRangeAttributeSetMap.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficDisplayLineRangeAttributeSetMap::TrafficDisplayLineRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

TrafficDisplayLineRangeAttributeSetMap::TrafficDisplayLineRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

TrafficDisplayLineRangeAttributeSetMap::TrafficDisplayLineRangeAttributeSetMap(TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

TrafficDisplayLineRangeAttributeSetMap::TrafficDisplayLineRangeAttributeSetMap(const TrafficDisplayLineRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeSetMap& TrafficDisplayLineRangeAttributeSetMap::operator=(const TrafficDisplayLineRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeSetMap::TrafficDisplayLineRangeAttributeSetMap(TrafficDisplayLineRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeSetMap& TrafficDisplayLineRangeAttributeSetMap::operator=(TrafficDisplayLineRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeSetMap::TrafficDisplayLineRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficDisplayLineRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficDisplayLineRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void TrafficDisplayLineRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficDisplayLineRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficDisplayLineRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSet& TrafficDisplayLineRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSet& TrafficDisplayLineRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void TrafficDisplayLineRangeAttributeSetMap::setAttributeSet(const ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void TrafficDisplayLineRangeAttributeSetMap::setAttributeSet(::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator TrafficDisplayLineRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void TrafficDisplayLineRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::display::reference::types::DisplayLineReference>& TrafficDisplayLineRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& TrafficDisplayLineRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void TrafficDisplayLineRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void TrafficDisplayLineRangeAttributeSetMap::setReferences(::zserio::vector<::nds::display::reference::types::DisplayLineReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& TrafficDisplayLineRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& TrafficDisplayLineRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void TrafficDisplayLineRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void TrafficDisplayLineRangeAttributeSetMap::setValidities(::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void TrafficDisplayLineRangeAttributeSetMap::initPackingContext(TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t TrafficDisplayLineRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeSetMap::bitSizeOf(TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficDisplayLineRangeAttributeSetMap::initializeOffsets(TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficDisplayLineRangeAttributeSetMap::operator==(const TrafficDisplayLineRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t TrafficDisplayLineRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void TrafficDisplayLineRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeSetMap::write(TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficDisplayLineRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeSetMap::ZserioElementFactory_references::create(TrafficDisplayLineRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::nds::display::reference::types::DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TrafficDisplayLineRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(TrafficDisplayLineRangeAttributeSetMap& owner,
        ::nds::display::reference::types::DisplayLineRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficDisplayLineRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficDisplayLineRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficDisplayLineRangeAttributeSetMap::ZserioElementFactory_validities::create(TrafficDisplayLineRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& array,
        ::nds::display::reference::types::DisplayLineRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSet TrafficDisplayLineRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSet(in, allocator);
}

::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSet TrafficDisplayLineRangeAttributeSetMap::readAttributeSet(TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator TrafficDisplayLineRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator TrafficDisplayLineRangeAttributeSetMap::readFeature(TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficDisplayLineRangeAttributeSetMap::ZserioArrayType_references TrafficDisplayLineRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficDisplayLineRangeAttributeSetMap::ZserioArrayType_references TrafficDisplayLineRangeAttributeSetMap::readReferences(TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
TrafficDisplayLineRangeAttributeSetMap::ZserioArrayType_validities TrafficDisplayLineRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

TrafficDisplayLineRangeAttributeSetMap::ZserioArrayType_validities TrafficDisplayLineRangeAttributeSetMap::readValidities(TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadRangeAttributeSetList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadRangeAttributeSetList::TrafficRoadRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

TrafficRoadRangeAttributeSetList::TrafficRoadRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

TrafficRoadRangeAttributeSetList::TrafficRoadRangeAttributeSetList(TrafficRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

TrafficRoadRangeAttributeSetList::TrafficRoadRangeAttributeSetList(const TrafficRoadRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeSetList& TrafficRoadRangeAttributeSetList::operator=(const TrafficRoadRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeSetList::TrafficRoadRangeAttributeSetList(TrafficRoadRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeSetList& TrafficRoadRangeAttributeSetList::operator=(TrafficRoadRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeSetList::TrafficRoadRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficRoadRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void TrafficRoadRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeSetMap>& TrafficRoadRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeSetMap>& TrafficRoadRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void TrafficRoadRangeAttributeSetList::setSets(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void TrafficRoadRangeAttributeSetList::setSets(::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void TrafficRoadRangeAttributeSetList::initPackingContext(TrafficRoadRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t TrafficRoadRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeSetList::bitSizeOf(TrafficRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadRangeAttributeSetList::initializeOffsets(TrafficRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadRangeAttributeSetList::operator==(const TrafficRoadRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t TrafficRoadRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void TrafficRoadRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeSetList::write(TrafficRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficRoadRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(TrafficRoadRangeAttributeSetList& owner,
        ::nds::traffic::instantiations::TrafficRoadRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadRangeAttributeSetMap>& array,
        ::nds::traffic::instantiations::TrafficRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficRoadRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficRoadRangeAttributeSetList::readNumAttributeSets(TrafficRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadRangeAttributeSetList::ZserioArrayType_sets TrafficRoadRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

TrafficRoadRangeAttributeSetList::ZserioArrayType_sets TrafficRoadRangeAttributeSetList::readSets(TrafficRoadRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficIndirectRoadRangeAttributeSetList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficIndirectRoadRangeAttributeSetList::TrafficIndirectRoadRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

TrafficIndirectRoadRangeAttributeSetList::TrafficIndirectRoadRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

TrafficIndirectRoadRangeAttributeSetList::TrafficIndirectRoadRangeAttributeSetList(TrafficIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

TrafficIndirectRoadRangeAttributeSetList::TrafficIndirectRoadRangeAttributeSetList(const TrafficIndirectRoadRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectRoadRangeAttributeSetList& TrafficIndirectRoadRangeAttributeSetList::operator=(const TrafficIndirectRoadRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectRoadRangeAttributeSetList::TrafficIndirectRoadRangeAttributeSetList(TrafficIndirectRoadRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectRoadRangeAttributeSetList& TrafficIndirectRoadRangeAttributeSetList::operator=(TrafficIndirectRoadRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectRoadRangeAttributeSetList::TrafficIndirectRoadRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const TrafficIndirectRoadRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficIndirectRoadRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficIndirectRoadRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficIndirectRoadRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficIndirectRoadRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficIndirectRoadRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficIndirectRoadRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void TrafficIndirectRoadRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeSetMap>& TrafficIndirectRoadRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeSetMap>& TrafficIndirectRoadRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void TrafficIndirectRoadRangeAttributeSetList::setSets(const ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void TrafficIndirectRoadRangeAttributeSetList::setSets(::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void TrafficIndirectRoadRangeAttributeSetList::initPackingContext(TrafficIndirectRoadRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t TrafficIndirectRoadRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectRoadRangeAttributeSetList::bitSizeOf(TrafficIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectRoadRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficIndirectRoadRangeAttributeSetList::initializeOffsets(TrafficIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficIndirectRoadRangeAttributeSetList::operator==(const TrafficIndirectRoadRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t TrafficIndirectRoadRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void TrafficIndirectRoadRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficIndirectRoadRangeAttributeSetList::write(TrafficIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficIndirectRoadRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(TrafficIndirectRoadRangeAttributeSetList& owner,
        ::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficIndirectRoadRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficIndirectRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectRoadRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficIndirectRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeSetMap>& array,
        ::nds::traffic::instantiations::TrafficIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficIndirectRoadRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficIndirectRoadRangeAttributeSetList::readNumAttributeSets(TrafficIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficIndirectRoadRangeAttributeSetList::ZserioArrayType_sets TrafficIndirectRoadRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

TrafficIndirectRoadRangeAttributeSetList::ZserioArrayType_sets TrafficIndirectRoadRangeAttributeSetList::readSets(TrafficIndirectRoadRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadLocationRangeAttributeSetList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadLocationRangeAttributeSetList::TrafficRoadLocationRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

TrafficRoadLocationRangeAttributeSetList::TrafficRoadLocationRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

TrafficRoadLocationRangeAttributeSetList::TrafficRoadLocationRangeAttributeSetList(TrafficRoadLocationRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

TrafficRoadLocationRangeAttributeSetList::TrafficRoadLocationRangeAttributeSetList(const TrafficRoadLocationRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationRangeAttributeSetList& TrafficRoadLocationRangeAttributeSetList::operator=(const TrafficRoadLocationRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationRangeAttributeSetList::TrafficRoadLocationRangeAttributeSetList(TrafficRoadLocationRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationRangeAttributeSetList& TrafficRoadLocationRangeAttributeSetList::operator=(TrafficRoadLocationRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationRangeAttributeSetList::TrafficRoadLocationRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const TrafficRoadLocationRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadLocationRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadLocationRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadLocationRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadLocationRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadLocationRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficRoadLocationRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void TrafficRoadLocationRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeSetMap>& TrafficRoadLocationRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeSetMap>& TrafficRoadLocationRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void TrafficRoadLocationRangeAttributeSetList::setSets(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void TrafficRoadLocationRangeAttributeSetList::setSets(::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void TrafficRoadLocationRangeAttributeSetList::initPackingContext(TrafficRoadLocationRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t TrafficRoadLocationRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationRangeAttributeSetList::bitSizeOf(TrafficRoadLocationRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadLocationRangeAttributeSetList::initializeOffsets(TrafficRoadLocationRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadLocationRangeAttributeSetList::operator==(const TrafficRoadLocationRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t TrafficRoadLocationRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void TrafficRoadLocationRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficRoadLocationRangeAttributeSetList::write(TrafficRoadLocationRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficRoadLocationRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(TrafficRoadLocationRangeAttributeSetList& owner,
        ::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadLocationRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficRoadLocationRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadLocationRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficRoadLocationRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeSetMap>& array,
        ::nds::traffic::instantiations::TrafficRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficRoadLocationRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficRoadLocationRangeAttributeSetList::readNumAttributeSets(TrafficRoadLocationRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadLocationRangeAttributeSetList::ZserioArrayType_sets TrafficRoadLocationRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

TrafficRoadLocationRangeAttributeSetList::ZserioArrayType_sets TrafficRoadLocationRangeAttributeSetList::readSets(TrafficRoadLocationRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficLaneRangeAttributeSetList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficLaneRangeAttributeSetList::TrafficLaneRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

TrafficLaneRangeAttributeSetList::TrafficLaneRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

TrafficLaneRangeAttributeSetList::TrafficLaneRangeAttributeSetList(TrafficLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

TrafficLaneRangeAttributeSetList::TrafficLaneRangeAttributeSetList(const TrafficLaneRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeSetList& TrafficLaneRangeAttributeSetList::operator=(const TrafficLaneRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeSetList::TrafficLaneRangeAttributeSetList(TrafficLaneRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeSetList& TrafficLaneRangeAttributeSetList::operator=(TrafficLaneRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeSetList::TrafficLaneRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficLaneRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficLaneRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficLaneRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficLaneRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficLaneRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficLaneRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void TrafficLaneRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeSetMap>& TrafficLaneRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeSetMap>& TrafficLaneRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void TrafficLaneRangeAttributeSetList::setSets(const ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void TrafficLaneRangeAttributeSetList::setSets(::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void TrafficLaneRangeAttributeSetList::initPackingContext(TrafficLaneRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t TrafficLaneRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeSetList::bitSizeOf(TrafficLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLaneRangeAttributeSetList::initializeOffsets(TrafficLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLaneRangeAttributeSetList::operator==(const TrafficLaneRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t TrafficLaneRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void TrafficLaneRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeSetList::write(TrafficLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficLaneRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(TrafficLaneRangeAttributeSetList& owner,
        ::nds::traffic::instantiations::TrafficLaneRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficLaneRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficLaneRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficLaneRangeAttributeSetMap>& array,
        ::nds::traffic::instantiations::TrafficLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficLaneRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficLaneRangeAttributeSetList::readNumAttributeSets(TrafficLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficLaneRangeAttributeSetList::ZserioArrayType_sets TrafficLaneRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

TrafficLaneRangeAttributeSetList::ZserioArrayType_sets TrafficLaneRangeAttributeSetList::readSets(TrafficLaneRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficIndirectLaneRangeAttributeSetList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficIndirectLaneRangeAttributeSetList::TrafficIndirectLaneRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

TrafficIndirectLaneRangeAttributeSetList::TrafficIndirectLaneRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

TrafficIndirectLaneRangeAttributeSetList::TrafficIndirectLaneRangeAttributeSetList(TrafficIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

TrafficIndirectLaneRangeAttributeSetList::TrafficIndirectLaneRangeAttributeSetList(const TrafficIndirectLaneRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectLaneRangeAttributeSetList& TrafficIndirectLaneRangeAttributeSetList::operator=(const TrafficIndirectLaneRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectLaneRangeAttributeSetList::TrafficIndirectLaneRangeAttributeSetList(TrafficIndirectLaneRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficIndirectLaneRangeAttributeSetList& TrafficIndirectLaneRangeAttributeSetList::operator=(TrafficIndirectLaneRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficIndirectLaneRangeAttributeSetList::TrafficIndirectLaneRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const TrafficIndirectLaneRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficIndirectLaneRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficIndirectLaneRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficIndirectLaneRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficIndirectLaneRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficIndirectLaneRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficIndirectLaneRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void TrafficIndirectLaneRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeSetMap>& TrafficIndirectLaneRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeSetMap>& TrafficIndirectLaneRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void TrafficIndirectLaneRangeAttributeSetList::setSets(const ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void TrafficIndirectLaneRangeAttributeSetList::setSets(::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void TrafficIndirectLaneRangeAttributeSetList::initPackingContext(TrafficIndirectLaneRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t TrafficIndirectLaneRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectLaneRangeAttributeSetList::bitSizeOf(TrafficIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficIndirectLaneRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficIndirectLaneRangeAttributeSetList::initializeOffsets(TrafficIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficIndirectLaneRangeAttributeSetList::operator==(const TrafficIndirectLaneRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t TrafficIndirectLaneRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void TrafficIndirectLaneRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficIndirectLaneRangeAttributeSetList::write(TrafficIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficIndirectLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficIndirectLaneRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(TrafficIndirectLaneRangeAttributeSetList& owner,
        ::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficIndirectLaneRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficIndirectLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficIndirectLaneRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficIndirectLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeSetMap>& array,
        ::nds::traffic::instantiations::TrafficIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficIndirectLaneRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficIndirectLaneRangeAttributeSetList::readNumAttributeSets(TrafficIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficIndirectLaneRangeAttributeSetList::ZserioArrayType_sets TrafficIndirectLaneRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

TrafficIndirectLaneRangeAttributeSetList::ZserioArrayType_sets TrafficIndirectLaneRangeAttributeSetList::readSets(TrafficIndirectLaneRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficTransitionAttributeSetList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficTransitionAttributeSetList::TrafficTransitionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

TrafficTransitionAttributeSetList::TrafficTransitionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

TrafficTransitionAttributeSetList::TrafficTransitionAttributeSetList(TrafficTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

TrafficTransitionAttributeSetList::TrafficTransitionAttributeSetList(const TrafficTransitionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeSetList& TrafficTransitionAttributeSetList::operator=(const TrafficTransitionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeSetList::TrafficTransitionAttributeSetList(TrafficTransitionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeSetList& TrafficTransitionAttributeSetList::operator=(TrafficTransitionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeSetList::TrafficTransitionAttributeSetList(::zserio::PropagateAllocatorT,
        const TrafficTransitionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficTransitionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficTransitionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficTransitionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficTransitionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficTransitionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficTransitionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void TrafficTransitionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeSetMap>& TrafficTransitionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeSetMap>& TrafficTransitionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void TrafficTransitionAttributeSetList::setSets(const ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void TrafficTransitionAttributeSetList::setSets(::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void TrafficTransitionAttributeSetList::initPackingContext(TrafficTransitionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t TrafficTransitionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeSetList::bitSizeOf(TrafficTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficTransitionAttributeSetList::initializeOffsets(TrafficTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficTransitionAttributeSetList::operator==(const TrafficTransitionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t TrafficTransitionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void TrafficTransitionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficTransitionAttributeSetList::write(TrafficTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficTransitionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(TrafficTransitionAttributeSetList& owner,
        ::nds::traffic::instantiations::TrafficTransitionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficTransitionAttributeSetList::ZserioElementFactory_sets::create(TrafficTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficTransitionAttributeSetList::ZserioElementFactory_sets::create(TrafficTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficTransitionAttributeSetMap>& array,
        ::nds::traffic::instantiations::TrafficTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficTransitionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficTransitionAttributeSetList::readNumAttributeSets(TrafficTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficTransitionAttributeSetList::ZserioArrayType_sets TrafficTransitionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

TrafficTransitionAttributeSetList::ZserioArrayType_sets TrafficTransitionAttributeSetList::readSets(TrafficTransitionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficRoadLocationTransitionAttributeSetList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficRoadLocationTransitionAttributeSetList::TrafficRoadLocationTransitionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

TrafficRoadLocationTransitionAttributeSetList::TrafficRoadLocationTransitionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

TrafficRoadLocationTransitionAttributeSetList::TrafficRoadLocationTransitionAttributeSetList(TrafficRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

TrafficRoadLocationTransitionAttributeSetList::TrafficRoadLocationTransitionAttributeSetList(const TrafficRoadLocationTransitionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationTransitionAttributeSetList& TrafficRoadLocationTransitionAttributeSetList::operator=(const TrafficRoadLocationTransitionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationTransitionAttributeSetList::TrafficRoadLocationTransitionAttributeSetList(TrafficRoadLocationTransitionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficRoadLocationTransitionAttributeSetList& TrafficRoadLocationTransitionAttributeSetList::operator=(TrafficRoadLocationTransitionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadLocationTransitionAttributeSetList::TrafficRoadLocationTransitionAttributeSetList(::zserio::PropagateAllocatorT,
        const TrafficRoadLocationTransitionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficRoadLocationTransitionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficRoadLocationTransitionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficRoadLocationTransitionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficRoadLocationTransitionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficRoadLocationTransitionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficRoadLocationTransitionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void TrafficRoadLocationTransitionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeSetMap>& TrafficRoadLocationTransitionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeSetMap>& TrafficRoadLocationTransitionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void TrafficRoadLocationTransitionAttributeSetList::setSets(const ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void TrafficRoadLocationTransitionAttributeSetList::setSets(::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void TrafficRoadLocationTransitionAttributeSetList::initPackingContext(TrafficRoadLocationTransitionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t TrafficRoadLocationTransitionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationTransitionAttributeSetList::bitSizeOf(TrafficRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficRoadLocationTransitionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficRoadLocationTransitionAttributeSetList::initializeOffsets(TrafficRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficRoadLocationTransitionAttributeSetList::operator==(const TrafficRoadLocationTransitionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t TrafficRoadLocationTransitionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void TrafficRoadLocationTransitionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficRoadLocationTransitionAttributeSetList::write(TrafficRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficRoadLocationTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficRoadLocationTransitionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(TrafficRoadLocationTransitionAttributeSetList& owner,
        ::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficRoadLocationTransitionAttributeSetList::ZserioElementFactory_sets::create(TrafficRoadLocationTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficRoadLocationTransitionAttributeSetList::ZserioElementFactory_sets::create(TrafficRoadLocationTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeSetMap>& array,
        ::nds::traffic::instantiations::TrafficRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficRoadLocationTransitionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficRoadLocationTransitionAttributeSetList::readNumAttributeSets(TrafficRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficRoadLocationTransitionAttributeSetList::ZserioArrayType_sets TrafficRoadLocationTransitionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

TrafficRoadLocationTransitionAttributeSetList::ZserioArrayType_sets TrafficRoadLocationTransitionAttributeSetList::readSets(TrafficRoadLocationTransitionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/instantiations/TrafficDisplayLineRangeAttributeSetList.h>

namespace nds
{
namespace traffic
{
namespace instantiations
{

TrafficDisplayLineRangeAttributeSetList::TrafficDisplayLineRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

TrafficDisplayLineRangeAttributeSetList::TrafficDisplayLineRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

TrafficDisplayLineRangeAttributeSetList::TrafficDisplayLineRangeAttributeSetList(TrafficDisplayLineRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

TrafficDisplayLineRangeAttributeSetList::TrafficDisplayLineRangeAttributeSetList(const TrafficDisplayLineRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeSetList& TrafficDisplayLineRangeAttributeSetList::operator=(const TrafficDisplayLineRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeSetList::TrafficDisplayLineRangeAttributeSetList(TrafficDisplayLineRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeSetList& TrafficDisplayLineRangeAttributeSetList::operator=(TrafficDisplayLineRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeSetList::TrafficDisplayLineRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void TrafficDisplayLineRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficDisplayLineRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void TrafficDisplayLineRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift TrafficDisplayLineRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'TrafficDisplayLineRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t TrafficDisplayLineRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void TrafficDisplayLineRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSetMap>& TrafficDisplayLineRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSetMap>& TrafficDisplayLineRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void TrafficDisplayLineRangeAttributeSetList::setSets(const ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void TrafficDisplayLineRangeAttributeSetList::setSets(::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void TrafficDisplayLineRangeAttributeSetList::initPackingContext(TrafficDisplayLineRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t TrafficDisplayLineRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeSetList::bitSizeOf(TrafficDisplayLineRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficDisplayLineRangeAttributeSetList::initializeOffsets(TrafficDisplayLineRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficDisplayLineRangeAttributeSetList::operator==(const TrafficDisplayLineRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t TrafficDisplayLineRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void TrafficDisplayLineRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeSetList::write(TrafficDisplayLineRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficDisplayLineRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void TrafficDisplayLineRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(TrafficDisplayLineRangeAttributeSetList& owner,
        ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void TrafficDisplayLineRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficDisplayLineRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void TrafficDisplayLineRangeAttributeSetList::ZserioElementFactory_sets::create(TrafficDisplayLineRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSetMap>& array,
        ::nds::traffic::instantiations::TrafficDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t TrafficDisplayLineRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t TrafficDisplayLineRangeAttributeSetList::readNumAttributeSets(TrafficDisplayLineRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
TrafficDisplayLineRangeAttributeSetList::ZserioArrayType_sets TrafficDisplayLineRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

TrafficDisplayLineRangeAttributeSetList::ZserioArrayType_sets TrafficDisplayLineRangeAttributeSetList::readSets(TrafficDisplayLineRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace traffic
} // namespace nds
