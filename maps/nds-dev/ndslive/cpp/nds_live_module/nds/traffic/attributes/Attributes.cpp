/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/traffic/attributes/TrafficTransitionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficTransitionAttributeType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::traffic::attributes::TrafficTransitionAttributeType>::names;
constexpr ::std::array<::nds::traffic::attributes::TrafficTransitionAttributeType, 2> EnumTraits<::nds::traffic::attributes::TrafficTransitionAttributeType>::values;
constexpr const char* EnumTraits<::nds::traffic::attributes::TrafficTransitionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::traffic::attributes::TrafficTransitionAttributeType value)
{
    switch (value)
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        return 0;
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficTransitionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::traffic::attributes::TrafficTransitionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::traffic::attributes::TrafficTransitionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::traffic::attributes::TrafficTransitionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
        return static_cast<::nds::traffic::attributes::TrafficTransitionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficTransitionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::traffic::attributes::TrafficTransitionAttributeType>(::nds::traffic::attributes::TrafficTransitionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::traffic::attributes::TrafficTransitionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::traffic::attributes::TrafficTransitionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::traffic::attributes::TrafficTransitionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::traffic::attributes::TrafficTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::traffic::attributes::TrafficTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::traffic::attributes::TrafficTransitionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::traffic::attributes::TrafficTransitionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::traffic::attributes::TrafficTransitionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::traffic::attributes::TrafficTransitionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::traffic::attributes::TrafficTransitionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficTransitionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::traffic::attributes::TrafficTransitionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::traffic::attributes::TrafficTransitionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficTransitionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/traffic/attributes/TrafficRoadRangeAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficRoadRangeAttributeType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::names;
constexpr ::std::array<::nds::traffic::attributes::TrafficRoadRangeAttributeType, 4> EnumTraits<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::values;
constexpr const char* EnumTraits<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::traffic::attributes::TrafficRoadRangeAttributeType value)
{
    switch (value)
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        return 0;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        return 1;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        return 2;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficRoadRangeAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::traffic::attributes::TrafficRoadRangeAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
        return static_cast<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficRoadRangeAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(::nds::traffic::attributes::TrafficRoadRangeAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::traffic::attributes::TrafficRoadRangeAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::traffic::attributes::TrafficRoadRangeAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::traffic::attributes::TrafficRoadRangeAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::traffic::attributes::TrafficRoadRangeAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::traffic::attributes::TrafficRoadRangeAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::traffic::attributes::TrafficRoadRangeAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::traffic::attributes::TrafficRoadRangeAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::traffic::attributes::TrafficRoadRangeAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::traffic::attributes::TrafficRoadRangeAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::traffic::attributes::TrafficRoadRangeAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficRoadRangeAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/traffic/attributes/TrafficLaneRangeAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficLaneRangeAttributeType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::names;
constexpr ::std::array<::nds::traffic::attributes::TrafficLaneRangeAttributeType, 4> EnumTraits<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::values;
constexpr const char* EnumTraits<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::traffic::attributes::TrafficLaneRangeAttributeType value)
{
    switch (value)
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        return 0;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        return 1;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        return 2;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLaneRangeAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::traffic::attributes::TrafficLaneRangeAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
        return static_cast<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLaneRangeAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(::nds::traffic::attributes::TrafficLaneRangeAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::traffic::attributes::TrafficLaneRangeAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::traffic::attributes::TrafficLaneRangeAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::traffic::attributes::TrafficLaneRangeAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::traffic::attributes::TrafficLaneRangeAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::traffic::attributes::TrafficLaneRangeAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::traffic::attributes::TrafficLaneRangeAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::traffic::attributes::TrafficLaneRangeAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::traffic::attributes::TrafficLaneRangeAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::traffic::attributes::TrafficLaneRangeAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::traffic::attributes::TrafficLaneRangeAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficLaneRangeAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/traffic/attributes/TrafficDisplayLineRangeAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficDisplayLineRangeAttributeType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::names;
constexpr ::std::array<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType, 4> EnumTraits<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::values;
constexpr const char* EnumTraits<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType value)
{
    switch (value)
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        return 0;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        return 1;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        return 2;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficDisplayLineRangeAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
        return static_cast<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficDisplayLineRangeAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/attributes/TrafficTransitionAttributeValue.h>

namespace nds
{
namespace traffic
{
namespace attributes
{

TrafficTransitionAttributeValue::TrafficTransitionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

TrafficTransitionAttributeValue::TrafficTransitionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

TrafficTransitionAttributeValue::TrafficTransitionAttributeValue(TrafficTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

TrafficTransitionAttributeValue::TrafficTransitionAttributeValue(const TrafficTransitionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeValue& TrafficTransitionAttributeValue::operator=(const TrafficTransitionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeValue::TrafficTransitionAttributeValue(TrafficTransitionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

TrafficTransitionAttributeValue& TrafficTransitionAttributeValue::operator=(TrafficTransitionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficTransitionAttributeValue::TrafficTransitionAttributeValue(::zserio::PropagateAllocatorT,
        const TrafficTransitionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void TrafficTransitionAttributeValue::initialize(
        ::nds::traffic::attributes::TrafficTransitionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool TrafficTransitionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::traffic::attributes::TrafficTransitionAttributeType TrafficTransitionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'TrafficTransitionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::traffic::types::TrafficFlow TrafficTransitionAttributeValue::getTrafficFlow() const
{
    return m_objectChoice.get<::nds::traffic::types::TrafficFlow>();
}

void TrafficTransitionAttributeValue::setTrafficFlow(::nds::traffic::types::TrafficFlow trafficFlow_)
{
    m_objectChoice = trafficFlow_;
}

::nds::traffic::types::CurrentRoadCondition& TrafficTransitionAttributeValue::getCurrentRoadCondition()
{
    return m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>();
}

const ::nds::traffic::types::CurrentRoadCondition& TrafficTransitionAttributeValue::getCurrentRoadCondition() const
{
    return m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>();
}

void TrafficTransitionAttributeValue::setCurrentRoadCondition(const ::nds::traffic::types::CurrentRoadCondition& currentRoadCondition_)
{
    m_objectChoice = currentRoadCondition_;
}

void TrafficTransitionAttributeValue::setCurrentRoadCondition(::nds::traffic::types::CurrentRoadCondition&& currentRoadCondition_)
{
    m_objectChoice = ::std::move(currentRoadCondition_);
}

TrafficTransitionAttributeValue::ChoiceTag TrafficTransitionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        return CHOICE_trafficFlow;
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        return CHOICE_currentRoadCondition;
    default:
        return UNDEFINED_CHOICE;
    }
}

void TrafficTransitionAttributeValue::initPackingContext(TrafficTransitionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        ::zserio::initPackingContext(context.getTrafficFlow(), m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }
}

size_t TrafficTransitionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeValue::bitSizeOf(TrafficTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficFlow(), m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t TrafficTransitionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }

    return endBitPosition;
}

size_t TrafficTransitionAttributeValue::initializeOffsets(TrafficTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficFlow(), endBitPosition,
        m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }

    return endBitPosition;
}

bool TrafficTransitionAttributeValue::operator==(const TrafficTransitionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::TrafficFlow>() == other.m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>() == other.m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }
}

uint32_t TrafficTransitionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
            break;
        case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>());
            break;
        default:
            break;
        }
    }

    return result;
}

void TrafficTransitionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        ::zserio::write(out, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }
}

void TrafficTransitionAttributeValue::write(TrafficTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        ::zserio::write(context.getTrafficFlow(), out, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficTransitionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::traffic::types::TrafficFlow>(in), allocator);
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::AnyHolder<>(::nds::traffic::types::CurrentRoadCondition(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficTransitionAttributeValue::readObject(TrafficTransitionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::traffic::types::TrafficFlow>(context.getTrafficFlow(), in), allocator);
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::AnyHolder<>(::nds::traffic::types::CurrentRoadCondition(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficTransitionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::TRAFFIC_FLOW:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::TrafficFlow>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficTransitionAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::CurrentRoadCondition>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficTransitionAttributeValue!");
    }
}

} // namespace attributes
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/attributes/TrafficRoadRangeAttributeValue.h>

namespace nds
{
namespace traffic
{
namespace attributes
{

TrafficRoadRangeAttributeValue::TrafficRoadRangeAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

TrafficRoadRangeAttributeValue::TrafficRoadRangeAttributeValue(::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficRoadRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

TrafficRoadRangeAttributeValue::TrafficRoadRangeAttributeValue(TrafficRoadRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficRoadRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

TrafficRoadRangeAttributeValue::TrafficRoadRangeAttributeValue(const TrafficRoadRangeAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeValue& TrafficRoadRangeAttributeValue::operator=(const TrafficRoadRangeAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeValue::TrafficRoadRangeAttributeValue(TrafficRoadRangeAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

TrafficRoadRangeAttributeValue& TrafficRoadRangeAttributeValue::operator=(TrafficRoadRangeAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficRoadRangeAttributeValue::TrafficRoadRangeAttributeValue(::zserio::PropagateAllocatorT,
        const TrafficRoadRangeAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void TrafficRoadRangeAttributeValue::initialize(
        ::nds::traffic::attributes::TrafficRoadRangeAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool TrafficRoadRangeAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::traffic::attributes::TrafficRoadRangeAttributeType TrafficRoadRangeAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'TrafficRoadRangeAttributeValue' is not initialized!");

    return m_type_;
}

::nds::traffic::types::TrafficEvent& TrafficRoadRangeAttributeValue::getTrafficEvent()
{
    return m_objectChoice.get<::nds::traffic::types::TrafficEvent>();
}

const ::nds::traffic::types::TrafficEvent& TrafficRoadRangeAttributeValue::getTrafficEvent() const
{
    return m_objectChoice.get<::nds::traffic::types::TrafficEvent>();
}

void TrafficRoadRangeAttributeValue::setTrafficEvent(const ::nds::traffic::types::TrafficEvent& trafficEvent_)
{
    m_objectChoice = trafficEvent_;
}

void TrafficRoadRangeAttributeValue::setTrafficEvent(::nds::traffic::types::TrafficEvent&& trafficEvent_)
{
    m_objectChoice = ::std::move(trafficEvent_);
}

::nds::traffic::types::TrafficFlow TrafficRoadRangeAttributeValue::getTrafficFlow() const
{
    return m_objectChoice.get<::nds::traffic::types::TrafficFlow>();
}

void TrafficRoadRangeAttributeValue::setTrafficFlow(::nds::traffic::types::TrafficFlow trafficFlow_)
{
    m_objectChoice = trafficFlow_;
}

::nds::traffic::types::CurrentRoadCondition& TrafficRoadRangeAttributeValue::getCurrentRoadCondition()
{
    return m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>();
}

const ::nds::traffic::types::CurrentRoadCondition& TrafficRoadRangeAttributeValue::getCurrentRoadCondition() const
{
    return m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>();
}

void TrafficRoadRangeAttributeValue::setCurrentRoadCondition(const ::nds::traffic::types::CurrentRoadCondition& currentRoadCondition_)
{
    m_objectChoice = currentRoadCondition_;
}

void TrafficRoadRangeAttributeValue::setCurrentRoadCondition(::nds::traffic::types::CurrentRoadCondition&& currentRoadCondition_)
{
    m_objectChoice = ::std::move(currentRoadCondition_);
}

::nds::traffic::types::ParkingAvailability TrafficRoadRangeAttributeValue::getParkingAvailability() const
{
    return m_objectChoice.get<::nds::traffic::types::ParkingAvailability>();
}

void TrafficRoadRangeAttributeValue::setParkingAvailability(::nds::traffic::types::ParkingAvailability parkingAvailability_)
{
    m_objectChoice = parkingAvailability_;
}

TrafficRoadRangeAttributeValue::ChoiceTag TrafficRoadRangeAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        return CHOICE_trafficEvent;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        return CHOICE_trafficFlow;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        return CHOICE_currentRoadCondition;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        return CHOICE_parkingAvailability;
    default:
        return UNDEFINED_CHOICE;
    }
}

void TrafficRoadRangeAttributeValue::initPackingContext(TrafficRoadRangeAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        m_objectChoice.get<::nds::traffic::types::TrafficEvent>().initPackingContext(context.getTrafficEvent());
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        ::zserio::initPackingContext(context.getTrafficFlow(), m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }
}

size_t TrafficRoadRangeAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::TrafficEvent>().bitSizeOf(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeValue::bitSizeOf(TrafficRoadRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::TrafficEvent>().bitSizeOf(context.getTrafficEvent(), endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficFlow(), m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t TrafficRoadRangeAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::TrafficEvent>().initializeOffsets(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }

    return endBitPosition;
}

size_t TrafficRoadRangeAttributeValue::initializeOffsets(TrafficRoadRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::TrafficEvent>().initializeOffsets(context.getTrafficEvent(), endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficFlow(), endBitPosition,
        m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }

    return endBitPosition;
}

bool TrafficRoadRangeAttributeValue::operator==(const TrafficRoadRangeAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::TrafficEvent>() == other.m_objectChoice.get<::nds::traffic::types::TrafficEvent>());
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::TrafficFlow>() == other.m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>() == other.m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>());
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::ParkingAvailability>() == other.m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }
}

uint32_t TrafficRoadRangeAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::TrafficEvent>());
            break;
        case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
            break;
        case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>());
            break;
        case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
            break;
        default:
            break;
        }
    }

    return result;
}

void TrafficRoadRangeAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        m_objectChoice.get<::nds::traffic::types::TrafficEvent>().write(out);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        ::zserio::write(out, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().write(out);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        out.writeBool(m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }
}

void TrafficRoadRangeAttributeValue::write(TrafficRoadRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        m_objectChoice.get<::nds::traffic::types::TrafficEvent>().write(context.getTrafficEvent(), out);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        ::zserio::write(context.getTrafficFlow(), out, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().write(out);
        break;
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        out.writeBool(m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficRoadRangeAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        return ::zserio::AnyHolder<>(::nds::traffic::types::TrafficEvent(in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::traffic::types::TrafficFlow>(in), allocator);
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::AnyHolder<>(::nds::traffic::types::CurrentRoadCondition(in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        return ::zserio::AnyHolder<>(static_cast<::nds::traffic::types::ParkingAvailability>(in.readBool()), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficRoadRangeAttributeValue::readObject(TrafficRoadRangeAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        return ::zserio::AnyHolder<>(::nds::traffic::types::TrafficEvent(context.getTrafficEvent(), in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::traffic::types::TrafficFlow>(context.getTrafficFlow(), in), allocator);
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::AnyHolder<>(::nds::traffic::types::CurrentRoadCondition(in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        return ::zserio::AnyHolder<>(static_cast<::nds::traffic::types::ParkingAvailability>(in.readBool()), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficRoadRangeAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_EVENT:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::TrafficEvent>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::TRAFFIC_FLOW:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::TrafficFlow>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::CurrentRoadCondition>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficRoadRangeAttributeType::PARKING_AVAILABILITY:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::ParkingAvailability>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficRoadRangeAttributeValue!");
    }
}

} // namespace attributes
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/attributes/TrafficLaneRangeAttributeValue.h>

namespace nds
{
namespace traffic
{
namespace attributes
{

TrafficLaneRangeAttributeValue::TrafficLaneRangeAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

TrafficLaneRangeAttributeValue::TrafficLaneRangeAttributeValue(::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficLaneRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

TrafficLaneRangeAttributeValue::TrafficLaneRangeAttributeValue(TrafficLaneRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficLaneRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

TrafficLaneRangeAttributeValue::TrafficLaneRangeAttributeValue(const TrafficLaneRangeAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeValue& TrafficLaneRangeAttributeValue::operator=(const TrafficLaneRangeAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeValue::TrafficLaneRangeAttributeValue(TrafficLaneRangeAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

TrafficLaneRangeAttributeValue& TrafficLaneRangeAttributeValue::operator=(TrafficLaneRangeAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLaneRangeAttributeValue::TrafficLaneRangeAttributeValue(::zserio::PropagateAllocatorT,
        const TrafficLaneRangeAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void TrafficLaneRangeAttributeValue::initialize(
        ::nds::traffic::attributes::TrafficLaneRangeAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool TrafficLaneRangeAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::traffic::attributes::TrafficLaneRangeAttributeType TrafficLaneRangeAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'TrafficLaneRangeAttributeValue' is not initialized!");

    return m_type_;
}

::nds::traffic::types::TrafficEvent& TrafficLaneRangeAttributeValue::getTrafficEvent()
{
    return m_objectChoice.get<::nds::traffic::types::TrafficEvent>();
}

const ::nds::traffic::types::TrafficEvent& TrafficLaneRangeAttributeValue::getTrafficEvent() const
{
    return m_objectChoice.get<::nds::traffic::types::TrafficEvent>();
}

void TrafficLaneRangeAttributeValue::setTrafficEvent(const ::nds::traffic::types::TrafficEvent& trafficEvent_)
{
    m_objectChoice = trafficEvent_;
}

void TrafficLaneRangeAttributeValue::setTrafficEvent(::nds::traffic::types::TrafficEvent&& trafficEvent_)
{
    m_objectChoice = ::std::move(trafficEvent_);
}

::nds::traffic::types::TrafficFlow TrafficLaneRangeAttributeValue::getTrafficFlow() const
{
    return m_objectChoice.get<::nds::traffic::types::TrafficFlow>();
}

void TrafficLaneRangeAttributeValue::setTrafficFlow(::nds::traffic::types::TrafficFlow trafficFlow_)
{
    m_objectChoice = trafficFlow_;
}

::nds::traffic::types::CurrentRoadCondition& TrafficLaneRangeAttributeValue::getCurrentRoadCondition()
{
    return m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>();
}

const ::nds::traffic::types::CurrentRoadCondition& TrafficLaneRangeAttributeValue::getCurrentRoadCondition() const
{
    return m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>();
}

void TrafficLaneRangeAttributeValue::setCurrentRoadCondition(const ::nds::traffic::types::CurrentRoadCondition& currentRoadCondition_)
{
    m_objectChoice = currentRoadCondition_;
}

void TrafficLaneRangeAttributeValue::setCurrentRoadCondition(::nds::traffic::types::CurrentRoadCondition&& currentRoadCondition_)
{
    m_objectChoice = ::std::move(currentRoadCondition_);
}

::nds::traffic::types::ParkingAvailability TrafficLaneRangeAttributeValue::getParkingAvailability() const
{
    return m_objectChoice.get<::nds::traffic::types::ParkingAvailability>();
}

void TrafficLaneRangeAttributeValue::setParkingAvailability(::nds::traffic::types::ParkingAvailability parkingAvailability_)
{
    m_objectChoice = parkingAvailability_;
}

TrafficLaneRangeAttributeValue::ChoiceTag TrafficLaneRangeAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        return CHOICE_trafficEvent;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        return CHOICE_trafficFlow;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        return CHOICE_currentRoadCondition;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        return CHOICE_parkingAvailability;
    default:
        return UNDEFINED_CHOICE;
    }
}

void TrafficLaneRangeAttributeValue::initPackingContext(TrafficLaneRangeAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        m_objectChoice.get<::nds::traffic::types::TrafficEvent>().initPackingContext(context.getTrafficEvent());
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        ::zserio::initPackingContext(context.getTrafficFlow(), m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }
}

size_t TrafficLaneRangeAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::TrafficEvent>().bitSizeOf(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeValue::bitSizeOf(TrafficLaneRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::TrafficEvent>().bitSizeOf(context.getTrafficEvent(), endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficFlow(), m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t TrafficLaneRangeAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::TrafficEvent>().initializeOffsets(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }

    return endBitPosition;
}

size_t TrafficLaneRangeAttributeValue::initializeOffsets(TrafficLaneRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::TrafficEvent>().initializeOffsets(context.getTrafficEvent(), endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficFlow(), endBitPosition,
        m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }

    return endBitPosition;
}

bool TrafficLaneRangeAttributeValue::operator==(const TrafficLaneRangeAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::TrafficEvent>() == other.m_objectChoice.get<::nds::traffic::types::TrafficEvent>());
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::TrafficFlow>() == other.m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>() == other.m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>());
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::ParkingAvailability>() == other.m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }
}

uint32_t TrafficLaneRangeAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::TrafficEvent>());
            break;
        case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
            break;
        case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>());
            break;
        case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
            break;
        default:
            break;
        }
    }

    return result;
}

void TrafficLaneRangeAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        m_objectChoice.get<::nds::traffic::types::TrafficEvent>().write(out);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        ::zserio::write(out, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().write(out);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        out.writeBool(m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }
}

void TrafficLaneRangeAttributeValue::write(TrafficLaneRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        m_objectChoice.get<::nds::traffic::types::TrafficEvent>().write(context.getTrafficEvent(), out);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        ::zserio::write(context.getTrafficFlow(), out, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().write(out);
        break;
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        out.writeBool(m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficLaneRangeAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        return ::zserio::AnyHolder<>(::nds::traffic::types::TrafficEvent(in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::traffic::types::TrafficFlow>(in), allocator);
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::AnyHolder<>(::nds::traffic::types::CurrentRoadCondition(in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        return ::zserio::AnyHolder<>(static_cast<::nds::traffic::types::ParkingAvailability>(in.readBool()), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficLaneRangeAttributeValue::readObject(TrafficLaneRangeAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        return ::zserio::AnyHolder<>(::nds::traffic::types::TrafficEvent(context.getTrafficEvent(), in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::traffic::types::TrafficFlow>(context.getTrafficFlow(), in), allocator);
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::AnyHolder<>(::nds::traffic::types::CurrentRoadCondition(in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        return ::zserio::AnyHolder<>(static_cast<::nds::traffic::types::ParkingAvailability>(in.readBool()), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficLaneRangeAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_EVENT:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::TrafficEvent>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::TRAFFIC_FLOW:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::TrafficFlow>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::CurrentRoadCondition>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficLaneRangeAttributeType::PARKING_AVAILABILITY:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::ParkingAvailability>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficLaneRangeAttributeValue!");
    }
}

} // namespace attributes
} // namespace traffic
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/traffic/attributes/TrafficDisplayLineRangeAttributeValue.h>

namespace nds
{
namespace traffic
{
namespace attributes
{

TrafficDisplayLineRangeAttributeValue::TrafficDisplayLineRangeAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

TrafficDisplayLineRangeAttributeValue::TrafficDisplayLineRangeAttributeValue(::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

TrafficDisplayLineRangeAttributeValue::TrafficDisplayLineRangeAttributeValue(TrafficDisplayLineRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

TrafficDisplayLineRangeAttributeValue::TrafficDisplayLineRangeAttributeValue(const TrafficDisplayLineRangeAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeValue& TrafficDisplayLineRangeAttributeValue::operator=(const TrafficDisplayLineRangeAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeValue::TrafficDisplayLineRangeAttributeValue(TrafficDisplayLineRangeAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

TrafficDisplayLineRangeAttributeValue& TrafficDisplayLineRangeAttributeValue::operator=(TrafficDisplayLineRangeAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficDisplayLineRangeAttributeValue::TrafficDisplayLineRangeAttributeValue(::zserio::PropagateAllocatorT,
        const TrafficDisplayLineRangeAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void TrafficDisplayLineRangeAttributeValue::initialize(
        ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool TrafficDisplayLineRangeAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType TrafficDisplayLineRangeAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'TrafficDisplayLineRangeAttributeValue' is not initialized!");

    return m_type_;
}

::nds::traffic::types::TrafficEvent& TrafficDisplayLineRangeAttributeValue::getTrafficEvent()
{
    return m_objectChoice.get<::nds::traffic::types::TrafficEvent>();
}

const ::nds::traffic::types::TrafficEvent& TrafficDisplayLineRangeAttributeValue::getTrafficEvent() const
{
    return m_objectChoice.get<::nds::traffic::types::TrafficEvent>();
}

void TrafficDisplayLineRangeAttributeValue::setTrafficEvent(const ::nds::traffic::types::TrafficEvent& trafficEvent_)
{
    m_objectChoice = trafficEvent_;
}

void TrafficDisplayLineRangeAttributeValue::setTrafficEvent(::nds::traffic::types::TrafficEvent&& trafficEvent_)
{
    m_objectChoice = ::std::move(trafficEvent_);
}

::nds::traffic::types::TrafficFlow TrafficDisplayLineRangeAttributeValue::getTrafficFlow() const
{
    return m_objectChoice.get<::nds::traffic::types::TrafficFlow>();
}

void TrafficDisplayLineRangeAttributeValue::setTrafficFlow(::nds::traffic::types::TrafficFlow trafficFlow_)
{
    m_objectChoice = trafficFlow_;
}

::nds::traffic::types::CurrentRoadCondition& TrafficDisplayLineRangeAttributeValue::getCurrentRoadCondition()
{
    return m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>();
}

const ::nds::traffic::types::CurrentRoadCondition& TrafficDisplayLineRangeAttributeValue::getCurrentRoadCondition() const
{
    return m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>();
}

void TrafficDisplayLineRangeAttributeValue::setCurrentRoadCondition(const ::nds::traffic::types::CurrentRoadCondition& currentRoadCondition_)
{
    m_objectChoice = currentRoadCondition_;
}

void TrafficDisplayLineRangeAttributeValue::setCurrentRoadCondition(::nds::traffic::types::CurrentRoadCondition&& currentRoadCondition_)
{
    m_objectChoice = ::std::move(currentRoadCondition_);
}

::nds::traffic::types::ParkingAvailability TrafficDisplayLineRangeAttributeValue::getParkingAvailability() const
{
    return m_objectChoice.get<::nds::traffic::types::ParkingAvailability>();
}

void TrafficDisplayLineRangeAttributeValue::setParkingAvailability(::nds::traffic::types::ParkingAvailability parkingAvailability_)
{
    m_objectChoice = parkingAvailability_;
}

TrafficDisplayLineRangeAttributeValue::ChoiceTag TrafficDisplayLineRangeAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        return CHOICE_trafficEvent;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        return CHOICE_trafficFlow;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        return CHOICE_currentRoadCondition;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        return CHOICE_parkingAvailability;
    default:
        return UNDEFINED_CHOICE;
    }
}

void TrafficDisplayLineRangeAttributeValue::initPackingContext(TrafficDisplayLineRangeAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        m_objectChoice.get<::nds::traffic::types::TrafficEvent>().initPackingContext(context.getTrafficEvent());
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        ::zserio::initPackingContext(context.getTrafficFlow(), m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }
}

size_t TrafficDisplayLineRangeAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::TrafficEvent>().bitSizeOf(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeValue::bitSizeOf(TrafficDisplayLineRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::TrafficEvent>().bitSizeOf(context.getTrafficEvent(), endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficFlow(), m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition += m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t TrafficDisplayLineRangeAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::TrafficEvent>().initializeOffsets(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }

    return endBitPosition;
}

size_t TrafficDisplayLineRangeAttributeValue::initializeOffsets(TrafficDisplayLineRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::TrafficEvent>().initializeOffsets(context.getTrafficEvent(), endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficFlow(), endBitPosition,
        m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        endBitPosition = m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        endBitPosition += UINT8_C(1);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }

    return endBitPosition;
}

bool TrafficDisplayLineRangeAttributeValue::operator==(const TrafficDisplayLineRangeAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::TrafficEvent>() == other.m_objectChoice.get<::nds::traffic::types::TrafficEvent>());
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::TrafficFlow>() == other.m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>() == other.m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>());
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::traffic::types::ParkingAvailability>() == other.m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }
}

uint32_t TrafficDisplayLineRangeAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::TrafficEvent>());
            break;
        case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
            break;
        case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>());
            break;
        case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
            break;
        default:
            break;
        }
    }

    return result;
}

void TrafficDisplayLineRangeAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        m_objectChoice.get<::nds::traffic::types::TrafficEvent>().write(out);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        ::zserio::write(out, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().write(out);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        out.writeBool(m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }
}

void TrafficDisplayLineRangeAttributeValue::write(TrafficDisplayLineRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        m_objectChoice.get<::nds::traffic::types::TrafficEvent>().write(context.getTrafficEvent(), out);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        ::zserio::write(context.getTrafficFlow(), out, m_objectChoice.get<::nds::traffic::types::TrafficFlow>());
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        m_objectChoice.get<::nds::traffic::types::CurrentRoadCondition>().write(out);
        break;
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        out.writeBool(m_objectChoice.get<::nds::traffic::types::ParkingAvailability>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficDisplayLineRangeAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        return ::zserio::AnyHolder<>(::nds::traffic::types::TrafficEvent(in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::traffic::types::TrafficFlow>(in), allocator);
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::AnyHolder<>(::nds::traffic::types::CurrentRoadCondition(in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        return ::zserio::AnyHolder<>(static_cast<::nds::traffic::types::ParkingAvailability>(in.readBool()), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficDisplayLineRangeAttributeValue::readObject(TrafficDisplayLineRangeAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        return ::zserio::AnyHolder<>(::nds::traffic::types::TrafficEvent(context.getTrafficEvent(), in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::traffic::types::TrafficFlow>(context.getTrafficFlow(), in), allocator);
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::AnyHolder<>(::nds::traffic::types::CurrentRoadCondition(in, allocator), allocator);
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        return ::zserio::AnyHolder<>(static_cast<::nds::traffic::types::ParkingAvailability>(in.readBool()), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> TrafficDisplayLineRangeAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_EVENT:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::TrafficEvent>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::TRAFFIC_FLOW:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::TrafficFlow>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::CURRENT_ROAD_CONDITION:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::CurrentRoadCondition>(m_objectChoice, allocator);
    case ::nds::traffic::attributes::TrafficDisplayLineRangeAttributeType::PARKING_AVAILABILITY:
        return ::zserio::allocatorPropagatingCopy<::nds::traffic::types::ParkingAvailability>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice TrafficDisplayLineRangeAttributeValue!");
    }
}

} // namespace attributes
} // namespace traffic
} // namespace nds
