/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadRangeAttributeMetadata.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadRangeAttributeMetadata::RoutingRoadRangeAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RoutingRoadRangeAttributeMetadata::RoutingRoadRangeAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RoutingRoadRangeAttributeMetadata::RoutingRoadRangeAttributeMetadata(RoutingRoadRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RoutingRoadRangeAttributeMetadata::RoutingRoadRangeAttributeMetadata(::zserio::PropagateAllocatorT,
        const RoutingRoadRangeAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>& RoutingRoadRangeAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>& RoutingRoadRangeAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RoutingRoadRangeAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RoutingRoadRangeAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& RoutingRoadRangeAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& RoutingRoadRangeAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RoutingRoadRangeAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RoutingRoadRangeAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RoutingRoadRangeAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RoutingRoadRangeAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RoutingRoadRangeAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RoutingRoadRangeAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RoutingRoadRangeAttributeMetadata::initPackingContext(RoutingRoadRangeAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RoutingRoadRangeAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeMetadata::bitSizeOf(RoutingRoadRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadRangeAttributeMetadata::initializeOffsets(RoutingRoadRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RoutingRoadRangeAttributeMetadata::operator==(const RoutingRoadRangeAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RoutingRoadRangeAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RoutingRoadRangeAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RoutingRoadRangeAttributeMetadata::write(RoutingRoadRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RoutingRoadRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RoutingRoadRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RoutingRoadRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& array,
        ::nds::routingdata::properties::RoutingPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RoutingRoadRangeAttributeMetadata::ZserioArrayType_availableAttributes RoutingRoadRangeAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RoutingRoadRangeAttributeMetadata::ZserioArrayType_availableAttributes RoutingRoadRangeAttributeMetadata::readAvailableAttributes(RoutingRoadRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RoutingRoadRangeAttributeMetadata::ZserioArrayType_availableProperties RoutingRoadRangeAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RoutingRoadRangeAttributeMetadata::ZserioArrayType_availableProperties RoutingRoadRangeAttributeMetadata::readAvailableProperties(RoutingRoadRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RoutingRoadRangeAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RoutingRoadRangeAttributeMetadata::readAvailableConditions(RoutingRoadRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadTransitionAttributeMetadata.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadTransitionAttributeMetadata::RoutingRoadTransitionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RoutingRoadTransitionAttributeMetadata::RoutingRoadTransitionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RoutingRoadTransitionAttributeMetadata::RoutingRoadTransitionAttributeMetadata(RoutingRoadTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RoutingRoadTransitionAttributeMetadata::RoutingRoadTransitionAttributeMetadata(::zserio::PropagateAllocatorT,
        const RoutingRoadTransitionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>& RoutingRoadTransitionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>& RoutingRoadTransitionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RoutingRoadTransitionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RoutingRoadTransitionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& RoutingRoadTransitionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& RoutingRoadTransitionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RoutingRoadTransitionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RoutingRoadTransitionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RoutingRoadTransitionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RoutingRoadTransitionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RoutingRoadTransitionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RoutingRoadTransitionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RoutingRoadTransitionAttributeMetadata::initPackingContext(RoutingRoadTransitionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RoutingRoadTransitionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeMetadata::bitSizeOf(RoutingRoadTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadTransitionAttributeMetadata::initializeOffsets(RoutingRoadTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RoutingRoadTransitionAttributeMetadata::operator==(const RoutingRoadTransitionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RoutingRoadTransitionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RoutingRoadTransitionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RoutingRoadTransitionAttributeMetadata::write(RoutingRoadTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RoutingRoadTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(RoutingRoadTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(RoutingRoadTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& array,
        ::nds::routingdata::properties::RoutingPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RoutingRoadTransitionAttributeMetadata::ZserioArrayType_availableAttributes RoutingRoadTransitionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RoutingRoadTransitionAttributeMetadata::ZserioArrayType_availableAttributes RoutingRoadTransitionAttributeMetadata::readAvailableAttributes(RoutingRoadTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RoutingRoadTransitionAttributeMetadata::ZserioArrayType_availableProperties RoutingRoadTransitionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RoutingRoadTransitionAttributeMetadata::ZserioArrayType_availableProperties RoutingRoadTransitionAttributeMetadata::readAvailableProperties(RoutingRoadTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RoutingRoadTransitionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RoutingRoadTransitionAttributeMetadata::readAvailableConditions(RoutingRoadTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneRangeAttributeMetadata.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneRangeAttributeMetadata::RoutingLaneRangeAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RoutingLaneRangeAttributeMetadata::RoutingLaneRangeAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RoutingLaneRangeAttributeMetadata::RoutingLaneRangeAttributeMetadata(RoutingLaneRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RoutingLaneRangeAttributeMetadata::RoutingLaneRangeAttributeMetadata(::zserio::PropagateAllocatorT,
        const RoutingLaneRangeAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>& RoutingLaneRangeAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>& RoutingLaneRangeAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RoutingLaneRangeAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RoutingLaneRangeAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& RoutingLaneRangeAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& RoutingLaneRangeAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RoutingLaneRangeAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RoutingLaneRangeAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RoutingLaneRangeAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RoutingLaneRangeAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RoutingLaneRangeAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RoutingLaneRangeAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RoutingLaneRangeAttributeMetadata::initPackingContext(RoutingLaneRangeAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RoutingLaneRangeAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeMetadata::bitSizeOf(RoutingLaneRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneRangeAttributeMetadata::initializeOffsets(RoutingLaneRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RoutingLaneRangeAttributeMetadata::operator==(const RoutingLaneRangeAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RoutingLaneRangeAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RoutingLaneRangeAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RoutingLaneRangeAttributeMetadata::write(RoutingLaneRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RoutingLaneRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RoutingLaneRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RoutingLaneRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& array,
        ::nds::routingdata::properties::RoutingPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RoutingLaneRangeAttributeMetadata::ZserioArrayType_availableAttributes RoutingLaneRangeAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RoutingLaneRangeAttributeMetadata::ZserioArrayType_availableAttributes RoutingLaneRangeAttributeMetadata::readAvailableAttributes(RoutingLaneRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RoutingLaneRangeAttributeMetadata::ZserioArrayType_availableProperties RoutingLaneRangeAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RoutingLaneRangeAttributeMetadata::ZserioArrayType_availableProperties RoutingLaneRangeAttributeMetadata::readAvailableProperties(RoutingLaneRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RoutingLaneRangeAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RoutingLaneRangeAttributeMetadata::readAvailableConditions(RoutingLaneRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneTransitionAttributeMetadata.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneTransitionAttributeMetadata::RoutingLaneTransitionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RoutingLaneTransitionAttributeMetadata::RoutingLaneTransitionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RoutingLaneTransitionAttributeMetadata::RoutingLaneTransitionAttributeMetadata(RoutingLaneTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RoutingLaneTransitionAttributeMetadata::RoutingLaneTransitionAttributeMetadata(::zserio::PropagateAllocatorT,
        const RoutingLaneTransitionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>& RoutingLaneTransitionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>& RoutingLaneTransitionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RoutingLaneTransitionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RoutingLaneTransitionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& RoutingLaneTransitionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& RoutingLaneTransitionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RoutingLaneTransitionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RoutingLaneTransitionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RoutingLaneTransitionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RoutingLaneTransitionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RoutingLaneTransitionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RoutingLaneTransitionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RoutingLaneTransitionAttributeMetadata::initPackingContext(RoutingLaneTransitionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RoutingLaneTransitionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeMetadata::bitSizeOf(RoutingLaneTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneTransitionAttributeMetadata::initializeOffsets(RoutingLaneTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RoutingLaneTransitionAttributeMetadata::operator==(const RoutingLaneTransitionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RoutingLaneTransitionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RoutingLaneTransitionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RoutingLaneTransitionAttributeMetadata::write(RoutingLaneTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RoutingLaneTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(RoutingLaneTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(RoutingLaneTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::routingdata::properties::RoutingPropertyType>& array,
        ::nds::routingdata::properties::RoutingPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RoutingLaneTransitionAttributeMetadata::ZserioArrayType_availableAttributes RoutingLaneTransitionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RoutingLaneTransitionAttributeMetadata::ZserioArrayType_availableAttributes RoutingLaneTransitionAttributeMetadata::readAvailableAttributes(RoutingLaneTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RoutingLaneTransitionAttributeMetadata::ZserioArrayType_availableProperties RoutingLaneTransitionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RoutingLaneTransitionAttributeMetadata::ZserioArrayType_availableProperties RoutingLaneTransitionAttributeMetadata::readAvailableProperties(RoutingLaneTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RoutingLaneTransitionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RoutingLaneTransitionAttributeMetadata::readAvailableConditions(RoutingLaneTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadRangeAttributeMapList.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadRangeAttributeMapList::RoutingRoadRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RoutingRoadRangeAttributeMapList::RoutingRoadRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RoutingRoadRangeAttributeMapList::RoutingRoadRangeAttributeMapList(RoutingRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RoutingRoadRangeAttributeMapList::RoutingRoadRangeAttributeMapList(const RoutingRoadRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeMapList& RoutingRoadRangeAttributeMapList::operator=(const RoutingRoadRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeMapList::RoutingRoadRangeAttributeMapList(RoutingRoadRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeMapList& RoutingRoadRangeAttributeMapList::operator=(RoutingRoadRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeMapList::RoutingRoadRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const RoutingRoadRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingRoadRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingRoadRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingRoadRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RoutingRoadRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RoutingRoadRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::routingdata::instantiations::RoutingRoadRangeAttributeMapListHeader& RoutingRoadRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::routingdata::instantiations::RoutingRoadRangeAttributeMapListHeader& RoutingRoadRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void RoutingRoadRangeAttributeMapList::setHeader(const ::nds::routingdata::instantiations::RoutingRoadRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RoutingRoadRangeAttributeMapList::setHeader(::nds::routingdata::instantiations::RoutingRoadRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeMap>& RoutingRoadRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeMap>& RoutingRoadRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RoutingRoadRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RoutingRoadRangeAttributeMapList::setMaps(::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RoutingRoadRangeAttributeMapList::initPackingContext(RoutingRoadRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RoutingRoadRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeMapList::bitSizeOf(RoutingRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadRangeAttributeMapList::initializeOffsets(RoutingRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadRangeAttributeMapList::operator==(const RoutingRoadRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RoutingRoadRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RoutingRoadRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RoutingRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeMapList::write(RoutingRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RoutingRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RoutingRoadRangeAttributeMapList& owner,
        ::nds::routingdata::instantiations::RoutingRoadRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingRoadRangeAttributeMapList::ZserioElementFactory_maps::create(RoutingRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingRoadRangeAttributeMapList::ZserioElementFactory_maps::create(RoutingRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeMap>& array,
        ::nds::routingdata::instantiations::RoutingRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RoutingRoadRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingRoadRangeAttributeMapList::readNumMaps(RoutingRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::routingdata::instantiations::RoutingRoadRangeAttributeMapListHeader RoutingRoadRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingRoadRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::routingdata::instantiations::RoutingRoadRangeAttributeMapListHeader RoutingRoadRangeAttributeMapList::readHeader(RoutingRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingRoadRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RoutingRoadRangeAttributeMapList::ZserioArrayType_maps RoutingRoadRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingRoadRangeAttributeMapList::ZserioArrayType_maps RoutingRoadRangeAttributeMapList::readMaps(RoutingRoadRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadTransitionAttributeMapList.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadTransitionAttributeMapList::RoutingRoadTransitionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RoutingRoadTransitionAttributeMapList::RoutingRoadTransitionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RoutingRoadTransitionAttributeMapList::RoutingRoadTransitionAttributeMapList(RoutingRoadTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RoutingRoadTransitionAttributeMapList::RoutingRoadTransitionAttributeMapList(const RoutingRoadTransitionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeMapList& RoutingRoadTransitionAttributeMapList::operator=(const RoutingRoadTransitionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeMapList::RoutingRoadTransitionAttributeMapList(RoutingRoadTransitionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeMapList& RoutingRoadTransitionAttributeMapList::operator=(RoutingRoadTransitionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeMapList::RoutingRoadTransitionAttributeMapList(::zserio::PropagateAllocatorT,
        const RoutingRoadTransitionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingRoadTransitionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadTransitionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadTransitionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingRoadTransitionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingRoadTransitionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RoutingRoadTransitionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RoutingRoadTransitionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMapListHeader& RoutingRoadTransitionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMapListHeader& RoutingRoadTransitionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RoutingRoadTransitionAttributeMapList::setHeader(const ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RoutingRoadTransitionAttributeMapList::setHeader(::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMap>& RoutingRoadTransitionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMap>& RoutingRoadTransitionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RoutingRoadTransitionAttributeMapList::setMaps(const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RoutingRoadTransitionAttributeMapList::setMaps(::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RoutingRoadTransitionAttributeMapList::initPackingContext(RoutingRoadTransitionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RoutingRoadTransitionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeMapList::bitSizeOf(RoutingRoadTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadTransitionAttributeMapList::initializeOffsets(RoutingRoadTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadTransitionAttributeMapList::operator==(const RoutingRoadTransitionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RoutingRoadTransitionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RoutingRoadTransitionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RoutingRoadTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeMapList::write(RoutingRoadTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RoutingRoadTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RoutingRoadTransitionAttributeMapList& owner,
        ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingRoadTransitionAttributeMapList::ZserioElementFactory_maps::create(RoutingRoadTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingRoadTransitionAttributeMapList::ZserioElementFactory_maps::create(RoutingRoadTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMap>& array,
        ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RoutingRoadTransitionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingRoadTransitionAttributeMapList::readNumMaps(RoutingRoadTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMapListHeader RoutingRoadTransitionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMapListHeader RoutingRoadTransitionAttributeMapList::readHeader(RoutingRoadTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RoutingRoadTransitionAttributeMapList::ZserioArrayType_maps RoutingRoadTransitionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingRoadTransitionAttributeMapList::ZserioArrayType_maps RoutingRoadTransitionAttributeMapList::readMaps(RoutingRoadTransitionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneRangeAttributeMapList.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneRangeAttributeMapList::RoutingLaneRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RoutingLaneRangeAttributeMapList::RoutingLaneRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RoutingLaneRangeAttributeMapList::RoutingLaneRangeAttributeMapList(RoutingLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RoutingLaneRangeAttributeMapList::RoutingLaneRangeAttributeMapList(const RoutingLaneRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeMapList& RoutingLaneRangeAttributeMapList::operator=(const RoutingLaneRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeMapList::RoutingLaneRangeAttributeMapList(RoutingLaneRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeMapList& RoutingLaneRangeAttributeMapList::operator=(RoutingLaneRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeMapList::RoutingLaneRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const RoutingLaneRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingLaneRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingLaneRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingLaneRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RoutingLaneRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RoutingLaneRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::routingdata::instantiations::RoutingLaneRangeAttributeMapListHeader& RoutingLaneRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::routingdata::instantiations::RoutingLaneRangeAttributeMapListHeader& RoutingLaneRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void RoutingLaneRangeAttributeMapList::setHeader(const ::nds::routingdata::instantiations::RoutingLaneRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RoutingLaneRangeAttributeMapList::setHeader(::nds::routingdata::instantiations::RoutingLaneRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeMap>& RoutingLaneRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeMap>& RoutingLaneRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RoutingLaneRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RoutingLaneRangeAttributeMapList::setMaps(::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RoutingLaneRangeAttributeMapList::initPackingContext(RoutingLaneRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RoutingLaneRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeMapList::bitSizeOf(RoutingLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneRangeAttributeMapList::initializeOffsets(RoutingLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneRangeAttributeMapList::operator==(const RoutingLaneRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RoutingLaneRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RoutingLaneRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RoutingLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeMapList::write(RoutingLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RoutingLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RoutingLaneRangeAttributeMapList& owner,
        ::nds::routingdata::instantiations::RoutingLaneRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingLaneRangeAttributeMapList::ZserioElementFactory_maps::create(RoutingLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingLaneRangeAttributeMapList::ZserioElementFactory_maps::create(RoutingLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeMap>& array,
        ::nds::routingdata::instantiations::RoutingLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RoutingLaneRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingLaneRangeAttributeMapList::readNumMaps(RoutingLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::routingdata::instantiations::RoutingLaneRangeAttributeMapListHeader RoutingLaneRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingLaneRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::routingdata::instantiations::RoutingLaneRangeAttributeMapListHeader RoutingLaneRangeAttributeMapList::readHeader(RoutingLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingLaneRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RoutingLaneRangeAttributeMapList::ZserioArrayType_maps RoutingLaneRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingLaneRangeAttributeMapList::ZserioArrayType_maps RoutingLaneRangeAttributeMapList::readMaps(RoutingLaneRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneTransitionAttributeMapList.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneTransitionAttributeMapList::RoutingLaneTransitionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RoutingLaneTransitionAttributeMapList::RoutingLaneTransitionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RoutingLaneTransitionAttributeMapList::RoutingLaneTransitionAttributeMapList(RoutingLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RoutingLaneTransitionAttributeMapList::RoutingLaneTransitionAttributeMapList(const RoutingLaneTransitionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeMapList& RoutingLaneTransitionAttributeMapList::operator=(const RoutingLaneTransitionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeMapList::RoutingLaneTransitionAttributeMapList(RoutingLaneTransitionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeMapList& RoutingLaneTransitionAttributeMapList::operator=(RoutingLaneTransitionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeMapList::RoutingLaneTransitionAttributeMapList(::zserio::PropagateAllocatorT,
        const RoutingLaneTransitionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingLaneTransitionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneTransitionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneTransitionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingLaneTransitionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingLaneTransitionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RoutingLaneTransitionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RoutingLaneTransitionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMapListHeader& RoutingLaneTransitionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMapListHeader& RoutingLaneTransitionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RoutingLaneTransitionAttributeMapList::setHeader(const ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RoutingLaneTransitionAttributeMapList::setHeader(::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMap>& RoutingLaneTransitionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMap>& RoutingLaneTransitionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RoutingLaneTransitionAttributeMapList::setMaps(const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RoutingLaneTransitionAttributeMapList::setMaps(::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RoutingLaneTransitionAttributeMapList::initPackingContext(RoutingLaneTransitionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RoutingLaneTransitionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeMapList::bitSizeOf(RoutingLaneTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneTransitionAttributeMapList::initializeOffsets(RoutingLaneTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneTransitionAttributeMapList::operator==(const RoutingLaneTransitionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RoutingLaneTransitionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RoutingLaneTransitionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RoutingLaneTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeMapList::write(RoutingLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RoutingLaneTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RoutingLaneTransitionAttributeMapList& owner,
        ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingLaneTransitionAttributeMapList::ZserioElementFactory_maps::create(RoutingLaneTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingLaneTransitionAttributeMapList::ZserioElementFactory_maps::create(RoutingLaneTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMap>& array,
        ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RoutingLaneTransitionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingLaneTransitionAttributeMapList::readNumMaps(RoutingLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMapListHeader RoutingLaneTransitionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMapListHeader RoutingLaneTransitionAttributeMapList::readHeader(RoutingLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RoutingLaneTransitionAttributeMapList::ZserioArrayType_maps RoutingLaneTransitionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingLaneTransitionAttributeMapList::ZserioArrayType_maps RoutingLaneTransitionAttributeMapList::readMaps(RoutingLaneTransitionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadRangeAttributeMapListHeader.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadRangeAttributeMapListHeader::RoutingRoadRangeAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RoutingRoadRangeAttributeMapListHeader::RoutingRoadRangeAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RoutingRoadRangeAttributeMapListHeader::RoutingRoadRangeAttributeMapListHeader(RoutingRoadRangeAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RoutingRoadRangeAttributeMapListHeader::RoutingRoadRangeAttributeMapListHeader(const RoutingRoadRangeAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeMapListHeader& RoutingRoadRangeAttributeMapListHeader::operator=(const RoutingRoadRangeAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeMapListHeader::RoutingRoadRangeAttributeMapListHeader(RoutingRoadRangeAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeMapListHeader& RoutingRoadRangeAttributeMapListHeader::operator=(RoutingRoadRangeAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeMapListHeader::RoutingRoadRangeAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RoutingRoadRangeAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RoutingRoadRangeAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RoutingRoadRangeAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RoutingRoadRangeAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RoutingRoadRangeAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>& RoutingRoadRangeAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>& RoutingRoadRangeAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RoutingRoadRangeAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RoutingRoadRangeAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RoutingRoadRangeAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RoutingRoadRangeAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RoutingRoadRangeAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RoutingRoadRangeAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RoutingRoadRangeAttributeMapListHeader::initPackingContext(RoutingRoadRangeAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RoutingRoadRangeAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeMapListHeader::bitSizeOf(RoutingRoadRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadRangeAttributeMapListHeader::initializeOffsets(RoutingRoadRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadRangeAttributeMapListHeader::operator==(const RoutingRoadRangeAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RoutingRoadRangeAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RoutingRoadRangeAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeMapListHeader::write(RoutingRoadRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RoutingRoadRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RoutingRoadRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RoutingRoadRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RoutingRoadRangeAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingRoadRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RoutingRoadRangeAttributeMapListHeader::readAttributeTypeCode(RoutingRoadRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RoutingRoadRangeAttributeMapListHeader::ZserioArrayType_conditionType RoutingRoadRangeAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingRoadRangeAttributeMapListHeader::ZserioArrayType_conditionType RoutingRoadRangeAttributeMapListHeader::readConditionType(RoutingRoadRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadTransitionAttributeMapListHeader.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadTransitionAttributeMapListHeader::RoutingRoadTransitionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RoutingRoadTransitionAttributeMapListHeader::RoutingRoadTransitionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RoutingRoadTransitionAttributeMapListHeader::RoutingRoadTransitionAttributeMapListHeader(RoutingRoadTransitionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RoutingRoadTransitionAttributeMapListHeader::RoutingRoadTransitionAttributeMapListHeader(const RoutingRoadTransitionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeMapListHeader& RoutingRoadTransitionAttributeMapListHeader::operator=(const RoutingRoadTransitionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeMapListHeader::RoutingRoadTransitionAttributeMapListHeader(RoutingRoadTransitionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeMapListHeader& RoutingRoadTransitionAttributeMapListHeader::operator=(RoutingRoadTransitionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeMapListHeader::RoutingRoadTransitionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RoutingRoadTransitionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RoutingRoadTransitionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RoutingRoadTransitionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RoutingRoadTransitionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RoutingRoadTransitionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>& RoutingRoadTransitionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>& RoutingRoadTransitionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RoutingRoadTransitionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RoutingRoadTransitionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RoutingRoadTransitionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RoutingRoadTransitionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RoutingRoadTransitionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RoutingRoadTransitionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RoutingRoadTransitionAttributeMapListHeader::initPackingContext(RoutingRoadTransitionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RoutingRoadTransitionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeMapListHeader::bitSizeOf(RoutingRoadTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadTransitionAttributeMapListHeader::initializeOffsets(RoutingRoadTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadTransitionAttributeMapListHeader::operator==(const RoutingRoadTransitionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RoutingRoadTransitionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RoutingRoadTransitionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeMapListHeader::write(RoutingRoadTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RoutingRoadTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RoutingRoadTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RoutingRoadTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RoutingRoadTransitionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingRoadTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RoutingRoadTransitionAttributeMapListHeader::readAttributeTypeCode(RoutingRoadTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RoutingRoadTransitionAttributeMapListHeader::ZserioArrayType_conditionType RoutingRoadTransitionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingRoadTransitionAttributeMapListHeader::ZserioArrayType_conditionType RoutingRoadTransitionAttributeMapListHeader::readConditionType(RoutingRoadTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneRangeAttributeMapListHeader.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneRangeAttributeMapListHeader::RoutingLaneRangeAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RoutingLaneRangeAttributeMapListHeader::RoutingLaneRangeAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RoutingLaneRangeAttributeMapListHeader::RoutingLaneRangeAttributeMapListHeader(RoutingLaneRangeAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RoutingLaneRangeAttributeMapListHeader::RoutingLaneRangeAttributeMapListHeader(const RoutingLaneRangeAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeMapListHeader& RoutingLaneRangeAttributeMapListHeader::operator=(const RoutingLaneRangeAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeMapListHeader::RoutingLaneRangeAttributeMapListHeader(RoutingLaneRangeAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeMapListHeader& RoutingLaneRangeAttributeMapListHeader::operator=(RoutingLaneRangeAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeMapListHeader::RoutingLaneRangeAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RoutingLaneRangeAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RoutingLaneRangeAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RoutingLaneRangeAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RoutingLaneRangeAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RoutingLaneRangeAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>& RoutingLaneRangeAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>& RoutingLaneRangeAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RoutingLaneRangeAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RoutingLaneRangeAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RoutingLaneRangeAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RoutingLaneRangeAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RoutingLaneRangeAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RoutingLaneRangeAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RoutingLaneRangeAttributeMapListHeader::initPackingContext(RoutingLaneRangeAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RoutingLaneRangeAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeMapListHeader::bitSizeOf(RoutingLaneRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneRangeAttributeMapListHeader::initializeOffsets(RoutingLaneRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneRangeAttributeMapListHeader::operator==(const RoutingLaneRangeAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RoutingLaneRangeAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RoutingLaneRangeAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeMapListHeader::write(RoutingLaneRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RoutingLaneRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RoutingLaneRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RoutingLaneRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RoutingLaneRangeAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingLaneRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RoutingLaneRangeAttributeMapListHeader::readAttributeTypeCode(RoutingLaneRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RoutingLaneRangeAttributeMapListHeader::ZserioArrayType_conditionType RoutingLaneRangeAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingLaneRangeAttributeMapListHeader::ZserioArrayType_conditionType RoutingLaneRangeAttributeMapListHeader::readConditionType(RoutingLaneRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneTransitionAttributeMapListHeader.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneTransitionAttributeMapListHeader::RoutingLaneTransitionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RoutingLaneTransitionAttributeMapListHeader::RoutingLaneTransitionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RoutingLaneTransitionAttributeMapListHeader::RoutingLaneTransitionAttributeMapListHeader(RoutingLaneTransitionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RoutingLaneTransitionAttributeMapListHeader::RoutingLaneTransitionAttributeMapListHeader(const RoutingLaneTransitionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeMapListHeader& RoutingLaneTransitionAttributeMapListHeader::operator=(const RoutingLaneTransitionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeMapListHeader::RoutingLaneTransitionAttributeMapListHeader(RoutingLaneTransitionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeMapListHeader& RoutingLaneTransitionAttributeMapListHeader::operator=(RoutingLaneTransitionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeMapListHeader::RoutingLaneTransitionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RoutingLaneTransitionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RoutingLaneTransitionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RoutingLaneTransitionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RoutingLaneTransitionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RoutingLaneTransitionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>& RoutingLaneTransitionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>& RoutingLaneTransitionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RoutingLaneTransitionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RoutingLaneTransitionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RoutingLaneTransitionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RoutingLaneTransitionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RoutingLaneTransitionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RoutingLaneTransitionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RoutingLaneTransitionAttributeMapListHeader::initPackingContext(RoutingLaneTransitionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RoutingLaneTransitionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeMapListHeader::bitSizeOf(RoutingLaneTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneTransitionAttributeMapListHeader::initializeOffsets(RoutingLaneTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneTransitionAttributeMapListHeader::operator==(const RoutingLaneTransitionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RoutingLaneTransitionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RoutingLaneTransitionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeMapListHeader::write(RoutingLaneTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RoutingLaneTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RoutingLaneTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RoutingLaneTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RoutingLaneTransitionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingLaneTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RoutingLaneTransitionAttributeMapListHeader::readAttributeTypeCode(RoutingLaneTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RoutingLaneTransitionAttributeMapListHeader::ZserioArrayType_conditionType RoutingLaneTransitionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RoutingLaneTransitionAttributeMapListHeader::ZserioArrayType_conditionType RoutingLaneTransitionAttributeMapListHeader::readConditionType(RoutingLaneTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadRangeAttributeMap.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadRangeAttributeMap::RoutingRoadRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::routingdata::attributes::RoutingRoadRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RoutingRoadRangeAttributeMap::RoutingRoadRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RoutingRoadRangeAttributeMap::RoutingRoadRangeAttributeMap(RoutingRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RoutingRoadRangeAttributeMap::RoutingRoadRangeAttributeMap(const RoutingRoadRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeMap& RoutingRoadRangeAttributeMap::operator=(const RoutingRoadRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeMap::RoutingRoadRangeAttributeMap(RoutingRoadRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeMap& RoutingRoadRangeAttributeMap::operator=(RoutingRoadRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeMap::RoutingRoadRangeAttributeMap(::zserio::PropagateAllocatorT,
        const RoutingRoadRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingRoadRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingRoadRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingRoadRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeType RoutingRoadRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RoutingRoadRangeAttributeMap::setAttributeTypeCode(::nds::routingdata::attributes::RoutingRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RoutingRoadRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void RoutingRoadRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& RoutingRoadRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& RoutingRoadRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RoutingRoadRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RoutingRoadRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RoutingRoadRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RoutingRoadRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RoutingRoadRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RoutingRoadRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RoutingRoadRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RoutingRoadRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RoutingRoadRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RoutingRoadRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RoutingRoadRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RoutingRoadRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttribute>& RoutingRoadRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttribute>& RoutingRoadRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RoutingRoadRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RoutingRoadRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& RoutingRoadRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& RoutingRoadRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RoutingRoadRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RoutingRoadRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RoutingRoadRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RoutingRoadRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RoutingRoadRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RoutingRoadRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RoutingRoadRangeAttributeMap::initPackingContext(RoutingRoadRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RoutingRoadRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeMap::bitSizeOf(RoutingRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadRangeAttributeMap::initializeOffsets(RoutingRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadRangeAttributeMap::operator==(const RoutingRoadRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RoutingRoadRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RoutingRoadRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeMap::write(RoutingRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(RoutingRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(RoutingRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingRoadRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RoutingRoadRangeAttributeMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(RoutingRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(RoutingRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingRoadRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RoutingRoadRangeAttributeMap& owner,
        ::nds::routingdata::instantiations::RoutingRoadRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(owner.getAttributeTypeCode()));
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(RoutingRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(RoutingRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttribute>& array,
        ::nds::routingdata::instantiations::RoutingRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RoutingRoadRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RoutingRoadRangeAttributeMap&,
        ::nds::routingdata::instantiations::RoutingPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RoutingRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RoutingRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& array,
        ::nds::routingdata::instantiations::RoutingPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingRoadRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RoutingRoadRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RoutingRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RoutingRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeType RoutingRoadRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(in);
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeType RoutingRoadRangeAttributeMap::readAttributeTypeCode(RoutingRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RoutingRoadRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RoutingRoadRangeAttributeMap::readFeature(RoutingRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadRangeAttributeMap::ZserioArrayType_featureReferences RoutingRoadRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingRoadRangeAttributeMap::ZserioArrayType_featureReferences RoutingRoadRangeAttributeMap::readFeatureReferences(RoutingRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingRoadRangeAttributeMap::ZserioArrayType_featureValidities RoutingRoadRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingRoadRangeAttributeMap::ZserioArrayType_featureValidities RoutingRoadRangeAttributeMap::readFeatureValidities(RoutingRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingRoadRangeAttributeMap::ZserioArrayType_featureValuePtr RoutingRoadRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingRoadRangeAttributeMap::ZserioArrayType_featureValuePtr RoutingRoadRangeAttributeMap::readFeatureValuePtr(RoutingRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RoutingRoadRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RoutingRoadRangeAttributeMap::readAttribute(RoutingRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadRangeAttributeMap::ZserioArrayType_attributeValues RoutingRoadRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingRoadRangeAttributeMap::ZserioArrayType_attributeValues RoutingRoadRangeAttributeMap::readAttributeValues(RoutingRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RoutingRoadRangeAttributeMap::ZserioArrayType_attributeProperties RoutingRoadRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingRoadRangeAttributeMap::ZserioArrayType_attributeProperties RoutingRoadRangeAttributeMap::readAttributeProperties(RoutingRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RoutingRoadRangeAttributeMap::ZserioArrayType_attributeConditions RoutingRoadRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingRoadRangeAttributeMap::ZserioArrayType_attributeConditions RoutingRoadRangeAttributeMap::readAttributeConditions(RoutingRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadTransitionAttributeMap.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadTransitionAttributeMap::RoutingRoadTransitionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::routingdata::attributes::RoutingRoadTransitionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RoutingRoadTransitionAttributeMap::RoutingRoadTransitionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RoutingRoadTransitionAttributeMap::RoutingRoadTransitionAttributeMap(RoutingRoadTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RoutingRoadTransitionAttributeMap::RoutingRoadTransitionAttributeMap(const RoutingRoadTransitionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeMap& RoutingRoadTransitionAttributeMap::operator=(const RoutingRoadTransitionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeMap::RoutingRoadTransitionAttributeMap(RoutingRoadTransitionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeMap& RoutingRoadTransitionAttributeMap::operator=(RoutingRoadTransitionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeMap::RoutingRoadTransitionAttributeMap(::zserio::PropagateAllocatorT,
        const RoutingRoadTransitionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingRoadTransitionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadTransitionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadTransitionAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingRoadTransitionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingRoadTransitionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeType RoutingRoadTransitionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RoutingRoadTransitionAttributeMap::setAttributeTypeCode(::nds::routingdata::attributes::RoutingRoadTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RoutingRoadTransitionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RoutingRoadTransitionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::TransitionReference>& RoutingRoadTransitionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::TransitionReference>& RoutingRoadTransitionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RoutingRoadTransitionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::TransitionReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RoutingRoadTransitionAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::TransitionReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RoutingRoadTransitionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RoutingRoadTransitionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RoutingRoadTransitionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RoutingRoadTransitionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RoutingRoadTransitionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RoutingRoadTransitionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RoutingRoadTransitionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RoutingRoadTransitionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RoutingRoadTransitionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RoutingRoadTransitionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttribute>& RoutingRoadTransitionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttribute>& RoutingRoadTransitionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RoutingRoadTransitionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RoutingRoadTransitionAttributeMap::setAttributeValues(::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& RoutingRoadTransitionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& RoutingRoadTransitionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RoutingRoadTransitionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RoutingRoadTransitionAttributeMap::setAttributeProperties(::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RoutingRoadTransitionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RoutingRoadTransitionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RoutingRoadTransitionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RoutingRoadTransitionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RoutingRoadTransitionAttributeMap::initPackingContext(RoutingRoadTransitionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RoutingRoadTransitionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeMap::bitSizeOf(RoutingRoadTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadTransitionAttributeMap::initializeOffsets(RoutingRoadTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadTransitionAttributeMap::operator==(const RoutingRoadTransitionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RoutingRoadTransitionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RoutingRoadTransitionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeMap::write(RoutingRoadTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(RoutingRoadTransitionAttributeMap&,
        ::nds::road::reference::types::TransitionReference& element, size_t)
{
    element.initializeChildren();
}

void RoutingRoadTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RoutingRoadTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RoutingRoadTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::nds::road::reference::types::TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingRoadTransitionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RoutingRoadTransitionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingRoadTransitionAttributeMap::ZserioElementFactory_featureValidities::create(RoutingRoadTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingRoadTransitionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RoutingRoadTransitionAttributeMap& owner,
        ::nds::routingdata::instantiations::RoutingRoadTransitionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(owner.getAttributeTypeCode()));
}

void RoutingRoadTransitionAttributeMap::ZserioElementFactory_attributeValues::create(RoutingRoadTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RoutingRoadTransitionAttributeMap::ZserioElementFactory_attributeValues::create(RoutingRoadTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttribute>& array,
        ::nds::routingdata::instantiations::RoutingRoadTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RoutingRoadTransitionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RoutingRoadTransitionAttributeMap&,
        ::nds::routingdata::instantiations::RoutingPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RoutingRoadTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RoutingRoadTransitionAttributeMap&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RoutingRoadTransitionAttributeMap&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& array,
        ::nds::routingdata::instantiations::RoutingPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingRoadTransitionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RoutingRoadTransitionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RoutingRoadTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RoutingRoadTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RoutingRoadTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeType RoutingRoadTransitionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(in);
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeType RoutingRoadTransitionAttributeMap::readAttributeTypeCode(RoutingRoadTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RoutingRoadTransitionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RoutingRoadTransitionAttributeMap::readFeature(RoutingRoadTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadTransitionAttributeMap::ZserioArrayType_featureReferences RoutingRoadTransitionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingRoadTransitionAttributeMap::ZserioArrayType_featureReferences RoutingRoadTransitionAttributeMap::readFeatureReferences(RoutingRoadTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingRoadTransitionAttributeMap::ZserioArrayType_featureValidities RoutingRoadTransitionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingRoadTransitionAttributeMap::ZserioArrayType_featureValuePtr RoutingRoadTransitionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingRoadTransitionAttributeMap::ZserioArrayType_featureValuePtr RoutingRoadTransitionAttributeMap::readFeatureValuePtr(RoutingRoadTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RoutingRoadTransitionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RoutingRoadTransitionAttributeMap::readAttribute(RoutingRoadTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadTransitionAttributeMap::ZserioArrayType_attributeValues RoutingRoadTransitionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingRoadTransitionAttributeMap::ZserioArrayType_attributeValues RoutingRoadTransitionAttributeMap::readAttributeValues(RoutingRoadTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RoutingRoadTransitionAttributeMap::ZserioArrayType_attributeProperties RoutingRoadTransitionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingRoadTransitionAttributeMap::ZserioArrayType_attributeProperties RoutingRoadTransitionAttributeMap::readAttributeProperties(RoutingRoadTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RoutingRoadTransitionAttributeMap::ZserioArrayType_attributeConditions RoutingRoadTransitionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingRoadTransitionAttributeMap::ZserioArrayType_attributeConditions RoutingRoadTransitionAttributeMap::readAttributeConditions(RoutingRoadTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneRangeAttributeMap.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneRangeAttributeMap::RoutingLaneRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::routingdata::attributes::RoutingLaneRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RoutingLaneRangeAttributeMap::RoutingLaneRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RoutingLaneRangeAttributeMap::RoutingLaneRangeAttributeMap(RoutingLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RoutingLaneRangeAttributeMap::RoutingLaneRangeAttributeMap(const RoutingLaneRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeMap& RoutingLaneRangeAttributeMap::operator=(const RoutingLaneRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeMap::RoutingLaneRangeAttributeMap(RoutingLaneRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeMap& RoutingLaneRangeAttributeMap::operator=(RoutingLaneRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeMap::RoutingLaneRangeAttributeMap(::zserio::PropagateAllocatorT,
        const RoutingLaneRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingLaneRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingLaneRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingLaneRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeType RoutingLaneRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RoutingLaneRangeAttributeMap::setAttributeTypeCode(::nds::routingdata::attributes::RoutingLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RoutingLaneRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void RoutingLaneRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RoutingLaneRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RoutingLaneRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RoutingLaneRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RoutingLaneRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RoutingLaneRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RoutingLaneRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RoutingLaneRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RoutingLaneRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RoutingLaneRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RoutingLaneRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RoutingLaneRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RoutingLaneRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RoutingLaneRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RoutingLaneRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttribute>& RoutingLaneRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttribute>& RoutingLaneRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RoutingLaneRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RoutingLaneRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& RoutingLaneRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& RoutingLaneRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RoutingLaneRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RoutingLaneRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RoutingLaneRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RoutingLaneRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RoutingLaneRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RoutingLaneRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RoutingLaneRangeAttributeMap::initPackingContext(RoutingLaneRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RoutingLaneRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeMap::bitSizeOf(RoutingLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneRangeAttributeMap::initializeOffsets(RoutingLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneRangeAttributeMap::operator==(const RoutingLaneRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RoutingLaneRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RoutingLaneRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeMap::write(RoutingLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(RoutingLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(RoutingLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingLaneRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RoutingLaneRangeAttributeMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(RoutingLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(RoutingLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingLaneRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RoutingLaneRangeAttributeMap& owner,
        ::nds::routingdata::instantiations::RoutingLaneRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(owner.getAttributeTypeCode()));
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(RoutingLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(RoutingLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttribute>& array,
        ::nds::routingdata::instantiations::RoutingLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RoutingLaneRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RoutingLaneRangeAttributeMap&,
        ::nds::routingdata::instantiations::RoutingPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RoutingLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RoutingLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& array,
        ::nds::routingdata::instantiations::RoutingPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingLaneRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RoutingLaneRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RoutingLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RoutingLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeType RoutingLaneRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(in);
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeType RoutingLaneRangeAttributeMap::readAttributeTypeCode(RoutingLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RoutingLaneRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RoutingLaneRangeAttributeMap::readFeature(RoutingLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneRangeAttributeMap::ZserioArrayType_featureReferences RoutingLaneRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingLaneRangeAttributeMap::ZserioArrayType_featureReferences RoutingLaneRangeAttributeMap::readFeatureReferences(RoutingLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingLaneRangeAttributeMap::ZserioArrayType_featureValidities RoutingLaneRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingLaneRangeAttributeMap::ZserioArrayType_featureValidities RoutingLaneRangeAttributeMap::readFeatureValidities(RoutingLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingLaneRangeAttributeMap::ZserioArrayType_featureValuePtr RoutingLaneRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingLaneRangeAttributeMap::ZserioArrayType_featureValuePtr RoutingLaneRangeAttributeMap::readFeatureValuePtr(RoutingLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RoutingLaneRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RoutingLaneRangeAttributeMap::readAttribute(RoutingLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneRangeAttributeMap::ZserioArrayType_attributeValues RoutingLaneRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingLaneRangeAttributeMap::ZserioArrayType_attributeValues RoutingLaneRangeAttributeMap::readAttributeValues(RoutingLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RoutingLaneRangeAttributeMap::ZserioArrayType_attributeProperties RoutingLaneRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingLaneRangeAttributeMap::ZserioArrayType_attributeProperties RoutingLaneRangeAttributeMap::readAttributeProperties(RoutingLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RoutingLaneRangeAttributeMap::ZserioArrayType_attributeConditions RoutingLaneRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingLaneRangeAttributeMap::ZserioArrayType_attributeConditions RoutingLaneRangeAttributeMap::readAttributeConditions(RoutingLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneTransitionAttributeMap.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneTransitionAttributeMap::RoutingLaneTransitionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::routingdata::attributes::RoutingLaneTransitionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RoutingLaneTransitionAttributeMap::RoutingLaneTransitionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RoutingLaneTransitionAttributeMap::RoutingLaneTransitionAttributeMap(RoutingLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RoutingLaneTransitionAttributeMap::RoutingLaneTransitionAttributeMap(const RoutingLaneTransitionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeMap& RoutingLaneTransitionAttributeMap::operator=(const RoutingLaneTransitionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeMap::RoutingLaneTransitionAttributeMap(RoutingLaneTransitionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeMap& RoutingLaneTransitionAttributeMap::operator=(RoutingLaneTransitionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeMap::RoutingLaneTransitionAttributeMap(::zserio::PropagateAllocatorT,
        const RoutingLaneTransitionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingLaneTransitionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneTransitionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneTransitionAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingLaneTransitionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingLaneTransitionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeType RoutingLaneTransitionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RoutingLaneTransitionAttributeMap::setAttributeTypeCode(::nds::routingdata::attributes::RoutingLaneTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RoutingLaneTransitionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RoutingLaneTransitionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& RoutingLaneTransitionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& RoutingLaneTransitionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RoutingLaneTransitionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RoutingLaneTransitionAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RoutingLaneTransitionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RoutingLaneTransitionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RoutingLaneTransitionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RoutingLaneTransitionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RoutingLaneTransitionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RoutingLaneTransitionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RoutingLaneTransitionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RoutingLaneTransitionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RoutingLaneTransitionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RoutingLaneTransitionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttribute>& RoutingLaneTransitionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttribute>& RoutingLaneTransitionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RoutingLaneTransitionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RoutingLaneTransitionAttributeMap::setAttributeValues(::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& RoutingLaneTransitionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& RoutingLaneTransitionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RoutingLaneTransitionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RoutingLaneTransitionAttributeMap::setAttributeProperties(::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RoutingLaneTransitionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RoutingLaneTransitionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RoutingLaneTransitionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RoutingLaneTransitionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RoutingLaneTransitionAttributeMap::initPackingContext(RoutingLaneTransitionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RoutingLaneTransitionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeMap::bitSizeOf(RoutingLaneTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneTransitionAttributeMap::initializeOffsets(RoutingLaneTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneTransitionAttributeMap::operator==(const RoutingLaneTransitionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RoutingLaneTransitionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RoutingLaneTransitionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeMap::write(RoutingLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RoutingLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RoutingLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& array,
        ::nds::lane::reference::types::LaneGroupTransition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingLaneTransitionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RoutingLaneTransitionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingLaneTransitionAttributeMap::ZserioElementFactory_featureValidities::create(RoutingLaneTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingLaneTransitionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RoutingLaneTransitionAttributeMap& owner,
        ::nds::routingdata::instantiations::RoutingLaneTransitionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(owner.getAttributeTypeCode()));
}

void RoutingLaneTransitionAttributeMap::ZserioElementFactory_attributeValues::create(RoutingLaneTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RoutingLaneTransitionAttributeMap::ZserioElementFactory_attributeValues::create(RoutingLaneTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttribute>& array,
        ::nds::routingdata::instantiations::RoutingLaneTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RoutingLaneTransitionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RoutingLaneTransitionAttributeMap&,
        ::nds::routingdata::instantiations::RoutingPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RoutingLaneTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RoutingLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RoutingLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingPropertyList>& array,
        ::nds::routingdata::instantiations::RoutingPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingLaneTransitionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RoutingLaneTransitionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RoutingLaneTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RoutingLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RoutingLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeType RoutingLaneTransitionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(in);
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeType RoutingLaneTransitionAttributeMap::readAttributeTypeCode(RoutingLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RoutingLaneTransitionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RoutingLaneTransitionAttributeMap::readFeature(RoutingLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneTransitionAttributeMap::ZserioArrayType_featureReferences RoutingLaneTransitionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingLaneTransitionAttributeMap::ZserioArrayType_featureReferences RoutingLaneTransitionAttributeMap::readFeatureReferences(RoutingLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingLaneTransitionAttributeMap::ZserioArrayType_featureValidities RoutingLaneTransitionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingLaneTransitionAttributeMap::ZserioArrayType_featureValuePtr RoutingLaneTransitionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingLaneTransitionAttributeMap::ZserioArrayType_featureValuePtr RoutingLaneTransitionAttributeMap::readFeatureValuePtr(RoutingLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RoutingLaneTransitionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RoutingLaneTransitionAttributeMap::readAttribute(RoutingLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneTransitionAttributeMap::ZserioArrayType_attributeValues RoutingLaneTransitionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingLaneTransitionAttributeMap::ZserioArrayType_attributeValues RoutingLaneTransitionAttributeMap::readAttributeValues(RoutingLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RoutingLaneTransitionAttributeMap::ZserioArrayType_attributeProperties RoutingLaneTransitionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingLaneTransitionAttributeMap::ZserioArrayType_attributeProperties RoutingLaneTransitionAttributeMap::readAttributeProperties(RoutingLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RoutingLaneTransitionAttributeMap::ZserioArrayType_attributeConditions RoutingLaneTransitionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RoutingLaneTransitionAttributeMap::ZserioArrayType_attributeConditions RoutingLaneTransitionAttributeMap::readAttributeConditions(RoutingLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadRangeAttribute.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadRangeAttribute::RoutingRoadRangeAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RoutingRoadRangeAttribute::RoutingRoadRangeAttribute(::zserio::BitStreamReader& in,
        ::nds::routingdata::attributes::RoutingRoadRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RoutingRoadRangeAttribute::RoutingRoadRangeAttribute(RoutingRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::routingdata::attributes::RoutingRoadRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RoutingRoadRangeAttribute::RoutingRoadRangeAttribute(const RoutingRoadRangeAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttribute& RoutingRoadRangeAttribute::operator=(const RoutingRoadRangeAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttribute::RoutingRoadRangeAttribute(RoutingRoadRangeAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttribute& RoutingRoadRangeAttribute::operator=(RoutingRoadRangeAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttribute::RoutingRoadRangeAttribute(::zserio::PropagateAllocatorT,
        const RoutingRoadRangeAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RoutingRoadRangeAttribute::initialize(
        ::nds::routingdata::attributes::RoutingRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadRangeAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadRangeAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()));
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeType RoutingRoadRangeAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RoutingRoadRangeAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeValue& RoutingRoadRangeAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::routingdata::attributes::RoutingRoadRangeAttributeValue& RoutingRoadRangeAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RoutingRoadRangeAttribute::setAttributeValue(const ::nds::routingdata::attributes::RoutingRoadRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RoutingRoadRangeAttribute::setAttributeValue(::nds::routingdata::attributes::RoutingRoadRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RoutingRoadRangeAttribute::initPackingContext(RoutingRoadRangeAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RoutingRoadRangeAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttribute::bitSizeOf(RoutingRoadRangeAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadRangeAttribute::initializeOffsets(RoutingRoadRangeAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RoutingRoadRangeAttribute::operator==(const RoutingRoadRangeAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RoutingRoadRangeAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RoutingRoadRangeAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRoadRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RoutingRoadRangeAttribute::write(RoutingRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRoadRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeValue RoutingRoadRangeAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingRoadRangeAttributeValue(in, static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeValue RoutingRoadRangeAttribute::readAttributeValue(RoutingRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingRoadRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadTransitionAttribute.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadTransitionAttribute::RoutingRoadTransitionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RoutingRoadTransitionAttribute::RoutingRoadTransitionAttribute(::zserio::BitStreamReader& in,
        ::nds::routingdata::attributes::RoutingRoadTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RoutingRoadTransitionAttribute::RoutingRoadTransitionAttribute(RoutingRoadTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::routingdata::attributes::RoutingRoadTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RoutingRoadTransitionAttribute::RoutingRoadTransitionAttribute(const RoutingRoadTransitionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttribute& RoutingRoadTransitionAttribute::operator=(const RoutingRoadTransitionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttribute::RoutingRoadTransitionAttribute(RoutingRoadTransitionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttribute& RoutingRoadTransitionAttribute::operator=(RoutingRoadTransitionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttribute::RoutingRoadTransitionAttribute(::zserio::PropagateAllocatorT,
        const RoutingRoadTransitionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RoutingRoadTransitionAttribute::initialize(
        ::nds::routingdata::attributes::RoutingRoadTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadTransitionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadTransitionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()));
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeType RoutingRoadTransitionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RoutingRoadTransitionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue& RoutingRoadTransitionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue& RoutingRoadTransitionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RoutingRoadTransitionAttribute::setAttributeValue(const ::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RoutingRoadTransitionAttribute::setAttributeValue(::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RoutingRoadTransitionAttribute::initPackingContext(RoutingRoadTransitionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RoutingRoadTransitionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttribute::bitSizeOf(RoutingRoadTransitionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadTransitionAttribute::initializeOffsets(RoutingRoadTransitionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RoutingRoadTransitionAttribute::operator==(const RoutingRoadTransitionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RoutingRoadTransitionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RoutingRoadTransitionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRoadTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RoutingRoadTransitionAttribute::write(RoutingRoadTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRoadTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue RoutingRoadTransitionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue(in, static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue RoutingRoadTransitionAttribute::readAttributeValue(RoutingRoadTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneRangeAttribute.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneRangeAttribute::RoutingLaneRangeAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RoutingLaneRangeAttribute::RoutingLaneRangeAttribute(::zserio::BitStreamReader& in,
        ::nds::routingdata::attributes::RoutingLaneRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RoutingLaneRangeAttribute::RoutingLaneRangeAttribute(RoutingLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::routingdata::attributes::RoutingLaneRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RoutingLaneRangeAttribute::RoutingLaneRangeAttribute(const RoutingLaneRangeAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttribute& RoutingLaneRangeAttribute::operator=(const RoutingLaneRangeAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttribute::RoutingLaneRangeAttribute(RoutingLaneRangeAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttribute& RoutingLaneRangeAttribute::operator=(RoutingLaneRangeAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttribute::RoutingLaneRangeAttribute(::zserio::PropagateAllocatorT,
        const RoutingLaneRangeAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RoutingLaneRangeAttribute::initialize(
        ::nds::routingdata::attributes::RoutingLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneRangeAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneRangeAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()));
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeType RoutingLaneRangeAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RoutingLaneRangeAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeValue& RoutingLaneRangeAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::routingdata::attributes::RoutingLaneRangeAttributeValue& RoutingLaneRangeAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RoutingLaneRangeAttribute::setAttributeValue(const ::nds::routingdata::attributes::RoutingLaneRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RoutingLaneRangeAttribute::setAttributeValue(::nds::routingdata::attributes::RoutingLaneRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RoutingLaneRangeAttribute::initPackingContext(RoutingLaneRangeAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RoutingLaneRangeAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttribute::bitSizeOf(RoutingLaneRangeAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneRangeAttribute::initializeOffsets(RoutingLaneRangeAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RoutingLaneRangeAttribute::operator==(const RoutingLaneRangeAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RoutingLaneRangeAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RoutingLaneRangeAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingLaneRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RoutingLaneRangeAttribute::write(RoutingLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingLaneRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeValue RoutingLaneRangeAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingLaneRangeAttributeValue(in, static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeValue RoutingLaneRangeAttribute::readAttributeValue(RoutingLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingLaneRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneTransitionAttribute.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneTransitionAttribute::RoutingLaneTransitionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RoutingLaneTransitionAttribute::RoutingLaneTransitionAttribute(::zserio::BitStreamReader& in,
        ::nds::routingdata::attributes::RoutingLaneTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RoutingLaneTransitionAttribute::RoutingLaneTransitionAttribute(RoutingLaneTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::routingdata::attributes::RoutingLaneTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RoutingLaneTransitionAttribute::RoutingLaneTransitionAttribute(const RoutingLaneTransitionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttribute& RoutingLaneTransitionAttribute::operator=(const RoutingLaneTransitionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttribute::RoutingLaneTransitionAttribute(RoutingLaneTransitionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttribute& RoutingLaneTransitionAttribute::operator=(RoutingLaneTransitionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttribute::RoutingLaneTransitionAttribute(::zserio::PropagateAllocatorT,
        const RoutingLaneTransitionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RoutingLaneTransitionAttribute::initialize(
        ::nds::routingdata::attributes::RoutingLaneTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneTransitionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneTransitionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()));
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeType RoutingLaneTransitionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RoutingLaneTransitionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue& RoutingLaneTransitionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue& RoutingLaneTransitionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RoutingLaneTransitionAttribute::setAttributeValue(const ::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RoutingLaneTransitionAttribute::setAttributeValue(::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RoutingLaneTransitionAttribute::initPackingContext(RoutingLaneTransitionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RoutingLaneTransitionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttribute::bitSizeOf(RoutingLaneTransitionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneTransitionAttribute::initializeOffsets(RoutingLaneTransitionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RoutingLaneTransitionAttribute::operator==(const RoutingLaneTransitionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RoutingLaneTransitionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RoutingLaneTransitionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingLaneTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RoutingLaneTransitionAttribute::write(RoutingLaneTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingLaneTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue RoutingLaneTransitionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue(in, static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue RoutingLaneTransitionAttribute::readAttributeValue(RoutingLaneTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingProperty.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingProperty::RoutingProperty(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_propertyTypeCode_(allocator),
        m_propertyValue_(allocator)
{
}

RoutingProperty::RoutingProperty(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(in, allocator)),
        m_propertyValue_(readPropertyValue(in, allocator))
{
}

RoutingProperty::RoutingProperty(RoutingProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(context, in, allocator)),
        m_propertyValue_(readPropertyValue(context, in, allocator))
{
}

RoutingProperty::RoutingProperty(const RoutingProperty& other) :
        m_propertyTypeCode_(other.m_propertyTypeCode_),
        m_propertyValue_(other.m_propertyValue_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingProperty& RoutingProperty::operator=(const RoutingProperty& other)
{
    m_propertyTypeCode_ = other.m_propertyTypeCode_;
    m_propertyValue_ = other.m_propertyValue_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingProperty::RoutingProperty(RoutingProperty&& other) :
        m_propertyTypeCode_(::std::move(other.m_propertyTypeCode_)),
        m_propertyValue_(::std::move(other.m_propertyValue_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingProperty& RoutingProperty::operator=(RoutingProperty&& other)
{
    m_propertyTypeCode_ = ::std::move(other.m_propertyTypeCode_);
    m_propertyValue_ = ::std::move(other.m_propertyValue_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingProperty::RoutingProperty(::zserio::PropagateAllocatorT,
        const RoutingProperty& other, const allocator_type& allocator) :
        m_propertyTypeCode_(::zserio::allocatorPropagatingCopy(other.m_propertyTypeCode_, allocator)),
        m_propertyValue_(::zserio::allocatorPropagatingCopy(other.m_propertyValue_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoutingProperty::initializeChildren()
{
    m_propertyValue_.initialize(getPropertyTypeCode());

    m_areChildrenInitialized = true;
}

::nds::routingdata::properties::RoutingPropertyType& RoutingProperty::getPropertyTypeCode()
{
    return m_propertyTypeCode_;
}

const ::nds::routingdata::properties::RoutingPropertyType& RoutingProperty::getPropertyTypeCode() const
{
    return m_propertyTypeCode_;
}

void RoutingProperty::setPropertyTypeCode(const ::nds::routingdata::properties::RoutingPropertyType& propertyTypeCode_)
{
    m_propertyTypeCode_ = propertyTypeCode_;
}

void RoutingProperty::setPropertyTypeCode(::nds::routingdata::properties::RoutingPropertyType&& propertyTypeCode_)
{
    m_propertyTypeCode_ = ::std::move(propertyTypeCode_);
}

::nds::routingdata::properties::RoutingPropertyValue& RoutingProperty::getPropertyValue()
{
    return m_propertyValue_;
}

const ::nds::routingdata::properties::RoutingPropertyValue& RoutingProperty::getPropertyValue() const
{
    return m_propertyValue_;
}

void RoutingProperty::setPropertyValue(const ::nds::routingdata::properties::RoutingPropertyValue& propertyValue_)
{
    m_propertyValue_ = propertyValue_;
}

void RoutingProperty::setPropertyValue(::nds::routingdata::properties::RoutingPropertyValue&& propertyValue_)
{
    m_propertyValue_ = ::std::move(propertyValue_);
}

void RoutingProperty::initPackingContext(RoutingProperty::ZserioPackingContext& context) const
{
    m_propertyTypeCode_.initPackingContext(context.getPropertyTypeCode());
    m_propertyValue_.initPackingContext(context.getPropertyValue());
}

size_t RoutingProperty::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingProperty::bitSizeOf(RoutingProperty::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(context.getPropertyValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingProperty::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingProperty::initializeOffsets(RoutingProperty::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(context.getPropertyValue(), endBitPosition);

    return endBitPosition;
}

bool RoutingProperty::operator==(const RoutingProperty& other) const
{
    if (this != &other)
    {
        return
                (m_propertyTypeCode_ == other.m_propertyTypeCode_) &&
                (m_propertyValue_ == other.m_propertyValue_);
    }

    return true;
}

uint32_t RoutingProperty::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_propertyTypeCode_);
    result = ::zserio::calcHashCode(result, m_propertyValue_);

    return result;
}

void RoutingProperty::write(::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field RoutingProperty.propertyValue!");
    }
    m_propertyValue_.write(out);
}

void RoutingProperty::write(RoutingProperty::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(context.getPropertyTypeCode(), out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field RoutingProperty.propertyValue!");
    }
    m_propertyValue_.write(context.getPropertyValue(), out);
}

::nds::routingdata::properties::RoutingPropertyType RoutingProperty::readPropertyTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::properties::RoutingPropertyType(in, allocator);
}

::nds::routingdata::properties::RoutingPropertyType RoutingProperty::readPropertyTypeCode(RoutingProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::properties::RoutingPropertyType(context.getPropertyTypeCode(), in, allocator);
}
::nds::routingdata::properties::RoutingPropertyValue RoutingProperty::readPropertyValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::properties::RoutingPropertyValue(in, getPropertyTypeCode(), allocator);
}

::nds::routingdata::properties::RoutingPropertyValue RoutingProperty::readPropertyValue(RoutingProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::properties::RoutingPropertyValue(context.getPropertyValue(), in, getPropertyTypeCode(), allocator);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingPropertyList.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingPropertyList::RoutingPropertyList(const allocator_type&) noexcept :
        m_numProperties_(uint8_t()),
        m_property_(::zserio::NullOpt)
{
}

RoutingPropertyList::RoutingPropertyList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(in)),
        m_property_(readProperty(in, allocator))
{
}

RoutingPropertyList::RoutingPropertyList(RoutingPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(context, in)),
        m_property_(readProperty(context, in, allocator))
{
}

RoutingPropertyList::RoutingPropertyList(::zserio::PropagateAllocatorT,
        const RoutingPropertyList& other, const allocator_type& allocator) :
        m_numProperties_(::zserio::allocatorPropagatingCopy(other.m_numProperties_, allocator)),
        m_property_(::zserio::allocatorPropagatingCopy(other.m_property_, allocator))
{
}

void RoutingPropertyList::initializeChildren()
{
    if (getNumProperties() > 0)
        m_property_.value().initializeElements(*this);
}

uint8_t RoutingPropertyList::getNumProperties() const
{
    return m_numProperties_;
}

void RoutingPropertyList::setNumProperties(uint8_t numProperties_)
{
    m_numProperties_ = numProperties_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingProperty>& RoutingPropertyList::getProperty()
{
    return m_property_.value().getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingProperty>& RoutingPropertyList::getProperty() const
{
    return m_property_.value().getRawArray();
}

void RoutingPropertyList::setProperty(const ::zserio::vector<::nds::routingdata::instantiations::RoutingProperty>& property_)
{
    m_property_ = ZserioArrayType_property(property_);
}

void RoutingPropertyList::setProperty(::zserio::vector<::nds::routingdata::instantiations::RoutingProperty>&& property_)
{
    m_property_ = ZserioArrayType_property(std::move(property_));
}

bool RoutingPropertyList::isPropertyUsed() const
{
    return (getNumProperties() > 0);
}

bool RoutingPropertyList::isPropertySet() const
{
    return m_property_.hasValue();
}

void RoutingPropertyList::resetProperty()
{
    m_property_.reset();
}

void RoutingPropertyList::initPackingContext(RoutingPropertyList::ZserioPackingContext& context) const
{
    context.getNumProperties().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
}

size_t RoutingPropertyList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingPropertyList::bitSizeOf(RoutingPropertyList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingPropertyList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t RoutingPropertyList::initializeOffsets(RoutingPropertyList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool RoutingPropertyList::operator==(const RoutingPropertyList& other) const
{
    if (this != &other)
    {
        return
                (m_numProperties_ == other.m_numProperties_) &&
                (!isPropertyUsed() ? !other.isPropertyUsed() : (m_property_ == other.m_property_));
    }

    return true;
}

uint32_t RoutingPropertyList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numProperties_);
    if (isPropertyUsed())
        result = ::zserio::calcHashCode(result, m_property_);

    return result;
}

void RoutingPropertyList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numProperties_, UINT8_C(8));

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void RoutingPropertyList::write(RoutingPropertyList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumProperties().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numProperties_);

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void RoutingPropertyList::ZserioArrayExpressions_property::initializeElement(RoutingPropertyList&,
        ::nds::routingdata::instantiations::RoutingProperty& element, size_t)
{
    element.initializeChildren();
}

void RoutingPropertyList::ZserioElementFactory_property::create(RoutingPropertyList&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingProperty>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingPropertyList::ZserioElementFactory_property::create(RoutingPropertyList&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingProperty>& array,
        ::nds::routingdata::instantiations::RoutingProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t RoutingPropertyList::readNumProperties(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t RoutingPropertyList::readNumProperties(RoutingPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumProperties().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::zserio::InplaceOptionalHolder<RoutingPropertyList::ZserioArrayType_property> RoutingPropertyList::readProperty(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoutingPropertyList::ZserioArrayType_property> RoutingPropertyList::readProperty(RoutingPropertyList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadRangeAttributeSet.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadRangeAttributeSet::RoutingRoadRangeAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RoutingRoadRangeAttributeSet::RoutingRoadRangeAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RoutingRoadRangeAttributeSet::RoutingRoadRangeAttributeSet(RoutingRoadRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RoutingRoadRangeAttributeSet::RoutingRoadRangeAttributeSet(::zserio::PropagateAllocatorT,
        const RoutingRoadRangeAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RoutingRoadRangeAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RoutingRoadRangeAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RoutingRoadRangeAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeFullAttribute>& RoutingRoadRangeAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeFullAttribute>& RoutingRoadRangeAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RoutingRoadRangeAttributeSet::setAttributes(const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RoutingRoadRangeAttributeSet::setAttributes(::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RoutingRoadRangeAttributeSet::initPackingContext(RoutingRoadRangeAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RoutingRoadRangeAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeSet::bitSizeOf(RoutingRoadRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadRangeAttributeSet::initializeOffsets(RoutingRoadRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadRangeAttributeSet::operator==(const RoutingRoadRangeAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RoutingRoadRangeAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RoutingRoadRangeAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeSet::write(RoutingRoadRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RoutingRoadRangeAttributeSet&,
        ::nds::routingdata::instantiations::RoutingRoadRangeFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RoutingRoadRangeAttributeSet::ZserioElementFactory_attributes::create(RoutingRoadRangeAttributeSet&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadRangeAttributeSet::ZserioElementFactory_attributes::create(RoutingRoadRangeAttributeSet&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeFullAttribute>& array,
        ::nds::routingdata::instantiations::RoutingRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RoutingRoadRangeAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingRoadRangeAttributeSet::readNumEntries(RoutingRoadRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadRangeAttributeSet::ZserioArrayType_attributes RoutingRoadRangeAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RoutingRoadRangeAttributeSet::ZserioArrayType_attributes RoutingRoadRangeAttributeSet::readAttributes(RoutingRoadRangeAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadTransitionAttributeSet.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadTransitionAttributeSet::RoutingRoadTransitionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RoutingRoadTransitionAttributeSet::RoutingRoadTransitionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RoutingRoadTransitionAttributeSet::RoutingRoadTransitionAttributeSet(RoutingRoadTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RoutingRoadTransitionAttributeSet::RoutingRoadTransitionAttributeSet(::zserio::PropagateAllocatorT,
        const RoutingRoadTransitionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RoutingRoadTransitionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RoutingRoadTransitionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RoutingRoadTransitionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionFullAttribute>& RoutingRoadTransitionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionFullAttribute>& RoutingRoadTransitionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RoutingRoadTransitionAttributeSet::setAttributes(const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RoutingRoadTransitionAttributeSet::setAttributes(::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RoutingRoadTransitionAttributeSet::initPackingContext(RoutingRoadTransitionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RoutingRoadTransitionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeSet::bitSizeOf(RoutingRoadTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadTransitionAttributeSet::initializeOffsets(RoutingRoadTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadTransitionAttributeSet::operator==(const RoutingRoadTransitionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RoutingRoadTransitionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RoutingRoadTransitionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeSet::write(RoutingRoadTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RoutingRoadTransitionAttributeSet&,
        ::nds::routingdata::instantiations::RoutingRoadTransitionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RoutingRoadTransitionAttributeSet::ZserioElementFactory_attributes::create(RoutingRoadTransitionAttributeSet&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadTransitionAttributeSet::ZserioElementFactory_attributes::create(RoutingRoadTransitionAttributeSet&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionFullAttribute>& array,
        ::nds::routingdata::instantiations::RoutingRoadTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RoutingRoadTransitionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingRoadTransitionAttributeSet::readNumEntries(RoutingRoadTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadTransitionAttributeSet::ZserioArrayType_attributes RoutingRoadTransitionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RoutingRoadTransitionAttributeSet::ZserioArrayType_attributes RoutingRoadTransitionAttributeSet::readAttributes(RoutingRoadTransitionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneRangeAttributeSet.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneRangeAttributeSet::RoutingLaneRangeAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RoutingLaneRangeAttributeSet::RoutingLaneRangeAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RoutingLaneRangeAttributeSet::RoutingLaneRangeAttributeSet(RoutingLaneRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RoutingLaneRangeAttributeSet::RoutingLaneRangeAttributeSet(::zserio::PropagateAllocatorT,
        const RoutingLaneRangeAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RoutingLaneRangeAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RoutingLaneRangeAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RoutingLaneRangeAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeFullAttribute>& RoutingLaneRangeAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeFullAttribute>& RoutingLaneRangeAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RoutingLaneRangeAttributeSet::setAttributes(const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RoutingLaneRangeAttributeSet::setAttributes(::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RoutingLaneRangeAttributeSet::initPackingContext(RoutingLaneRangeAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RoutingLaneRangeAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeSet::bitSizeOf(RoutingLaneRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneRangeAttributeSet::initializeOffsets(RoutingLaneRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneRangeAttributeSet::operator==(const RoutingLaneRangeAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RoutingLaneRangeAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RoutingLaneRangeAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeSet::write(RoutingLaneRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RoutingLaneRangeAttributeSet&,
        ::nds::routingdata::instantiations::RoutingLaneRangeFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RoutingLaneRangeAttributeSet::ZserioElementFactory_attributes::create(RoutingLaneRangeAttributeSet&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneRangeAttributeSet::ZserioElementFactory_attributes::create(RoutingLaneRangeAttributeSet&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeFullAttribute>& array,
        ::nds::routingdata::instantiations::RoutingLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RoutingLaneRangeAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingLaneRangeAttributeSet::readNumEntries(RoutingLaneRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneRangeAttributeSet::ZserioArrayType_attributes RoutingLaneRangeAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RoutingLaneRangeAttributeSet::ZserioArrayType_attributes RoutingLaneRangeAttributeSet::readAttributes(RoutingLaneRangeAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneTransitionAttributeSet.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneTransitionAttributeSet::RoutingLaneTransitionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RoutingLaneTransitionAttributeSet::RoutingLaneTransitionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RoutingLaneTransitionAttributeSet::RoutingLaneTransitionAttributeSet(RoutingLaneTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RoutingLaneTransitionAttributeSet::RoutingLaneTransitionAttributeSet(::zserio::PropagateAllocatorT,
        const RoutingLaneTransitionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RoutingLaneTransitionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RoutingLaneTransitionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RoutingLaneTransitionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionFullAttribute>& RoutingLaneTransitionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionFullAttribute>& RoutingLaneTransitionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RoutingLaneTransitionAttributeSet::setAttributes(const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RoutingLaneTransitionAttributeSet::setAttributes(::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RoutingLaneTransitionAttributeSet::initPackingContext(RoutingLaneTransitionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RoutingLaneTransitionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeSet::bitSizeOf(RoutingLaneTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneTransitionAttributeSet::initializeOffsets(RoutingLaneTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneTransitionAttributeSet::operator==(const RoutingLaneTransitionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RoutingLaneTransitionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RoutingLaneTransitionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeSet::write(RoutingLaneTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RoutingLaneTransitionAttributeSet&,
        ::nds::routingdata::instantiations::RoutingLaneTransitionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RoutingLaneTransitionAttributeSet::ZserioElementFactory_attributes::create(RoutingLaneTransitionAttributeSet&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneTransitionAttributeSet::ZserioElementFactory_attributes::create(RoutingLaneTransitionAttributeSet&        ,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionFullAttribute>& array,
        ::nds::routingdata::instantiations::RoutingLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RoutingLaneTransitionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingLaneTransitionAttributeSet::readNumEntries(RoutingLaneTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneTransitionAttributeSet::ZserioArrayType_attributes RoutingLaneTransitionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RoutingLaneTransitionAttributeSet::ZserioArrayType_attributes RoutingLaneTransitionAttributeSet::readAttributes(RoutingLaneTransitionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadRangeFullAttribute.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadRangeFullAttribute::RoutingRoadRangeFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::routingdata::attributes::RoutingRoadRangeAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RoutingRoadRangeFullAttribute::RoutingRoadRangeFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RoutingRoadRangeFullAttribute::RoutingRoadRangeFullAttribute(RoutingRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RoutingRoadRangeFullAttribute::RoutingRoadRangeFullAttribute(const RoutingRoadRangeFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingRoadRangeFullAttribute& RoutingRoadRangeFullAttribute::operator=(const RoutingRoadRangeFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingRoadRangeFullAttribute::RoutingRoadRangeFullAttribute(RoutingRoadRangeFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingRoadRangeFullAttribute& RoutingRoadRangeFullAttribute::operator=(RoutingRoadRangeFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingRoadRangeFullAttribute::RoutingRoadRangeFullAttribute(::zserio::PropagateAllocatorT,
        const RoutingRoadRangeFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoutingRoadRangeFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeType RoutingRoadRangeFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RoutingRoadRangeFullAttribute::setAttributeTypeCode(::nds::routingdata::attributes::RoutingRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeValue& RoutingRoadRangeFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::routingdata::attributes::RoutingRoadRangeAttributeValue& RoutingRoadRangeFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RoutingRoadRangeFullAttribute::setAttributeValue(const ::nds::routingdata::attributes::RoutingRoadRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RoutingRoadRangeFullAttribute::setAttributeValue(::nds::routingdata::attributes::RoutingRoadRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::routingdata::instantiations::RoutingPropertyList& RoutingRoadRangeFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::routingdata::instantiations::RoutingPropertyList& RoutingRoadRangeFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RoutingRoadRangeFullAttribute::setProperties(const ::nds::routingdata::instantiations::RoutingPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RoutingRoadRangeFullAttribute::setProperties(::nds::routingdata::instantiations::RoutingPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RoutingRoadRangeFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RoutingRoadRangeFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RoutingRoadRangeFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RoutingRoadRangeFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RoutingRoadRangeFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RoutingRoadRangeFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RoutingRoadRangeFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RoutingRoadRangeFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RoutingRoadRangeFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RoutingRoadRangeFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RoutingRoadRangeFullAttribute::initPackingContext(RoutingRoadRangeFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RoutingRoadRangeFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeFullAttribute::bitSizeOf(RoutingRoadRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RoutingRoadRangeFullAttribute::initializeOffsets(RoutingRoadRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RoutingRoadRangeFullAttribute::operator==(const RoutingRoadRangeFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RoutingRoadRangeFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RoutingRoadRangeFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRoadRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoutingRoadRangeFullAttribute::write(RoutingRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRoadRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeType RoutingRoadRangeFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(in);
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeType RoutingRoadRangeFullAttribute::readAttributeTypeCode(RoutingRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::routingdata::attributes::RoutingRoadRangeAttributeValue RoutingRoadRangeFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingRoadRangeAttributeValue(in, static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::routingdata::attributes::RoutingRoadRangeAttributeValue RoutingRoadRangeFullAttribute::readAttributeValue(RoutingRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingRoadRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::routingdata::attributes::RoutingRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList> RoutingRoadRangeFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::nds::routingdata::instantiations::RoutingPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList> RoutingRoadRangeFullAttribute::readProperties(RoutingRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::nds::routingdata::instantiations::RoutingPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RoutingRoadRangeFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RoutingRoadRangeFullAttribute::readConditions(RoutingRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadTransitionFullAttribute.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadTransitionFullAttribute::RoutingRoadTransitionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::routingdata::attributes::RoutingRoadTransitionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RoutingRoadTransitionFullAttribute::RoutingRoadTransitionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RoutingRoadTransitionFullAttribute::RoutingRoadTransitionFullAttribute(RoutingRoadTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RoutingRoadTransitionFullAttribute::RoutingRoadTransitionFullAttribute(const RoutingRoadTransitionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingRoadTransitionFullAttribute& RoutingRoadTransitionFullAttribute::operator=(const RoutingRoadTransitionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingRoadTransitionFullAttribute::RoutingRoadTransitionFullAttribute(RoutingRoadTransitionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingRoadTransitionFullAttribute& RoutingRoadTransitionFullAttribute::operator=(RoutingRoadTransitionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingRoadTransitionFullAttribute::RoutingRoadTransitionFullAttribute(::zserio::PropagateAllocatorT,
        const RoutingRoadTransitionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoutingRoadTransitionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeType RoutingRoadTransitionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RoutingRoadTransitionFullAttribute::setAttributeTypeCode(::nds::routingdata::attributes::RoutingRoadTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue& RoutingRoadTransitionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue& RoutingRoadTransitionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RoutingRoadTransitionFullAttribute::setAttributeValue(const ::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RoutingRoadTransitionFullAttribute::setAttributeValue(::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::routingdata::instantiations::RoutingPropertyList& RoutingRoadTransitionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::routingdata::instantiations::RoutingPropertyList& RoutingRoadTransitionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RoutingRoadTransitionFullAttribute::setProperties(const ::nds::routingdata::instantiations::RoutingPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RoutingRoadTransitionFullAttribute::setProperties(::nds::routingdata::instantiations::RoutingPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RoutingRoadTransitionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RoutingRoadTransitionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RoutingRoadTransitionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RoutingRoadTransitionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RoutingRoadTransitionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RoutingRoadTransitionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RoutingRoadTransitionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RoutingRoadTransitionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RoutingRoadTransitionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RoutingRoadTransitionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RoutingRoadTransitionFullAttribute::initPackingContext(RoutingRoadTransitionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RoutingRoadTransitionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionFullAttribute::bitSizeOf(RoutingRoadTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RoutingRoadTransitionFullAttribute::initializeOffsets(RoutingRoadTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RoutingRoadTransitionFullAttribute::operator==(const RoutingRoadTransitionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RoutingRoadTransitionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RoutingRoadTransitionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRoadTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoutingRoadTransitionFullAttribute::write(RoutingRoadTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRoadTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeType RoutingRoadTransitionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(in);
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeType RoutingRoadTransitionFullAttribute::readAttributeTypeCode(RoutingRoadTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue RoutingRoadTransitionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue(in, static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue RoutingRoadTransitionFullAttribute::readAttributeValue(RoutingRoadTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingRoadTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::routingdata::attributes::RoutingRoadTransitionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList> RoutingRoadTransitionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::nds::routingdata::instantiations::RoutingPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList> RoutingRoadTransitionFullAttribute::readProperties(RoutingRoadTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::nds::routingdata::instantiations::RoutingPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RoutingRoadTransitionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RoutingRoadTransitionFullAttribute::readConditions(RoutingRoadTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneRangeFullAttribute.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneRangeFullAttribute::RoutingLaneRangeFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::routingdata::attributes::RoutingLaneRangeAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RoutingLaneRangeFullAttribute::RoutingLaneRangeFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RoutingLaneRangeFullAttribute::RoutingLaneRangeFullAttribute(RoutingLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RoutingLaneRangeFullAttribute::RoutingLaneRangeFullAttribute(const RoutingLaneRangeFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingLaneRangeFullAttribute& RoutingLaneRangeFullAttribute::operator=(const RoutingLaneRangeFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingLaneRangeFullAttribute::RoutingLaneRangeFullAttribute(RoutingLaneRangeFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingLaneRangeFullAttribute& RoutingLaneRangeFullAttribute::operator=(RoutingLaneRangeFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingLaneRangeFullAttribute::RoutingLaneRangeFullAttribute(::zserio::PropagateAllocatorT,
        const RoutingLaneRangeFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoutingLaneRangeFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeType RoutingLaneRangeFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RoutingLaneRangeFullAttribute::setAttributeTypeCode(::nds::routingdata::attributes::RoutingLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeValue& RoutingLaneRangeFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::routingdata::attributes::RoutingLaneRangeAttributeValue& RoutingLaneRangeFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RoutingLaneRangeFullAttribute::setAttributeValue(const ::nds::routingdata::attributes::RoutingLaneRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RoutingLaneRangeFullAttribute::setAttributeValue(::nds::routingdata::attributes::RoutingLaneRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::routingdata::instantiations::RoutingPropertyList& RoutingLaneRangeFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::routingdata::instantiations::RoutingPropertyList& RoutingLaneRangeFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RoutingLaneRangeFullAttribute::setProperties(const ::nds::routingdata::instantiations::RoutingPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RoutingLaneRangeFullAttribute::setProperties(::nds::routingdata::instantiations::RoutingPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RoutingLaneRangeFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RoutingLaneRangeFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RoutingLaneRangeFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RoutingLaneRangeFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RoutingLaneRangeFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RoutingLaneRangeFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RoutingLaneRangeFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RoutingLaneRangeFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RoutingLaneRangeFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RoutingLaneRangeFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RoutingLaneRangeFullAttribute::initPackingContext(RoutingLaneRangeFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RoutingLaneRangeFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeFullAttribute::bitSizeOf(RoutingLaneRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RoutingLaneRangeFullAttribute::initializeOffsets(RoutingLaneRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RoutingLaneRangeFullAttribute::operator==(const RoutingLaneRangeFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RoutingLaneRangeFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RoutingLaneRangeFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingLaneRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoutingLaneRangeFullAttribute::write(RoutingLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingLaneRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeType RoutingLaneRangeFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(in);
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeType RoutingLaneRangeFullAttribute::readAttributeTypeCode(RoutingLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::routingdata::attributes::RoutingLaneRangeAttributeValue RoutingLaneRangeFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingLaneRangeAttributeValue(in, static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::routingdata::attributes::RoutingLaneRangeAttributeValue RoutingLaneRangeFullAttribute::readAttributeValue(RoutingLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingLaneRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::routingdata::attributes::RoutingLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList> RoutingLaneRangeFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::nds::routingdata::instantiations::RoutingPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList> RoutingLaneRangeFullAttribute::readProperties(RoutingLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::nds::routingdata::instantiations::RoutingPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RoutingLaneRangeFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RoutingLaneRangeFullAttribute::readConditions(RoutingLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneTransitionFullAttribute.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneTransitionFullAttribute::RoutingLaneTransitionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::routingdata::attributes::RoutingLaneTransitionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RoutingLaneTransitionFullAttribute::RoutingLaneTransitionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RoutingLaneTransitionFullAttribute::RoutingLaneTransitionFullAttribute(RoutingLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RoutingLaneTransitionFullAttribute::RoutingLaneTransitionFullAttribute(const RoutingLaneTransitionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingLaneTransitionFullAttribute& RoutingLaneTransitionFullAttribute::operator=(const RoutingLaneTransitionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingLaneTransitionFullAttribute::RoutingLaneTransitionFullAttribute(RoutingLaneTransitionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingLaneTransitionFullAttribute& RoutingLaneTransitionFullAttribute::operator=(RoutingLaneTransitionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingLaneTransitionFullAttribute::RoutingLaneTransitionFullAttribute(::zserio::PropagateAllocatorT,
        const RoutingLaneTransitionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoutingLaneTransitionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeType RoutingLaneTransitionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RoutingLaneTransitionFullAttribute::setAttributeTypeCode(::nds::routingdata::attributes::RoutingLaneTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue& RoutingLaneTransitionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue& RoutingLaneTransitionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RoutingLaneTransitionFullAttribute::setAttributeValue(const ::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RoutingLaneTransitionFullAttribute::setAttributeValue(::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::routingdata::instantiations::RoutingPropertyList& RoutingLaneTransitionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::routingdata::instantiations::RoutingPropertyList& RoutingLaneTransitionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RoutingLaneTransitionFullAttribute::setProperties(const ::nds::routingdata::instantiations::RoutingPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RoutingLaneTransitionFullAttribute::setProperties(::nds::routingdata::instantiations::RoutingPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RoutingLaneTransitionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RoutingLaneTransitionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RoutingLaneTransitionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RoutingLaneTransitionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RoutingLaneTransitionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RoutingLaneTransitionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RoutingLaneTransitionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RoutingLaneTransitionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RoutingLaneTransitionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RoutingLaneTransitionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RoutingLaneTransitionFullAttribute::initPackingContext(RoutingLaneTransitionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RoutingLaneTransitionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionFullAttribute::bitSizeOf(RoutingLaneTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RoutingLaneTransitionFullAttribute::initializeOffsets(RoutingLaneTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RoutingLaneTransitionFullAttribute::operator==(const RoutingLaneTransitionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RoutingLaneTransitionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RoutingLaneTransitionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingLaneTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoutingLaneTransitionFullAttribute::write(RoutingLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingLaneTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeType RoutingLaneTransitionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(in);
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeType RoutingLaneTransitionFullAttribute::readAttributeTypeCode(RoutingLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue RoutingLaneTransitionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue(in, static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue RoutingLaneTransitionFullAttribute::readAttributeValue(RoutingLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::attributes::RoutingLaneTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::routingdata::attributes::RoutingLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList> RoutingLaneTransitionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::nds::routingdata::instantiations::RoutingPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList> RoutingLaneTransitionFullAttribute::readProperties(RoutingLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::nds::routingdata::instantiations::RoutingPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routingdata::instantiations::RoutingPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RoutingLaneTransitionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RoutingLaneTransitionFullAttribute::readConditions(RoutingLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadRangeAttributeSetMap.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadRangeAttributeSetMap::RoutingRoadRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RoutingRoadRangeAttributeSetMap::RoutingRoadRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RoutingRoadRangeAttributeSetMap::RoutingRoadRangeAttributeSetMap(RoutingRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RoutingRoadRangeAttributeSetMap::RoutingRoadRangeAttributeSetMap(const RoutingRoadRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeSetMap& RoutingRoadRangeAttributeSetMap::operator=(const RoutingRoadRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeSetMap::RoutingRoadRangeAttributeSetMap(RoutingRoadRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeSetMap& RoutingRoadRangeAttributeSetMap::operator=(RoutingRoadRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeSetMap::RoutingRoadRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const RoutingRoadRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingRoadRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingRoadRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingRoadRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::routingdata::instantiations::RoutingRoadRangeAttributeSet& RoutingRoadRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::routingdata::instantiations::RoutingRoadRangeAttributeSet& RoutingRoadRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RoutingRoadRangeAttributeSetMap::setAttributeSet(const ::nds::routingdata::instantiations::RoutingRoadRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RoutingRoadRangeAttributeSetMap::setAttributeSet(::nds::routingdata::instantiations::RoutingRoadRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RoutingRoadRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RoutingRoadRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& RoutingRoadRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& RoutingRoadRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RoutingRoadRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RoutingRoadRangeAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RoutingRoadRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RoutingRoadRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RoutingRoadRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RoutingRoadRangeAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RoutingRoadRangeAttributeSetMap::initPackingContext(RoutingRoadRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RoutingRoadRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeSetMap::bitSizeOf(RoutingRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadRangeAttributeSetMap::initializeOffsets(RoutingRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadRangeAttributeSetMap::operator==(const RoutingRoadRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RoutingRoadRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RoutingRoadRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeSetMap::write(RoutingRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeSetMap::ZserioElementFactory_references::create(RoutingRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadRangeAttributeSetMap::ZserioElementFactory_references::create(RoutingRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingRoadRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RoutingRoadRangeAttributeSetMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(RoutingRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(RoutingRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::routingdata::instantiations::RoutingRoadRangeAttributeSet RoutingRoadRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingRoadRangeAttributeSet(in, allocator);
}

::nds::routingdata::instantiations::RoutingRoadRangeAttributeSet RoutingRoadRangeAttributeSetMap::readAttributeSet(RoutingRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingRoadRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RoutingRoadRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RoutingRoadRangeAttributeSetMap::readFeature(RoutingRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadRangeAttributeSetMap::ZserioArrayType_references RoutingRoadRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingRoadRangeAttributeSetMap::ZserioArrayType_references RoutingRoadRangeAttributeSetMap::readReferences(RoutingRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingRoadRangeAttributeSetMap::ZserioArrayType_validities RoutingRoadRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingRoadRangeAttributeSetMap::ZserioArrayType_validities RoutingRoadRangeAttributeSetMap::readValidities(RoutingRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadTransitionAttributeSetMap.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadTransitionAttributeSetMap::RoutingRoadTransitionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RoutingRoadTransitionAttributeSetMap::RoutingRoadTransitionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RoutingRoadTransitionAttributeSetMap::RoutingRoadTransitionAttributeSetMap(RoutingRoadTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RoutingRoadTransitionAttributeSetMap::RoutingRoadTransitionAttributeSetMap(const RoutingRoadTransitionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeSetMap& RoutingRoadTransitionAttributeSetMap::operator=(const RoutingRoadTransitionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeSetMap::RoutingRoadTransitionAttributeSetMap(RoutingRoadTransitionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeSetMap& RoutingRoadTransitionAttributeSetMap::operator=(RoutingRoadTransitionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeSetMap::RoutingRoadTransitionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RoutingRoadTransitionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingRoadTransitionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadTransitionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadTransitionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingRoadTransitionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingRoadTransitionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSet& RoutingRoadTransitionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSet& RoutingRoadTransitionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RoutingRoadTransitionAttributeSetMap::setAttributeSet(const ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RoutingRoadTransitionAttributeSetMap::setAttributeSet(::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RoutingRoadTransitionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RoutingRoadTransitionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::TransitionReference>& RoutingRoadTransitionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::TransitionReference>& RoutingRoadTransitionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RoutingRoadTransitionAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::TransitionReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RoutingRoadTransitionAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::TransitionReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RoutingRoadTransitionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RoutingRoadTransitionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RoutingRoadTransitionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RoutingRoadTransitionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RoutingRoadTransitionAttributeSetMap::initPackingContext(RoutingRoadTransitionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RoutingRoadTransitionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeSetMap::bitSizeOf(RoutingRoadTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadTransitionAttributeSetMap::initializeOffsets(RoutingRoadTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadTransitionAttributeSetMap::operator==(const RoutingRoadTransitionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RoutingRoadTransitionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RoutingRoadTransitionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RoutingRoadTransitionAttributeSetMap::write(RoutingRoadTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RoutingRoadTransitionAttributeSetMap::ZserioArrayExpressions_references::initializeElement(RoutingRoadTransitionAttributeSetMap&,
        ::nds::road::reference::types::TransitionReference& element, size_t)
{
    element.initializeChildren();
}

void RoutingRoadTransitionAttributeSetMap::ZserioElementFactory_references::create(RoutingRoadTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingRoadTransitionAttributeSetMap::ZserioElementFactory_references::create(RoutingRoadTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::nds::road::reference::types::TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingRoadTransitionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RoutingRoadTransitionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingRoadTransitionAttributeSetMap::ZserioElementFactory_validities::create(RoutingRoadTransitionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSet RoutingRoadTransitionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSet(in, allocator);
}

::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSet RoutingRoadTransitionAttributeSetMap::readAttributeSet(RoutingRoadTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RoutingRoadTransitionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RoutingRoadTransitionAttributeSetMap::readFeature(RoutingRoadTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadTransitionAttributeSetMap::ZserioArrayType_references RoutingRoadTransitionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingRoadTransitionAttributeSetMap::ZserioArrayType_references RoutingRoadTransitionAttributeSetMap::readReferences(RoutingRoadTransitionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingRoadTransitionAttributeSetMap::ZserioArrayType_validities RoutingRoadTransitionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneRangeAttributeSetMap.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneRangeAttributeSetMap::RoutingLaneRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RoutingLaneRangeAttributeSetMap::RoutingLaneRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RoutingLaneRangeAttributeSetMap::RoutingLaneRangeAttributeSetMap(RoutingLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RoutingLaneRangeAttributeSetMap::RoutingLaneRangeAttributeSetMap(const RoutingLaneRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeSetMap& RoutingLaneRangeAttributeSetMap::operator=(const RoutingLaneRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeSetMap::RoutingLaneRangeAttributeSetMap(RoutingLaneRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeSetMap& RoutingLaneRangeAttributeSetMap::operator=(RoutingLaneRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeSetMap::RoutingLaneRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const RoutingLaneRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingLaneRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingLaneRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingLaneRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::routingdata::instantiations::RoutingLaneRangeAttributeSet& RoutingLaneRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::routingdata::instantiations::RoutingLaneRangeAttributeSet& RoutingLaneRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RoutingLaneRangeAttributeSetMap::setAttributeSet(const ::nds::routingdata::instantiations::RoutingLaneRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RoutingLaneRangeAttributeSetMap::setAttributeSet(::nds::routingdata::instantiations::RoutingLaneRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RoutingLaneRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RoutingLaneRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RoutingLaneRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RoutingLaneRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RoutingLaneRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RoutingLaneRangeAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RoutingLaneRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RoutingLaneRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RoutingLaneRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RoutingLaneRangeAttributeSetMap::setValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RoutingLaneRangeAttributeSetMap::initPackingContext(RoutingLaneRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RoutingLaneRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeSetMap::bitSizeOf(RoutingLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneRangeAttributeSetMap::initializeOffsets(RoutingLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneRangeAttributeSetMap::operator==(const RoutingLaneRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RoutingLaneRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RoutingLaneRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeSetMap::write(RoutingLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeSetMap::ZserioElementFactory_references::create(RoutingLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneRangeAttributeSetMap::ZserioElementFactory_references::create(RoutingLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingLaneRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RoutingLaneRangeAttributeSetMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(RoutingLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(RoutingLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::routingdata::instantiations::RoutingLaneRangeAttributeSet RoutingLaneRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingLaneRangeAttributeSet(in, allocator);
}

::nds::routingdata::instantiations::RoutingLaneRangeAttributeSet RoutingLaneRangeAttributeSetMap::readAttributeSet(RoutingLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingLaneRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RoutingLaneRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RoutingLaneRangeAttributeSetMap::readFeature(RoutingLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneRangeAttributeSetMap::ZserioArrayType_references RoutingLaneRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingLaneRangeAttributeSetMap::ZserioArrayType_references RoutingLaneRangeAttributeSetMap::readReferences(RoutingLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingLaneRangeAttributeSetMap::ZserioArrayType_validities RoutingLaneRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingLaneRangeAttributeSetMap::ZserioArrayType_validities RoutingLaneRangeAttributeSetMap::readValidities(RoutingLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneTransitionAttributeSetMap.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneTransitionAttributeSetMap::RoutingLaneTransitionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RoutingLaneTransitionAttributeSetMap::RoutingLaneTransitionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RoutingLaneTransitionAttributeSetMap::RoutingLaneTransitionAttributeSetMap(RoutingLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RoutingLaneTransitionAttributeSetMap::RoutingLaneTransitionAttributeSetMap(const RoutingLaneTransitionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeSetMap& RoutingLaneTransitionAttributeSetMap::operator=(const RoutingLaneTransitionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeSetMap::RoutingLaneTransitionAttributeSetMap(RoutingLaneTransitionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeSetMap& RoutingLaneTransitionAttributeSetMap::operator=(RoutingLaneTransitionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeSetMap::RoutingLaneTransitionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RoutingLaneTransitionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingLaneTransitionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneTransitionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneTransitionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingLaneTransitionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingLaneTransitionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSet& RoutingLaneTransitionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSet& RoutingLaneTransitionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RoutingLaneTransitionAttributeSetMap::setAttributeSet(const ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RoutingLaneTransitionAttributeSetMap::setAttributeSet(::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RoutingLaneTransitionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RoutingLaneTransitionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& RoutingLaneTransitionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& RoutingLaneTransitionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RoutingLaneTransitionAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RoutingLaneTransitionAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RoutingLaneTransitionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RoutingLaneTransitionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RoutingLaneTransitionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RoutingLaneTransitionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RoutingLaneTransitionAttributeSetMap::initPackingContext(RoutingLaneTransitionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RoutingLaneTransitionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeSetMap::bitSizeOf(RoutingLaneTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneTransitionAttributeSetMap::initializeOffsets(RoutingLaneTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneTransitionAttributeSetMap::operator==(const RoutingLaneTransitionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RoutingLaneTransitionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RoutingLaneTransitionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RoutingLaneTransitionAttributeSetMap::write(RoutingLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RoutingLaneTransitionAttributeSetMap::ZserioElementFactory_references::create(RoutingLaneTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingLaneTransitionAttributeSetMap::ZserioElementFactory_references::create(RoutingLaneTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& array,
        ::nds::lane::reference::types::LaneGroupTransition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingLaneTransitionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RoutingLaneTransitionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingLaneTransitionAttributeSetMap::ZserioElementFactory_validities::create(RoutingLaneTransitionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSet RoutingLaneTransitionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSet(in, allocator);
}

::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSet RoutingLaneTransitionAttributeSetMap::readAttributeSet(RoutingLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RoutingLaneTransitionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RoutingLaneTransitionAttributeSetMap::readFeature(RoutingLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneTransitionAttributeSetMap::ZserioArrayType_references RoutingLaneTransitionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RoutingLaneTransitionAttributeSetMap::ZserioArrayType_references RoutingLaneTransitionAttributeSetMap::readReferences(RoutingLaneTransitionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RoutingLaneTransitionAttributeSetMap::ZserioArrayType_validities RoutingLaneTransitionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadRangeAttributeSetList.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadRangeAttributeSetList::RoutingRoadRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RoutingRoadRangeAttributeSetList::RoutingRoadRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RoutingRoadRangeAttributeSetList::RoutingRoadRangeAttributeSetList(RoutingRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RoutingRoadRangeAttributeSetList::RoutingRoadRangeAttributeSetList(const RoutingRoadRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeSetList& RoutingRoadRangeAttributeSetList::operator=(const RoutingRoadRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeSetList::RoutingRoadRangeAttributeSetList(RoutingRoadRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadRangeAttributeSetList& RoutingRoadRangeAttributeSetList::operator=(RoutingRoadRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadRangeAttributeSetList::RoutingRoadRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const RoutingRoadRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingRoadRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingRoadRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingRoadRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RoutingRoadRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RoutingRoadRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeSetMap>& RoutingRoadRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeSetMap>& RoutingRoadRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RoutingRoadRangeAttributeSetList::setSets(const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RoutingRoadRangeAttributeSetList::setSets(::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RoutingRoadRangeAttributeSetList::initPackingContext(RoutingRoadRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RoutingRoadRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeSetList::bitSizeOf(RoutingRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadRangeAttributeSetList::initializeOffsets(RoutingRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadRangeAttributeSetList::operator==(const RoutingRoadRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RoutingRoadRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RoutingRoadRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeSetList::write(RoutingRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RoutingRoadRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RoutingRoadRangeAttributeSetList& owner,
        ::nds::routingdata::instantiations::RoutingRoadRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingRoadRangeAttributeSetList::ZserioElementFactory_sets::create(RoutingRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingRoadRangeAttributeSetList::ZserioElementFactory_sets::create(RoutingRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadRangeAttributeSetMap>& array,
        ::nds::routingdata::instantiations::RoutingRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RoutingRoadRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingRoadRangeAttributeSetList::readNumAttributeSets(RoutingRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadRangeAttributeSetList::ZserioArrayType_sets RoutingRoadRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RoutingRoadRangeAttributeSetList::ZserioArrayType_sets RoutingRoadRangeAttributeSetList::readSets(RoutingRoadRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingRoadTransitionAttributeSetList.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingRoadTransitionAttributeSetList::RoutingRoadTransitionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RoutingRoadTransitionAttributeSetList::RoutingRoadTransitionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RoutingRoadTransitionAttributeSetList::RoutingRoadTransitionAttributeSetList(RoutingRoadTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RoutingRoadTransitionAttributeSetList::RoutingRoadTransitionAttributeSetList(const RoutingRoadTransitionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeSetList& RoutingRoadTransitionAttributeSetList::operator=(const RoutingRoadTransitionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeSetList::RoutingRoadTransitionAttributeSetList(RoutingRoadTransitionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingRoadTransitionAttributeSetList& RoutingRoadTransitionAttributeSetList::operator=(RoutingRoadTransitionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingRoadTransitionAttributeSetList::RoutingRoadTransitionAttributeSetList(::zserio::PropagateAllocatorT,
        const RoutingRoadTransitionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingRoadTransitionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingRoadTransitionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RoutingRoadTransitionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingRoadTransitionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingRoadTransitionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RoutingRoadTransitionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RoutingRoadTransitionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSetMap>& RoutingRoadTransitionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSetMap>& RoutingRoadTransitionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RoutingRoadTransitionAttributeSetList::setSets(const ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RoutingRoadTransitionAttributeSetList::setSets(::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RoutingRoadTransitionAttributeSetList::initPackingContext(RoutingRoadTransitionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RoutingRoadTransitionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeSetList::bitSizeOf(RoutingRoadTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRoadTransitionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingRoadTransitionAttributeSetList::initializeOffsets(RoutingRoadTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingRoadTransitionAttributeSetList::operator==(const RoutingRoadTransitionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RoutingRoadTransitionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RoutingRoadTransitionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeSetList::write(RoutingRoadTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingRoadTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RoutingRoadTransitionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RoutingRoadTransitionAttributeSetList& owner,
        ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingRoadTransitionAttributeSetList::ZserioElementFactory_sets::create(RoutingRoadTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingRoadTransitionAttributeSetList::ZserioElementFactory_sets::create(RoutingRoadTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSetMap>& array,
        ::nds::routingdata::instantiations::RoutingRoadTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RoutingRoadTransitionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingRoadTransitionAttributeSetList::readNumAttributeSets(RoutingRoadTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingRoadTransitionAttributeSetList::ZserioArrayType_sets RoutingRoadTransitionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RoutingRoadTransitionAttributeSetList::ZserioArrayType_sets RoutingRoadTransitionAttributeSetList::readSets(RoutingRoadTransitionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneRangeAttributeSetList.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneRangeAttributeSetList::RoutingLaneRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RoutingLaneRangeAttributeSetList::RoutingLaneRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RoutingLaneRangeAttributeSetList::RoutingLaneRangeAttributeSetList(RoutingLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RoutingLaneRangeAttributeSetList::RoutingLaneRangeAttributeSetList(const RoutingLaneRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeSetList& RoutingLaneRangeAttributeSetList::operator=(const RoutingLaneRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeSetList::RoutingLaneRangeAttributeSetList(RoutingLaneRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneRangeAttributeSetList& RoutingLaneRangeAttributeSetList::operator=(RoutingLaneRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneRangeAttributeSetList::RoutingLaneRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const RoutingLaneRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingLaneRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingLaneRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingLaneRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RoutingLaneRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RoutingLaneRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeSetMap>& RoutingLaneRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeSetMap>& RoutingLaneRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RoutingLaneRangeAttributeSetList::setSets(const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RoutingLaneRangeAttributeSetList::setSets(::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RoutingLaneRangeAttributeSetList::initPackingContext(RoutingLaneRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RoutingLaneRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeSetList::bitSizeOf(RoutingLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneRangeAttributeSetList::initializeOffsets(RoutingLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneRangeAttributeSetList::operator==(const RoutingLaneRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RoutingLaneRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RoutingLaneRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeSetList::write(RoutingLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RoutingLaneRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RoutingLaneRangeAttributeSetList& owner,
        ::nds::routingdata::instantiations::RoutingLaneRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingLaneRangeAttributeSetList::ZserioElementFactory_sets::create(RoutingLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingLaneRangeAttributeSetList::ZserioElementFactory_sets::create(RoutingLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneRangeAttributeSetMap>& array,
        ::nds::routingdata::instantiations::RoutingLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RoutingLaneRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingLaneRangeAttributeSetList::readNumAttributeSets(RoutingLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneRangeAttributeSetList::ZserioArrayType_sets RoutingLaneRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RoutingLaneRangeAttributeSetList::ZserioArrayType_sets RoutingLaneRangeAttributeSetList::readSets(RoutingLaneRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routingdata/instantiations/RoutingLaneTransitionAttributeSetList.h>

namespace nds
{
namespace routingdata
{
namespace instantiations
{

RoutingLaneTransitionAttributeSetList::RoutingLaneTransitionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RoutingLaneTransitionAttributeSetList::RoutingLaneTransitionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RoutingLaneTransitionAttributeSetList::RoutingLaneTransitionAttributeSetList(RoutingLaneTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RoutingLaneTransitionAttributeSetList::RoutingLaneTransitionAttributeSetList(const RoutingLaneTransitionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeSetList& RoutingLaneTransitionAttributeSetList::operator=(const RoutingLaneTransitionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeSetList::RoutingLaneTransitionAttributeSetList(RoutingLaneTransitionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RoutingLaneTransitionAttributeSetList& RoutingLaneTransitionAttributeSetList::operator=(RoutingLaneTransitionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingLaneTransitionAttributeSetList::RoutingLaneTransitionAttributeSetList(::zserio::PropagateAllocatorT,
        const RoutingLaneTransitionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RoutingLaneTransitionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoutingLaneTransitionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RoutingLaneTransitionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RoutingLaneTransitionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RoutingLaneTransitionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RoutingLaneTransitionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RoutingLaneTransitionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSetMap>& RoutingLaneTransitionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSetMap>& RoutingLaneTransitionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RoutingLaneTransitionAttributeSetList::setSets(const ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RoutingLaneTransitionAttributeSetList::setSets(::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RoutingLaneTransitionAttributeSetList::initPackingContext(RoutingLaneTransitionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RoutingLaneTransitionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeSetList::bitSizeOf(RoutingLaneTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingLaneTransitionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoutingLaneTransitionAttributeSetList::initializeOffsets(RoutingLaneTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoutingLaneTransitionAttributeSetList::operator==(const RoutingLaneTransitionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RoutingLaneTransitionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RoutingLaneTransitionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeSetList::write(RoutingLaneTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoutingLaneTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RoutingLaneTransitionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RoutingLaneTransitionAttributeSetList& owner,
        ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RoutingLaneTransitionAttributeSetList::ZserioElementFactory_sets::create(RoutingLaneTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RoutingLaneTransitionAttributeSetList::ZserioElementFactory_sets::create(RoutingLaneTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSetMap>& array,
        ::nds::routingdata::instantiations::RoutingLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RoutingLaneTransitionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoutingLaneTransitionAttributeSetList::readNumAttributeSets(RoutingLaneTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RoutingLaneTransitionAttributeSetList::ZserioArrayType_sets RoutingLaneTransitionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RoutingLaneTransitionAttributeSetList::ZserioArrayType_sets RoutingLaneTransitionAttributeSetList::readSets(RoutingLaneTransitionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace routingdata
} // namespace nds
