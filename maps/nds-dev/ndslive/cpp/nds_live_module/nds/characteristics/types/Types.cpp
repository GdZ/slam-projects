/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/SuperElevationClass.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for SuperElevationClass enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::characteristics::types::SuperElevationClass>::names;
constexpr ::std::array<::nds::characteristics::types::SuperElevationClass, 7> EnumTraits<::nds::characteristics::types::SuperElevationClass>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::SuperElevationClass>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::SuperElevationClass value)
{
    switch (value)
    {
    case ::nds::characteristics::types::SuperElevationClass::FLAT:
        return 0;
    case ::nds::characteristics::types::SuperElevationClass::MORE_THAN_4_TOWARDS_CURB:
        return 1;
    case ::nds::characteristics::types::SuperElevationClass::MORE_THAN_6_TOWARDS_CURB:
        return 2;
    case ::nds::characteristics::types::SuperElevationClass::MORE_THAN_8_TOWARDS_CURB:
        return 3;
    case ::nds::characteristics::types::SuperElevationClass::MORE_THAN_4_TOWARDS_MIDDLE:
        return 4;
    case ::nds::characteristics::types::SuperElevationClass::MORE_THAN_6_TOWARDS_MIDDLE:
        return 5;
    case ::nds::characteristics::types::SuperElevationClass::MORE_THAN_8_TOWARDS_MIDDLE:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration SuperElevationClass: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::SuperElevationClass>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::SuperElevationClass valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::SuperElevationClass>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::characteristics::types::SuperElevationClass>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration SuperElevationClass: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::SuperElevationClass>(::nds::characteristics::types::SuperElevationClass value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::SuperElevationClass value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::SuperElevationClass>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::SuperElevationClass)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::SuperElevationClass value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::SuperElevationClass>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::SuperElevationClass value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::SuperElevationClass value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::SuperElevationClass read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::SuperElevationClass>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::SuperElevationClass>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::SuperElevationClass read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::SuperElevationClass>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::SuperElevationClass>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::SuperElevationClass value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::SuperElevationClass value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::SuperElevationClass>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/RoadMedianShape.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadMedianShape enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::RoadMedianShape>::names;
constexpr ::std::array<::nds::characteristics::types::RoadMedianShape, 3> EnumTraits<::nds::characteristics::types::RoadMedianShape>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::RoadMedianShape>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::RoadMedianShape value)
{
    switch (value)
    {
    case ::nds::characteristics::types::RoadMedianShape::FLAT:
        return 0;
    case ::nds::characteristics::types::RoadMedianShape::BERM:
        return 1;
    case ::nds::characteristics::types::RoadMedianShape::DITCH:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadMedianShape: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianShape>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::RoadMedianShape valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::RoadMedianShape>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::characteristics::types::RoadMedianShape>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadMedianShape: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::RoadMedianShape>(::nds::characteristics::types::RoadMedianShape value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::RoadMedianShape value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianShape>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::RoadMedianShape)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::RoadMedianShape value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianShape>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::RoadMedianShape value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::RoadMedianShape value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::RoadMedianShape read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::RoadMedianShape>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianShape>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::RoadMedianShape read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::RoadMedianShape>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianShape>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::RoadMedianShape value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::RoadMedianShape value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianShape>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/RoadMedianSurface.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadMedianSurface enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::characteristics::types::RoadMedianSurface>::names;
constexpr ::std::array<::nds::characteristics::types::RoadMedianSurface, 2> EnumTraits<::nds::characteristics::types::RoadMedianSurface>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::RoadMedianSurface>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::RoadMedianSurface value)
{
    switch (value)
    {
    case ::nds::characteristics::types::RoadMedianSurface::PAVED:
        return 0;
    case ::nds::characteristics::types::RoadMedianSurface::UNPAVED:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadMedianSurface: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianSurface>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::RoadMedianSurface valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::RoadMedianSurface>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::characteristics::types::RoadMedianSurface>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadMedianSurface: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::RoadMedianSurface>(::nds::characteristics::types::RoadMedianSurface value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::RoadMedianSurface value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianSurface>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::RoadMedianSurface)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::RoadMedianSurface value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianSurface>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::RoadMedianSurface value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::RoadMedianSurface value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::RoadMedianSurface read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::RoadMedianSurface>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianSurface>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::RoadMedianSurface read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::RoadMedianSurface>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianSurface>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::RoadMedianSurface value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::RoadMedianSurface value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RoadMedianSurface>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/ComplexIntersectionType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ComplexIntersectionType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::ComplexIntersectionType>::names;
constexpr ::std::array<::nds::characteristics::types::ComplexIntersectionType, 3> EnumTraits<::nds::characteristics::types::ComplexIntersectionType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::ComplexIntersectionType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::ComplexIntersectionType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::ComplexIntersectionType::STANDARD_INTERSECTION:
        return 0;
    case ::nds::characteristics::types::ComplexIntersectionType::CONTROLLED_ACCESS_INTERSECTION:
        return 1;
    case ::nds::characteristics::types::ComplexIntersectionType::COMBINED_INTERSECTION:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ComplexIntersectionType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::ComplexIntersectionType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::ComplexIntersectionType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::ComplexIntersectionType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::characteristics::types::ComplexIntersectionType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ComplexIntersectionType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::ComplexIntersectionType>(::nds::characteristics::types::ComplexIntersectionType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::ComplexIntersectionType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::ComplexIntersectionType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::ComplexIntersectionType)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::ComplexIntersectionType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::ComplexIntersectionType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::ComplexIntersectionType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::ComplexIntersectionType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::ComplexIntersectionType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::ComplexIntersectionType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::ComplexIntersectionType>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::characteristics::types::ComplexIntersectionType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::ComplexIntersectionType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::ComplexIntersectionType>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::ComplexIntersectionType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::ComplexIntersectionType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::ComplexIntersectionType>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/StationaryObjectType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for StationaryObjectType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::StationaryObjectType>::names;
constexpr ::std::array<::nds::characteristics::types::StationaryObjectType, 3> EnumTraits<::nds::characteristics::types::StationaryObjectType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::StationaryObjectType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::StationaryObjectType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::StationaryObjectType::CHECKPOINT:
        return 0;
    case ::nds::characteristics::types::StationaryObjectType::TOLL_STATION:
        return 1;
    case ::nds::characteristics::types::StationaryObjectType::PORTER:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StationaryObjectType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::StationaryObjectType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::StationaryObjectType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::StationaryObjectType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::characteristics::types::StationaryObjectType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StationaryObjectType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::StationaryObjectType>(::nds::characteristics::types::StationaryObjectType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::StationaryObjectType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationaryObjectType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::StationaryObjectType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::StationaryObjectType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationaryObjectType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::StationaryObjectType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::StationaryObjectType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::StationaryObjectType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::StationaryObjectType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::StationaryObjectType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::StationaryObjectType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::StationaryObjectType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationaryObjectType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::StationaryObjectType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::StationaryObjectType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationaryObjectType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/StationPlazaType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for StationPlazaType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::StationPlazaType>::names;
constexpr ::std::array<::nds::characteristics::types::StationPlazaType, 3> EnumTraits<::nds::characteristics::types::StationPlazaType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::StationPlazaType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::StationPlazaType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::StationPlazaType::ENTRY_AND_EXIT:
        return 0;
    case ::nds::characteristics::types::StationPlazaType::ENTRY:
        return 1;
    case ::nds::characteristics::types::StationPlazaType::EXIT:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StationPlazaType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::StationPlazaType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::StationPlazaType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::StationPlazaType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::characteristics::types::StationPlazaType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StationPlazaType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::StationPlazaType>(::nds::characteristics::types::StationPlazaType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::StationPlazaType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationPlazaType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::StationPlazaType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::StationPlazaType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationPlazaType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::StationPlazaType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::StationPlazaType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::StationPlazaType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::StationPlazaType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::StationPlazaType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::StationPlazaType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::StationPlazaType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationPlazaType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::StationPlazaType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::StationPlazaType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationPlazaType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/TollPaymentType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TollPaymentType enumeration.
constexpr ::std::array<const char*, 12> EnumTraits<::nds::characteristics::types::TollPaymentType>::names;
constexpr ::std::array<::nds::characteristics::types::TollPaymentType, 12> EnumTraits<::nds::characteristics::types::TollPaymentType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::TollPaymentType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::TollPaymentType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::TollPaymentType::VARIABLE:
        return 0;
    case ::nds::characteristics::types::TollPaymentType::CASH_COINS_AND_BILLS:
        return 1;
    case ::nds::characteristics::types::TollPaymentType::CASH_BILLS_ONLY:
        return 2;
    case ::nds::characteristics::types::TollPaymentType::CASH_COINS_ONLY:
        return 3;
    case ::nds::characteristics::types::TollPaymentType::CASH_EXACT_CHANGE:
        return 4;
    case ::nds::characteristics::types::TollPaymentType::CREDIT_CARD:
        return 5;
    case ::nds::characteristics::types::TollPaymentType::DEBIT_CARD:
        return 6;
    case ::nds::characteristics::types::TollPaymentType::TRAVEL_CARD:
        return 7;
    case ::nds::characteristics::types::TollPaymentType::ETC:
        return 8;
    case ::nds::characteristics::types::TollPaymentType::ETC_TRANSPONDER:
        return 9;
    case ::nds::characteristics::types::TollPaymentType::ETC_VIDEO_CAMERA:
        return 10;
    case ::nds::characteristics::types::TollPaymentType::SUBSCRIPTION:
        return 11;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TollPaymentType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::TollPaymentType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::TollPaymentType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::TollPaymentType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
        return static_cast<::nds::characteristics::types::TollPaymentType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TollPaymentType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::TollPaymentType>(::nds::characteristics::types::TollPaymentType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::TollPaymentType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::TollPaymentType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::TollPaymentType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::TollPaymentType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::TollPaymentType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::TollPaymentType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::TollPaymentType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::TollPaymentType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::TollPaymentType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::TollPaymentType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::characteristics::types::TollPaymentType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::TollPaymentType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::TollPaymentType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::TollPaymentType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::TollPaymentType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::TollPaymentType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/StationStopType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for StationStopType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::StationStopType>::names;
constexpr ::std::array<::nds::characteristics::types::StationStopType, 3> EnumTraits<::nds::characteristics::types::StationStopType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::StationStopType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::StationStopType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::StationStopType::NO_STOP:
        return 0;
    case ::nds::characteristics::types::StationStopType::SLOW_DOWN:
        return 1;
    case ::nds::characteristics::types::StationStopType::STOP:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StationStopType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::StationStopType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::StationStopType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::StationStopType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::characteristics::types::StationStopType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StationStopType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::StationStopType>(::nds::characteristics::types::StationStopType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::StationStopType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationStopType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::StationStopType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::StationStopType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationStopType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::StationStopType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::StationStopType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::StationStopType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::StationStopType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::StationStopType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::characteristics::types::StationStopType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::StationStopType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationStopType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::StationStopType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::StationStopType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::StationStopType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/DividerType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DividerType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::DividerType>::names;
constexpr ::std::array<::nds::characteristics::types::DividerType, 3> EnumTraits<::nds::characteristics::types::DividerType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::DividerType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::DividerType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::DividerType::HAS_DIVIDER:
        return 0;
    case ::nds::characteristics::types::DividerType::UNKNOWN_DIVIDER_TYPE:
        return 1;
    case ::nds::characteristics::types::DividerType::LEGAL_DIVIDER:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DividerType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::DividerType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::DividerType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::DividerType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::characteristics::types::DividerType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DividerType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::DividerType>(::nds::characteristics::types::DividerType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::DividerType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::DividerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::DividerType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::DividerType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::DividerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::DividerType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::DividerType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::DividerType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::DividerType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::DividerType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::DividerType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::DividerType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::DividerType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::DividerType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::DividerType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::DividerType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/PavementType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PavementType enumeration.
constexpr ::std::array<const char*, 10> EnumTraits<::nds::characteristics::types::PavementType>::names;
constexpr ::std::array<::nds::characteristics::types::PavementType, 10> EnumTraits<::nds::characteristics::types::PavementType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::PavementType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::PavementType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::PavementType::UNKNOWN:
        return 0;
    case ::nds::characteristics::types::PavementType::SANDY:
        return 1;
    case ::nds::characteristics::types::PavementType::GRAVEL:
        return 2;
    case ::nds::characteristics::types::PavementType::COBBLESTONE:
        return 3;
    case ::nds::characteristics::types::PavementType::CONCRETE:
        return 4;
    case ::nds::characteristics::types::PavementType::ASPHALT:
        return 5;
    case ::nds::characteristics::types::PavementType::PAVED:
        return 6;
    case ::nds::characteristics::types::PavementType::UNPAVED:
        return 7;
    case ::nds::characteristics::types::PavementType::POOR_CONDITION:
        return 8;
    case ::nds::characteristics::types::PavementType::OTHER:
        return 9;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PavementType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::PavementType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::PavementType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::PavementType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
        return static_cast<::nds::characteristics::types::PavementType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PavementType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::PavementType>(::nds::characteristics::types::PavementType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::PavementType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::PavementType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::PavementType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::PavementType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::PavementType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::PavementType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::PavementType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::PavementType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::PavementType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::PavementType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::PavementType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::PavementType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::PavementType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::PavementType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::PavementType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::PavementType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/FerryType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for FerryType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::FerryType>::names;
constexpr ::std::array<::nds::characteristics::types::FerryType, 3> EnumTraits<::nds::characteristics::types::FerryType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::FerryType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::FerryType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::FerryType::SHIP_OR_HOVERCRAFT:
        return 0;
    case ::nds::characteristics::types::FerryType::TRAIN:
        return 1;
    case ::nds::characteristics::types::FerryType::SKY_CABLE_RAIL:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration FerryType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::FerryType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::FerryType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::FerryType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::characteristics::types::FerryType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration FerryType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::FerryType>(::nds::characteristics::types::FerryType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::FerryType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::FerryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::FerryType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::FerryType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::FerryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::FerryType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::FerryType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::FerryType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::FerryType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::FerryType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::FerryType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::FerryType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::FerryType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::FerryType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::FerryType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::FerryType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/GradeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for GradeType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::GradeType>::names;
constexpr ::std::array<::nds::characteristics::types::GradeType, 3> EnumTraits<::nds::characteristics::types::GradeType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::GradeType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::GradeType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::GradeType::UP:
        return 0;
    case ::nds::characteristics::types::GradeType::LEVEL:
        return 1;
    case ::nds::characteristics::types::GradeType::DOWN:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GradeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::GradeType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::GradeType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::GradeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::characteristics::types::GradeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GradeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::GradeType>(::nds::characteristics::types::GradeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::GradeType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::GradeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::GradeType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::GradeType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::GradeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::GradeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::GradeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::GradeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::GradeType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::GradeType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::GradeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::GradeType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::GradeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::GradeType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::GradeType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::GradeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/RailwayCrossing.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RailwayCrossing enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::RailwayCrossing>::names;
constexpr ::std::array<::nds::characteristics::types::RailwayCrossing, 3> EnumTraits<::nds::characteristics::types::RailwayCrossing>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::RailwayCrossing>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::RailwayCrossing value)
{
    switch (value)
    {
    case ::nds::characteristics::types::RailwayCrossing::RAILROAD_CROSSING_WITH_GATES:
        return 0;
    case ::nds::characteristics::types::RailwayCrossing::RAILROAD_CROSSING_WITHOUT_GATES:
        return 1;
    case ::nds::characteristics::types::RailwayCrossing::RAILROAD_CROSSING_UNKNOWN:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RailwayCrossing: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::RailwayCrossing>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::RailwayCrossing valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::RailwayCrossing>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::characteristics::types::RailwayCrossing>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RailwayCrossing: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::RailwayCrossing>(::nds::characteristics::types::RailwayCrossing value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::RailwayCrossing value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RailwayCrossing>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::RailwayCrossing)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::RailwayCrossing value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RailwayCrossing>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::RailwayCrossing value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::RailwayCrossing value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::RailwayCrossing read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::RailwayCrossing>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::RailwayCrossing>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::RailwayCrossing read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::RailwayCrossing>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RailwayCrossing>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::RailwayCrossing value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::RailwayCrossing value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::RailwayCrossing>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/TrafficCalming.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficCalming enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::characteristics::types::TrafficCalming>::names;
constexpr ::std::array<::nds::characteristics::types::TrafficCalming, 5> EnumTraits<::nds::characteristics::types::TrafficCalming>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::TrafficCalming>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::TrafficCalming value)
{
    switch (value)
    {
    case ::nds::characteristics::types::TrafficCalming::OTHER:
        return 0;
    case ::nds::characteristics::types::TrafficCalming::SPEED_BUMP:
        return 1;
    case ::nds::characteristics::types::TrafficCalming::SPEED_HUMP:
        return 2;
    case ::nds::characteristics::types::TrafficCalming::SPEED_CUSHION:
        return 3;
    case ::nds::characteristics::types::TrafficCalming::SPEED_TABLE:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficCalming: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::TrafficCalming>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::TrafficCalming valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::TrafficCalming>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::characteristics::types::TrafficCalming>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficCalming: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::TrafficCalming>(::nds::characteristics::types::TrafficCalming value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::TrafficCalming value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::TrafficCalming>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::TrafficCalming)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::TrafficCalming value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::TrafficCalming>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::TrafficCalming value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::TrafficCalming value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::TrafficCalming read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::TrafficCalming>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::TrafficCalming>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::TrafficCalming read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::TrafficCalming>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::TrafficCalming>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::TrafficCalming value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::TrafficCalming value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::TrafficCalming>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/LaneWidthState.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneWidthState enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::characteristics::types::LaneWidthState>::names;
constexpr ::std::array<::nds::characteristics::types::LaneWidthState, 4> EnumTraits<::nds::characteristics::types::LaneWidthState>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::LaneWidthState>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::LaneWidthState value)
{
    switch (value)
    {
    case ::nds::characteristics::types::LaneWidthState::NOT_FULLY_FORMED:
        return 0;
    case ::nds::characteristics::types::LaneWidthState::OVERLAP_RIGHT:
        return 1;
    case ::nds::characteristics::types::LaneWidthState::OVERLAP_LEFT:
        return 2;
    case ::nds::characteristics::types::LaneWidthState::OVERLAP_BOTH:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneWidthState: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::LaneWidthState>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::LaneWidthState valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::LaneWidthState>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::characteristics::types::LaneWidthState>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneWidthState: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::LaneWidthState>(::nds::characteristics::types::LaneWidthState value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::LaneWidthState value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::LaneWidthState>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::LaneWidthState)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::LaneWidthState value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::LaneWidthState>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::LaneWidthState value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::LaneWidthState value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::LaneWidthState read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::LaneWidthState>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::LaneWidthState>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::characteristics::types::LaneWidthState read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::LaneWidthState>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::LaneWidthState>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::LaneWidthState value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::LaneWidthState value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::LaneWidthState>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/characteristics/types/IntersectionType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for IntersectionType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::characteristics::types::IntersectionType>::names;
constexpr ::std::array<::nds::characteristics::types::IntersectionType, 3> EnumTraits<::nds::characteristics::types::IntersectionType>::values;
constexpr const char* EnumTraits<::nds::characteristics::types::IntersectionType>::enumName;

template <>
size_t enumToOrdinal(::nds::characteristics::types::IntersectionType value)
{
    switch (value)
    {
    case ::nds::characteristics::types::IntersectionType::ROUNDABOUT:
        return 0;
    case ::nds::characteristics::types::IntersectionType::MINI_ROUNDABOUT:
        return 1;
    case ::nds::characteristics::types::IntersectionType::SPECIAL_TRAFFIC_FIGURE:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration IntersectionType: ") <<
                static_cast<typename ::std::underlying_type<::nds::characteristics::types::IntersectionType>::type>(value) << "!";
    }
}

template <>
::nds::characteristics::types::IntersectionType valueToEnum(
        typename ::std::underlying_type<::nds::characteristics::types::IntersectionType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::characteristics::types::IntersectionType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration IntersectionType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::characteristics::types::IntersectionType>(::nds::characteristics::types::IntersectionType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::characteristics::types::IntersectionType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::IntersectionType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::characteristics::types::IntersectionType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::characteristics::types::IntersectionType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::IntersectionType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::characteristics::types::IntersectionType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::characteristics::types::IntersectionType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::characteristics::types::IntersectionType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::IntersectionType>(
            static_cast<typename ::std::underlying_type<::nds::characteristics::types::IntersectionType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::characteristics::types::IntersectionType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::characteristics::types::IntersectionType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::IntersectionType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::characteristics::types::IntersectionType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::characteristics::types::IntersectionType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::characteristics::types::IntersectionType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/characteristics/types/RoadMedian.h>

namespace nds
{
namespace characteristics
{
namespace types
{

RoadMedian::RoadMedian(const allocator_type&) noexcept :
        m_width_(uint16_t()),
        m_shape_(::nds::characteristics::types::RoadMedianShape()),
        m_surface_(::nds::characteristics::types::RoadMedianSurface())
{
}

RoadMedian::RoadMedian(::zserio::BitStreamReader& in, const allocator_type&) :
        m_width_(readWidth(in)),
        m_shape_(readShape(in)),
        m_surface_(readSurface(in))
{
}

RoadMedian::RoadMedian(RoadMedian::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_width_(readWidth(context, in)),
        m_shape_(readShape(context, in)),
        m_surface_(readSurface(context, in))
{
}

RoadMedian::RoadMedian(::zserio::PropagateAllocatorT,
        const RoadMedian& other, const allocator_type& allocator) :
        m_width_(::zserio::allocatorPropagatingCopy(other.m_width_, allocator)),
        m_shape_(::zserio::allocatorPropagatingCopy(other.m_shape_, allocator)),
        m_surface_(::zserio::allocatorPropagatingCopy(other.m_surface_, allocator))
{
}

uint16_t RoadMedian::getWidth() const
{
    return m_width_;
}

void RoadMedian::setWidth(uint16_t width_)
{
    m_width_ = width_;
}

::nds::characteristics::types::RoadMedianShape RoadMedian::getShape() const
{
    return m_shape_;
}

void RoadMedian::setShape(::nds::characteristics::types::RoadMedianShape shape_)
{
    m_shape_ = shape_;
}

::nds::characteristics::types::RoadMedianSurface RoadMedian::getSurface() const
{
    return m_surface_;
}

void RoadMedian::setSurface(::nds::characteristics::types::RoadMedianSurface surface_)
{
    m_surface_ = surface_;
}

void RoadMedian::initPackingContext(RoadMedian::ZserioPackingContext& context) const
{
    context.getWidth().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_width_);
    ::zserio::initPackingContext(context.getShape(), m_shape_);
    ::zserio::initPackingContext(context.getSurface(), m_surface_);
}

size_t RoadMedian::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_width_);
    endBitPosition += ::zserio::bitSizeOf(m_shape_);
    endBitPosition += ::zserio::bitSizeOf(m_surface_);

    return endBitPosition - bitPosition;
}

size_t RoadMedian::bitSizeOf(RoadMedian::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_width_);
    endBitPosition += ::zserio::bitSizeOf(context.getShape(), m_shape_);
    endBitPosition += ::zserio::bitSizeOf(context.getSurface(), m_surface_);

    return endBitPosition - bitPosition;
}

size_t RoadMedian::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_width_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_shape_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_surface_);

    return endBitPosition;
}

size_t RoadMedian::initializeOffsets(RoadMedian::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_width_);
    endBitPosition = ::zserio::initializeOffsets(context.getShape(), endBitPosition,
        m_shape_);
    endBitPosition = ::zserio::initializeOffsets(context.getSurface(), endBitPosition,
        m_surface_);

    return endBitPosition;
}

bool RoadMedian::operator==(const RoadMedian& other) const
{
    if (this != &other)
    {
        return
                (m_width_ == other.m_width_) &&
                (m_shape_ == other.m_shape_) &&
                (m_surface_ == other.m_surface_);
    }

    return true;
}

uint32_t RoadMedian::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_width_);
    result = ::zserio::calcHashCode(result, m_shape_);
    result = ::zserio::calcHashCode(result, m_surface_);

    return result;
}

void RoadMedian::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_width_);
    ::zserio::write(out, m_shape_);
    ::zserio::write(out, m_surface_);
}

void RoadMedian::write(RoadMedian::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getWidth().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_width_);
    ::zserio::write(context.getShape(), out, m_shape_);
    ::zserio::write(context.getSurface(), out, m_surface_);
}

uint16_t RoadMedian::readWidth(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t RoadMedian::readWidth(RoadMedian::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getWidth().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
::nds::characteristics::types::RoadMedianShape RoadMedian::readShape(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::characteristics::types::RoadMedianShape>(in);
}

::nds::characteristics::types::RoadMedianShape RoadMedian::readShape(RoadMedian::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::characteristics::types::RoadMedianShape>(context.getShape(), in);
}
::nds::characteristics::types::RoadMedianSurface RoadMedian::readSurface(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::characteristics::types::RoadMedianSurface>(in);
}

::nds::characteristics::types::RoadMedianSurface RoadMedian::readSurface(RoadMedian::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::characteristics::types::RoadMedianSurface>(context.getSurface(), in);
}

} // namespace types
} // namespace characteristics
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/characteristics/types/MultiDigitizedRoadReference.h>

namespace nds
{
namespace characteristics
{
namespace types
{

MultiDigitizedRoadReference::MultiDigitizedRoadReference(const allocator_type&) noexcept :
        m_isDirectReference_(bool()),
        m_counterpartReference_(::zserio::NullOpt),
        m_counterpartReferenceIndirect_(::zserio::NullOpt)
{
}

MultiDigitizedRoadReference::MultiDigitizedRoadReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_isDirectReference_(readIsDirectReference(in)),
        m_counterpartReference_(readCounterpartReference(in, allocator)),
        m_counterpartReferenceIndirect_(readCounterpartReferenceIndirect(in, allocator))
{
}

MultiDigitizedRoadReference::MultiDigitizedRoadReference(MultiDigitizedRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_isDirectReference_(readIsDirectReference(in)),
        m_counterpartReference_(readCounterpartReference(context, in, allocator)),
        m_counterpartReferenceIndirect_(readCounterpartReferenceIndirect(context, in, allocator))
{
}

MultiDigitizedRoadReference::MultiDigitizedRoadReference(::zserio::PropagateAllocatorT,
        const MultiDigitizedRoadReference& other, const allocator_type& allocator) :
        m_isDirectReference_(::zserio::allocatorPropagatingCopy(other.m_isDirectReference_, allocator)),
        m_counterpartReference_(::zserio::allocatorPropagatingCopy(other.m_counterpartReference_, allocator)),
        m_counterpartReferenceIndirect_(::zserio::allocatorPropagatingCopy(other.m_counterpartReferenceIndirect_, allocator))
{
}

void MultiDigitizedRoadReference::initializeChildren()
{
    if (!getIsDirectReference())
        m_counterpartReferenceIndirect_.value().initializeChildren();
}

bool MultiDigitizedRoadReference::getIsDirectReference() const
{
    return m_isDirectReference_;
}

void MultiDigitizedRoadReference::setIsDirectReference(bool isDirectReference_)
{
    m_isDirectReference_ = isDirectReference_;
}

::nds::road::reference::types::RoadReference& MultiDigitizedRoadReference::getCounterpartReference()
{
    return m_counterpartReference_.value();
}

const ::nds::road::reference::types::RoadReference& MultiDigitizedRoadReference::getCounterpartReference() const
{
    return m_counterpartReference_.value();
}

void MultiDigitizedRoadReference::setCounterpartReference(const ::nds::road::reference::types::RoadReference& counterpartReference_)
{
    m_counterpartReference_ = counterpartReference_;
}

void MultiDigitizedRoadReference::setCounterpartReference(::nds::road::reference::types::RoadReference&& counterpartReference_)
{
    m_counterpartReference_ = ::std::move(counterpartReference_);
}

bool MultiDigitizedRoadReference::isCounterpartReferenceUsed() const
{
    return (getIsDirectReference());
}

bool MultiDigitizedRoadReference::isCounterpartReferenceSet() const
{
    return m_counterpartReference_.hasValue();
}

void MultiDigitizedRoadReference::resetCounterpartReference()
{
    m_counterpartReference_.reset();
}

::nds::road::reference::types::RoadReferenceIndirect& MultiDigitizedRoadReference::getCounterpartReferenceIndirect()
{
    return m_counterpartReferenceIndirect_.value();
}

const ::nds::road::reference::types::RoadReferenceIndirect& MultiDigitizedRoadReference::getCounterpartReferenceIndirect() const
{
    return m_counterpartReferenceIndirect_.value();
}

void MultiDigitizedRoadReference::setCounterpartReferenceIndirect(const ::nds::road::reference::types::RoadReferenceIndirect& counterpartReferenceIndirect_)
{
    m_counterpartReferenceIndirect_ = counterpartReferenceIndirect_;
}

void MultiDigitizedRoadReference::setCounterpartReferenceIndirect(::nds::road::reference::types::RoadReferenceIndirect&& counterpartReferenceIndirect_)
{
    m_counterpartReferenceIndirect_ = ::std::move(counterpartReferenceIndirect_);
}

bool MultiDigitizedRoadReference::isCounterpartReferenceIndirectUsed() const
{
    return (!getIsDirectReference());
}

bool MultiDigitizedRoadReference::isCounterpartReferenceIndirectSet() const
{
    return m_counterpartReferenceIndirect_.hasValue();
}

void MultiDigitizedRoadReference::resetCounterpartReferenceIndirect()
{
    m_counterpartReferenceIndirect_.reset();
}

void MultiDigitizedRoadReference::initPackingContext(MultiDigitizedRoadReference::ZserioPackingContext& context) const
{
    if (getIsDirectReference())
    {
        m_counterpartReference_.value().initPackingContext(context.getCounterpartReference());
    }
    if (!getIsDirectReference())
    {
        m_counterpartReferenceIndirect_.value().initPackingContext(context.getCounterpartReferenceIndirect());
    }
}

size_t MultiDigitizedRoadReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirectReference())
    {
        endBitPosition += m_counterpartReference_.value().bitSizeOf(endBitPosition);
    }
    if (!getIsDirectReference())
    {
        endBitPosition += m_counterpartReferenceIndirect_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t MultiDigitizedRoadReference::bitSizeOf(MultiDigitizedRoadReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirectReference())
    {
        endBitPosition += m_counterpartReference_.value().bitSizeOf(context.getCounterpartReference(), endBitPosition);
    }
    if (!getIsDirectReference())
    {
        endBitPosition += m_counterpartReferenceIndirect_.value().bitSizeOf(context.getCounterpartReferenceIndirect(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t MultiDigitizedRoadReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirectReference())
    {
        endBitPosition = m_counterpartReference_.value().initializeOffsets(endBitPosition);
    }
    if (!getIsDirectReference())
    {
        endBitPosition = m_counterpartReferenceIndirect_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t MultiDigitizedRoadReference::initializeOffsets(MultiDigitizedRoadReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirectReference())
    {
        endBitPosition = m_counterpartReference_.value().initializeOffsets(context.getCounterpartReference(), endBitPosition);
    }
    if (!getIsDirectReference())
    {
        endBitPosition = m_counterpartReferenceIndirect_.value().initializeOffsets(context.getCounterpartReferenceIndirect(), endBitPosition);
    }

    return endBitPosition;
}

bool MultiDigitizedRoadReference::operator==(const MultiDigitizedRoadReference& other) const
{
    if (this != &other)
    {
        return
                (m_isDirectReference_ == other.m_isDirectReference_) &&
                (!isCounterpartReferenceUsed() ? !other.isCounterpartReferenceUsed() : (m_counterpartReference_ == other.m_counterpartReference_)) &&
                (!isCounterpartReferenceIndirectUsed() ? !other.isCounterpartReferenceIndirectUsed() : (m_counterpartReferenceIndirect_ == other.m_counterpartReferenceIndirect_));
    }

    return true;
}

uint32_t MultiDigitizedRoadReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_isDirectReference_);
    if (isCounterpartReferenceUsed())
        result = ::zserio::calcHashCode(result, m_counterpartReference_);
    if (isCounterpartReferenceIndirectUsed())
        result = ::zserio::calcHashCode(result, m_counterpartReferenceIndirect_);

    return result;
}

void MultiDigitizedRoadReference::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirectReference_);
    if (getIsDirectReference())
    {
        m_counterpartReference_.value().write(out);
    }
    if (!getIsDirectReference())
    {
        m_counterpartReferenceIndirect_.value().write(out);
    }
}

void MultiDigitizedRoadReference::write(MultiDigitizedRoadReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirectReference_);
    if (getIsDirectReference())
    {
        m_counterpartReference_.value().write(context.getCounterpartReference(), out);
    }
    if (!getIsDirectReference())
    {
        m_counterpartReferenceIndirect_.value().write(context.getCounterpartReferenceIndirect(), out);
    }
}

bool MultiDigitizedRoadReference::readIsDirectReference(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference> MultiDigitizedRoadReference::readCounterpartReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getIsDirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference>(::nds::road::reference::types::RoadReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference> MultiDigitizedRoadReference::readCounterpartReference(MultiDigitizedRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getIsDirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference>(::nds::road::reference::types::RoadReference(context.getCounterpartReference(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect> MultiDigitizedRoadReference::readCounterpartReferenceIndirect(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getIsDirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect>(::nds::road::reference::types::RoadReferenceIndirect(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect> MultiDigitizedRoadReference::readCounterpartReferenceIndirect(MultiDigitizedRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getIsDirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect>(::nds::road::reference::types::RoadReferenceIndirect(context.getCounterpartReferenceIndirect(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect>(::zserio::NullOpt);
}

} // namespace types
} // namespace characteristics
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/characteristics/types/MultiDigitizedLaneGroupReference.h>

namespace nds
{
namespace characteristics
{
namespace types
{

MultiDigitizedLaneGroupReference::MultiDigitizedLaneGroupReference(const allocator_type&) noexcept :
        m_isDirectReference_(bool()),
        m_counterpartReference_(::zserio::NullOpt),
        m_counterpartReferenceIndirect_(::zserio::NullOpt)
{
}

MultiDigitizedLaneGroupReference::MultiDigitizedLaneGroupReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_isDirectReference_(readIsDirectReference(in)),
        m_counterpartReference_(readCounterpartReference(in, allocator)),
        m_counterpartReferenceIndirect_(readCounterpartReferenceIndirect(in, allocator))
{
}

MultiDigitizedLaneGroupReference::MultiDigitizedLaneGroupReference(MultiDigitizedLaneGroupReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_isDirectReference_(readIsDirectReference(in)),
        m_counterpartReference_(readCounterpartReference(context, in, allocator)),
        m_counterpartReferenceIndirect_(readCounterpartReferenceIndirect(context, in, allocator))
{
}

MultiDigitizedLaneGroupReference::MultiDigitizedLaneGroupReference(::zserio::PropagateAllocatorT,
        const MultiDigitizedLaneGroupReference& other, const allocator_type& allocator) :
        m_isDirectReference_(::zserio::allocatorPropagatingCopy(other.m_isDirectReference_, allocator)),
        m_counterpartReference_(::zserio::allocatorPropagatingCopy(other.m_counterpartReference_, allocator)),
        m_counterpartReferenceIndirect_(::zserio::allocatorPropagatingCopy(other.m_counterpartReferenceIndirect_, allocator))
{
}

void MultiDigitizedLaneGroupReference::initializeChildren()
{
    if (!getIsDirectReference())
        m_counterpartReferenceIndirect_.value().initializeChildren();
}

bool MultiDigitizedLaneGroupReference::getIsDirectReference() const
{
    return m_isDirectReference_;
}

void MultiDigitizedLaneGroupReference::setIsDirectReference(bool isDirectReference_)
{
    m_isDirectReference_ = isDirectReference_;
}

::nds::lane::reference::types::LaneGroupId& MultiDigitizedLaneGroupReference::getCounterpartReference()
{
    return m_counterpartReference_.value();
}

const ::nds::lane::reference::types::LaneGroupId& MultiDigitizedLaneGroupReference::getCounterpartReference() const
{
    return m_counterpartReference_.value();
}

void MultiDigitizedLaneGroupReference::setCounterpartReference(const ::nds::lane::reference::types::LaneGroupId& counterpartReference_)
{
    m_counterpartReference_ = counterpartReference_;
}

void MultiDigitizedLaneGroupReference::setCounterpartReference(::nds::lane::reference::types::LaneGroupId&& counterpartReference_)
{
    m_counterpartReference_ = ::std::move(counterpartReference_);
}

bool MultiDigitizedLaneGroupReference::isCounterpartReferenceUsed() const
{
    return (getIsDirectReference());
}

bool MultiDigitizedLaneGroupReference::isCounterpartReferenceSet() const
{
    return m_counterpartReference_.hasValue();
}

void MultiDigitizedLaneGroupReference::resetCounterpartReference()
{
    m_counterpartReference_.reset();
}

::nds::lane::reference::types::LaneGroupReferenceIndirect& MultiDigitizedLaneGroupReference::getCounterpartReferenceIndirect()
{
    return m_counterpartReferenceIndirect_.value();
}

const ::nds::lane::reference::types::LaneGroupReferenceIndirect& MultiDigitizedLaneGroupReference::getCounterpartReferenceIndirect() const
{
    return m_counterpartReferenceIndirect_.value();
}

void MultiDigitizedLaneGroupReference::setCounterpartReferenceIndirect(const ::nds::lane::reference::types::LaneGroupReferenceIndirect& counterpartReferenceIndirect_)
{
    m_counterpartReferenceIndirect_ = counterpartReferenceIndirect_;
}

void MultiDigitizedLaneGroupReference::setCounterpartReferenceIndirect(::nds::lane::reference::types::LaneGroupReferenceIndirect&& counterpartReferenceIndirect_)
{
    m_counterpartReferenceIndirect_ = ::std::move(counterpartReferenceIndirect_);
}

bool MultiDigitizedLaneGroupReference::isCounterpartReferenceIndirectUsed() const
{
    return (!getIsDirectReference());
}

bool MultiDigitizedLaneGroupReference::isCounterpartReferenceIndirectSet() const
{
    return m_counterpartReferenceIndirect_.hasValue();
}

void MultiDigitizedLaneGroupReference::resetCounterpartReferenceIndirect()
{
    m_counterpartReferenceIndirect_.reset();
}

void MultiDigitizedLaneGroupReference::initPackingContext(MultiDigitizedLaneGroupReference::ZserioPackingContext& context) const
{
    if (getIsDirectReference())
    {
        m_counterpartReference_.value().initPackingContext(context.getCounterpartReference());
    }
    if (!getIsDirectReference())
    {
        m_counterpartReferenceIndirect_.value().initPackingContext(context.getCounterpartReferenceIndirect());
    }
}

size_t MultiDigitizedLaneGroupReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirectReference())
    {
        endBitPosition += m_counterpartReference_.value().bitSizeOf(endBitPosition);
    }
    if (!getIsDirectReference())
    {
        endBitPosition += m_counterpartReferenceIndirect_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t MultiDigitizedLaneGroupReference::bitSizeOf(MultiDigitizedLaneGroupReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirectReference())
    {
        endBitPosition += m_counterpartReference_.value().bitSizeOf(context.getCounterpartReference(), endBitPosition);
    }
    if (!getIsDirectReference())
    {
        endBitPosition += m_counterpartReferenceIndirect_.value().bitSizeOf(context.getCounterpartReferenceIndirect(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t MultiDigitizedLaneGroupReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirectReference())
    {
        endBitPosition = m_counterpartReference_.value().initializeOffsets(endBitPosition);
    }
    if (!getIsDirectReference())
    {
        endBitPosition = m_counterpartReferenceIndirect_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t MultiDigitizedLaneGroupReference::initializeOffsets(MultiDigitizedLaneGroupReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirectReference())
    {
        endBitPosition = m_counterpartReference_.value().initializeOffsets(context.getCounterpartReference(), endBitPosition);
    }
    if (!getIsDirectReference())
    {
        endBitPosition = m_counterpartReferenceIndirect_.value().initializeOffsets(context.getCounterpartReferenceIndirect(), endBitPosition);
    }

    return endBitPosition;
}

bool MultiDigitizedLaneGroupReference::operator==(const MultiDigitizedLaneGroupReference& other) const
{
    if (this != &other)
    {
        return
                (m_isDirectReference_ == other.m_isDirectReference_) &&
                (!isCounterpartReferenceUsed() ? !other.isCounterpartReferenceUsed() : (m_counterpartReference_ == other.m_counterpartReference_)) &&
                (!isCounterpartReferenceIndirectUsed() ? !other.isCounterpartReferenceIndirectUsed() : (m_counterpartReferenceIndirect_ == other.m_counterpartReferenceIndirect_));
    }

    return true;
}

uint32_t MultiDigitizedLaneGroupReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_isDirectReference_);
    if (isCounterpartReferenceUsed())
        result = ::zserio::calcHashCode(result, m_counterpartReference_);
    if (isCounterpartReferenceIndirectUsed())
        result = ::zserio::calcHashCode(result, m_counterpartReferenceIndirect_);

    return result;
}

void MultiDigitizedLaneGroupReference::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirectReference_);
    if (getIsDirectReference())
    {
        m_counterpartReference_.value().write(out);
    }
    if (!getIsDirectReference())
    {
        m_counterpartReferenceIndirect_.value().write(out);
    }
}

void MultiDigitizedLaneGroupReference::write(MultiDigitizedLaneGroupReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirectReference_);
    if (getIsDirectReference())
    {
        m_counterpartReference_.value().write(context.getCounterpartReference(), out);
    }
    if (!getIsDirectReference())
    {
        m_counterpartReferenceIndirect_.value().write(context.getCounterpartReferenceIndirect(), out);
    }
}

bool MultiDigitizedLaneGroupReference::readIsDirectReference(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId> MultiDigitizedLaneGroupReference::readCounterpartReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getIsDirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId>(::nds::lane::reference::types::LaneGroupId(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId> MultiDigitizedLaneGroupReference::readCounterpartReference(MultiDigitizedLaneGroupReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getIsDirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId>(::nds::lane::reference::types::LaneGroupId(context.getCounterpartReference(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupReferenceIndirect> MultiDigitizedLaneGroupReference::readCounterpartReferenceIndirect(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getIsDirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupReferenceIndirect>(::nds::lane::reference::types::LaneGroupReferenceIndirect(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupReferenceIndirect>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupReferenceIndirect> MultiDigitizedLaneGroupReference::readCounterpartReferenceIndirect(MultiDigitizedLaneGroupReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getIsDirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupReferenceIndirect>(::nds::lane::reference::types::LaneGroupReferenceIndirect(context.getCounterpartReferenceIndirect(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupReferenceIndirect>(::zserio::NullOpt);
}

} // namespace types
} // namespace characteristics
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/characteristics/types/RoadLocationAssignment.h>

namespace nds
{
namespace characteristics
{
namespace types
{

RoadLocationAssignment::RoadLocationAssignment(const allocator_type& allocator) noexcept :
        m_locationId_(allocator),
        m_sameDirectionAsSource_(bool()),
        m_completeLocation_(bool()),
        m_startOnLocation_(::zserio::NullOpt),
        m_endOnLocation_(::zserio::NullOpt)
{
}

RoadLocationAssignment::RoadLocationAssignment(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_locationId_(readLocationId(in, allocator)),
        m_sameDirectionAsSource_(readSameDirectionAsSource(in)),
        m_completeLocation_(readCompleteLocation(in)),
        m_startOnLocation_(readStartOnLocation(in)),
        m_endOnLocation_(readEndOnLocation(in))
{
}

RoadLocationAssignment::RoadLocationAssignment(RoadLocationAssignment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_locationId_(readLocationId(context, in, allocator)),
        m_sameDirectionAsSource_(readSameDirectionAsSource(in)),
        m_completeLocation_(readCompleteLocation(in)),
        m_startOnLocation_(readStartOnLocation(context, in)),
        m_endOnLocation_(readEndOnLocation(context, in))
{
}

RoadLocationAssignment::RoadLocationAssignment(::zserio::PropagateAllocatorT,
        const RoadLocationAssignment& other, const allocator_type& allocator) :
        m_locationId_(::zserio::allocatorPropagatingCopy(other.m_locationId_, allocator)),
        m_sameDirectionAsSource_(::zserio::allocatorPropagatingCopy(other.m_sameDirectionAsSource_, allocator)),
        m_completeLocation_(::zserio::allocatorPropagatingCopy(other.m_completeLocation_, allocator)),
        m_startOnLocation_(::zserio::allocatorPropagatingCopy(other.m_startOnLocation_, allocator)),
        m_endOnLocation_(::zserio::allocatorPropagatingCopy(other.m_endOnLocation_, allocator))
{
}

::nds::core::location::RoadLocationId& RoadLocationAssignment::getLocationId()
{
    return m_locationId_;
}

const ::nds::core::location::RoadLocationId& RoadLocationAssignment::getLocationId() const
{
    return m_locationId_;
}

void RoadLocationAssignment::setLocationId(const ::nds::core::location::RoadLocationId& locationId_)
{
    m_locationId_ = locationId_;
}

void RoadLocationAssignment::setLocationId(::nds::core::location::RoadLocationId&& locationId_)
{
    m_locationId_ = ::std::move(locationId_);
}

bool RoadLocationAssignment::getSameDirectionAsSource() const
{
    return m_sameDirectionAsSource_;
}

void RoadLocationAssignment::setSameDirectionAsSource(bool sameDirectionAsSource_)
{
    m_sameDirectionAsSource_ = sameDirectionAsSource_;
}

bool RoadLocationAssignment::getCompleteLocation() const
{
    return m_completeLocation_;
}

void RoadLocationAssignment::setCompleteLocation(bool completeLocation_)
{
    m_completeLocation_ = completeLocation_;
}

::nds::core::types::LengthCentimeters RoadLocationAssignment::getStartOnLocation() const
{
    return m_startOnLocation_.value();
}

void RoadLocationAssignment::setStartOnLocation(::nds::core::types::LengthCentimeters startOnLocation_)
{
    m_startOnLocation_ = startOnLocation_;
}

bool RoadLocationAssignment::isStartOnLocationUsed() const
{
    return (!getCompleteLocation());
}

bool RoadLocationAssignment::isStartOnLocationSet() const
{
    return m_startOnLocation_.hasValue();
}

void RoadLocationAssignment::resetStartOnLocation()
{
    m_startOnLocation_.reset();
}

::nds::core::types::LengthCentimeters RoadLocationAssignment::getEndOnLocation() const
{
    return m_endOnLocation_.value();
}

void RoadLocationAssignment::setEndOnLocation(::nds::core::types::LengthCentimeters endOnLocation_)
{
    m_endOnLocation_ = endOnLocation_;
}

bool RoadLocationAssignment::isEndOnLocationUsed() const
{
    return (!getCompleteLocation());
}

bool RoadLocationAssignment::isEndOnLocationSet() const
{
    return m_endOnLocation_.hasValue();
}

void RoadLocationAssignment::resetEndOnLocation()
{
    m_endOnLocation_.reset();
}

void RoadLocationAssignment::initPackingContext(RoadLocationAssignment::ZserioPackingContext& context) const
{
    m_locationId_.initPackingContext(context.getLocationId());
    if (!getCompleteLocation())
    {
        context.getStartOnLocation().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_startOnLocation_.value());
    }
    if (!getCompleteLocation())
    {
        context.getEndOnLocation().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_endOnLocation_.value());
    }
}

size_t RoadLocationAssignment::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_locationId_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (!getCompleteLocation())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_startOnLocation_.value());
    }
    if (!getCompleteLocation())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_endOnLocation_.value());
    }

    return endBitPosition - bitPosition;
}

size_t RoadLocationAssignment::bitSizeOf(RoadLocationAssignment::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_locationId_.bitSizeOf(context.getLocationId(), endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (!getCompleteLocation())
    {
        endBitPosition += context.getStartOnLocation().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_startOnLocation_.value());
    }
    if (!getCompleteLocation())
    {
        endBitPosition += context.getEndOnLocation().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_endOnLocation_.value());
    }

    return endBitPosition - bitPosition;
}

size_t RoadLocationAssignment::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_locationId_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (!getCompleteLocation())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_startOnLocation_.value());
    }
    if (!getCompleteLocation())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_endOnLocation_.value());
    }

    return endBitPosition;
}

size_t RoadLocationAssignment::initializeOffsets(RoadLocationAssignment::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_locationId_.initializeOffsets(context.getLocationId(), endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (!getCompleteLocation())
    {
        endBitPosition += context.getStartOnLocation().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_startOnLocation_.value());
    }
    if (!getCompleteLocation())
    {
        endBitPosition += context.getEndOnLocation().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_endOnLocation_.value());
    }

    return endBitPosition;
}

bool RoadLocationAssignment::operator==(const RoadLocationAssignment& other) const
{
    if (this != &other)
    {
        return
                (m_locationId_ == other.m_locationId_) &&
                (m_sameDirectionAsSource_ == other.m_sameDirectionAsSource_) &&
                (m_completeLocation_ == other.m_completeLocation_) &&
                (!isStartOnLocationUsed() ? !other.isStartOnLocationUsed() : (m_startOnLocation_ == other.m_startOnLocation_)) &&
                (!isEndOnLocationUsed() ? !other.isEndOnLocationUsed() : (m_endOnLocation_ == other.m_endOnLocation_));
    }

    return true;
}

uint32_t RoadLocationAssignment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_locationId_);
    result = ::zserio::calcHashCode(result, m_sameDirectionAsSource_);
    result = ::zserio::calcHashCode(result, m_completeLocation_);
    if (isStartOnLocationUsed())
        result = ::zserio::calcHashCode(result, m_startOnLocation_);
    if (isEndOnLocationUsed())
        result = ::zserio::calcHashCode(result, m_endOnLocation_);

    return result;
}

void RoadLocationAssignment::write(::zserio::BitStreamWriter& out) const
{
    m_locationId_.write(out);

    out.writeBool(m_sameDirectionAsSource_);

    out.writeBool(m_completeLocation_);

    if (!getCompleteLocation())
    {
        out.writeVarUInt32(m_startOnLocation_.value());
    }

    if (!getCompleteLocation())
    {
        // check constraint
        if (!(getEndOnLocation() >= getStartOnLocation()))
            throw ::zserio::ConstraintException("Write: Constraint violated at RoadLocationAssignment.endOnLocation!");
        out.writeVarUInt32(m_endOnLocation_.value());
    }
}

void RoadLocationAssignment::write(RoadLocationAssignment::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_locationId_.write(context.getLocationId(), out);

    out.writeBool(m_sameDirectionAsSource_);

    out.writeBool(m_completeLocation_);

    if (!getCompleteLocation())
    {
        context.getStartOnLocation().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(out, m_startOnLocation_.value());
    }

    if (!getCompleteLocation())
    {
        // check constraint
        if (!(getEndOnLocation() >= getStartOnLocation()))
            throw ::zserio::ConstraintException("Write: Constraint violated at RoadLocationAssignment.endOnLocation!");
        context.getEndOnLocation().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(out, m_endOnLocation_.value());
    }
}

::nds::core::location::RoadLocationId RoadLocationAssignment::readLocationId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(in, allocator);
}

::nds::core::location::RoadLocationId RoadLocationAssignment::readLocationId(RoadLocationAssignment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(context.getLocationId(), in, allocator);
}
bool RoadLocationAssignment::readSameDirectionAsSource(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool RoadLocationAssignment::readCompleteLocation(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters> RoadLocationAssignment::readStartOnLocation(::zserio::BitStreamReader& in)
{
    if (!getCompleteLocation())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters>(static_cast<::nds::core::types::LengthCentimeters>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters> RoadLocationAssignment::readStartOnLocation(RoadLocationAssignment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (!getCompleteLocation())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters>(context.getStartOnLocation().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters> RoadLocationAssignment::readEndOnLocation(::zserio::BitStreamReader& in)
{
    if (!getCompleteLocation())
    {
        ::nds::core::types::LengthCentimeters readField = static_cast<::nds::core::types::LengthCentimeters>(in.readVarUInt32());
        // check constraint
        if (!(readField >= getStartOnLocation()))
            throw ::zserio::ConstraintException("Read: Constraint violated at RoadLocationAssignment.endOnLocation!");

        return ::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters> RoadLocationAssignment::readEndOnLocation(RoadLocationAssignment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (!getCompleteLocation())
    {
        ::nds::core::types::LengthCentimeters readField = context.getEndOnLocation().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(in);
        // check constraint
        if (!(readField >= getStartOnLocation()))
            throw ::zserio::ConstraintException("Read: Constraint violated at RoadLocationAssignment.endOnLocation!");

        return ::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::LengthCentimeters>(::zserio::NullOpt);
}

} // namespace types
} // namespace characteristics
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/characteristics/types/TollPayment.h>

namespace nds
{
namespace characteristics
{
namespace types
{

TollPayment::TollPayment(const allocator_type&) noexcept :
        m_type_(::nds::characteristics::types::TollPaymentType()),
        m_provider_(::zserio::NullOpt)
{
}

TollPayment::TollPayment(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_provider_(readProvider(in, allocator))
{
}

TollPayment::TollPayment(TollPayment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_provider_(readProvider(in, allocator))
{
}

TollPayment::TollPayment(::zserio::PropagateAllocatorT,
        const TollPayment& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_provider_(::zserio::allocatorPropagatingCopy(other.m_provider_, allocator))
{
}

::nds::characteristics::types::TollPaymentType TollPayment::getType() const
{
    return m_type_;
}

void TollPayment::setType(::nds::characteristics::types::TollPaymentType type_)
{
    m_type_ = type_;
}

::zserio::vector<::nds::characteristics::types::TollPaymentProvider>& TollPayment::getProvider()
{
    return m_provider_.value().getRawArray();
}

const ::zserio::vector<::nds::characteristics::types::TollPaymentProvider>& TollPayment::getProvider() const
{
    return m_provider_.value().getRawArray();
}

void TollPayment::setProvider(const ::zserio::vector<::nds::characteristics::types::TollPaymentProvider>& provider_)
{
    m_provider_ = ZserioArrayType_provider(provider_);
}

void TollPayment::setProvider(::zserio::vector<::nds::characteristics::types::TollPaymentProvider>&& provider_)
{
    m_provider_ = ZserioArrayType_provider(std::move(provider_));
}

bool TollPayment::isProviderUsed() const
{
    return (isProviderSet());
}

bool TollPayment::isProviderSet() const
{
    return m_provider_.hasValue();
}

void TollPayment::resetProvider()
{
    m_provider_.reset();
}

void TollPayment::initPackingContext(TollPayment::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
}

size_t TollPayment::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += 1;
    if (isProviderSet())
    {
        endBitPosition += m_provider_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TollPayment::bitSizeOf(TollPayment::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += 1;
    if (isProviderSet())
    {
        endBitPosition += m_provider_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TollPayment::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += 1;
    if (isProviderSet())
    {
        endBitPosition = m_provider_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t TollPayment::initializeOffsets(TollPayment::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += 1;
    if (isProviderSet())
    {
        endBitPosition = m_provider_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

bool TollPayment::operator==(const TollPayment& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isProviderUsed() ? !other.isProviderUsed() : (m_provider_ == other.m_provider_));
    }

    return true;
}

uint32_t TollPayment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isProviderUsed())
        result = ::zserio::calcHashCode(result, m_provider_);

    return result;
}

void TollPayment::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    if (isProviderSet())
    {
        out.writeBool(true);
        m_provider_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void TollPayment::write(TollPayment::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    if (isProviderSet())
    {
        out.writeBool(true);
        m_provider_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::characteristics::types::TollPaymentType TollPayment::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::characteristics::types::TollPaymentType>(in);
}

::nds::characteristics::types::TollPaymentType TollPayment::readType(TollPayment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::characteristics::types::TollPaymentType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<TollPayment::ZserioArrayType_provider> TollPayment::readProvider(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_provider readField(allocator);
        readField.read(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_provider>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_provider>(::zserio::NullOpt);
}

} // namespace types
} // namespace characteristics
} // namespace nds
