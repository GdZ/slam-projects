/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/PoiRelationType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PoiRelationType enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::poi::types::PoiRelationType>::names;
constexpr ::std::array<::nds::poi::types::PoiRelationType, 7> EnumTraits<::nds::poi::types::PoiRelationType>::values;
constexpr const char* EnumTraits<::nds::poi::types::PoiRelationType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::PoiRelationType value)
{
    switch (value)
    {
    case ::nds::poi::types::PoiRelationType::PART:
        return 0;
    case ::nds::poi::types::PoiRelationType::ACCESS:
        return 1;
    case ::nds::poi::types::PoiRelationType::ACTIVATION:
        return 2;
    case ::nds::poi::types::PoiRelationType::LOGICAL_ACCESS:
        return 3;
    case ::nds::poi::types::PoiRelationType::GUIDANCE_POINT:
        return 4;
    case ::nds::poi::types::PoiRelationType::CONNECTED:
        return 5;
    case ::nds::poi::types::PoiRelationType::PREFERRED:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PoiRelationType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::PoiRelationType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::PoiRelationType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::PoiRelationType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::poi::types::PoiRelationType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PoiRelationType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::PoiRelationType>(::nds::poi::types::PoiRelationType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::PoiRelationType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::PoiRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::PoiRelationType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::PoiRelationType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::PoiRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::PoiRelationType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::PoiRelationType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::PoiRelationType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::PoiRelationType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::PoiRelationType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::poi::types::PoiRelationType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::PoiRelationType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::PoiRelationType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::PoiRelationType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::PoiRelationType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::PoiRelationType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/AccessPointType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AccessPointType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::poi::types::AccessPointType>::names;
constexpr ::std::array<::nds::poi::types::AccessPointType, 3> EnumTraits<::nds::poi::types::AccessPointType>::values;
constexpr const char* EnumTraits<::nds::poi::types::AccessPointType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::AccessPointType value)
{
    switch (value)
    {
    case ::nds::poi::types::AccessPointType::ENTRY:
        return 0;
    case ::nds::poi::types::AccessPointType::EXIT:
        return 1;
    case ::nds::poi::types::AccessPointType::BOTH:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AccessPointType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::AccessPointType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::AccessPointType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::AccessPointType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::poi::types::AccessPointType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AccessPointType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::AccessPointType>(::nds::poi::types::AccessPointType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::AccessPointType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::AccessPointType)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::AccessPointType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::AccessPointType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::AccessPointType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::AccessPointType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::AccessPointType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::AccessPointType>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::poi::types::AccessPointType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::AccessPointType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointType>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::AccessPointType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::AccessPointType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointType>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/AccessPointMethod.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AccessPointMethod enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::poi::types::AccessPointMethod>::names;
constexpr ::std::array<::nds::poi::types::AccessPointMethod, 3> EnumTraits<::nds::poi::types::AccessPointMethod>::values;
constexpr const char* EnumTraits<::nds::poi::types::AccessPointMethod>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::AccessPointMethod value)
{
    switch (value)
    {
    case ::nds::poi::types::AccessPointMethod::STAIRS:
        return 0;
    case ::nds::poi::types::AccessPointMethod::ESCALATOR:
        return 1;
    case ::nds::poi::types::AccessPointMethod::ELEVATOR:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AccessPointMethod: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::AccessPointMethod>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::AccessPointMethod valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::AccessPointMethod>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::poi::types::AccessPointMethod>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AccessPointMethod: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::AccessPointMethod>(::nds::poi::types::AccessPointMethod value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::AccessPointMethod value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointMethod>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::AccessPointMethod)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::AccessPointMethod value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointMethod>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::AccessPointMethod value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::AccessPointMethod value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::AccessPointMethod read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::AccessPointMethod>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::AccessPointMethod>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::poi::types::AccessPointMethod read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::AccessPointMethod>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointMethod>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::AccessPointMethod value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::AccessPointMethod value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointMethod>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/AccessPointLevel.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AccessPointLevel enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::poi::types::AccessPointLevel>::names;
constexpr ::std::array<::nds::poi::types::AccessPointLevel, 3> EnumTraits<::nds::poi::types::AccessPointLevel>::values;
constexpr const char* EnumTraits<::nds::poi::types::AccessPointLevel>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::AccessPointLevel value)
{
    switch (value)
    {
    case ::nds::poi::types::AccessPointLevel::ABOVE_STREET_LEVEL:
        return 0;
    case ::nds::poi::types::AccessPointLevel::BELOW_STREET_LEVEL:
        return 1;
    case ::nds::poi::types::AccessPointLevel::AT_STREET_LEVEL:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AccessPointLevel: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::AccessPointLevel>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::AccessPointLevel valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::AccessPointLevel>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::poi::types::AccessPointLevel>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AccessPointLevel: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::AccessPointLevel>(::nds::poi::types::AccessPointLevel value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::AccessPointLevel value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointLevel>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::AccessPointLevel)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::AccessPointLevel value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointLevel>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::AccessPointLevel value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::AccessPointLevel value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::AccessPointLevel read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::AccessPointLevel>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::AccessPointLevel>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::poi::types::AccessPointLevel read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::AccessPointLevel>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointLevel>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::AccessPointLevel value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::AccessPointLevel value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AccessPointLevel>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/LogicalAccessPointType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LogicalAccessPointType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::poi::types::LogicalAccessPointType>::names;
constexpr ::std::array<::nds::poi::types::LogicalAccessPointType, 5> EnumTraits<::nds::poi::types::LogicalAccessPointType>::values;
constexpr const char* EnumTraits<::nds::poi::types::LogicalAccessPointType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::LogicalAccessPointType value)
{
    switch (value)
    {
    case ::nds::poi::types::LogicalAccessPointType::SERVICE:
        return 0;
    case ::nds::poi::types::LogicalAccessPointType::CONTROLLED_ACCESS_EXIT:
        return 1;
    case ::nds::poi::types::LogicalAccessPointType::SERVICE_AREA:
        return 2;
    case ::nds::poi::types::LogicalAccessPointType::PARKING_AREA:
        return 3;
    case ::nds::poi::types::LogicalAccessPointType::SMART_IC:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LogicalAccessPointType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::LogicalAccessPointType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::LogicalAccessPointType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::LogicalAccessPointType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::poi::types::LogicalAccessPointType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LogicalAccessPointType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::LogicalAccessPointType>(::nds::poi::types::LogicalAccessPointType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::LogicalAccessPointType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::LogicalAccessPointType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::LogicalAccessPointType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::LogicalAccessPointType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::LogicalAccessPointType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::LogicalAccessPointType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::LogicalAccessPointType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::LogicalAccessPointType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::LogicalAccessPointType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::LogicalAccessPointType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::poi::types::LogicalAccessPointType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::LogicalAccessPointType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::LogicalAccessPointType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::LogicalAccessPointType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::LogicalAccessPointType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::LogicalAccessPointType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/NameStringUsageType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameStringUsageType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::poi::types::NameStringUsageType>::names;
constexpr ::std::array<::nds::poi::types::NameStringUsageType, 4> EnumTraits<::nds::poi::types::NameStringUsageType>::values;
constexpr const char* EnumTraits<::nds::poi::types::NameStringUsageType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::NameStringUsageType value)
{
    switch (value)
    {
    case ::nds::poi::types::NameStringUsageType::DEFAULT_OFFICIAL_NAME:
        return 0;
    case ::nds::poi::types::NameStringUsageType::OFFICIAL_NAME:
        return 1;
    case ::nds::poi::types::NameStringUsageType::PREFERRED_ALTERNATE_NAME:
        return 2;
    case ::nds::poi::types::NameStringUsageType::ALTERNATE_NAME:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameStringUsageType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::NameStringUsageType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::NameStringUsageType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::NameStringUsageType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::poi::types::NameStringUsageType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameStringUsageType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::NameStringUsageType>(::nds::poi::types::NameStringUsageType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::NameStringUsageType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::NameStringUsageType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::NameStringUsageType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::NameStringUsageType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::NameStringUsageType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::NameStringUsageType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::NameStringUsageType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::NameStringUsageType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::NameStringUsageType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::NameStringUsageType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::poi::types::NameStringUsageType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::NameStringUsageType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::NameStringUsageType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::NameStringUsageType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::NameStringUsageType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::NameStringUsageType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/NameStringRelationType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameStringRelationType enumeration.
constexpr ::std::array<const char*, 8> EnumTraits<::nds::poi::types::NameStringRelationType>::names;
constexpr ::std::array<::nds::poi::types::NameStringRelationType, 8> EnumTraits<::nds::poi::types::NameStringRelationType>::values;
constexpr const char* EnumTraits<::nds::poi::types::NameStringRelationType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::NameStringRelationType value)
{
    switch (value)
    {
    case ::nds::poi::types::NameStringRelationType::SYNONYM:
        return 0;
    case ::nds::poi::types::NameStringRelationType::TRANSLITERATION:
        return 1;
    case ::nds::poi::types::NameStringRelationType::BASE_NAME:
        return 2;
    case ::nds::poi::types::NameStringRelationType::FIRST_LETTER_INPUT:
        return 3;
    case ::nds::poi::types::NameStringRelationType::EXONYM:
        return 4;
    case ::nds::poi::types::NameStringRelationType::ALTERNATE_SPELLING:
        return 5;
    case ::nds::poi::types::NameStringRelationType::NO_RELATION:
        return 6;
    case ::nds::poi::types::NameStringRelationType::ABBREVIATION:
        return 7;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameStringRelationType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::NameStringRelationType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::NameStringRelationType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::NameStringRelationType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
        return static_cast<::nds::poi::types::NameStringRelationType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameStringRelationType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::NameStringRelationType>(::nds::poi::types::NameStringRelationType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::NameStringRelationType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::NameStringRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::NameStringRelationType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::NameStringRelationType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::NameStringRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::NameStringRelationType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::NameStringRelationType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::NameStringRelationType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::NameStringRelationType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::NameStringRelationType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::poi::types::NameStringRelationType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::NameStringRelationType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::NameStringRelationType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::NameStringRelationType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::NameStringRelationType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::NameStringRelationType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/PriceRange.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PriceRange enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::poi::types::PriceRange>::names;
constexpr ::std::array<::nds::poi::types::PriceRange, 3> EnumTraits<::nds::poi::types::PriceRange>::values;
constexpr const char* EnumTraits<::nds::poi::types::PriceRange>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::PriceRange value)
{
    switch (value)
    {
    case ::nds::poi::types::PriceRange::MODERATE:
        return 0;
    case ::nds::poi::types::PriceRange::REGULAR:
        return 1;
    case ::nds::poi::types::PriceRange::EXPENSIVE:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PriceRange: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::PriceRange>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::PriceRange valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::PriceRange>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::poi::types::PriceRange>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PriceRange: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::PriceRange>(::nds::poi::types::PriceRange value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::PriceRange value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::PriceRange>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::PriceRange)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::PriceRange value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::PriceRange>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::PriceRange value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::PriceRange value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::PriceRange read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::PriceRange>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::PriceRange>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::poi::types::PriceRange read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::PriceRange>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::PriceRange>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::PriceRange value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::PriceRange value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::PriceRange>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/AirportEntranceType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AirportEntranceType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::poi::types::AirportEntranceType>::names;
constexpr ::std::array<::nds::poi::types::AirportEntranceType, 3> EnumTraits<::nds::poi::types::AirportEntranceType>::values;
constexpr const char* EnumTraits<::nds::poi::types::AirportEntranceType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::AirportEntranceType value)
{
    switch (value)
    {
    case ::nds::poi::types::AirportEntranceType::MAIN:
        return 0;
    case ::nds::poi::types::AirportEntranceType::TERMINAL:
        return 1;
    case ::nds::poi::types::AirportEntranceType::BOTH:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AirportEntranceType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::AirportEntranceType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::AirportEntranceType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::AirportEntranceType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::poi::types::AirportEntranceType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AirportEntranceType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::AirportEntranceType>(::nds::poi::types::AirportEntranceType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::AirportEntranceType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AirportEntranceType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::AirportEntranceType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::AirportEntranceType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AirportEntranceType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::AirportEntranceType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::AirportEntranceType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::AirportEntranceType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::AirportEntranceType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::AirportEntranceType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::poi::types::AirportEntranceType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::AirportEntranceType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AirportEntranceType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::AirportEntranceType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::AirportEntranceType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::AirportEntranceType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/DepartureArrivalService.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DepartureArrivalService enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::poi::types::DepartureArrivalService>::names;
constexpr ::std::array<::nds::poi::types::DepartureArrivalService, 2> EnumTraits<::nds::poi::types::DepartureArrivalService>::values;
constexpr const char* EnumTraits<::nds::poi::types::DepartureArrivalService>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::DepartureArrivalService value)
{
    switch (value)
    {
    case ::nds::poi::types::DepartureArrivalService::DEPARTURE:
        return 0;
    case ::nds::poi::types::DepartureArrivalService::ARRIVAL:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DepartureArrivalService: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::DepartureArrivalService>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::DepartureArrivalService valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::DepartureArrivalService>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::poi::types::DepartureArrivalService>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DepartureArrivalService: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::DepartureArrivalService>(::nds::poi::types::DepartureArrivalService value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::DepartureArrivalService value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::DepartureArrivalService>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::DepartureArrivalService)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::DepartureArrivalService value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::DepartureArrivalService>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::DepartureArrivalService value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::DepartureArrivalService value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::DepartureArrivalService read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::DepartureArrivalService>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::DepartureArrivalService>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::poi::types::DepartureArrivalService read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::DepartureArrivalService>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::DepartureArrivalService>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::DepartureArrivalService value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::DepartureArrivalService value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::DepartureArrivalService>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/TransitType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TransitType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::poi::types::TransitType>::names;
constexpr ::std::array<::nds::poi::types::TransitType, 3> EnumTraits<::nds::poi::types::TransitType>::values;
constexpr const char* EnumTraits<::nds::poi::types::TransitType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::TransitType value)
{
    switch (value)
    {
    case ::nds::poi::types::TransitType::BUS:
        return 0;
    case ::nds::poi::types::TransitType::RAIL:
        return 1;
    case ::nds::poi::types::TransitType::BOTH:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TransitType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::TransitType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::TransitType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::TransitType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::poi::types::TransitType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TransitType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::TransitType>(::nds::poi::types::TransitType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::TransitType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::TransitType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::TransitType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::TransitType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::TransitType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::TransitType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::TransitType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::TransitType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::TransitType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::TransitType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::poi::types::TransitType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::TransitType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::TransitType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::TransitType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::TransitType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::TransitType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/HydrogenPressureAvailability.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for HydrogenPressureAvailability enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::poi::types::HydrogenPressureAvailability>::names;
constexpr ::std::array<::nds::poi::types::HydrogenPressureAvailability, 3> EnumTraits<::nds::poi::types::HydrogenPressureAvailability>::values;
constexpr const char* EnumTraits<::nds::poi::types::HydrogenPressureAvailability>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::HydrogenPressureAvailability value)
{
    switch (value)
    {
    case ::nds::poi::types::HydrogenPressureAvailability::H35:
        return 0;
    case ::nds::poi::types::HydrogenPressureAvailability::H70:
        return 1;
    case ::nds::poi::types::HydrogenPressureAvailability::BOTH:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration HydrogenPressureAvailability: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::HydrogenPressureAvailability>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::HydrogenPressureAvailability valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::HydrogenPressureAvailability>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::poi::types::HydrogenPressureAvailability>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration HydrogenPressureAvailability: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::HydrogenPressureAvailability>(::nds::poi::types::HydrogenPressureAvailability value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::HydrogenPressureAvailability value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::HydrogenPressureAvailability>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::HydrogenPressureAvailability)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::HydrogenPressureAvailability value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::HydrogenPressureAvailability>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::HydrogenPressureAvailability value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::HydrogenPressureAvailability value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::HydrogenPressureAvailability read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::HydrogenPressureAvailability>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::HydrogenPressureAvailability>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::poi::types::HydrogenPressureAvailability read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::HydrogenPressureAvailability>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::HydrogenPressureAvailability>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::HydrogenPressureAvailability value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::HydrogenPressureAvailability value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::HydrogenPressureAvailability>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/CarDealerType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for CarDealerType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::poi::types::CarDealerType>::names;
constexpr ::std::array<::nds::poi::types::CarDealerType, 3> EnumTraits<::nds::poi::types::CarDealerType>::values;
constexpr const char* EnumTraits<::nds::poi::types::CarDealerType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::CarDealerType value)
{
    switch (value)
    {
    case ::nds::poi::types::CarDealerType::SALES_FACILITY:
        return 0;
    case ::nds::poi::types::CarDealerType::REPAIR_FACILITY:
        return 1;
    case ::nds::poi::types::CarDealerType::BOTH:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration CarDealerType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::CarDealerType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::CarDealerType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::CarDealerType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::poi::types::CarDealerType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration CarDealerType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::CarDealerType>(::nds::poi::types::CarDealerType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::CarDealerType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::CarDealerType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::CarDealerType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::CarDealerType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::CarDealerType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::CarDealerType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::CarDealerType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::CarDealerType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::CarDealerType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::CarDealerType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::poi::types::CarDealerType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::CarDealerType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::CarDealerType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::CarDealerType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::CarDealerType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::CarDealerType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/EvCommunicationStandard.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for EvCommunicationStandard enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::poi::types::EvCommunicationStandard>::names;
constexpr ::std::array<::nds::poi::types::EvCommunicationStandard, 5> EnumTraits<::nds::poi::types::EvCommunicationStandard>::values;
constexpr const char* EnumTraits<::nds::poi::types::EvCommunicationStandard>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::EvCommunicationStandard value)
{
    switch (value)
    {
    case ::nds::poi::types::EvCommunicationStandard::GB_27930_11:
        return 0;
    case ::nds::poi::types::EvCommunicationStandard::GB_27930_15:
        return 1;
    case ::nds::poi::types::EvCommunicationStandard::GB_18487_1:
        return 2;
    case ::nds::poi::types::EvCommunicationStandard::GB_18487_1_11:
        return 3;
    case ::nds::poi::types::EvCommunicationStandard::GB_18487_1_15:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration EvCommunicationStandard: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::EvCommunicationStandard>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::EvCommunicationStandard valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::EvCommunicationStandard>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::poi::types::EvCommunicationStandard>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration EvCommunicationStandard: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::EvCommunicationStandard>(::nds::poi::types::EvCommunicationStandard value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::EvCommunicationStandard value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::EvCommunicationStandard>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::EvCommunicationStandard)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::EvCommunicationStandard value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::EvCommunicationStandard>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::EvCommunicationStandard value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::EvCommunicationStandard value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::EvCommunicationStandard read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::EvCommunicationStandard>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::EvCommunicationStandard>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::poi::types::EvCommunicationStandard read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::EvCommunicationStandard>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::EvCommunicationStandard>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::EvCommunicationStandard value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::EvCommunicationStandard value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::EvCommunicationStandard>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/EvConnectorType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for EvConnectorType enumeration.
constexpr ::std::array<const char*, 64> EnumTraits<::nds::poi::types::EvConnectorType>::names;
constexpr ::std::array<::nds::poi::types::EvConnectorType, 64> EnumTraits<::nds::poi::types::EvConnectorType>::values;
constexpr const char* EnumTraits<::nds::poi::types::EvConnectorType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::EvConnectorType value)
{
    switch (value)
    {
    case ::nds::poi::types::EvConnectorType::VDE_AR_E_2623_2_2:
        return 0;
    case ::nds::poi::types::EvConnectorType::SAE_J1772:
        return 1;
    case ::nds::poi::types::EvConnectorType::SMALL_PADDLE_INDUCTIVE:
        return 2;
    case ::nds::poi::types::EvConnectorType::LARGE_PADDLE_INDUCTIVE:
        return 3;
    case ::nds::poi::types::EvConnectorType::AVCON:
        return 4;
    case ::nds::poi::types::EvConnectorType::TESLA:
        return 5;
    case ::nds::poi::types::EvConnectorType::NEMA_5_20:
        return 6;
    case ::nds::poi::types::EvConnectorType::TEPCO:
        return 7;
    case ::nds::poi::types::EvConnectorType::HOUSEHOLD:
        return 8;
    case ::nds::poi::types::EvConnectorType::SINGLE_PHASE_60309:
        return 9;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T2O:
        return 10;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T3O_16A:
        return 11;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T3O_32A:
        return 12;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T3O_32A_3PHASE:
        return 13;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T1C:
        return 14;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T2C_M13:
        return 15;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T2C_M23:
        return 16;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T3C_16A:
        return 17;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T3C_32A:
        return 18;
    case ::nds::poi::types::EvConnectorType::IEC62196_2_T3C_32A_3PHASE:
        return 19;
    case ::nds::poi::types::EvConnectorType::COMBO_T1:
        return 20;
    case ::nds::poi::types::EvConnectorType::COMBO_T2:
        return 21;
    case ::nds::poi::types::EvConnectorType::GB_P2:
        return 22;
    case ::nds::poi::types::EvConnectorType::GB_P3:
        return 23;
    case ::nds::poi::types::EvConnectorType::BETTER_PLACE:
        return 24;
    case ::nds::poi::types::EvConnectorType::MARECHAL:
        return 25;
    case ::nds::poi::types::EvConnectorType::IEC309_2:
        return 26;
    case ::nds::poi::types::EvConnectorType::GBT20234_M13_1P:
        return 27;
    case ::nds::poi::types::EvConnectorType::GBT20234_M13_3P:
        return 28;
    case ::nds::poi::types::EvConnectorType::GBT20234_M3_7P:
        return 29;
    case ::nds::poi::types::EvConnectorType::GBT20234_M4_9P:
        return 30;
    case ::nds::poi::types::EvConnectorType::DC_CHADEMO:
        return 31;
    case ::nds::poi::types::EvConnectorType::DC_COMBO:
        return 32;
    case ::nds::poi::types::EvConnectorType::AC_3PHASE:
        return 33;
    case ::nds::poi::types::EvConnectorType::AC_SLOW:
        return 34;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_B_5_15:
        return 35;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_B_5_20:
        return 36;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_D:
        return 37;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_E:
        return 38;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_F:
        return 39;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_EF:
        return 40;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_G:
        return 41;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_H:
        return 42;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_I_ASNZ:
        return 43;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_I_CPCS:
        return 44;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_I_IRAM:
        return 45;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_J_TX3:
        return 46;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_J_T15:
        return 47;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_K:
        return 48;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_K_TH:
        return 49;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_L:
        return 50;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_M:
        return 51;
    case ::nds::poi::types::EvConnectorType::DOMESTIC_IEC:
        return 52;
    case ::nds::poi::types::EvConnectorType::TESLA_HIGH:
        return 53;
    case ::nds::poi::types::EvConnectorType::TESLA_UNI:
        return 54;
    case ::nds::poi::types::EvConnectorType::TESLA_SPARE:
        return 55;
    case ::nds::poi::types::EvConnectorType::IEC61851_1:
        return 56;
    case ::nds::poi::types::EvConnectorType::IEC60309_PNE:
        return 57;
    case ::nds::poi::types::EvConnectorType::IEC60309_PNE_CEEPLUS:
        return 58;
    case ::nds::poi::types::EvConnectorType::IEC60309_2PE:
        return 59;
    case ::nds::poi::types::EvConnectorType::IEC60309_3PEN:
        return 60;
    case ::nds::poi::types::EvConnectorType::IEC60309_3PNE:
        return 61;
    case ::nds::poi::types::EvConnectorType::IEC60309_ASNZ:
        return 62;
    case ::nds::poi::types::EvConnectorType::UNSPECIFIED:
        return 63;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration EvConnectorType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::EvConnectorType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::EvConnectorType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::EvConnectorType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
    case UINT16_C(18):
    case UINT16_C(19):
    case UINT16_C(20):
    case UINT16_C(21):
    case UINT16_C(22):
    case UINT16_C(23):
    case UINT16_C(24):
    case UINT16_C(25):
    case UINT16_C(26):
    case UINT16_C(27):
    case UINT16_C(28):
    case UINT16_C(29):
    case UINT16_C(30):
    case UINT16_C(31):
    case UINT16_C(32):
    case UINT16_C(33):
    case UINT16_C(34):
    case UINT16_C(35):
    case UINT16_C(36):
    case UINT16_C(37):
    case UINT16_C(38):
    case UINT16_C(39):
    case UINT16_C(40):
    case UINT16_C(41):
    case UINT16_C(42):
    case UINT16_C(43):
    case UINT16_C(44):
    case UINT16_C(45):
    case UINT16_C(46):
    case UINT16_C(47):
    case UINT16_C(48):
    case UINT16_C(49):
    case UINT16_C(50):
    case UINT16_C(51):
    case UINT16_C(52):
    case UINT16_C(53):
    case UINT16_C(54):
    case UINT16_C(55):
    case UINT16_C(56):
    case UINT16_C(57):
    case UINT16_C(58):
    case UINT16_C(59):
    case UINT16_C(60):
    case UINT16_C(61):
    case UINT16_C(62):
    case UINT16_C(63):
        return static_cast<::nds::poi::types::EvConnectorType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration EvConnectorType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::EvConnectorType>(::nds::poi::types::EvConnectorType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::EvConnectorType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::poi::types::EvConnectorType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::EvConnectorType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::EvConnectorType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::poi::types::EvConnectorType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::EvConnectorType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::EvConnectorType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::EvConnectorType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::EvConnectorType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::EvConnectorType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::poi::types::EvConnectorType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::EvConnectorType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::poi::types::EvConnectorType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::EvConnectorType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::EvConnectorType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::poi::types::EvConnectorType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/Cuisine.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for Cuisine enumeration.
constexpr ::std::array<const char*, 55> EnumTraits<::nds::poi::types::Cuisine>::names;
constexpr ::std::array<::nds::poi::types::Cuisine, 55> EnumTraits<::nds::poi::types::Cuisine>::values;
constexpr const char* EnumTraits<::nds::poi::types::Cuisine>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::Cuisine value)
{
    switch (value)
    {
    case ::nds::poi::types::Cuisine::OTHER:
        return 0;
    case ::nds::poi::types::Cuisine::CUSTOM:
        return 1;
    case ::nds::poi::types::Cuisine::AFGHAN:
        return 2;
    case ::nds::poi::types::Cuisine::AFRICAN:
        return 3;
    case ::nds::poi::types::Cuisine::AMERICAN:
        return 4;
    case ::nds::poi::types::Cuisine::ARAB:
        return 5;
    case ::nds::poi::types::Cuisine::ARGENTINIAN:
        return 6;
    case ::nds::poi::types::Cuisine::ASIAN:
        return 7;
    case ::nds::poi::types::Cuisine::AUSTRALIAN:
        return 8;
    case ::nds::poi::types::Cuisine::BAIANA:
        return 9;
    case ::nds::poi::types::Cuisine::BALKAN:
        return 10;
    case ::nds::poi::types::Cuisine::BASQUE:
        return 11;
    case ::nds::poi::types::Cuisine::BELARUSIAN:
        return 12;
    case ::nds::poi::types::Cuisine::BOLIVIAN:
        return 13;
    case ::nds::poi::types::Cuisine::BRAZILIAN:
        return 14;
    case ::nds::poi::types::Cuisine::CANTONESE:
        return 15;
    case ::nds::poi::types::Cuisine::CARIBBEAN:
        return 16;
    case ::nds::poi::types::Cuisine::CHINESE:
        return 17;
    case ::nds::poi::types::Cuisine::CROATIAN:
        return 18;
    case ::nds::poi::types::Cuisine::CZECH:
        return 19;
    case ::nds::poi::types::Cuisine::DANISH:
        return 20;
    case ::nds::poi::types::Cuisine::FILIPINO:
        return 21;
    case ::nds::poi::types::Cuisine::FRENCH:
        return 22;
    case ::nds::poi::types::Cuisine::GAUCHO:
        return 23;
    case ::nds::poi::types::Cuisine::GEORGIAN:
        return 24;
    case ::nds::poi::types::Cuisine::GERMAN:
        return 25;
    case ::nds::poi::types::Cuisine::GREEK:
        return 26;
    case ::nds::poi::types::Cuisine::HAWAIIAN:
        return 27;
    case ::nds::poi::types::Cuisine::HUNGARIAN:
        return 28;
    case ::nds::poi::types::Cuisine::INDIAN:
        return 29;
    case ::nds::poi::types::Cuisine::INDONESIAN:
        return 30;
    case ::nds::poi::types::Cuisine::INTERNATIONAL:
        return 31;
    case ::nds::poi::types::Cuisine::IRANIAN:
        return 32;
    case ::nds::poi::types::Cuisine::ITALIAN:
        return 33;
    case ::nds::poi::types::Cuisine::JAPANESE:
        return 34;
    case ::nds::poi::types::Cuisine::JEWISH:
        return 35;
    case ::nds::poi::types::Cuisine::KOREAN:
        return 36;
    case ::nds::poi::types::Cuisine::LATIN_AMERICAN:
        return 37;
    case ::nds::poi::types::Cuisine::LEBANESE:
        return 38;
    case ::nds::poi::types::Cuisine::MALAYSIAN:
        return 39;
    case ::nds::poi::types::Cuisine::MALAGASY:
        return 40;
    case ::nds::poi::types::Cuisine::MEDITERRANEAN:
        return 41;
    case ::nds::poi::types::Cuisine::MEXICAN:
        return 42;
    case ::nds::poi::types::Cuisine::PAKISTANI:
        return 43;
    case ::nds::poi::types::Cuisine::PERUVIAN:
        return 44;
    case ::nds::poi::types::Cuisine::POLISH:
        return 45;
    case ::nds::poi::types::Cuisine::PORTUGUESE:
        return 46;
    case ::nds::poi::types::Cuisine::REGIONAL:
        return 47;
    case ::nds::poi::types::Cuisine::RUSSIAN:
        return 48;
    case ::nds::poi::types::Cuisine::SCOTTISH:
        return 49;
    case ::nds::poi::types::Cuisine::SPANISH:
        return 50;
    case ::nds::poi::types::Cuisine::THAI:
        return 51;
    case ::nds::poi::types::Cuisine::TURKISH:
        return 52;
    case ::nds::poi::types::Cuisine::VIETNAMESE:
        return 53;
    case ::nds::poi::types::Cuisine::WESTERN:
        return 54;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Cuisine: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::Cuisine>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::Cuisine valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::Cuisine>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
    case UINT8_C(17):
    case UINT8_C(18):
    case UINT8_C(19):
    case UINT8_C(20):
    case UINT8_C(21):
    case UINT8_C(22):
    case UINT8_C(23):
    case UINT8_C(24):
    case UINT8_C(25):
    case UINT8_C(26):
    case UINT8_C(27):
    case UINT8_C(28):
    case UINT8_C(29):
    case UINT8_C(30):
    case UINT8_C(31):
    case UINT8_C(32):
    case UINT8_C(33):
    case UINT8_C(34):
    case UINT8_C(35):
    case UINT8_C(36):
    case UINT8_C(37):
    case UINT8_C(38):
    case UINT8_C(39):
    case UINT8_C(40):
    case UINT8_C(41):
    case UINT8_C(42):
    case UINT8_C(43):
    case UINT8_C(44):
    case UINT8_C(45):
    case UINT8_C(46):
    case UINT8_C(47):
    case UINT8_C(48):
    case UINT8_C(49):
    case UINT8_C(50):
    case UINT8_C(51):
    case UINT8_C(52):
    case UINT8_C(53):
    case UINT8_C(54):
        return static_cast<::nds::poi::types::Cuisine>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Cuisine: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::Cuisine>(::nds::poi::types::Cuisine value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::Cuisine value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::Cuisine>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::Cuisine)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::Cuisine value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::Cuisine>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::Cuisine value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::Cuisine value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::Cuisine read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::Cuisine>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::Cuisine>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::poi::types::Cuisine read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::Cuisine>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::Cuisine>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::Cuisine value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::Cuisine value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::Cuisine>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/StarRating.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for StarRating enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::poi::types::StarRating>::names;
constexpr ::std::array<::nds::poi::types::StarRating, 7> EnumTraits<::nds::poi::types::StarRating>::values;
constexpr const char* EnumTraits<::nds::poi::types::StarRating>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::StarRating value)
{
    switch (value)
    {
    case ::nds::poi::types::StarRating::RATING_1_STAR:
        return 0;
    case ::nds::poi::types::StarRating::RATING_2_STAR:
        return 1;
    case ::nds::poi::types::StarRating::RATING_3_STAR:
        return 2;
    case ::nds::poi::types::StarRating::RATING_4_STAR:
        return 3;
    case ::nds::poi::types::StarRating::RATING_5_STAR:
        return 4;
    case ::nds::poi::types::StarRating::RATING_6_STAR:
        return 5;
    case ::nds::poi::types::StarRating::RATING_7_STAR:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StarRating: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::StarRating>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::StarRating valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::StarRating>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::poi::types::StarRating>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StarRating: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::StarRating>(::nds::poi::types::StarRating value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::StarRating value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::StarRating>::type, UINT8_C(3)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::StarRating)
{
    return UINT8_C(3);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::StarRating value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::StarRating>::type, UINT8_C(3)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::StarRating value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::StarRating value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::StarRating read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::StarRating>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::StarRating>::type>(
                    in.readBits(UINT8_C(3))));
}

template <>
::nds::poi::types::StarRating read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::StarRating>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::StarRating>::type, UINT8_C(3)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::StarRating value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(3));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::StarRating value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::StarRating>::type, UINT8_C(3)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/ParkingFacilitiesSizeClass.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ParkingFacilitiesSizeClass enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::poi::types::ParkingFacilitiesSizeClass>::names;
constexpr ::std::array<::nds::poi::types::ParkingFacilitiesSizeClass, 7> EnumTraits<::nds::poi::types::ParkingFacilitiesSizeClass>::values;
constexpr const char* EnumTraits<::nds::poi::types::ParkingFacilitiesSizeClass>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::ParkingFacilitiesSizeClass value)
{
    switch (value)
    {
    case ::nds::poi::types::ParkingFacilitiesSizeClass::NONE:
        return 0;
    case ::nds::poi::types::ParkingFacilitiesSizeClass::UNKNOWN:
        return 1;
    case ::nds::poi::types::ParkingFacilitiesSizeClass::FROM_1_TO_50:
        return 2;
    case ::nds::poi::types::ParkingFacilitiesSizeClass::FROM_51_TO_100:
        return 3;
    case ::nds::poi::types::ParkingFacilitiesSizeClass::FROM_101_TO_250:
        return 4;
    case ::nds::poi::types::ParkingFacilitiesSizeClass::FROM_251_TO_500:
        return 5;
    case ::nds::poi::types::ParkingFacilitiesSizeClass::MORE_THAN_500:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingFacilitiesSizeClass: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::ParkingFacilitiesSizeClass>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::ParkingFacilitiesSizeClass valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::ParkingFacilitiesSizeClass>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::poi::types::ParkingFacilitiesSizeClass>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingFacilitiesSizeClass: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::ParkingFacilitiesSizeClass>(::nds::poi::types::ParkingFacilitiesSizeClass value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::ParkingFacilitiesSizeClass value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::ParkingFacilitiesSizeClass>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::ParkingFacilitiesSizeClass)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::ParkingFacilitiesSizeClass value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::ParkingFacilitiesSizeClass>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::ParkingFacilitiesSizeClass value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::ParkingFacilitiesSizeClass value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::ParkingFacilitiesSizeClass read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::ParkingFacilitiesSizeClass>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::ParkingFacilitiesSizeClass>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::poi::types::ParkingFacilitiesSizeClass read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::ParkingFacilitiesSizeClass>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::ParkingFacilitiesSizeClass>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::ParkingFacilitiesSizeClass value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::ParkingFacilitiesSizeClass value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::poi::types::ParkingFacilitiesSizeClass>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/PlaceOfWorshipType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PlaceOfWorshipType enumeration.
constexpr ::std::array<const char*, 6> EnumTraits<::nds::poi::types::PlaceOfWorshipType>::names;
constexpr ::std::array<::nds::poi::types::PlaceOfWorshipType, 6> EnumTraits<::nds::poi::types::PlaceOfWorshipType>::values;
constexpr const char* EnumTraits<::nds::poi::types::PlaceOfWorshipType>::enumName;

template <>
size_t enumToOrdinal(::nds::poi::types::PlaceOfWorshipType value)
{
    switch (value)
    {
    case ::nds::poi::types::PlaceOfWorshipType::OTHER:
        return 0;
    case ::nds::poi::types::PlaceOfWorshipType::SYNAGOGUE:
        return 1;
    case ::nds::poi::types::PlaceOfWorshipType::CHURCH:
        return 2;
    case ::nds::poi::types::PlaceOfWorshipType::MOSQUE:
        return 3;
    case ::nds::poi::types::PlaceOfWorshipType::TEMPLE:
        return 4;
    case ::nds::poi::types::PlaceOfWorshipType::MONASTERY:
        return 5;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PlaceOfWorshipType: ") <<
                static_cast<typename ::std::underlying_type<::nds::poi::types::PlaceOfWorshipType>::type>(value) << "!";
    }
}

template <>
::nds::poi::types::PlaceOfWorshipType valueToEnum(
        typename ::std::underlying_type<::nds::poi::types::PlaceOfWorshipType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
        return static_cast<::nds::poi::types::PlaceOfWorshipType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PlaceOfWorshipType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::poi::types::PlaceOfWorshipType>(::nds::poi::types::PlaceOfWorshipType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::poi::types::PlaceOfWorshipType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::PlaceOfWorshipType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::poi::types::PlaceOfWorshipType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::poi::types::PlaceOfWorshipType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::PlaceOfWorshipType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::poi::types::PlaceOfWorshipType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::poi::types::PlaceOfWorshipType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::poi::types::PlaceOfWorshipType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::PlaceOfWorshipType>(
            static_cast<typename ::std::underlying_type<::nds::poi::types::PlaceOfWorshipType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::poi::types::PlaceOfWorshipType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::poi::types::PlaceOfWorshipType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::PlaceOfWorshipType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::poi::types::PlaceOfWorshipType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::poi::types::PlaceOfWorshipType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::poi::types::PlaceOfWorshipType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/AirportServiceAvailability.h>

namespace nds
{
namespace poi
{
namespace types
{

AirportServiceAvailability::AirportServiceAvailability(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

AirportServiceAvailability::AirportServiceAvailability(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

AirportServiceAvailability::AirportServiceAvailability(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'AirportServiceAvailability' out of bounds: ") << value << "!";
}

void AirportServiceAvailability::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::poi::types::AirportServiceAvailability::underlying_type>>(m_value);
}

size_t AirportServiceAvailability::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t AirportServiceAvailability::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::poi::types::AirportServiceAvailability::underlying_type>>(m_value);
}

size_t AirportServiceAvailability::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t AirportServiceAvailability::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t AirportServiceAvailability::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void AirportServiceAvailability::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void AirportServiceAvailability::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::poi::types::AirportServiceAvailability::underlying_type>>(out, m_value);
}

::zserio::string<> AirportServiceAvailability::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & AirportServiceAvailability::Values::COMMERCIAL) == AirportServiceAvailability::Values::COMMERCIAL)
        result += result.empty() ? "COMMERCIAL" : " | COMMERCIAL";
    if ((*this & AirportServiceAvailability::Values::GENERAL_AVIATION) == AirportServiceAvailability::Values::GENERAL_AVIATION)
        result += result.empty() ? "GENERAL_AVIATION" : " | GENERAL_AVIATION";
    if ((*this & AirportServiceAvailability::Values::DOMESTIC_FLIGHTS) == AirportServiceAvailability::Values::DOMESTIC_FLIGHTS)
        result += result.empty() ? "DOMESTIC_FLIGHTS" : " | DOMESTIC_FLIGHTS";
    if ((*this & AirportServiceAvailability::Values::INTERNATIONAL_FLIGHTS) == AirportServiceAvailability::Values::INTERNATIONAL_FLIGHTS)
        result += result.empty() ? "INTERNATIONAL_FLIGHTS" : " | INTERNATIONAL_FLIGHTS";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

AirportServiceAvailability::underlying_type AirportServiceAvailability::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

AirportServiceAvailability::underlying_type AirportServiceAvailability::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::poi::types::AirportServiceAvailability::underlying_type>>(
            in);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/poi/types/AdBlueAvailability.h>

namespace nds
{
namespace poi
{
namespace types
{

AdBlueAvailability::AdBlueAvailability(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

AdBlueAvailability::AdBlueAvailability(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void AdBlueAvailability::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::poi::types::AdBlueAvailability::underlying_type>>(m_value);
}

size_t AdBlueAvailability::bitSizeOf(size_t) const
{
    return UINT8_C(8);
}

size_t AdBlueAvailability::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::poi::types::AdBlueAvailability::underlying_type>>(m_value);
}

size_t AdBlueAvailability::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t AdBlueAvailability::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t AdBlueAvailability::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void AdBlueAvailability::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(8));
}

void AdBlueAvailability::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::poi::types::AdBlueAvailability::underlying_type>>(out, m_value);
}

::zserio::string<> AdBlueAvailability::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & AdBlueAvailability::Values::VIA_CAN) == AdBlueAvailability::Values::VIA_CAN)
        result += result.empty() ? "VIA_CAN" : " | VIA_CAN";
    if ((*this & AdBlueAvailability::Values::VIA_PUMP) == AdBlueAvailability::Values::VIA_PUMP)
        result += result.empty() ? "VIA_PUMP" : " | VIA_PUMP";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

AdBlueAvailability::underlying_type AdBlueAvailability::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(8)));
}

AdBlueAvailability::underlying_type AdBlueAvailability::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::poi::types::AdBlueAvailability::underlying_type>>(
            in);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/RestAreaServiceAvailability.h>

namespace nds
{
namespace poi
{
namespace types
{

RestAreaServiceAvailability::RestAreaServiceAvailability(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

RestAreaServiceAvailability::RestAreaServiceAvailability(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

RestAreaServiceAvailability::RestAreaServiceAvailability(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'RestAreaServiceAvailability' out of bounds: ") << value << "!";
}

void RestAreaServiceAvailability::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::poi::types::RestAreaServiceAvailability::underlying_type>>(m_value);
}

size_t RestAreaServiceAvailability::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t RestAreaServiceAvailability::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::poi::types::RestAreaServiceAvailability::underlying_type>>(m_value);
}

size_t RestAreaServiceAvailability::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t RestAreaServiceAvailability::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t RestAreaServiceAvailability::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void RestAreaServiceAvailability::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void RestAreaServiceAvailability::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::poi::types::RestAreaServiceAvailability::underlying_type>>(out, m_value);
}

::zserio::string<> RestAreaServiceAvailability::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & RestAreaServiceAvailability::Values::REST_ROOM) == RestAreaServiceAvailability::Values::REST_ROOM)
        result += result.empty() ? "REST_ROOM" : " | REST_ROOM";
    if ((*this & RestAreaServiceAvailability::Values::PARKING) == RestAreaServiceAvailability::Values::PARKING)
        result += result.empty() ? "PARKING" : " | PARKING";
    if ((*this & RestAreaServiceAvailability::Values::MOTORWAY_SERVICE) == RestAreaServiceAvailability::Values::MOTORWAY_SERVICE)
        result += result.empty() ? "MOTORWAY_SERVICE" : " | MOTORWAY_SERVICE";
    if ((*this & RestAreaServiceAvailability::Values::OTHER_SERVICE) == RestAreaServiceAvailability::Values::OTHER_SERVICE)
        result += result.empty() ? "OTHER_SERVICE" : " | OTHER_SERVICE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

RestAreaServiceAvailability::underlying_type RestAreaServiceAvailability::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

RestAreaServiceAvailability::underlying_type RestAreaServiceAvailability::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::poi::types::RestAreaServiceAvailability::underlying_type>>(
            in);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/DietAvailability.h>

namespace nds
{
namespace poi
{
namespace types
{

DietAvailability::DietAvailability(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

DietAvailability::DietAvailability(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

DietAvailability::DietAvailability(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'DietAvailability' out of bounds: ") << value << "!";
}

void DietAvailability::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::poi::types::DietAvailability::underlying_type>>(m_value);
}

size_t DietAvailability::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t DietAvailability::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::poi::types::DietAvailability::underlying_type>>(m_value);
}

size_t DietAvailability::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t DietAvailability::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t DietAvailability::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void DietAvailability::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void DietAvailability::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::poi::types::DietAvailability::underlying_type>>(out, m_value);
}

::zserio::string<> DietAvailability::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & DietAvailability::Values::PESCETARIAN) == DietAvailability::Values::PESCETARIAN)
        result += result.empty() ? "PESCETARIAN" : " | PESCETARIAN";
    if ((*this & DietAvailability::Values::VEGETARIAN) == DietAvailability::Values::VEGETARIAN)
        result += result.empty() ? "VEGETARIAN" : " | VEGETARIAN";
    if ((*this & DietAvailability::Values::LACTO_VEGETARIAN) == DietAvailability::Values::LACTO_VEGETARIAN)
        result += result.empty() ? "LACTO_VEGETARIAN" : " | LACTO_VEGETARIAN";
    if ((*this & DietAvailability::Values::OVO_VEGETARIAN) == DietAvailability::Values::OVO_VEGETARIAN)
        result += result.empty() ? "OVO_VEGETARIAN" : " | OVO_VEGETARIAN";
    if ((*this & DietAvailability::Values::VEGAN) == DietAvailability::Values::VEGAN)
        result += result.empty() ? "VEGAN" : " | VEGAN";
    if ((*this & DietAvailability::Values::FRUITARIAN) == DietAvailability::Values::FRUITARIAN)
        result += result.empty() ? "FRUITARIAN" : " | FRUITARIAN";
    if ((*this & DietAvailability::Values::RAW) == DietAvailability::Values::RAW)
        result += result.empty() ? "RAW" : " | RAW";
    if ((*this & DietAvailability::Values::GLUTEN_FREE) == DietAvailability::Values::GLUTEN_FREE)
        result += result.empty() ? "GLUTEN_FREE" : " | GLUTEN_FREE";
    if ((*this & DietAvailability::Values::DAIRY_FREE) == DietAvailability::Values::DAIRY_FREE)
        result += result.empty() ? "DAIRY_FREE" : " | DAIRY_FREE";
    if ((*this & DietAvailability::Values::LACTOSE_FREE) == DietAvailability::Values::LACTOSE_FREE)
        result += result.empty() ? "LACTOSE_FREE" : " | LACTOSE_FREE";
    if ((*this & DietAvailability::Values::DIABETES) == DietAvailability::Values::DIABETES)
        result += result.empty() ? "DIABETES" : " | DIABETES";
    if ((*this & DietAvailability::Values::HALAL) == DietAvailability::Values::HALAL)
        result += result.empty() ? "HALAL" : " | HALAL";
    if ((*this & DietAvailability::Values::KOSHER) == DietAvailability::Values::KOSHER)
        result += result.empty() ? "KOSHER" : " | KOSHER";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

DietAvailability::underlying_type DietAvailability::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

DietAvailability::underlying_type DietAvailability::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::poi::types::DietAvailability::underlying_type>>(
            in);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/poi/types/AccessibilityAids.h>

namespace nds
{
namespace poi
{
namespace types
{

AccessibilityAids::AccessibilityAids(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

AccessibilityAids::AccessibilityAids(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

AccessibilityAids::AccessibilityAids(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'AccessibilityAids' out of bounds: ") << value << "!";
}

void AccessibilityAids::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::poi::types::AccessibilityAids::underlying_type>>(m_value);
}

size_t AccessibilityAids::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t AccessibilityAids::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::poi::types::AccessibilityAids::underlying_type>>(m_value);
}

size_t AccessibilityAids::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t AccessibilityAids::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t AccessibilityAids::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void AccessibilityAids::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void AccessibilityAids::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::poi::types::AccessibilityAids::underlying_type>>(out, m_value);
}

::zserio::string<> AccessibilityAids::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & AccessibilityAids::Values::AIDS_FOR_DISABLED) == AccessibilityAids::Values::AIDS_FOR_DISABLED)
        result += result.empty() ? "AIDS_FOR_DISABLED" : " | AIDS_FOR_DISABLED";
    if ((*this & AccessibilityAids::Values::AIDS_FOR_WHEELCHAIR) == AccessibilityAids::Values::AIDS_FOR_WHEELCHAIR)
        result += result.empty() ? "AIDS_FOR_WHEELCHAIR" : " | AIDS_FOR_WHEELCHAIR";
    if ((*this & AccessibilityAids::Values::AIDS_FOR_HEARING) == AccessibilityAids::Values::AIDS_FOR_HEARING)
        result += result.empty() ? "AIDS_FOR_HEARING" : " | AIDS_FOR_HEARING";
    if ((*this & AccessibilityAids::Values::AIDS_FOR_VISION) == AccessibilityAids::Values::AIDS_FOR_VISION)
        result += result.empty() ? "AIDS_FOR_VISION" : " | AIDS_FOR_VISION";
    if ((*this & AccessibilityAids::Values::AIDS_FOR_WALK) == AccessibilityAids::Values::AIDS_FOR_WALK)
        result += result.empty() ? "AIDS_FOR_WALK" : " | AIDS_FOR_WALK";
    if ((*this & AccessibilityAids::Values::AIDS_FOR_NON_SWIMMER) == AccessibilityAids::Values::AIDS_FOR_NON_SWIMMER)
        result += result.empty() ? "AIDS_FOR_NON_SWIMMER" : " | AIDS_FOR_NON_SWIMMER";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

AccessibilityAids::underlying_type AccessibilityAids::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

AccessibilityAids::underlying_type AccessibilityAids::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::poi::types::AccessibilityAids::underlying_type>>(
            in);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/PoiRelation.h>

namespace nds
{
namespace poi
{
namespace types
{

PoiRelation::PoiRelation(const allocator_type&) noexcept :
        m_inSameTile_(bool()),
        m_relatedPoi_(::zserio::NullOpt),
        m_extRelatedPoi_(::zserio::NullOpt),
        m_type_(::nds::poi::types::PoiRelationType())
{
}

PoiRelation::PoiRelation(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_inSameTile_(readInSameTile(in)),
        m_relatedPoi_(readRelatedPoi(in)),
        m_extRelatedPoi_(readExtRelatedPoi(in, allocator)),
        m_type_(readType(in))
{
}

PoiRelation::PoiRelation(PoiRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_inSameTile_(readInSameTile(in)),
        m_relatedPoi_(readRelatedPoi(context, in)),
        m_extRelatedPoi_(readExtRelatedPoi(context, in, allocator)),
        m_type_(readType(context, in))
{
}

PoiRelation::PoiRelation(::zserio::PropagateAllocatorT,
        const PoiRelation& other, const allocator_type& allocator) :
        m_inSameTile_(::zserio::allocatorPropagatingCopy(other.m_inSameTile_, allocator)),
        m_relatedPoi_(::zserio::allocatorPropagatingCopy(other.m_relatedPoi_, allocator)),
        m_extRelatedPoi_(::zserio::allocatorPropagatingCopy(other.m_extRelatedPoi_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator))
{
}

void PoiRelation::initializeChildren()
{
    if (!getInSameTile())
        m_extRelatedPoi_.value().initializeChildren();
}

bool PoiRelation::getInSameTile() const
{
    return m_inSameTile_;
}

void PoiRelation::setInSameTile(bool inSameTile_)
{
    m_inSameTile_ = inSameTile_;
}

::nds::poi::reference::types::PoiReference PoiRelation::getRelatedPoi() const
{
    return m_relatedPoi_.value();
}

void PoiRelation::setRelatedPoi(::nds::poi::reference::types::PoiReference relatedPoi_)
{
    m_relatedPoi_ = relatedPoi_;
}

bool PoiRelation::isRelatedPoiUsed() const
{
    return (getInSameTile());
}

bool PoiRelation::isRelatedPoiSet() const
{
    return m_relatedPoi_.hasValue();
}

void PoiRelation::resetRelatedPoi()
{
    m_relatedPoi_.reset();
}

::nds::poi::reference::types::PoiReferenceIndirect& PoiRelation::getExtRelatedPoi()
{
    return m_extRelatedPoi_.value();
}

const ::nds::poi::reference::types::PoiReferenceIndirect& PoiRelation::getExtRelatedPoi() const
{
    return m_extRelatedPoi_.value();
}

void PoiRelation::setExtRelatedPoi(const ::nds::poi::reference::types::PoiReferenceIndirect& extRelatedPoi_)
{
    m_extRelatedPoi_ = extRelatedPoi_;
}

void PoiRelation::setExtRelatedPoi(::nds::poi::reference::types::PoiReferenceIndirect&& extRelatedPoi_)
{
    m_extRelatedPoi_ = ::std::move(extRelatedPoi_);
}

bool PoiRelation::isExtRelatedPoiUsed() const
{
    return (!getInSameTile());
}

bool PoiRelation::isExtRelatedPoiSet() const
{
    return m_extRelatedPoi_.hasValue();
}

void PoiRelation::resetExtRelatedPoi()
{
    m_extRelatedPoi_.reset();
}

::nds::poi::types::PoiRelationType PoiRelation::getType() const
{
    return m_type_;
}

void PoiRelation::setType(::nds::poi::types::PoiRelationType type_)
{
    m_type_ = type_;
}

void PoiRelation::initPackingContext(PoiRelation::ZserioPackingContext& context) const
{
    if (getInSameTile())
    {
        context.getRelatedPoi().init<::zserio::VarIntNNArrayTraits<::nds::poi::reference::types::PoiReference>>(m_relatedPoi_.value());
    }
    if (!getInSameTile())
    {
        m_extRelatedPoi_.value().initPackingContext(context.getExtRelatedPoi());
    }
    ::zserio::initPackingContext(context.getType(), m_type_);
}

size_t PoiRelation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getInSameTile())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_relatedPoi_.value());
    }
    if (!getInSameTile())
    {
        endBitPosition += m_extRelatedPoi_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOf(m_type_);

    return endBitPosition - bitPosition;
}

size_t PoiRelation::bitSizeOf(PoiRelation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getInSameTile())
    {
        endBitPosition += context.getRelatedPoi().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::poi::reference::types::PoiReference>>(m_relatedPoi_.value());
    }
    if (!getInSameTile())
    {
        endBitPosition += m_extRelatedPoi_.value().bitSizeOf(context.getExtRelatedPoi(), endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);

    return endBitPosition - bitPosition;
}

size_t PoiRelation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getInSameTile())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_relatedPoi_.value());
    }
    if (!getInSameTile())
    {
        endBitPosition = m_extRelatedPoi_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);

    return endBitPosition;
}

size_t PoiRelation::initializeOffsets(PoiRelation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getInSameTile())
    {
        endBitPosition += context.getRelatedPoi().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::poi::reference::types::PoiReference>>(m_relatedPoi_.value());
    }
    if (!getInSameTile())
    {
        endBitPosition = m_extRelatedPoi_.value().initializeOffsets(context.getExtRelatedPoi(), endBitPosition);
    }
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);

    return endBitPosition;
}

bool PoiRelation::operator==(const PoiRelation& other) const
{
    if (this != &other)
    {
        return
                (m_inSameTile_ == other.m_inSameTile_) &&
                (!isRelatedPoiUsed() ? !other.isRelatedPoiUsed() : (m_relatedPoi_ == other.m_relatedPoi_)) &&
                (!isExtRelatedPoiUsed() ? !other.isExtRelatedPoiUsed() : (m_extRelatedPoi_ == other.m_extRelatedPoi_)) &&
                (m_type_ == other.m_type_);
    }

    return true;
}

uint32_t PoiRelation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_inSameTile_);
    if (isRelatedPoiUsed())
        result = ::zserio::calcHashCode(result, m_relatedPoi_);
    if (isExtRelatedPoiUsed())
        result = ::zserio::calcHashCode(result, m_extRelatedPoi_);
    result = ::zserio::calcHashCode(result, m_type_);

    return result;
}

void PoiRelation::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_inSameTile_);
    if (getInSameTile())
    {
        out.writeVarUInt32(m_relatedPoi_.value());
    }
    if (!getInSameTile())
    {
        m_extRelatedPoi_.value().write(out);
    }
    ::zserio::write(out, m_type_);
}

void PoiRelation::write(PoiRelation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_inSameTile_);
    if (getInSameTile())
    {
        context.getRelatedPoi().write<::zserio::VarIntNNArrayTraits<::nds::poi::reference::types::PoiReference>>(out, m_relatedPoi_.value());
    }
    if (!getInSameTile())
    {
        m_extRelatedPoi_.value().write(context.getExtRelatedPoi(), out);
    }
    ::zserio::write(context.getType(), out, m_type_);
}

bool PoiRelation::readInSameTile(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReference> PoiRelation::readRelatedPoi(::zserio::BitStreamReader& in)
{
    if (getInSameTile())
    {
        return ::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReference>(static_cast<::nds::poi::reference::types::PoiReference>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReference> PoiRelation::readRelatedPoi(PoiRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getInSameTile())
    {
        return ::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReference>(context.getRelatedPoi().read<::zserio::VarIntNNArrayTraits<::nds::poi::reference::types::PoiReference>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReference>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReferenceIndirect> PoiRelation::readExtRelatedPoi(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getInSameTile())
    {
        return ::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReferenceIndirect>(::nds::poi::reference::types::PoiReferenceIndirect(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReferenceIndirect>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReferenceIndirect> PoiRelation::readExtRelatedPoi(PoiRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getInSameTile())
    {
        return ::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReferenceIndirect>(::nds::poi::reference::types::PoiReferenceIndirect(context.getExtRelatedPoi(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::poi::reference::types::PoiReferenceIndirect>(::zserio::NullOpt);
}
::nds::poi::types::PoiRelationType PoiRelation::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::PoiRelationType>(in);
}

::nds::poi::types::PoiRelationType PoiRelation::readType(PoiRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::PoiRelationType>(context.getType(), in);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/AccessPointDetails.h>

namespace nds
{
namespace poi
{
namespace types
{

AccessPointDetails::AccessPointDetails(const allocator_type&) noexcept :
        m_accessPointMethod_(::nds::poi::types::AccessPointMethod()),
        m_accessPointLevel_(::nds::poi::types::AccessPointLevel())
{
}

AccessPointDetails::AccessPointDetails(::zserio::BitStreamReader& in, const allocator_type&) :
        m_accessPointMethod_(readAccessPointMethod(in)),
        m_accessPointLevel_(readAccessPointLevel(in))
{
}

AccessPointDetails::AccessPointDetails(AccessPointDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_accessPointMethod_(readAccessPointMethod(context, in)),
        m_accessPointLevel_(readAccessPointLevel(context, in))
{
}

AccessPointDetails::AccessPointDetails(::zserio::PropagateAllocatorT,
        const AccessPointDetails& other, const allocator_type& allocator) :
        m_accessPointMethod_(::zserio::allocatorPropagatingCopy(other.m_accessPointMethod_, allocator)),
        m_accessPointLevel_(::zserio::allocatorPropagatingCopy(other.m_accessPointLevel_, allocator))
{
}

::nds::poi::types::AccessPointMethod AccessPointDetails::getAccessPointMethod() const
{
    return m_accessPointMethod_;
}

void AccessPointDetails::setAccessPointMethod(::nds::poi::types::AccessPointMethod accessPointMethod_)
{
    m_accessPointMethod_ = accessPointMethod_;
}

::nds::poi::types::AccessPointLevel AccessPointDetails::getAccessPointLevel() const
{
    return m_accessPointLevel_;
}

void AccessPointDetails::setAccessPointLevel(::nds::poi::types::AccessPointLevel accessPointLevel_)
{
    m_accessPointLevel_ = accessPointLevel_;
}

void AccessPointDetails::initPackingContext(AccessPointDetails::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAccessPointMethod(), m_accessPointMethod_);
    ::zserio::initPackingContext(context.getAccessPointLevel(), m_accessPointLevel_);
}

size_t AccessPointDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_accessPointMethod_);
    endBitPosition += ::zserio::bitSizeOf(m_accessPointLevel_);

    return endBitPosition - bitPosition;
}

size_t AccessPointDetails::bitSizeOf(AccessPointDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAccessPointMethod(), m_accessPointMethod_);
    endBitPosition += ::zserio::bitSizeOf(context.getAccessPointLevel(), m_accessPointLevel_);

    return endBitPosition - bitPosition;
}

size_t AccessPointDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_accessPointMethod_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_accessPointLevel_);

    return endBitPosition;
}

size_t AccessPointDetails::initializeOffsets(AccessPointDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAccessPointMethod(), endBitPosition,
        m_accessPointMethod_);
    endBitPosition = ::zserio::initializeOffsets(context.getAccessPointLevel(), endBitPosition,
        m_accessPointLevel_);

    return endBitPosition;
}

bool AccessPointDetails::operator==(const AccessPointDetails& other) const
{
    if (this != &other)
    {
        return
                (m_accessPointMethod_ == other.m_accessPointMethod_) &&
                (m_accessPointLevel_ == other.m_accessPointLevel_);
    }

    return true;
}

uint32_t AccessPointDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_accessPointMethod_);
    result = ::zserio::calcHashCode(result, m_accessPointLevel_);

    return result;
}

void AccessPointDetails::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_accessPointMethod_);
    ::zserio::write(out, m_accessPointLevel_);
}

void AccessPointDetails::write(AccessPointDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAccessPointMethod(), out, m_accessPointMethod_);
    ::zserio::write(context.getAccessPointLevel(), out, m_accessPointLevel_);
}

::nds::poi::types::AccessPointMethod AccessPointDetails::readAccessPointMethod(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::AccessPointMethod>(in);
}

::nds::poi::types::AccessPointMethod AccessPointDetails::readAccessPointMethod(AccessPointDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::AccessPointMethod>(context.getAccessPointMethod(), in);
}
::nds::poi::types::AccessPointLevel AccessPointDetails::readAccessPointLevel(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::AccessPointLevel>(in);
}

::nds::poi::types::AccessPointLevel AccessPointDetails::readAccessPointLevel(AccessPointDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::AccessPointLevel>(context.getAccessPointLevel(), in);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/NameStringCollection.h>

namespace nds
{
namespace poi
{
namespace types
{

NameStringCollection::NameStringCollection(const allocator_type& allocator) noexcept :
        m_nameStrings_(allocator)
{
}

NameStringCollection::NameStringCollection(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_nameStrings_(readNameStrings(in, allocator))
{
}

NameStringCollection::NameStringCollection(NameStringCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_nameStrings_(readNameStrings(context, in, allocator))
{
}

NameStringCollection::NameStringCollection(::zserio::PropagateAllocatorT,
        const NameStringCollection& other, const allocator_type& allocator) :
        m_nameStrings_(::zserio::allocatorPropagatingCopy(other.m_nameStrings_, allocator))
{
}

::zserio::vector<::nds::poi::types::NameString>& NameStringCollection::getNameStrings()
{
    return m_nameStrings_.getRawArray();
}

const ::zserio::vector<::nds::poi::types::NameString>& NameStringCollection::getNameStrings() const
{
    return m_nameStrings_.getRawArray();
}

void NameStringCollection::setNameStrings(const ::zserio::vector<::nds::poi::types::NameString>& nameStrings_)
{
    m_nameStrings_ = ZserioArrayType_nameStrings(nameStrings_);
}

void NameStringCollection::setNameStrings(::zserio::vector<::nds::poi::types::NameString>&& nameStrings_)
{
    m_nameStrings_ = ZserioArrayType_nameStrings(std::move(nameStrings_));
}

void NameStringCollection::initPackingContext(NameStringCollection::ZserioPackingContext&) const
{
}

size_t NameStringCollection::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_nameStrings_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t NameStringCollection::bitSizeOf(NameStringCollection::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_nameStrings_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t NameStringCollection::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_nameStrings_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t NameStringCollection::initializeOffsets(NameStringCollection::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_nameStrings_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool NameStringCollection::operator==(const NameStringCollection& other) const
{
    if (this != &other)
    {
        return
                (m_nameStrings_ == other.m_nameStrings_);
    }

    return true;
}

uint32_t NameStringCollection::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_nameStrings_);

    return result;
}

void NameStringCollection::write(::zserio::BitStreamWriter& out) const
{
    m_nameStrings_.write(*this, out);
}

void NameStringCollection::write(NameStringCollection::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_nameStrings_.writePacked(*this, out);
}

void NameStringCollection::ZserioElementFactory_nameStrings::create(NameStringCollection&        ,
        ::zserio::vector<::nds::poi::types::NameString>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void NameStringCollection::ZserioElementFactory_nameStrings::create(NameStringCollection&        ,
        ::zserio::vector<::nds::poi::types::NameString>& array,
        ::nds::poi::types::NameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

NameStringCollection::ZserioArrayType_nameStrings NameStringCollection::readNameStrings(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_nameStrings readField(allocator);
    readField.read(*this, in);

    return readField;
}

NameStringCollection::ZserioArrayType_nameStrings NameStringCollection::readNameStrings(NameStringCollection::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_nameStrings readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/poi/types/NameString.h>
#include <nds/poi/types/NameStringRelationType.h>

namespace nds
{
namespace poi
{
namespace types
{

NameString::NameString(const allocator_type& allocator) noexcept :
        m_nameString_(allocator),
        m_languageCode_(::nds::core::types::LanguageCode()),
        m_nameStringRelationType_(::nds::poi::types::NameStringRelationType()),
        m_nameStringUsageType_(::nds::poi::types::NameStringUsageType()),
        m_refNameStringIndex_(::zserio::NullOpt)
{
}

NameString::NameString(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_nameString_(readNameString(in, allocator)),
        m_languageCode_(readLanguageCode(in)),
        m_nameStringRelationType_(readNameStringRelationType(in)),
        m_nameStringUsageType_(readNameStringUsageType(in)),
        m_refNameStringIndex_(readRefNameStringIndex(in))
{
}

NameString::NameString(NameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_nameString_(readNameString(in, allocator)),
        m_languageCode_(readLanguageCode(context, in)),
        m_nameStringRelationType_(readNameStringRelationType(context, in)),
        m_nameStringUsageType_(readNameStringUsageType(context, in)),
        m_refNameStringIndex_(readRefNameStringIndex(context, in))
{
}

NameString::NameString(::zserio::PropagateAllocatorT,
        const NameString& other, const allocator_type& allocator) :
        m_nameString_(::zserio::allocatorPropagatingCopy(other.m_nameString_, allocator)),
        m_languageCode_(::zserio::allocatorPropagatingCopy(other.m_languageCode_, allocator)),
        m_nameStringRelationType_(::zserio::allocatorPropagatingCopy(other.m_nameStringRelationType_, allocator)),
        m_nameStringUsageType_(::zserio::allocatorPropagatingCopy(other.m_nameStringUsageType_, allocator)),
        m_refNameStringIndex_(::zserio::allocatorPropagatingCopy(other.m_refNameStringIndex_, allocator))
{
}

::zserio::string<>& NameString::getNameString()
{
    return m_nameString_;
}

const ::zserio::string<>& NameString::getNameString() const
{
    return m_nameString_;
}

void NameString::setNameString(const ::zserio::string<>& nameString_)
{
    m_nameString_ = nameString_;
}

void NameString::setNameString(::zserio::string<>&& nameString_)
{
    m_nameString_ = ::std::move(nameString_);
}

::nds::core::types::LanguageCode NameString::getLanguageCode() const
{
    return m_languageCode_;
}

void NameString::setLanguageCode(::nds::core::types::LanguageCode languageCode_)
{
    m_languageCode_ = languageCode_;
}

::nds::poi::types::NameStringRelationType NameString::getNameStringRelationType() const
{
    return m_nameStringRelationType_;
}

void NameString::setNameStringRelationType(::nds::poi::types::NameStringRelationType nameStringRelationType_)
{
    m_nameStringRelationType_ = nameStringRelationType_;
}

::nds::poi::types::NameStringUsageType NameString::getNameStringUsageType() const
{
    return m_nameStringUsageType_;
}

void NameString::setNameStringUsageType(::nds::poi::types::NameStringUsageType nameStringUsageType_)
{
    m_nameStringUsageType_ = nameStringUsageType_;
}

uint8_t NameString::getRefNameStringIndex() const
{
    return m_refNameStringIndex_.value();
}

void NameString::setRefNameStringIndex(uint8_t refNameStringIndex_)
{
    m_refNameStringIndex_ = refNameStringIndex_;
}

bool NameString::isRefNameStringIndexUsed() const
{
    return (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION);
}

bool NameString::isRefNameStringIndexSet() const
{
    return m_refNameStringIndex_.hasValue();
}

void NameString::resetRefNameStringIndex()
{
    m_refNameStringIndex_.reset();
}

void NameString::initPackingContext(NameString::ZserioPackingContext& context) const
{
    context.getLanguageCode().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    ::zserio::initPackingContext(context.getNameStringRelationType(), m_nameStringRelationType_);
    ::zserio::initPackingContext(context.getNameStringUsageType(), m_nameStringUsageType_);
    if (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION)
    {
        context.getRefNameStringIndex().init<::zserio::StdIntArrayTraits<uint8_t>>(m_refNameStringIndex_.value());
    }
}

size_t NameString::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_nameString_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOf(m_nameStringRelationType_);
    endBitPosition += ::zserio::bitSizeOf(m_nameStringUsageType_);
    if (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION)
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition - bitPosition;
}

size_t NameString::bitSizeOf(NameString::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_nameString_);
    endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOf(context.getNameStringRelationType(), m_nameStringRelationType_);
    endBitPosition += ::zserio::bitSizeOf(context.getNameStringUsageType(), m_nameStringUsageType_);
    if (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION)
    {
        endBitPosition += context.getRefNameStringIndex().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_refNameStringIndex_.value());
    }

    return endBitPosition - bitPosition;
}

size_t NameString::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_nameString_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_nameStringRelationType_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_nameStringUsageType_);
    if (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION)
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition;
}

size_t NameString::initializeOffsets(NameString::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_nameString_);
    endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    endBitPosition = ::zserio::initializeOffsets(context.getNameStringRelationType(), endBitPosition,
        m_nameStringRelationType_);
    endBitPosition = ::zserio::initializeOffsets(context.getNameStringUsageType(), endBitPosition,
        m_nameStringUsageType_);
    if (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION)
    {
        endBitPosition += context.getRefNameStringIndex().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_refNameStringIndex_.value());
    }

    return endBitPosition;
}

bool NameString::operator==(const NameString& other) const
{
    if (this != &other)
    {
        return
                (m_nameString_ == other.m_nameString_) &&
                (m_languageCode_ == other.m_languageCode_) &&
                (m_nameStringRelationType_ == other.m_nameStringRelationType_) &&
                (m_nameStringUsageType_ == other.m_nameStringUsageType_) &&
                (!isRefNameStringIndexUsed() ? !other.isRefNameStringIndexUsed() : (m_refNameStringIndex_ == other.m_refNameStringIndex_));
    }

    return true;
}

uint32_t NameString::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_nameString_);
    result = ::zserio::calcHashCode(result, m_languageCode_);
    result = ::zserio::calcHashCode(result, m_nameStringRelationType_);
    result = ::zserio::calcHashCode(result, m_nameStringUsageType_);
    if (isRefNameStringIndexUsed())
        result = ::zserio::calcHashCode(result, m_refNameStringIndex_);

    return result;
}

void NameString::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_nameString_);
    out.writeVarUInt16(m_languageCode_);
    ::zserio::write(out, m_nameStringRelationType_);
    ::zserio::write(out, m_nameStringUsageType_);
    if (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION)
    {
        out.writeBits(m_refNameStringIndex_.value(), UINT8_C(8));
    }
}

void NameString::write(NameString::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeString(m_nameString_);
    context.getLanguageCode().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(out, m_languageCode_);
    ::zserio::write(context.getNameStringRelationType(), out, m_nameStringRelationType_);
    ::zserio::write(context.getNameStringUsageType(), out, m_nameStringUsageType_);
    if (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION)
    {
        context.getRefNameStringIndex().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_refNameStringIndex_.value());
    }
}

::zserio::string<> NameString::readNameString(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::nds::core::types::LanguageCode NameString::readLanguageCode(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LanguageCode>(in.readVarUInt16());
}

::nds::core::types::LanguageCode NameString::readLanguageCode(NameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLanguageCode().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(in);
}
::nds::poi::types::NameStringRelationType NameString::readNameStringRelationType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::NameStringRelationType>(in);
}

::nds::poi::types::NameStringRelationType NameString::readNameStringRelationType(NameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::NameStringRelationType>(context.getNameStringRelationType(), in);
}
::nds::poi::types::NameStringUsageType NameString::readNameStringUsageType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::NameStringUsageType>(in);
}

::nds::poi::types::NameStringUsageType NameString::readNameStringUsageType(NameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::NameStringUsageType>(context.getNameStringUsageType(), in);
}
::zserio::InplaceOptionalHolder<uint8_t> NameString::readRefNameStringIndex(::zserio::BitStreamReader& in)
{
    if (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(static_cast<uint8_t>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint8_t> NameString::readRefNameStringIndex(NameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getNameStringRelationType() != ::nds::poi::types::NameStringRelationType::NO_RELATION)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(context.getRefNameStringIndex().read<::zserio::StdIntArrayTraits<uint8_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/AcceptedPaymentMethods.h>

namespace nds
{
namespace poi
{
namespace types
{

AcceptedPaymentMethods::AcceptedPaymentMethods(const allocator_type& allocator) noexcept :
        m_numMethods_(uint8_t()),
        m_methods_(allocator)
{
}

AcceptedPaymentMethods::AcceptedPaymentMethods(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numMethods_(readNumMethods(in)),
        m_methods_(readMethods(in, allocator))
{
}

AcceptedPaymentMethods::AcceptedPaymentMethods(AcceptedPaymentMethods::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numMethods_(readNumMethods(context, in)),
        m_methods_(readMethods(context, in, allocator))
{
}

AcceptedPaymentMethods::AcceptedPaymentMethods(::zserio::PropagateAllocatorT,
        const AcceptedPaymentMethods& other, const allocator_type& allocator) :
        m_numMethods_(::zserio::allocatorPropagatingCopy(other.m_numMethods_, allocator)),
        m_methods_(::zserio::allocatorPropagatingCopy(other.m_methods_, allocator))
{
}

uint8_t AcceptedPaymentMethods::getNumMethods() const
{
    return m_numMethods_;
}

void AcceptedPaymentMethods::setNumMethods(uint8_t numMethods_)
{
    m_numMethods_ = numMethods_;
}

::zserio::vector<::nds::poi::types::PaymentMethod>& AcceptedPaymentMethods::getMethods()
{
    return m_methods_.getRawArray();
}

const ::zserio::vector<::nds::poi::types::PaymentMethod>& AcceptedPaymentMethods::getMethods() const
{
    return m_methods_.getRawArray();
}

void AcceptedPaymentMethods::setMethods(const ::zserio::vector<::nds::poi::types::PaymentMethod>& methods_)
{
    m_methods_ = ZserioArrayType_methods(methods_);
}

void AcceptedPaymentMethods::setMethods(::zserio::vector<::nds::poi::types::PaymentMethod>&& methods_)
{
    m_methods_ = ZserioArrayType_methods(std::move(methods_));
}

void AcceptedPaymentMethods::initPackingContext(AcceptedPaymentMethods::ZserioPackingContext& context) const
{
    context.getNumMethods().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numMethods_);
}

size_t AcceptedPaymentMethods::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_methods_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AcceptedPaymentMethods::bitSizeOf(AcceptedPaymentMethods::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMethods().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numMethods_);
    endBitPosition += m_methods_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AcceptedPaymentMethods::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_methods_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t AcceptedPaymentMethods::initializeOffsets(AcceptedPaymentMethods::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMethods().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numMethods_);
    endBitPosition = m_methods_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool AcceptedPaymentMethods::operator==(const AcceptedPaymentMethods& other) const
{
    if (this != &other)
    {
        return
                (m_numMethods_ == other.m_numMethods_) &&
                (m_methods_ == other.m_methods_);
    }

    return true;
}

uint32_t AcceptedPaymentMethods::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numMethods_);
    result = ::zserio::calcHashCode(result, m_methods_);

    return result;
}

void AcceptedPaymentMethods::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numMethods_, UINT8_C(8));

    // check array length
    if (m_methods_.getRawArray().size() != static_cast<size_t>(getNumMethods()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AcceptedPaymentMethods.methods: ") <<
                m_methods_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMethods()) << "!";
    }
    m_methods_.write(*this, out);
}

void AcceptedPaymentMethods::write(AcceptedPaymentMethods::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMethods().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numMethods_);

    // check array length
    if (m_methods_.getRawArray().size() != static_cast<size_t>(getNumMethods()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AcceptedPaymentMethods.methods: ") <<
                m_methods_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMethods()) << "!";
    }
    m_methods_.writePacked(*this, out);
}

void AcceptedPaymentMethods::ZserioElementFactory_methods::create(AcceptedPaymentMethods&        ,
        ::zserio::vector<::nds::poi::types::PaymentMethod>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void AcceptedPaymentMethods::ZserioElementFactory_methods::create(AcceptedPaymentMethods&        ,
        ::zserio::vector<::nds::poi::types::PaymentMethod>& array,
        ::nds::poi::types::PaymentMethod::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t AcceptedPaymentMethods::readNumMethods(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t AcceptedPaymentMethods::readNumMethods(AcceptedPaymentMethods::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMethods().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
AcceptedPaymentMethods::ZserioArrayType_methods AcceptedPaymentMethods::readMethods(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_methods readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumMethods()));

    return readField;
}

AcceptedPaymentMethods::ZserioArrayType_methods AcceptedPaymentMethods::readMethods(AcceptedPaymentMethods::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_methods readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMethods()));

    return readField;
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/PaymentMethod.h>

namespace nds
{
namespace poi
{
namespace types
{

PaymentMethod::PaymentMethod(const allocator_type& allocator) noexcept :
        m_name_(allocator),
        m_iconSetReference_(::zserio::NullOpt)
{
}

PaymentMethod::PaymentMethod(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_name_(readName(in, allocator)),
        m_iconSetReference_(readIconSetReference(in))
{
}

PaymentMethod::PaymentMethod(PaymentMethod::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_name_(readName(in, allocator)),
        m_iconSetReference_(readIconSetReference(context, in))
{
}

PaymentMethod::PaymentMethod(::zserio::PropagateAllocatorT,
        const PaymentMethod& other, const allocator_type& allocator) :
        m_name_(::zserio::allocatorPropagatingCopy(other.m_name_, allocator)),
        m_iconSetReference_(::zserio::allocatorPropagatingCopy(other.m_iconSetReference_, allocator))
{
}

::zserio::string<>& PaymentMethod::getName()
{
    return m_name_;
}

const ::zserio::string<>& PaymentMethod::getName() const
{
    return m_name_;
}

void PaymentMethod::setName(const ::zserio::string<>& name_)
{
    m_name_ = name_;
}

void PaymentMethod::setName(::zserio::string<>&& name_)
{
    m_name_ = ::std::move(name_);
}

::nds::core::icons::IconSetReference PaymentMethod::getIconSetReference() const
{
    return m_iconSetReference_.value();
}

void PaymentMethod::setIconSetReference(::nds::core::icons::IconSetReference iconSetReference_)
{
    m_iconSetReference_ = iconSetReference_;
}

bool PaymentMethod::isIconSetReferenceUsed() const
{
    return (isIconSetReferenceSet());
}

bool PaymentMethod::isIconSetReferenceSet() const
{
    return m_iconSetReference_.hasValue();
}

void PaymentMethod::resetIconSetReference()
{
    m_iconSetReference_.reset();
}

void PaymentMethod::initPackingContext(PaymentMethod::ZserioPackingContext& context) const
{
    if (isIconSetReferenceSet())
    {
        context.getIconSetReference().init<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(m_iconSetReference_.value());
    }
}

size_t PaymentMethod::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += 1;
    if (isIconSetReferenceSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_iconSetReference_.value());
    }

    return endBitPosition - bitPosition;
}

size_t PaymentMethod::bitSizeOf(PaymentMethod::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += 1;
    if (isIconSetReferenceSet())
    {
        endBitPosition += context.getIconSetReference().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(m_iconSetReference_.value());
    }

    return endBitPosition - bitPosition;
}

size_t PaymentMethod::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += 1;
    if (isIconSetReferenceSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_iconSetReference_.value());
    }

    return endBitPosition;
}

size_t PaymentMethod::initializeOffsets(PaymentMethod::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += 1;
    if (isIconSetReferenceSet())
    {
        endBitPosition += context.getIconSetReference().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(m_iconSetReference_.value());
    }

    return endBitPosition;
}

bool PaymentMethod::operator==(const PaymentMethod& other) const
{
    if (this != &other)
    {
        return
                (m_name_ == other.m_name_) &&
                (!isIconSetReferenceUsed() ? !other.isIconSetReferenceUsed() : (m_iconSetReference_ == other.m_iconSetReference_));
    }

    return true;
}

uint32_t PaymentMethod::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_name_);
    if (isIconSetReferenceUsed())
        result = ::zserio::calcHashCode(result, m_iconSetReference_);

    return result;
}

void PaymentMethod::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_name_);
    if (isIconSetReferenceSet())
    {
        out.writeBool(true);
        out.writeVarUInt(m_iconSetReference_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void PaymentMethod::write(PaymentMethod::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeString(m_name_);
    if (isIconSetReferenceSet())
    {
        out.writeBool(true);
        context.getIconSetReference().write<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(out, m_iconSetReference_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::string<> PaymentMethod::readName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::InplaceOptionalHolder<::nds::core::icons::IconSetReference> PaymentMethod::readIconSetReference(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::icons::IconSetReference>(static_cast<::nds::core::icons::IconSetReference>(in.readVarUInt()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::icons::IconSetReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::icons::IconSetReference> PaymentMethod::readIconSetReference(PaymentMethod::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::icons::IconSetReference>(context.getIconSetReference().read<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::icons::IconSetReference>(::zserio::NullOpt);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/EvChargingStationDetails.h>

namespace nds
{
namespace poi
{
namespace types
{

EvChargingStationDetails::EvChargingStationDetails(const allocator_type& allocator) noexcept :
        m_totalPower_(::nds::core::vehicle::Watt()),
        m_numConnectors_(uint32_t()),
        m_connectors_(allocator),
        m_chargers_(allocator)
{
}

EvChargingStationDetails::EvChargingStationDetails(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_totalPower_(readTotalPower(in)),
        m_numConnectors_(readNumConnectors(in)),
        m_connectors_(readConnectors(in, allocator)),
        m_chargers_(readChargers(in, allocator))
{
}

EvChargingStationDetails::EvChargingStationDetails(EvChargingStationDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_totalPower_(readTotalPower(context, in)),
        m_numConnectors_(readNumConnectors(context, in)),
        m_connectors_(readConnectors(context, in, allocator)),
        m_chargers_(readChargers(context, in, allocator))
{
}

EvChargingStationDetails::EvChargingStationDetails(::zserio::PropagateAllocatorT,
        const EvChargingStationDetails& other, const allocator_type& allocator) :
        m_totalPower_(::zserio::allocatorPropagatingCopy(other.m_totalPower_, allocator)),
        m_numConnectors_(::zserio::allocatorPropagatingCopy(other.m_numConnectors_, allocator)),
        m_connectors_(::zserio::allocatorPropagatingCopy(other.m_connectors_, allocator)),
        m_chargers_(::zserio::allocatorPropagatingCopy(other.m_chargers_, allocator))
{
}

::nds::core::vehicle::Watt EvChargingStationDetails::getTotalPower() const
{
    return m_totalPower_;
}

void EvChargingStationDetails::setTotalPower(::nds::core::vehicle::Watt totalPower_)
{
    m_totalPower_ = totalPower_;
}

uint32_t EvChargingStationDetails::getNumConnectors() const
{
    return m_numConnectors_;
}

void EvChargingStationDetails::setNumConnectors(uint32_t numConnectors_)
{
    m_numConnectors_ = numConnectors_;
}

::zserio::vector<::nds::poi::types::EvConnector>& EvChargingStationDetails::getConnectors()
{
    return m_connectors_.getRawArray();
}

const ::zserio::vector<::nds::poi::types::EvConnector>& EvChargingStationDetails::getConnectors() const
{
    return m_connectors_.getRawArray();
}

void EvChargingStationDetails::setConnectors(const ::zserio::vector<::nds::poi::types::EvConnector>& connectors_)
{
    m_connectors_ = ZserioArrayType_connectors(connectors_);
}

void EvChargingStationDetails::setConnectors(::zserio::vector<::nds::poi::types::EvConnector>&& connectors_)
{
    m_connectors_ = ZserioArrayType_connectors(std::move(connectors_));
}

::zserio::vector<uint16_t>& EvChargingStationDetails::getChargers()
{
    return m_chargers_.getRawArray();
}

const ::zserio::vector<uint16_t>& EvChargingStationDetails::getChargers() const
{
    return m_chargers_.getRawArray();
}

void EvChargingStationDetails::setChargers(const ::zserio::vector<uint16_t>& chargers_)
{
    m_chargers_ = ZserioArrayType_chargers(chargers_);
}

void EvChargingStationDetails::setChargers(::zserio::vector<uint16_t>&& chargers_)
{
    m_chargers_ = ZserioArrayType_chargers(std::move(chargers_));
}

void EvChargingStationDetails::initPackingContext(EvChargingStationDetails::ZserioPackingContext& context) const
{
    context.getTotalPower().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(m_totalPower_);
    context.getNumConnectors().init<::zserio::VarSizeArrayTraits>(m_numConnectors_);
}

size_t EvChargingStationDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_totalPower_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numConnectors_);
    endBitPosition += m_connectors_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_chargers_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t EvChargingStationDetails::bitSizeOf(EvChargingStationDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTotalPower().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(m_totalPower_);
    endBitPosition += context.getNumConnectors().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numConnectors_);
    endBitPosition += m_connectors_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_chargers_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t EvChargingStationDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_totalPower_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numConnectors_);
    endBitPosition = m_connectors_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_chargers_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t EvChargingStationDetails::initializeOffsets(EvChargingStationDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTotalPower().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(m_totalPower_);
    endBitPosition += context.getNumConnectors().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numConnectors_);
    endBitPosition = m_connectors_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_chargers_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool EvChargingStationDetails::operator==(const EvChargingStationDetails& other) const
{
    if (this != &other)
    {
        return
                (m_totalPower_ == other.m_totalPower_) &&
                (m_numConnectors_ == other.m_numConnectors_) &&
                (m_connectors_ == other.m_connectors_) &&
                (m_chargers_ == other.m_chargers_);
    }

    return true;
}

uint32_t EvChargingStationDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_totalPower_);
    result = ::zserio::calcHashCode(result, m_numConnectors_);
    result = ::zserio::calcHashCode(result, m_connectors_);
    result = ::zserio::calcHashCode(result, m_chargers_);

    return result;
}

void EvChargingStationDetails::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_totalPower_);

    out.writeVarSize(m_numConnectors_);

    // check array length
    if (m_connectors_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingStationDetails.connectors: ") <<
                m_connectors_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_connectors_.write(*this, out);

    // check array length
    if (m_chargers_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingStationDetails.chargers: ") <<
                m_chargers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargers_.write(out);
}

void EvChargingStationDetails::write(EvChargingStationDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getTotalPower().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(out, m_totalPower_);

    context.getNumConnectors().write<::zserio::VarSizeArrayTraits>(out, m_numConnectors_);

    // check array length
    if (m_connectors_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingStationDetails.connectors: ") <<
                m_connectors_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_connectors_.writePacked(*this, out);

    // check array length
    if (m_chargers_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingStationDetails.chargers: ") <<
                m_chargers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargers_.writePacked(out);
}

void EvChargingStationDetails::ZserioElementFactory_connectors::create(EvChargingStationDetails&        ,
        ::zserio::vector<::nds::poi::types::EvConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void EvChargingStationDetails::ZserioElementFactory_connectors::create(EvChargingStationDetails&        ,
        ::zserio::vector<::nds::poi::types::EvConnector>& array,
        ::nds::poi::types::EvConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::vehicle::Watt EvChargingStationDetails::readTotalPower(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::Watt>(in.readVarUInt32());
}

::nds::core::vehicle::Watt EvChargingStationDetails::readTotalPower(EvChargingStationDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTotalPower().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(in);
}
uint32_t EvChargingStationDetails::readNumConnectors(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t EvChargingStationDetails::readNumConnectors(EvChargingStationDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumConnectors().read<::zserio::VarSizeArrayTraits>(in);
}
EvChargingStationDetails::ZserioArrayType_connectors EvChargingStationDetails::readConnectors(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_connectors readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumConnectors()));

    return readField;
}

EvChargingStationDetails::ZserioArrayType_connectors EvChargingStationDetails::readConnectors(EvChargingStationDetails::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_connectors readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumConnectors()));

    return readField;
}
EvChargingStationDetails::ZserioArrayType_chargers EvChargingStationDetails::readChargers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_chargers readField(allocator);
    readField.read(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}

EvChargingStationDetails::ZserioArrayType_chargers EvChargingStationDetails::readChargers(EvChargingStationDetails::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_chargers readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/EvChargingAvailability.h>

namespace nds
{
namespace poi
{
namespace types
{

EvChargingAvailability::EvChargingAvailability(const allocator_type& allocator) noexcept :
        m_numConnectors_(uint32_t()),
        m_connectorType_(allocator),
        m_chargersAvailable_(allocator),
        m_chargersOccupied_(allocator),
        m_chargersReserved_(allocator),
        m_chargersOutOfService_(allocator)
{
}

EvChargingAvailability::EvChargingAvailability(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numConnectors_(readNumConnectors(in)),
        m_connectorType_(readConnectorType(in, allocator)),
        m_chargersAvailable_(readChargersAvailable(in, allocator)),
        m_chargersOccupied_(readChargersOccupied(in, allocator)),
        m_chargersReserved_(readChargersReserved(in, allocator)),
        m_chargersOutOfService_(readChargersOutOfService(in, allocator))
{
}

EvChargingAvailability::EvChargingAvailability(EvChargingAvailability::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numConnectors_(readNumConnectors(context, in)),
        m_connectorType_(readConnectorType(context, in, allocator)),
        m_chargersAvailable_(readChargersAvailable(context, in, allocator)),
        m_chargersOccupied_(readChargersOccupied(context, in, allocator)),
        m_chargersReserved_(readChargersReserved(context, in, allocator)),
        m_chargersOutOfService_(readChargersOutOfService(context, in, allocator))
{
}

EvChargingAvailability::EvChargingAvailability(::zserio::PropagateAllocatorT,
        const EvChargingAvailability& other, const allocator_type& allocator) :
        m_numConnectors_(::zserio::allocatorPropagatingCopy(other.m_numConnectors_, allocator)),
        m_connectorType_(::zserio::allocatorPropagatingCopy(other.m_connectorType_, allocator)),
        m_chargersAvailable_(::zserio::allocatorPropagatingCopy(other.m_chargersAvailable_, allocator)),
        m_chargersOccupied_(::zserio::allocatorPropagatingCopy(other.m_chargersOccupied_, allocator)),
        m_chargersReserved_(::zserio::allocatorPropagatingCopy(other.m_chargersReserved_, allocator)),
        m_chargersOutOfService_(::zserio::allocatorPropagatingCopy(other.m_chargersOutOfService_, allocator))
{
}

uint32_t EvChargingAvailability::getNumConnectors() const
{
    return m_numConnectors_;
}

void EvChargingAvailability::setNumConnectors(uint32_t numConnectors_)
{
    m_numConnectors_ = numConnectors_;
}

::zserio::vector<::nds::poi::types::EvConnectorType>& EvChargingAvailability::getConnectorType()
{
    return m_connectorType_.getRawArray();
}

const ::zserio::vector<::nds::poi::types::EvConnectorType>& EvChargingAvailability::getConnectorType() const
{
    return m_connectorType_.getRawArray();
}

void EvChargingAvailability::setConnectorType(const ::zserio::vector<::nds::poi::types::EvConnectorType>& connectorType_)
{
    m_connectorType_ = ZserioArrayType_connectorType(connectorType_);
}

void EvChargingAvailability::setConnectorType(::zserio::vector<::nds::poi::types::EvConnectorType>&& connectorType_)
{
    m_connectorType_ = ZserioArrayType_connectorType(std::move(connectorType_));
}

::zserio::vector<uint16_t>& EvChargingAvailability::getChargersAvailable()
{
    return m_chargersAvailable_.getRawArray();
}

const ::zserio::vector<uint16_t>& EvChargingAvailability::getChargersAvailable() const
{
    return m_chargersAvailable_.getRawArray();
}

void EvChargingAvailability::setChargersAvailable(const ::zserio::vector<uint16_t>& chargersAvailable_)
{
    m_chargersAvailable_ = ZserioArrayType_chargersAvailable(chargersAvailable_);
}

void EvChargingAvailability::setChargersAvailable(::zserio::vector<uint16_t>&& chargersAvailable_)
{
    m_chargersAvailable_ = ZserioArrayType_chargersAvailable(std::move(chargersAvailable_));
}

::zserio::vector<uint16_t>& EvChargingAvailability::getChargersOccupied()
{
    return m_chargersOccupied_.getRawArray();
}

const ::zserio::vector<uint16_t>& EvChargingAvailability::getChargersOccupied() const
{
    return m_chargersOccupied_.getRawArray();
}

void EvChargingAvailability::setChargersOccupied(const ::zserio::vector<uint16_t>& chargersOccupied_)
{
    m_chargersOccupied_ = ZserioArrayType_chargersOccupied(chargersOccupied_);
}

void EvChargingAvailability::setChargersOccupied(::zserio::vector<uint16_t>&& chargersOccupied_)
{
    m_chargersOccupied_ = ZserioArrayType_chargersOccupied(std::move(chargersOccupied_));
}

::zserio::vector<uint16_t>& EvChargingAvailability::getChargersReserved()
{
    return m_chargersReserved_.getRawArray();
}

const ::zserio::vector<uint16_t>& EvChargingAvailability::getChargersReserved() const
{
    return m_chargersReserved_.getRawArray();
}

void EvChargingAvailability::setChargersReserved(const ::zserio::vector<uint16_t>& chargersReserved_)
{
    m_chargersReserved_ = ZserioArrayType_chargersReserved(chargersReserved_);
}

void EvChargingAvailability::setChargersReserved(::zserio::vector<uint16_t>&& chargersReserved_)
{
    m_chargersReserved_ = ZserioArrayType_chargersReserved(std::move(chargersReserved_));
}

::zserio::vector<uint16_t>& EvChargingAvailability::getChargersOutOfService()
{
    return m_chargersOutOfService_.getRawArray();
}

const ::zserio::vector<uint16_t>& EvChargingAvailability::getChargersOutOfService() const
{
    return m_chargersOutOfService_.getRawArray();
}

void EvChargingAvailability::setChargersOutOfService(const ::zserio::vector<uint16_t>& chargersOutOfService_)
{
    m_chargersOutOfService_ = ZserioArrayType_chargersOutOfService(chargersOutOfService_);
}

void EvChargingAvailability::setChargersOutOfService(::zserio::vector<uint16_t>&& chargersOutOfService_)
{
    m_chargersOutOfService_ = ZserioArrayType_chargersOutOfService(std::move(chargersOutOfService_));
}

void EvChargingAvailability::initPackingContext(EvChargingAvailability::ZserioPackingContext& context) const
{
    context.getNumConnectors().init<::zserio::VarSizeArrayTraits>(m_numConnectors_);
}

size_t EvChargingAvailability::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numConnectors_);
    endBitPosition += m_connectorType_.bitSizeOf(endBitPosition);
    endBitPosition += m_chargersAvailable_.bitSizeOf(endBitPosition);
    endBitPosition += m_chargersOccupied_.bitSizeOf(endBitPosition);
    endBitPosition += m_chargersReserved_.bitSizeOf(endBitPosition);
    endBitPosition += m_chargersOutOfService_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t EvChargingAvailability::bitSizeOf(EvChargingAvailability::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumConnectors().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numConnectors_);
    endBitPosition += m_connectorType_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_chargersAvailable_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_chargersOccupied_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_chargersReserved_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_chargersOutOfService_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t EvChargingAvailability::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numConnectors_);
    endBitPosition = m_connectorType_.initializeOffsets(endBitPosition);
    endBitPosition = m_chargersAvailable_.initializeOffsets(endBitPosition);
    endBitPosition = m_chargersOccupied_.initializeOffsets(endBitPosition);
    endBitPosition = m_chargersReserved_.initializeOffsets(endBitPosition);
    endBitPosition = m_chargersOutOfService_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t EvChargingAvailability::initializeOffsets(EvChargingAvailability::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumConnectors().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numConnectors_);
    endBitPosition = m_connectorType_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_chargersAvailable_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_chargersOccupied_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_chargersReserved_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_chargersOutOfService_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool EvChargingAvailability::operator==(const EvChargingAvailability& other) const
{
    if (this != &other)
    {
        return
                (m_numConnectors_ == other.m_numConnectors_) &&
                (m_connectorType_ == other.m_connectorType_) &&
                (m_chargersAvailable_ == other.m_chargersAvailable_) &&
                (m_chargersOccupied_ == other.m_chargersOccupied_) &&
                (m_chargersReserved_ == other.m_chargersReserved_) &&
                (m_chargersOutOfService_ == other.m_chargersOutOfService_);
    }

    return true;
}

uint32_t EvChargingAvailability::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numConnectors_);
    result = ::zserio::calcHashCode(result, m_connectorType_);
    result = ::zserio::calcHashCode(result, m_chargersAvailable_);
    result = ::zserio::calcHashCode(result, m_chargersOccupied_);
    result = ::zserio::calcHashCode(result, m_chargersReserved_);
    result = ::zserio::calcHashCode(result, m_chargersOutOfService_);

    return result;
}

void EvChargingAvailability::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numConnectors_);

    // check array length
    if (m_connectorType_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.connectorType: ") <<
                m_connectorType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_connectorType_.write(out);

    // check array length
    if (m_chargersAvailable_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.chargersAvailable: ") <<
                m_chargersAvailable_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargersAvailable_.write(out);

    // check array length
    if (m_chargersOccupied_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.chargersOccupied: ") <<
                m_chargersOccupied_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargersOccupied_.write(out);

    // check array length
    if (m_chargersReserved_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.chargersReserved: ") <<
                m_chargersReserved_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargersReserved_.write(out);

    // check array length
    if (m_chargersOutOfService_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.chargersOutOfService: ") <<
                m_chargersOutOfService_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargersOutOfService_.write(out);
}

void EvChargingAvailability::write(EvChargingAvailability::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumConnectors().write<::zserio::VarSizeArrayTraits>(out, m_numConnectors_);

    // check array length
    if (m_connectorType_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.connectorType: ") <<
                m_connectorType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_connectorType_.writePacked(out);

    // check array length
    if (m_chargersAvailable_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.chargersAvailable: ") <<
                m_chargersAvailable_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargersAvailable_.writePacked(out);

    // check array length
    if (m_chargersOccupied_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.chargersOccupied: ") <<
                m_chargersOccupied_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargersOccupied_.writePacked(out);

    // check array length
    if (m_chargersReserved_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.chargersReserved: ") <<
                m_chargersReserved_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargersReserved_.writePacked(out);

    // check array length
    if (m_chargersOutOfService_.getRawArray().size() != static_cast<size_t>(getNumConnectors()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field EvChargingAvailability.chargersOutOfService: ") <<
                m_chargersOutOfService_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConnectors()) << "!";
    }
    m_chargersOutOfService_.writePacked(out);
}

uint32_t EvChargingAvailability::readNumConnectors(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t EvChargingAvailability::readNumConnectors(EvChargingAvailability::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumConnectors().read<::zserio::VarSizeArrayTraits>(in);
}
EvChargingAvailability::ZserioArrayType_connectorType EvChargingAvailability::readConnectorType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_connectorType readField(allocator);
    readField.read(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}

EvChargingAvailability::ZserioArrayType_connectorType EvChargingAvailability::readConnectorType(EvChargingAvailability::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_connectorType readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}
EvChargingAvailability::ZserioArrayType_chargersAvailable EvChargingAvailability::readChargersAvailable(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_chargersAvailable readField(allocator);
    readField.read(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}

EvChargingAvailability::ZserioArrayType_chargersAvailable EvChargingAvailability::readChargersAvailable(EvChargingAvailability::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_chargersAvailable readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}
EvChargingAvailability::ZserioArrayType_chargersOccupied EvChargingAvailability::readChargersOccupied(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_chargersOccupied readField(allocator);
    readField.read(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}

EvChargingAvailability::ZserioArrayType_chargersOccupied EvChargingAvailability::readChargersOccupied(EvChargingAvailability::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_chargersOccupied readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}
EvChargingAvailability::ZserioArrayType_chargersReserved EvChargingAvailability::readChargersReserved(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_chargersReserved readField(allocator);
    readField.read(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}

EvChargingAvailability::ZserioArrayType_chargersReserved EvChargingAvailability::readChargersReserved(EvChargingAvailability::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_chargersReserved readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}
EvChargingAvailability::ZserioArrayType_chargersOutOfService EvChargingAvailability::readChargersOutOfService(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_chargersOutOfService readField(allocator);
    readField.read(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}

EvChargingAvailability::ZserioArrayType_chargersOutOfService EvChargingAvailability::readChargersOutOfService(EvChargingAvailability::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_chargersOutOfService readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumConnectors()));

    return readField;
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/EvConnector.h>

namespace nds
{
namespace poi
{
namespace types
{

EvConnector::EvConnector(const allocator_type&) noexcept :
        m_type_(::nds::poi::types::EvConnectorType()),
        m_current_(::nds::core::types::ElectricCurrent()),
        m_maxPower_(::nds::core::vehicle::Watt()),
        m_voltage_(::zserio::NullOpt),
        m_ampere_(::zserio::NullOpt),
        m_commStandard_(::zserio::NullOpt)
{
}

EvConnector::EvConnector(::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(in)),
        m_current_(readCurrent(in)),
        m_maxPower_(readMaxPower(in)),
        m_voltage_(readVoltage(in)),
        m_ampere_(readAmpere(in)),
        m_commStandard_(readCommStandard(in))
{
}

EvConnector::EvConnector(EvConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(context, in)),
        m_current_(readCurrent(context, in)),
        m_maxPower_(readMaxPower(context, in)),
        m_voltage_(readVoltage(context, in)),
        m_ampere_(readAmpere(context, in)),
        m_commStandard_(readCommStandard(context, in))
{
}

EvConnector::EvConnector(::zserio::PropagateAllocatorT,
        const EvConnector& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_current_(::zserio::allocatorPropagatingCopy(other.m_current_, allocator)),
        m_maxPower_(::zserio::allocatorPropagatingCopy(other.m_maxPower_, allocator)),
        m_voltage_(::zserio::allocatorPropagatingCopy(other.m_voltage_, allocator)),
        m_ampere_(::zserio::allocatorPropagatingCopy(other.m_ampere_, allocator)),
        m_commStandard_(::zserio::allocatorPropagatingCopy(other.m_commStandard_, allocator))
{
}

::nds::poi::types::EvConnectorType EvConnector::getType() const
{
    return m_type_;
}

void EvConnector::setType(::nds::poi::types::EvConnectorType type_)
{
    m_type_ = type_;
}

::nds::core::types::ElectricCurrent EvConnector::getCurrent() const
{
    return m_current_;
}

void EvConnector::setCurrent(::nds::core::types::ElectricCurrent current_)
{
    m_current_ = current_;
}

::nds::core::vehicle::Watt EvConnector::getMaxPower() const
{
    return m_maxPower_;
}

void EvConnector::setMaxPower(::nds::core::vehicle::Watt maxPower_)
{
    m_maxPower_ = maxPower_;
}

::nds::core::vehicle::Voltage EvConnector::getVoltage() const
{
    return m_voltage_.value();
}

void EvConnector::setVoltage(::nds::core::vehicle::Voltage voltage_)
{
    m_voltage_ = voltage_;
}

bool EvConnector::isVoltageUsed() const
{
    return (isVoltageSet());
}

bool EvConnector::isVoltageSet() const
{
    return m_voltage_.hasValue();
}

void EvConnector::resetVoltage()
{
    m_voltage_.reset();
}

::nds::core::vehicle::Ampere EvConnector::getAmpere() const
{
    return m_ampere_.value();
}

void EvConnector::setAmpere(::nds::core::vehicle::Ampere ampere_)
{
    m_ampere_ = ampere_;
}

bool EvConnector::isAmpereUsed() const
{
    return (isAmpereSet());
}

bool EvConnector::isAmpereSet() const
{
    return m_ampere_.hasValue();
}

void EvConnector::resetAmpere()
{
    m_ampere_.reset();
}

::nds::poi::types::EvCommunicationStandard EvConnector::getCommStandard() const
{
    return m_commStandard_.value();
}

void EvConnector::setCommStandard(::nds::poi::types::EvCommunicationStandard commStandard_)
{
    m_commStandard_ = commStandard_;
}

bool EvConnector::isCommStandardUsed() const
{
    return (isCommStandardSet());
}

bool EvConnector::isCommStandardSet() const
{
    return m_commStandard_.hasValue();
}

void EvConnector::resetCommStandard()
{
    m_commStandard_.reset();
}

void EvConnector::initPackingContext(EvConnector::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    ::zserio::initPackingContext(context.getCurrent(), m_current_);
    context.getMaxPower().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(m_maxPower_);
    if (isVoltageSet())
    {
        context.getVoltage().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Voltage>>(m_voltage_.value());
    }
    if (isAmpereSet())
    {
        context.getAmpere().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Ampere>>(m_ampere_.value());
    }
    if (isCommStandardSet())
    {
        ::zserio::initPackingContext(context.getCommStandard(), m_commStandard_.value());
    }
}

size_t EvConnector::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += ::zserio::bitSizeOf(m_current_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxPower_);
    endBitPosition += 1;
    if (isVoltageSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_voltage_.value());
    }
    endBitPosition += 1;
    if (isAmpereSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_ampere_.value());
    }
    endBitPosition += 1;
    if (isCommStandardSet())
    {
        endBitPosition += ::zserio::bitSizeOf(m_commStandard_.value());
    }

    return endBitPosition - bitPosition;
}

size_t EvConnector::bitSizeOf(EvConnector::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += ::zserio::bitSizeOf(context.getCurrent(), m_current_);
    endBitPosition += context.getMaxPower().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(m_maxPower_);
    endBitPosition += 1;
    if (isVoltageSet())
    {
        endBitPosition += context.getVoltage().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Voltage>>(m_voltage_.value());
    }
    endBitPosition += 1;
    if (isAmpereSet())
    {
        endBitPosition += context.getAmpere().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Ampere>>(m_ampere_.value());
    }
    endBitPosition += 1;
    if (isCommStandardSet())
    {
        endBitPosition += ::zserio::bitSizeOf(context.getCommStandard(), m_commStandard_.value());
    }

    return endBitPosition - bitPosition;
}

size_t EvConnector::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_current_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxPower_);
    endBitPosition += 1;
    if (isVoltageSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_voltage_.value());
    }
    endBitPosition += 1;
    if (isAmpereSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_ampere_.value());
    }
    endBitPosition += 1;
    if (isCommStandardSet())
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_commStandard_.value());
    }

    return endBitPosition;
}

size_t EvConnector::initializeOffsets(EvConnector::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = ::zserio::initializeOffsets(context.getCurrent(), endBitPosition,
        m_current_);
    endBitPosition += context.getMaxPower().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(m_maxPower_);
    endBitPosition += 1;
    if (isVoltageSet())
    {
        endBitPosition += context.getVoltage().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Voltage>>(m_voltage_.value());
    }
    endBitPosition += 1;
    if (isAmpereSet())
    {
        endBitPosition += context.getAmpere().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Ampere>>(m_ampere_.value());
    }
    endBitPosition += 1;
    if (isCommStandardSet())
    {
        endBitPosition = ::zserio::initializeOffsets(context.getCommStandard(), endBitPosition,
        m_commStandard_.value());
    }

    return endBitPosition;
}

bool EvConnector::operator==(const EvConnector& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_current_ == other.m_current_) &&
                (m_maxPower_ == other.m_maxPower_) &&
                (!isVoltageUsed() ? !other.isVoltageUsed() : (m_voltage_ == other.m_voltage_)) &&
                (!isAmpereUsed() ? !other.isAmpereUsed() : (m_ampere_ == other.m_ampere_)) &&
                (!isCommStandardUsed() ? !other.isCommStandardUsed() : (m_commStandard_ == other.m_commStandard_));
    }

    return true;
}

uint32_t EvConnector::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_current_);
    result = ::zserio::calcHashCode(result, m_maxPower_);
    if (isVoltageUsed())
        result = ::zserio::calcHashCode(result, m_voltage_);
    if (isAmpereUsed())
        result = ::zserio::calcHashCode(result, m_ampere_);
    if (isCommStandardUsed())
        result = ::zserio::calcHashCode(result, m_commStandard_);

    return result;
}

void EvConnector::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    ::zserio::write(out, m_current_);
    out.writeVarUInt32(m_maxPower_);
    if (isVoltageSet())
    {
        out.writeBool(true);
        out.writeVarUInt16(m_voltage_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isAmpereSet())
    {
        out.writeBool(true);
        out.writeVarUInt16(m_ampere_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isCommStandardSet())
    {
        out.writeBool(true);
        ::zserio::write(out, m_commStandard_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void EvConnector::write(EvConnector::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    ::zserio::write(context.getCurrent(), out, m_current_);
    context.getMaxPower().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(out, m_maxPower_);
    if (isVoltageSet())
    {
        out.writeBool(true);
        context.getVoltage().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Voltage>>(out, m_voltage_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isAmpereSet())
    {
        out.writeBool(true);
        context.getAmpere().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Ampere>>(out, m_ampere_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isCommStandardSet())
    {
        out.writeBool(true);
        ::zserio::write(context.getCommStandard(), out, m_commStandard_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::poi::types::EvConnectorType EvConnector::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::EvConnectorType>(in);
}

::nds::poi::types::EvConnectorType EvConnector::readType(EvConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::EvConnectorType>(context.getType(), in);
}
::nds::core::types::ElectricCurrent EvConnector::readCurrent(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::ElectricCurrent>(in);
}

::nds::core::types::ElectricCurrent EvConnector::readCurrent(EvConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::ElectricCurrent>(context.getCurrent(), in);
}
::nds::core::vehicle::Watt EvConnector::readMaxPower(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::Watt>(in.readVarUInt32());
}

::nds::core::vehicle::Watt EvConnector::readMaxPower(EvConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getMaxPower().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(in);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::Voltage> EvConnector::readVoltage(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Voltage>(static_cast<::nds::core::vehicle::Voltage>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Voltage>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::Voltage> EvConnector::readVoltage(EvConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Voltage>(context.getVoltage().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Voltage>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Voltage>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::Ampere> EvConnector::readAmpere(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Ampere>(static_cast<::nds::core::vehicle::Ampere>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Ampere>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::Ampere> EvConnector::readAmpere(EvConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Ampere>(context.getAmpere().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Ampere>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Ampere>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::poi::types::EvCommunicationStandard> EvConnector::readCommStandard(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::poi::types::EvCommunicationStandard>(::zserio::read<::nds::poi::types::EvCommunicationStandard>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::poi::types::EvCommunicationStandard>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::poi::types::EvCommunicationStandard> EvConnector::readCommStandard(EvConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::poi::types::EvCommunicationStandard>(::zserio::read<::nds::poi::types::EvCommunicationStandard>(context.getCommStandard(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::poi::types::EvCommunicationStandard>(::zserio::NullOpt);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/AvailableSportiveActivities.h>

namespace nds
{
namespace poi
{
namespace types
{

AvailableSportiveActivities::AvailableSportiveActivities(const allocator_type& allocator) noexcept :
        m_numSports_(uint8_t()),
        m_sports_(allocator)
{
}

AvailableSportiveActivities::AvailableSportiveActivities(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numSports_(readNumSports(in)),
        m_sports_(readSports(in, allocator))
{
}

AvailableSportiveActivities::AvailableSportiveActivities(AvailableSportiveActivities::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numSports_(readNumSports(context, in)),
        m_sports_(readSports(in, allocator))
{
}

AvailableSportiveActivities::AvailableSportiveActivities(::zserio::PropagateAllocatorT,
        const AvailableSportiveActivities& other, const allocator_type& allocator) :
        m_numSports_(::zserio::allocatorPropagatingCopy(other.m_numSports_, allocator)),
        m_sports_(::zserio::allocatorPropagatingCopy(other.m_sports_, allocator))
{
}

uint8_t AvailableSportiveActivities::getNumSports() const
{
    return m_numSports_;
}

void AvailableSportiveActivities::setNumSports(uint8_t numSports_)
{
    m_numSports_ = numSports_;
}

::zserio::vector<::zserio::string<>>& AvailableSportiveActivities::getSports()
{
    return m_sports_.getRawArray();
}

const ::zserio::vector<::zserio::string<>>& AvailableSportiveActivities::getSports() const
{
    return m_sports_.getRawArray();
}

void AvailableSportiveActivities::setSports(const ::zserio::vector<::zserio::string<>>& sports_)
{
    m_sports_ = ZserioArrayType_sports(sports_);
}

void AvailableSportiveActivities::setSports(::zserio::vector<::zserio::string<>>&& sports_)
{
    m_sports_ = ZserioArrayType_sports(std::move(sports_));
}

void AvailableSportiveActivities::initPackingContext(AvailableSportiveActivities::ZserioPackingContext& context) const
{
    context.getNumSports().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numSports_);
}

size_t AvailableSportiveActivities::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_sports_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AvailableSportiveActivities::bitSizeOf(AvailableSportiveActivities::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumSports().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numSports_);
    endBitPosition += m_sports_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AvailableSportiveActivities::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_sports_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t AvailableSportiveActivities::initializeOffsets(AvailableSportiveActivities::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumSports().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numSports_);
    endBitPosition = m_sports_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

bool AvailableSportiveActivities::operator==(const AvailableSportiveActivities& other) const
{
    if (this != &other)
    {
        return
                (m_numSports_ == other.m_numSports_) &&
                (m_sports_ == other.m_sports_);
    }

    return true;
}

uint32_t AvailableSportiveActivities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numSports_);
    result = ::zserio::calcHashCode(result, m_sports_);

    return result;
}

void AvailableSportiveActivities::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numSports_, UINT8_C(8));

    // check array length
    if (m_sports_.getRawArray().size() != static_cast<size_t>(getNumSports()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AvailableSportiveActivities.sports: ") <<
                m_sports_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSports()) << "!";
    }
    m_sports_.write(out);
}

void AvailableSportiveActivities::write(AvailableSportiveActivities::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumSports().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numSports_);

    // check array length
    if (m_sports_.getRawArray().size() != static_cast<size_t>(getNumSports()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AvailableSportiveActivities.sports: ") <<
                m_sports_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSports()) << "!";
    }
    m_sports_.write(out);
}

uint8_t AvailableSportiveActivities::readNumSports(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t AvailableSportiveActivities::readNumSports(AvailableSportiveActivities::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumSports().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
AvailableSportiveActivities::ZserioArrayType_sports AvailableSportiveActivities::readSports(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sports readField(allocator);
    readField.read(in, static_cast<size_t>(getNumSports()));

    return readField;
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/poi/types/FoodType.h>
#include <nds/poi/types/Cuisine.h>

namespace nds
{
namespace poi
{
namespace types
{

FoodType::FoodType(const allocator_type&) noexcept :
        m_cuisine_(::nds::poi::types::Cuisine()),
        m_customCuisine_(::zserio::NullOpt),
        m_hasDietAvailability_(bool()),
        m_dietAvailability_(::nds::poi::types::DietAvailability())
{
}

FoodType::FoodType(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_cuisine_(readCuisine(in)),
        m_customCuisine_(readCustomCuisine(in, allocator)),
        m_hasDietAvailability_(readHasDietAvailability(in)),
        m_dietAvailability_(readDietAvailability(in))
{
}

FoodType::FoodType(FoodType::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_cuisine_(readCuisine(context, in)),
        m_customCuisine_(readCustomCuisine(in, allocator)),
        m_hasDietAvailability_(readHasDietAvailability(in)),
        m_dietAvailability_(readDietAvailability(context, in))
{
}

FoodType::FoodType(::zserio::PropagateAllocatorT,
        const FoodType& other, const allocator_type& allocator) :
        m_cuisine_(::zserio::allocatorPropagatingCopy(other.m_cuisine_, allocator)),
        m_customCuisine_(::zserio::allocatorPropagatingCopy(other.m_customCuisine_, allocator)),
        m_hasDietAvailability_(::zserio::allocatorPropagatingCopy(other.m_hasDietAvailability_, allocator)),
        m_dietAvailability_(::zserio::allocatorPropagatingCopy(other.m_dietAvailability_, allocator))
{
}

::nds::poi::types::Cuisine FoodType::getCuisine() const
{
    return m_cuisine_;
}

void FoodType::setCuisine(::nds::poi::types::Cuisine cuisine_)
{
    m_cuisine_ = cuisine_;
}

::zserio::string<>& FoodType::getCustomCuisine()
{
    return m_customCuisine_.value();
}

const ::zserio::string<>& FoodType::getCustomCuisine() const
{
    return m_customCuisine_.value();
}

void FoodType::setCustomCuisine(const ::zserio::string<>& customCuisine_)
{
    m_customCuisine_ = customCuisine_;
}

void FoodType::setCustomCuisine(::zserio::string<>&& customCuisine_)
{
    m_customCuisine_ = ::std::move(customCuisine_);
}

bool FoodType::isCustomCuisineUsed() const
{
    return (getCuisine() == ::nds::poi::types::Cuisine::CUSTOM);
}

bool FoodType::isCustomCuisineSet() const
{
    return m_customCuisine_.hasValue();
}

void FoodType::resetCustomCuisine()
{
    m_customCuisine_.reset();
}

bool FoodType::getHasDietAvailability() const
{
    return m_hasDietAvailability_;
}

void FoodType::setHasDietAvailability(bool hasDietAvailability_)
{
    m_hasDietAvailability_ = hasDietAvailability_;
}

::nds::poi::types::DietAvailability FoodType::getDietAvailability() const
{
    return m_dietAvailability_;
}

void FoodType::setDietAvailability(::nds::poi::types::DietAvailability dietAvailability_)
{
    m_dietAvailability_ = dietAvailability_;
}

void FoodType::initPackingContext(FoodType::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getCuisine(), m_cuisine_);
    m_dietAvailability_.initPackingContext(context.getDietAvailability());
}

size_t FoodType::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_cuisine_);
    if (getCuisine() == ::nds::poi::types::Cuisine::CUSTOM)
    {
        endBitPosition += ::zserio::bitSizeOfString(m_customCuisine_.value());
    }
    endBitPosition += UINT8_C(1);
    endBitPosition += m_dietAvailability_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t FoodType::bitSizeOf(FoodType::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getCuisine(), m_cuisine_);
    if (getCuisine() == ::nds::poi::types::Cuisine::CUSTOM)
    {
        endBitPosition += ::zserio::bitSizeOfString(m_customCuisine_.value());
    }
    endBitPosition += UINT8_C(1);
    endBitPosition += m_dietAvailability_.bitSizeOf(context.getDietAvailability(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t FoodType::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_cuisine_);
    if (getCuisine() == ::nds::poi::types::Cuisine::CUSTOM)
    {
        endBitPosition += ::zserio::bitSizeOfString(m_customCuisine_.value());
    }
    endBitPosition += UINT8_C(1);
    endBitPosition = m_dietAvailability_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t FoodType::initializeOffsets(FoodType::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getCuisine(), endBitPosition,
        m_cuisine_);
    if (getCuisine() == ::nds::poi::types::Cuisine::CUSTOM)
    {
        endBitPosition += ::zserio::bitSizeOfString(m_customCuisine_.value());
    }
    endBitPosition += UINT8_C(1);
    endBitPosition = m_dietAvailability_.initializeOffsets(context.getDietAvailability(), endBitPosition);

    return endBitPosition;
}

bool FoodType::operator==(const FoodType& other) const
{
    if (this != &other)
    {
        return
                (m_cuisine_ == other.m_cuisine_) &&
                (!isCustomCuisineUsed() ? !other.isCustomCuisineUsed() : (m_customCuisine_ == other.m_customCuisine_)) &&
                (m_hasDietAvailability_ == other.m_hasDietAvailability_) &&
                (m_dietAvailability_ == other.m_dietAvailability_);
    }

    return true;
}

uint32_t FoodType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_cuisine_);
    if (isCustomCuisineUsed())
        result = ::zserio::calcHashCode(result, m_customCuisine_);
    result = ::zserio::calcHashCode(result, m_hasDietAvailability_);
    result = ::zserio::calcHashCode(result, m_dietAvailability_);

    return result;
}

void FoodType::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_cuisine_);
    if (getCuisine() == ::nds::poi::types::Cuisine::CUSTOM)
    {
        out.writeString(m_customCuisine_.value());
    }
    out.writeBool(m_hasDietAvailability_);
    m_dietAvailability_.write(out);
}

void FoodType::write(FoodType::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getCuisine(), out, m_cuisine_);
    if (getCuisine() == ::nds::poi::types::Cuisine::CUSTOM)
    {
        out.writeString(m_customCuisine_.value());
    }
    out.writeBool(m_hasDietAvailability_);
    m_dietAvailability_.write(context.getDietAvailability(), out);
}

::nds::poi::types::Cuisine FoodType::readCuisine(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::Cuisine>(in);
}

::nds::poi::types::Cuisine FoodType::readCuisine(FoodType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::poi::types::Cuisine>(context.getCuisine(), in);
}
::zserio::InplaceOptionalHolder<::zserio::string<>> FoodType::readCustomCuisine(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getCuisine() == ::nds::poi::types::Cuisine::CUSTOM)
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}
bool FoodType::readHasDietAvailability(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::poi::types::DietAvailability FoodType::readDietAvailability(::zserio::BitStreamReader& in)
{
    return ::nds::poi::types::DietAvailability(in);
}

::nds::poi::types::DietAvailability FoodType::readDietAvailability(FoodType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::poi::types::DietAvailability(context.getDietAvailability(), in);
}

} // namespace types
} // namespace poi
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/poi/types/MultimediaResourceReference.h>

namespace nds
{
namespace poi
{
namespace types
{

MultimediaResourceReference::MultimediaResourceReference(const allocator_type& allocator) noexcept :
        m_mimeType_(allocator),
        m_uri_(allocator)
{
}

MultimediaResourceReference::MultimediaResourceReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_mimeType_(readMimeType(in, allocator)),
        m_uri_(readUri(in, allocator))
{
}

MultimediaResourceReference::MultimediaResourceReference(::zserio::PropagateAllocatorT,
        const MultimediaResourceReference& other, const allocator_type& allocator) :
        m_mimeType_(::zserio::allocatorPropagatingCopy(other.m_mimeType_, allocator)),
        m_uri_(::zserio::allocatorPropagatingCopy(other.m_uri_, allocator))
{
}

::zserio::string<>& MultimediaResourceReference::getMimeType()
{
    return m_mimeType_;
}

const ::zserio::string<>& MultimediaResourceReference::getMimeType() const
{
    return m_mimeType_;
}

void MultimediaResourceReference::setMimeType(const ::zserio::string<>& mimeType_)
{
    m_mimeType_ = mimeType_;
}

void MultimediaResourceReference::setMimeType(::zserio::string<>&& mimeType_)
{
    m_mimeType_ = ::std::move(mimeType_);
}

::zserio::string<>& MultimediaResourceReference::getUri()
{
    return m_uri_;
}

const ::zserio::string<>& MultimediaResourceReference::getUri() const
{
    return m_uri_;
}

void MultimediaResourceReference::setUri(const ::zserio::string<>& uri_)
{
    m_uri_ = uri_;
}

void MultimediaResourceReference::setUri(::zserio::string<>&& uri_)
{
    m_uri_ = ::std::move(uri_);
}

size_t MultimediaResourceReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_mimeType_);
    endBitPosition += ::zserio::bitSizeOfString(m_uri_);

    return endBitPosition - bitPosition;
}

size_t MultimediaResourceReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_mimeType_);
    endBitPosition += ::zserio::bitSizeOfString(m_uri_);

    return endBitPosition;
}

bool MultimediaResourceReference::operator==(const MultimediaResourceReference& other) const
{
    if (this != &other)
    {
        return
                (m_mimeType_ == other.m_mimeType_) &&
                (m_uri_ == other.m_uri_);
    }

    return true;
}

uint32_t MultimediaResourceReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_mimeType_);
    result = ::zserio::calcHashCode(result, m_uri_);

    return result;
}

void MultimediaResourceReference::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_mimeType_);
    out.writeString(m_uri_);
}

::zserio::string<> MultimediaResourceReference::readMimeType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> MultimediaResourceReference::readUri(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

} // namespace types
} // namespace poi
} // namespace nds
