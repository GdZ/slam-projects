/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/attributes/NameTransitionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameTransitionAttributeType enumeration.
constexpr ::std::array<const char*, 1> EnumTraits<::nds::name::attributes::NameTransitionAttributeType>::names;
constexpr ::std::array<::nds::name::attributes::NameTransitionAttributeType, 1> EnumTraits<::nds::name::attributes::NameTransitionAttributeType>::values;
constexpr const char* EnumTraits<::nds::name::attributes::NameTransitionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::attributes::NameTransitionAttributeType value)
{
    switch (value)
    {
    case ::nds::name::attributes::NameTransitionAttributeType::INTERSECTION_NAME:
        return 0;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameTransitionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::attributes::NameTransitionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::name::attributes::NameTransitionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::name::attributes::NameTransitionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
        return static_cast<::nds::name::attributes::NameTransitionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameTransitionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::attributes::NameTransitionAttributeType>(::nds::name::attributes::NameTransitionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::attributes::NameTransitionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::attributes::NameTransitionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::attributes::NameTransitionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::attributes::NameTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::attributes::NameTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::attributes::NameTransitionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameTransitionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::name::attributes::NameTransitionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::attributes::NameTransitionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameTransitionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameTransitionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::attributes::NameTransitionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::attributes::NameTransitionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameTransitionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/attributes/NameRoadRangeAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameRoadRangeAttributeType enumeration.
constexpr ::std::array<const char*, 9> EnumTraits<::nds::name::attributes::NameRoadRangeAttributeType>::names;
constexpr ::std::array<::nds::name::attributes::NameRoadRangeAttributeType, 9> EnumTraits<::nds::name::attributes::NameRoadRangeAttributeType>::values;
constexpr const char* EnumTraits<::nds::name::attributes::NameRoadRangeAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::attributes::NameRoadRangeAttributeType value)
{
    switch (value)
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        return 0;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        return 1;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        return 2;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        return 3;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        return 4;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return 5;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        return 6;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        return 7;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        return 8;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameRoadRangeAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::attributes::NameRoadRangeAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::name::attributes::NameRoadRangeAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::name::attributes::NameRoadRangeAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
        return static_cast<::nds::name::attributes::NameRoadRangeAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameRoadRangeAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::attributes::NameRoadRangeAttributeType>(::nds::name::attributes::NameRoadRangeAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::attributes::NameRoadRangeAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameRoadRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::attributes::NameRoadRangeAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::attributes::NameRoadRangeAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameRoadRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::attributes::NameRoadRangeAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::attributes::NameRoadRangeAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::attributes::NameRoadRangeAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameRoadRangeAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::name::attributes::NameRoadRangeAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::attributes::NameRoadRangeAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameRoadRangeAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameRoadRangeAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::attributes::NameRoadRangeAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::attributes::NameRoadRangeAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameRoadRangeAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/attributes/NameRoadPositionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameRoadPositionAttributeType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::name::attributes::NameRoadPositionAttributeType>::names;
constexpr ::std::array<::nds::name::attributes::NameRoadPositionAttributeType, 2> EnumTraits<::nds::name::attributes::NameRoadPositionAttributeType>::values;
constexpr const char* EnumTraits<::nds::name::attributes::NameRoadPositionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::attributes::NameRoadPositionAttributeType value)
{
    switch (value)
    {
    case ::nds::name::attributes::NameRoadPositionAttributeType::HOUSE_NUMBER:
        return 0;
    case ::nds::name::attributes::NameRoadPositionAttributeType::TOLL_STATION_NAME:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameRoadPositionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::attributes::NameRoadPositionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::name::attributes::NameRoadPositionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::name::attributes::NameRoadPositionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
        return static_cast<::nds::name::attributes::NameRoadPositionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameRoadPositionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::attributes::NameRoadPositionAttributeType>(::nds::name::attributes::NameRoadPositionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::attributes::NameRoadPositionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameRoadPositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::attributes::NameRoadPositionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::attributes::NameRoadPositionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameRoadPositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::attributes::NameRoadPositionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::attributes::NameRoadPositionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::attributes::NameRoadPositionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameRoadPositionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::name::attributes::NameRoadPositionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::attributes::NameRoadPositionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameRoadPositionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameRoadPositionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::attributes::NameRoadPositionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::attributes::NameRoadPositionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameRoadPositionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/attributes/NameLaneRangeAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameLaneRangeAttributeType enumeration.
constexpr ::std::array<const char*, 9> EnumTraits<::nds::name::attributes::NameLaneRangeAttributeType>::names;
constexpr ::std::array<::nds::name::attributes::NameLaneRangeAttributeType, 9> EnumTraits<::nds::name::attributes::NameLaneRangeAttributeType>::values;
constexpr const char* EnumTraits<::nds::name::attributes::NameLaneRangeAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::attributes::NameLaneRangeAttributeType value)
{
    switch (value)
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        return 0;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        return 1;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        return 2;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        return 3;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        return 4;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return 5;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        return 6;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        return 7;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        return 8;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameLaneRangeAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::attributes::NameLaneRangeAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::name::attributes::NameLaneRangeAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::name::attributes::NameLaneRangeAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
        return static_cast<::nds::name::attributes::NameLaneRangeAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameLaneRangeAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::attributes::NameLaneRangeAttributeType>(::nds::name::attributes::NameLaneRangeAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::attributes::NameLaneRangeAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameLaneRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::attributes::NameLaneRangeAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::attributes::NameLaneRangeAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameLaneRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::attributes::NameLaneRangeAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::attributes::NameLaneRangeAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::attributes::NameLaneRangeAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameLaneRangeAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::name::attributes::NameLaneRangeAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::attributes::NameLaneRangeAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameLaneRangeAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameLaneRangeAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::attributes::NameLaneRangeAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::attributes::NameLaneRangeAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameLaneRangeAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/attributes/NameLanePositionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameLanePositionAttributeType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::name::attributes::NameLanePositionAttributeType>::names;
constexpr ::std::array<::nds::name::attributes::NameLanePositionAttributeType, 2> EnumTraits<::nds::name::attributes::NameLanePositionAttributeType>::values;
constexpr const char* EnumTraits<::nds::name::attributes::NameLanePositionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::attributes::NameLanePositionAttributeType value)
{
    switch (value)
    {
    case ::nds::name::attributes::NameLanePositionAttributeType::HOUSE_NUMBER:
        return 0;
    case ::nds::name::attributes::NameLanePositionAttributeType::TOLL_STATION_NAME:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameLanePositionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::attributes::NameLanePositionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::name::attributes::NameLanePositionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::name::attributes::NameLanePositionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
        return static_cast<::nds::name::attributes::NameLanePositionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameLanePositionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::attributes::NameLanePositionAttributeType>(::nds::name::attributes::NameLanePositionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::attributes::NameLanePositionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameLanePositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::attributes::NameLanePositionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::attributes::NameLanePositionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameLanePositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::attributes::NameLanePositionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::attributes::NameLanePositionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::attributes::NameLanePositionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameLanePositionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::name::attributes::NameLanePositionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::attributes::NameLanePositionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameLanePositionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameLanePositionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::attributes::NameLanePositionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::attributes::NameLanePositionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameLanePositionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/attributes/NameDisplayLineRangeAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameDisplayLineRangeAttributeType enumeration.
constexpr ::std::array<const char*, 12> EnumTraits<::nds::name::attributes::NameDisplayLineRangeAttributeType>::names;
constexpr ::std::array<::nds::name::attributes::NameDisplayLineRangeAttributeType, 12> EnumTraits<::nds::name::attributes::NameDisplayLineRangeAttributeType>::values;
constexpr const char* EnumTraits<::nds::name::attributes::NameDisplayLineRangeAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::attributes::NameDisplayLineRangeAttributeType value)
{
    switch (value)
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        return 0;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        return 1;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        return 2;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        return 3;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        return 4;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return 5;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        return 6;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        return 7;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        return 8;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        return 9;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        return 10;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        return 11;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameDisplayLineRangeAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::attributes::NameDisplayLineRangeAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::name::attributes::NameDisplayLineRangeAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::name::attributes::NameDisplayLineRangeAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
        return static_cast<::nds::name::attributes::NameDisplayLineRangeAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameDisplayLineRangeAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::attributes::NameDisplayLineRangeAttributeType>(::nds::name::attributes::NameDisplayLineRangeAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::attributes::NameDisplayLineRangeAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayLineRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::attributes::NameDisplayLineRangeAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::attributes::NameDisplayLineRangeAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayLineRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::attributes::NameDisplayLineRangeAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::attributes::NameDisplayLineRangeAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::attributes::NameDisplayLineRangeAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameDisplayLineRangeAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::name::attributes::NameDisplayLineRangeAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::attributes::NameDisplayLineRangeAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameDisplayLineRangeAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayLineRangeAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::attributes::NameDisplayLineRangeAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::attributes::NameDisplayLineRangeAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayLineRangeAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/attributes/NameDisplayAreaAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameDisplayAreaAttributeType enumeration.
constexpr ::std::array<const char*, 11> EnumTraits<::nds::name::attributes::NameDisplayAreaAttributeType>::names;
constexpr ::std::array<::nds::name::attributes::NameDisplayAreaAttributeType, 11> EnumTraits<::nds::name::attributes::NameDisplayAreaAttributeType>::values;
constexpr const char* EnumTraits<::nds::name::attributes::NameDisplayAreaAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::attributes::NameDisplayAreaAttributeType value)
{
    switch (value)
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        return 0;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        return 1;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        return 2;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        return 3;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        return 4;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        return 5;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        return 6;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        return 7;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        return 8;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        return 9;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        return 10;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameDisplayAreaAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::attributes::NameDisplayAreaAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::name::attributes::NameDisplayAreaAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::name::attributes::NameDisplayAreaAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
        return static_cast<::nds::name::attributes::NameDisplayAreaAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameDisplayAreaAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::attributes::NameDisplayAreaAttributeType>(::nds::name::attributes::NameDisplayAreaAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::attributes::NameDisplayAreaAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayAreaAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::attributes::NameDisplayAreaAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::attributes::NameDisplayAreaAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayAreaAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::attributes::NameDisplayAreaAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::attributes::NameDisplayAreaAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::attributes::NameDisplayAreaAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameDisplayAreaAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::name::attributes::NameDisplayAreaAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::attributes::NameDisplayAreaAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameDisplayAreaAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayAreaAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::attributes::NameDisplayAreaAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::attributes::NameDisplayAreaAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayAreaAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/attributes/NameDisplayPointAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameDisplayPointAttributeType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::name::attributes::NameDisplayPointAttributeType>::names;
constexpr ::std::array<::nds::name::attributes::NameDisplayPointAttributeType, 5> EnumTraits<::nds::name::attributes::NameDisplayPointAttributeType>::values;
constexpr const char* EnumTraits<::nds::name::attributes::NameDisplayPointAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::attributes::NameDisplayPointAttributeType value)
{
    switch (value)
    {
    case ::nds::name::attributes::NameDisplayPointAttributeType::POINT_LABEL_NAME:
        return 0;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ADMINISTRATIVE_AREA_CENTER_NAME:
        return 1;
    case ::nds::name::attributes::NameDisplayPointAttributeType::MOUNTAIN_NAME:
        return 2;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ISLAND_NAME:
        return 3;
    case ::nds::name::attributes::NameDisplayPointAttributeType::TOLL_STATION_NAME:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameDisplayPointAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::attributes::NameDisplayPointAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::name::attributes::NameDisplayPointAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::name::attributes::NameDisplayPointAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
        return static_cast<::nds::name::attributes::NameDisplayPointAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameDisplayPointAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::attributes::NameDisplayPointAttributeType>(::nds::name::attributes::NameDisplayPointAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::attributes::NameDisplayPointAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayPointAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::attributes::NameDisplayPointAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::attributes::NameDisplayPointAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayPointAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::attributes::NameDisplayPointAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::attributes::NameDisplayPointAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::attributes::NameDisplayPointAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameDisplayPointAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::name::attributes::NameDisplayPointAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::attributes::NameDisplayPointAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NameDisplayPointAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayPointAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::attributes::NameDisplayPointAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::attributes::NameDisplayPointAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NameDisplayPointAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/attributes/NamePoiAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NamePoiAttributeType enumeration.
constexpr ::std::array<const char*, 6> EnumTraits<::nds::name::attributes::NamePoiAttributeType>::names;
constexpr ::std::array<::nds::name::attributes::NamePoiAttributeType, 6> EnumTraits<::nds::name::attributes::NamePoiAttributeType>::values;
constexpr const char* EnumTraits<::nds::name::attributes::NamePoiAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::attributes::NamePoiAttributeType value)
{
    switch (value)
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        return 0;
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        return 1;
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        return 2;
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        return 3;
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        return 4;
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        return 5;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NamePoiAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::attributes::NamePoiAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::name::attributes::NamePoiAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::name::attributes::NamePoiAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
        return static_cast<::nds::name::attributes::NamePoiAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NamePoiAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::attributes::NamePoiAttributeType>(::nds::name::attributes::NamePoiAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::attributes::NamePoiAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NamePoiAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::attributes::NamePoiAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::attributes::NamePoiAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NamePoiAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::attributes::NamePoiAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::attributes::NamePoiAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::attributes::NamePoiAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NamePoiAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::name::attributes::NamePoiAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::attributes::NamePoiAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::attributes::NamePoiAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NamePoiAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::attributes::NamePoiAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::attributes::NamePoiAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::attributes::NamePoiAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/attributes/NameTransitionAttributeValue.h>

namespace nds
{
namespace name
{
namespace attributes
{

NameTransitionAttributeValue::NameTransitionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

NameTransitionAttributeValue::NameTransitionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

NameTransitionAttributeValue::NameTransitionAttributeValue(const NameTransitionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameTransitionAttributeValue& NameTransitionAttributeValue::operator=(const NameTransitionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameTransitionAttributeValue::NameTransitionAttributeValue(NameTransitionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameTransitionAttributeValue& NameTransitionAttributeValue::operator=(NameTransitionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameTransitionAttributeValue::NameTransitionAttributeValue(::zserio::PropagateAllocatorT,
        const NameTransitionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void NameTransitionAttributeValue::initialize(
        ::nds::name::attributes::NameTransitionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool NameTransitionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::name::attributes::NameTransitionAttributeType NameTransitionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'NameTransitionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::name::types::IntersectionName& NameTransitionAttributeValue::getIntersectionName()
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

const ::nds::name::types::IntersectionName& NameTransitionAttributeValue::getIntersectionName() const
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

void NameTransitionAttributeValue::setIntersectionName(const ::nds::name::types::IntersectionName& intersectionName_)
{
    m_objectChoice = intersectionName_;
}

void NameTransitionAttributeValue::setIntersectionName(::nds::name::types::IntersectionName&& intersectionName_)
{
    m_objectChoice = ::std::move(intersectionName_);
}

NameTransitionAttributeValue::ChoiceTag NameTransitionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameTransitionAttributeType::INTERSECTION_NAME:
        return CHOICE_intersectionName;
    default:
        return UNDEFINED_CHOICE;
    }
}

size_t NameTransitionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameTransitionAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameTransitionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameTransitionAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameTransitionAttributeValue!");
    }

    return endBitPosition;
}

bool NameTransitionAttributeValue::operator==(const NameTransitionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::attributes::NameTransitionAttributeType::INTERSECTION_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::IntersectionName>() == other.m_objectChoice.get<::nds::name::types::IntersectionName>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameTransitionAttributeValue!");
    }
}

uint32_t NameTransitionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::attributes::NameTransitionAttributeType::INTERSECTION_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::IntersectionName>());
            break;
        default:
            break;
        }
    }

    return result;
}

void NameTransitionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameTransitionAttributeType::INTERSECTION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> NameTransitionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameTransitionAttributeType::INTERSECTION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::IntersectionName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> NameTransitionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameTransitionAttributeType::INTERSECTION_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::IntersectionName>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameTransitionAttributeValue!");
    }
}

} // namespace attributes
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/attributes/NameRoadRangeAttributeValue.h>

namespace nds
{
namespace name
{
namespace attributes
{

NameRoadRangeAttributeValue::NameRoadRangeAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

NameRoadRangeAttributeValue::NameRoadRangeAttributeValue(::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameRoadRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

NameRoadRangeAttributeValue::NameRoadRangeAttributeValue(NameRoadRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameRoadRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

NameRoadRangeAttributeValue::NameRoadRangeAttributeValue(const NameRoadRangeAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameRoadRangeAttributeValue& NameRoadRangeAttributeValue::operator=(const NameRoadRangeAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameRoadRangeAttributeValue::NameRoadRangeAttributeValue(NameRoadRangeAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameRoadRangeAttributeValue& NameRoadRangeAttributeValue::operator=(NameRoadRangeAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameRoadRangeAttributeValue::NameRoadRangeAttributeValue(::zserio::PropagateAllocatorT,
        const NameRoadRangeAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void NameRoadRangeAttributeValue::initialize(
        ::nds::name::attributes::NameRoadRangeAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;

    initializeChildren();
}

bool NameRoadRangeAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

void NameRoadRangeAttributeValue::initializeChildren()
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        m_objectChoice.get<::nds::name::types::HouseNumberRange>().initializeChildren();
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }
}

::nds::name::attributes::NameRoadRangeAttributeType NameRoadRangeAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'NameRoadRangeAttributeValue' is not initialized!");

    return m_type_;
}

::nds::name::types::RoadName& NameRoadRangeAttributeValue::getRoadName()
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

const ::nds::name::types::RoadName& NameRoadRangeAttributeValue::getRoadName() const
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

void NameRoadRangeAttributeValue::setRoadName(const ::nds::name::types::RoadName& roadName_)
{
    m_objectChoice = roadName_;
}

void NameRoadRangeAttributeValue::setRoadName(::nds::name::types::RoadName&& roadName_)
{
    m_objectChoice = ::std::move(roadName_);
}

::nds::name::types::BridgeName& NameRoadRangeAttributeValue::getBridgeName()
{
    return m_objectChoice.get<::nds::name::types::BridgeName>();
}

const ::nds::name::types::BridgeName& NameRoadRangeAttributeValue::getBridgeName() const
{
    return m_objectChoice.get<::nds::name::types::BridgeName>();
}

void NameRoadRangeAttributeValue::setBridgeName(const ::nds::name::types::BridgeName& bridgeName_)
{
    m_objectChoice = bridgeName_;
}

void NameRoadRangeAttributeValue::setBridgeName(::nds::name::types::BridgeName&& bridgeName_)
{
    m_objectChoice = ::std::move(bridgeName_);
}

::nds::name::types::TunnelName& NameRoadRangeAttributeValue::getTunnelName()
{
    return m_objectChoice.get<::nds::name::types::TunnelName>();
}

const ::nds::name::types::TunnelName& NameRoadRangeAttributeValue::getTunnelName() const
{
    return m_objectChoice.get<::nds::name::types::TunnelName>();
}

void NameRoadRangeAttributeValue::setTunnelName(const ::nds::name::types::TunnelName& tunnelName_)
{
    m_objectChoice = tunnelName_;
}

void NameRoadRangeAttributeValue::setTunnelName(::nds::name::types::TunnelName&& tunnelName_)
{
    m_objectChoice = ::std::move(tunnelName_);
}

::nds::name::types::RouteName& NameRoadRangeAttributeValue::getRouteName()
{
    return m_objectChoice.get<::nds::name::types::RouteName>();
}

const ::nds::name::types::RouteName& NameRoadRangeAttributeValue::getRouteName() const
{
    return m_objectChoice.get<::nds::name::types::RouteName>();
}

void NameRoadRangeAttributeValue::setRouteName(const ::nds::name::types::RouteName& routeName_)
{
    m_objectChoice = routeName_;
}

void NameRoadRangeAttributeValue::setRouteName(::nds::name::types::RouteName&& routeName_)
{
    m_objectChoice = ::std::move(routeName_);
}

::nds::name::types::RoadNumber& NameRoadRangeAttributeValue::getRoadNumber()
{
    return m_objectChoice.get<::nds::name::types::RoadNumber>();
}

const ::nds::name::types::RoadNumber& NameRoadRangeAttributeValue::getRoadNumber() const
{
    return m_objectChoice.get<::nds::name::types::RoadNumber>();
}

void NameRoadRangeAttributeValue::setRoadNumber(const ::nds::name::types::RoadNumber& roadNumber_)
{
    m_objectChoice = roadNumber_;
}

void NameRoadRangeAttributeValue::setRoadNumber(::nds::name::types::RoadNumber&& roadNumber_)
{
    m_objectChoice = ::std::move(roadNumber_);
}

::nds::name::types::AdministrativeHierarchy& NameRoadRangeAttributeValue::getAdministrativeHierarchy()
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

const ::nds::name::types::AdministrativeHierarchy& NameRoadRangeAttributeValue::getAdministrativeHierarchy() const
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

void NameRoadRangeAttributeValue::setAdministrativeHierarchy(const ::nds::name::types::AdministrativeHierarchy& administrativeHierarchy_)
{
    m_objectChoice = administrativeHierarchy_;
}

void NameRoadRangeAttributeValue::setAdministrativeHierarchy(::nds::name::types::AdministrativeHierarchy&& administrativeHierarchy_)
{
    m_objectChoice = ::std::move(administrativeHierarchy_);
}

::nds::name::types::HouseNumberRange& NameRoadRangeAttributeValue::getHouseNumberRange()
{
    return m_objectChoice.get<::nds::name::types::HouseNumberRange>();
}

const ::nds::name::types::HouseNumberRange& NameRoadRangeAttributeValue::getHouseNumberRange() const
{
    return m_objectChoice.get<::nds::name::types::HouseNumberRange>();
}

void NameRoadRangeAttributeValue::setHouseNumberRange(const ::nds::name::types::HouseNumberRange& houseNumberRange_)
{
    m_objectChoice = houseNumberRange_;
}

void NameRoadRangeAttributeValue::setHouseNumberRange(::nds::name::types::HouseNumberRange&& houseNumberRange_)
{
    m_objectChoice = ::std::move(houseNumberRange_);
}

::nds::name::types::ServiceAreaName& NameRoadRangeAttributeValue::getServiceAreaName()
{
    return m_objectChoice.get<::nds::name::types::ServiceAreaName>();
}

const ::nds::name::types::ServiceAreaName& NameRoadRangeAttributeValue::getServiceAreaName() const
{
    return m_objectChoice.get<::nds::name::types::ServiceAreaName>();
}

void NameRoadRangeAttributeValue::setServiceAreaName(const ::nds::name::types::ServiceAreaName& serviceAreaName_)
{
    m_objectChoice = serviceAreaName_;
}

void NameRoadRangeAttributeValue::setServiceAreaName(::nds::name::types::ServiceAreaName&& serviceAreaName_)
{
    m_objectChoice = ::std::move(serviceAreaName_);
}

::nds::name::types::IntersectionName& NameRoadRangeAttributeValue::getIntersectionName()
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

const ::nds::name::types::IntersectionName& NameRoadRangeAttributeValue::getIntersectionName() const
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

void NameRoadRangeAttributeValue::setIntersectionName(const ::nds::name::types::IntersectionName& intersectionName_)
{
    m_objectChoice = intersectionName_;
}

void NameRoadRangeAttributeValue::setIntersectionName(::nds::name::types::IntersectionName&& intersectionName_)
{
    m_objectChoice = ::std::move(intersectionName_);
}

NameRoadRangeAttributeValue::ChoiceTag NameRoadRangeAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        return CHOICE_roadName;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        return CHOICE_bridgeName;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        return CHOICE_tunnelName;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        return CHOICE_routeName;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        return CHOICE_roadNumber;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return CHOICE_administrativeHierarchy;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        return CHOICE_houseNumberRange;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        return CHOICE_serviceAreaName;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        return CHOICE_intersectionName;
    default:
        return UNDEFINED_CHOICE;
    }
}

void NameRoadRangeAttributeValue::initPackingContext(NameRoadRangeAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initPackingContext(context.getAdministrativeHierarchy());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        m_objectChoice.get<::nds::name::types::HouseNumberRange>().initPackingContext(context.getHouseNumberRange());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }
}

size_t NameRoadRangeAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameRoadRangeAttributeValue::bitSizeOf(NameRoadRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberRange>().bitSizeOf(context.getHouseNumberRange(), endBitPosition);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameRoadRangeAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }

    return endBitPosition;
}

size_t NameRoadRangeAttributeValue::initializeOffsets(NameRoadRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberRange>().initializeOffsets(context.getHouseNumberRange(), endBitPosition);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }

    return endBitPosition;
}

bool NameRoadRangeAttributeValue::operator==(const NameRoadRangeAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RoadName>() == other.m_objectChoice.get<::nds::name::types::RoadName>());
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::BridgeName>() == other.m_objectChoice.get<::nds::name::types::BridgeName>());
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::TunnelName>() == other.m_objectChoice.get<::nds::name::types::TunnelName>());
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RouteName>() == other.m_objectChoice.get<::nds::name::types::RouteName>());
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RoadNumber>() == other.m_objectChoice.get<::nds::name::types::RoadNumber>());
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>() == other.m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::HouseNumberRange>() == other.m_objectChoice.get<::nds::name::types::HouseNumberRange>());
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::ServiceAreaName>() == other.m_objectChoice.get<::nds::name::types::ServiceAreaName>());
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::IntersectionName>() == other.m_objectChoice.get<::nds::name::types::IntersectionName>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }
}

uint32_t NameRoadRangeAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RoadName>());
            break;
        case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::BridgeName>());
            break;
        case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::TunnelName>());
            break;
        case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RouteName>());
            break;
        case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RoadNumber>());
            break;
        case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
            break;
        case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::HouseNumberRange>());
            break;
        case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::ServiceAreaName>());
            break;
        case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::IntersectionName>());
            break;
        default:
            break;
        }
    }

    return result;
}

void NameRoadRangeAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(out);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        m_objectChoice.get<::nds::name::types::HouseNumberRange>().write(out);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }
}

void NameRoadRangeAttributeValue::write(NameRoadRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(context.getAdministrativeHierarchy(), out);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        m_objectChoice.get<::nds::name::types::HouseNumberRange>().write(context.getHouseNumberRange(), out);
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> NameRoadRangeAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BridgeName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TunnelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RouteName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(in, allocator), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberRange(in, allocator), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::ServiceAreaName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::IntersectionName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> NameRoadRangeAttributeValue::readObject(NameRoadRangeAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BridgeName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TunnelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RouteName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(context.getAdministrativeHierarchy(), in, allocator), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberRange(context.getHouseNumberRange(), in, allocator), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::ServiceAreaName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::IntersectionName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> NameRoadRangeAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RoadName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::BRIDGE_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::BridgeName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::TUNNEL_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::TunnelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROUTE_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RouteName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::ROAD_NUMBER:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RoadNumber>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::AdministrativeHierarchy>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::HOUSE_NUMBER_RANGE:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::HouseNumberRange>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::SERVICE_AREA_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::ServiceAreaName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameRoadRangeAttributeType::INTERSECTION_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::IntersectionName>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadRangeAttributeValue!");
    }
}

} // namespace attributes
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/attributes/NameRoadPositionAttributeValue.h>

namespace nds
{
namespace name
{
namespace attributes
{

NameRoadPositionAttributeValue::NameRoadPositionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

NameRoadPositionAttributeValue::NameRoadPositionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameRoadPositionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

NameRoadPositionAttributeValue::NameRoadPositionAttributeValue(const NameRoadPositionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameRoadPositionAttributeValue& NameRoadPositionAttributeValue::operator=(const NameRoadPositionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameRoadPositionAttributeValue::NameRoadPositionAttributeValue(NameRoadPositionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameRoadPositionAttributeValue& NameRoadPositionAttributeValue::operator=(NameRoadPositionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameRoadPositionAttributeValue::NameRoadPositionAttributeValue(::zserio::PropagateAllocatorT,
        const NameRoadPositionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void NameRoadPositionAttributeValue::initialize(
        ::nds::name::attributes::NameRoadPositionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool NameRoadPositionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::name::attributes::NameRoadPositionAttributeType NameRoadPositionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'NameRoadPositionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::name::types::HouseNumber& NameRoadPositionAttributeValue::getHouseNumber()
{
    return m_objectChoice.get<::nds::name::types::HouseNumber>();
}

const ::nds::name::types::HouseNumber& NameRoadPositionAttributeValue::getHouseNumber() const
{
    return m_objectChoice.get<::nds::name::types::HouseNumber>();
}

void NameRoadPositionAttributeValue::setHouseNumber(const ::nds::name::types::HouseNumber& houseNumber_)
{
    m_objectChoice = houseNumber_;
}

void NameRoadPositionAttributeValue::setHouseNumber(::nds::name::types::HouseNumber&& houseNumber_)
{
    m_objectChoice = ::std::move(houseNumber_);
}

::nds::name::types::TollStationName& NameRoadPositionAttributeValue::getTollStationName()
{
    return m_objectChoice.get<::nds::name::types::TollStationName>();
}

const ::nds::name::types::TollStationName& NameRoadPositionAttributeValue::getTollStationName() const
{
    return m_objectChoice.get<::nds::name::types::TollStationName>();
}

void NameRoadPositionAttributeValue::setTollStationName(const ::nds::name::types::TollStationName& tollStationName_)
{
    m_objectChoice = tollStationName_;
}

void NameRoadPositionAttributeValue::setTollStationName(::nds::name::types::TollStationName&& tollStationName_)
{
    m_objectChoice = ::std::move(tollStationName_);
}

NameRoadPositionAttributeValue::ChoiceTag NameRoadPositionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadPositionAttributeType::HOUSE_NUMBER:
        return CHOICE_houseNumber;
    case ::nds::name::attributes::NameRoadPositionAttributeType::TOLL_STATION_NAME:
        return CHOICE_tollStationName;
    default:
        return UNDEFINED_CHOICE;
    }
}

size_t NameRoadPositionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameRoadPositionAttributeType::HOUSE_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NameRoadPositionAttributeType::TOLL_STATION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TollStationName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadPositionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameRoadPositionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameRoadPositionAttributeType::HOUSE_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NameRoadPositionAttributeType::TOLL_STATION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TollStationName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadPositionAttributeValue!");
    }

    return endBitPosition;
}

bool NameRoadPositionAttributeValue::operator==(const NameRoadPositionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::attributes::NameRoadPositionAttributeType::HOUSE_NUMBER:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::HouseNumber>() == other.m_objectChoice.get<::nds::name::types::HouseNumber>());
    case ::nds::name::attributes::NameRoadPositionAttributeType::TOLL_STATION_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::TollStationName>() == other.m_objectChoice.get<::nds::name::types::TollStationName>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadPositionAttributeValue!");
    }
}

uint32_t NameRoadPositionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::attributes::NameRoadPositionAttributeType::HOUSE_NUMBER:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::HouseNumber>());
            break;
        case ::nds::name::attributes::NameRoadPositionAttributeType::TOLL_STATION_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::TollStationName>());
            break;
        default:
            break;
        }
    }

    return result;
}

void NameRoadPositionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadPositionAttributeType::HOUSE_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NameRoadPositionAttributeType::TOLL_STATION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TollStationName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadPositionAttributeValue!");
    }
}

::zserio::AnyHolder<> NameRoadPositionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadPositionAttributeType::HOUSE_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::HouseNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameRoadPositionAttributeType::TOLL_STATION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TollStationName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadPositionAttributeValue!");
    }
}

::zserio::AnyHolder<> NameRoadPositionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameRoadPositionAttributeType::HOUSE_NUMBER:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::HouseNumber>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameRoadPositionAttributeType::TOLL_STATION_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::TollStationName>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameRoadPositionAttributeValue!");
    }
}

} // namespace attributes
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/attributes/NameLaneRangeAttributeValue.h>

namespace nds
{
namespace name
{
namespace attributes
{

NameLaneRangeAttributeValue::NameLaneRangeAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

NameLaneRangeAttributeValue::NameLaneRangeAttributeValue(::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameLaneRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

NameLaneRangeAttributeValue::NameLaneRangeAttributeValue(NameLaneRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameLaneRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

NameLaneRangeAttributeValue::NameLaneRangeAttributeValue(const NameLaneRangeAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameLaneRangeAttributeValue& NameLaneRangeAttributeValue::operator=(const NameLaneRangeAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameLaneRangeAttributeValue::NameLaneRangeAttributeValue(NameLaneRangeAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameLaneRangeAttributeValue& NameLaneRangeAttributeValue::operator=(NameLaneRangeAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameLaneRangeAttributeValue::NameLaneRangeAttributeValue(::zserio::PropagateAllocatorT,
        const NameLaneRangeAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void NameLaneRangeAttributeValue::initialize(
        ::nds::name::attributes::NameLaneRangeAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;

    initializeChildren();
}

bool NameLaneRangeAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

void NameLaneRangeAttributeValue::initializeChildren()
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        m_objectChoice.get<::nds::name::types::HouseNumberRange>().initializeChildren();
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }
}

::nds::name::attributes::NameLaneRangeAttributeType NameLaneRangeAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'NameLaneRangeAttributeValue' is not initialized!");

    return m_type_;
}

::nds::name::types::RoadName& NameLaneRangeAttributeValue::getRoadName()
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

const ::nds::name::types::RoadName& NameLaneRangeAttributeValue::getRoadName() const
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

void NameLaneRangeAttributeValue::setRoadName(const ::nds::name::types::RoadName& roadName_)
{
    m_objectChoice = roadName_;
}

void NameLaneRangeAttributeValue::setRoadName(::nds::name::types::RoadName&& roadName_)
{
    m_objectChoice = ::std::move(roadName_);
}

::nds::name::types::BridgeName& NameLaneRangeAttributeValue::getBridgeName()
{
    return m_objectChoice.get<::nds::name::types::BridgeName>();
}

const ::nds::name::types::BridgeName& NameLaneRangeAttributeValue::getBridgeName() const
{
    return m_objectChoice.get<::nds::name::types::BridgeName>();
}

void NameLaneRangeAttributeValue::setBridgeName(const ::nds::name::types::BridgeName& bridgeName_)
{
    m_objectChoice = bridgeName_;
}

void NameLaneRangeAttributeValue::setBridgeName(::nds::name::types::BridgeName&& bridgeName_)
{
    m_objectChoice = ::std::move(bridgeName_);
}

::nds::name::types::TunnelName& NameLaneRangeAttributeValue::getTunnelName()
{
    return m_objectChoice.get<::nds::name::types::TunnelName>();
}

const ::nds::name::types::TunnelName& NameLaneRangeAttributeValue::getTunnelName() const
{
    return m_objectChoice.get<::nds::name::types::TunnelName>();
}

void NameLaneRangeAttributeValue::setTunnelName(const ::nds::name::types::TunnelName& tunnelName_)
{
    m_objectChoice = tunnelName_;
}

void NameLaneRangeAttributeValue::setTunnelName(::nds::name::types::TunnelName&& tunnelName_)
{
    m_objectChoice = ::std::move(tunnelName_);
}

::nds::name::types::RouteName& NameLaneRangeAttributeValue::getRouteName()
{
    return m_objectChoice.get<::nds::name::types::RouteName>();
}

const ::nds::name::types::RouteName& NameLaneRangeAttributeValue::getRouteName() const
{
    return m_objectChoice.get<::nds::name::types::RouteName>();
}

void NameLaneRangeAttributeValue::setRouteName(const ::nds::name::types::RouteName& routeName_)
{
    m_objectChoice = routeName_;
}

void NameLaneRangeAttributeValue::setRouteName(::nds::name::types::RouteName&& routeName_)
{
    m_objectChoice = ::std::move(routeName_);
}

::nds::name::types::RoadNumber& NameLaneRangeAttributeValue::getRoadNumber()
{
    return m_objectChoice.get<::nds::name::types::RoadNumber>();
}

const ::nds::name::types::RoadNumber& NameLaneRangeAttributeValue::getRoadNumber() const
{
    return m_objectChoice.get<::nds::name::types::RoadNumber>();
}

void NameLaneRangeAttributeValue::setRoadNumber(const ::nds::name::types::RoadNumber& roadNumber_)
{
    m_objectChoice = roadNumber_;
}

void NameLaneRangeAttributeValue::setRoadNumber(::nds::name::types::RoadNumber&& roadNumber_)
{
    m_objectChoice = ::std::move(roadNumber_);
}

::nds::name::types::AdministrativeHierarchy& NameLaneRangeAttributeValue::getAdministrativeHierarchy()
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

const ::nds::name::types::AdministrativeHierarchy& NameLaneRangeAttributeValue::getAdministrativeHierarchy() const
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

void NameLaneRangeAttributeValue::setAdministrativeHierarchy(const ::nds::name::types::AdministrativeHierarchy& administrativeHierarchy_)
{
    m_objectChoice = administrativeHierarchy_;
}

void NameLaneRangeAttributeValue::setAdministrativeHierarchy(::nds::name::types::AdministrativeHierarchy&& administrativeHierarchy_)
{
    m_objectChoice = ::std::move(administrativeHierarchy_);
}

::nds::name::types::HouseNumberRange& NameLaneRangeAttributeValue::getHouseNumberRange()
{
    return m_objectChoice.get<::nds::name::types::HouseNumberRange>();
}

const ::nds::name::types::HouseNumberRange& NameLaneRangeAttributeValue::getHouseNumberRange() const
{
    return m_objectChoice.get<::nds::name::types::HouseNumberRange>();
}

void NameLaneRangeAttributeValue::setHouseNumberRange(const ::nds::name::types::HouseNumberRange& houseNumberRange_)
{
    m_objectChoice = houseNumberRange_;
}

void NameLaneRangeAttributeValue::setHouseNumberRange(::nds::name::types::HouseNumberRange&& houseNumberRange_)
{
    m_objectChoice = ::std::move(houseNumberRange_);
}

::nds::name::types::ServiceAreaName& NameLaneRangeAttributeValue::getServiceAreaName()
{
    return m_objectChoice.get<::nds::name::types::ServiceAreaName>();
}

const ::nds::name::types::ServiceAreaName& NameLaneRangeAttributeValue::getServiceAreaName() const
{
    return m_objectChoice.get<::nds::name::types::ServiceAreaName>();
}

void NameLaneRangeAttributeValue::setServiceAreaName(const ::nds::name::types::ServiceAreaName& serviceAreaName_)
{
    m_objectChoice = serviceAreaName_;
}

void NameLaneRangeAttributeValue::setServiceAreaName(::nds::name::types::ServiceAreaName&& serviceAreaName_)
{
    m_objectChoice = ::std::move(serviceAreaName_);
}

::nds::name::types::IntersectionName& NameLaneRangeAttributeValue::getIntersectionName()
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

const ::nds::name::types::IntersectionName& NameLaneRangeAttributeValue::getIntersectionName() const
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

void NameLaneRangeAttributeValue::setIntersectionName(const ::nds::name::types::IntersectionName& intersectionName_)
{
    m_objectChoice = intersectionName_;
}

void NameLaneRangeAttributeValue::setIntersectionName(::nds::name::types::IntersectionName&& intersectionName_)
{
    m_objectChoice = ::std::move(intersectionName_);
}

NameLaneRangeAttributeValue::ChoiceTag NameLaneRangeAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        return CHOICE_roadName;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        return CHOICE_bridgeName;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        return CHOICE_tunnelName;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        return CHOICE_routeName;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        return CHOICE_roadNumber;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return CHOICE_administrativeHierarchy;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        return CHOICE_houseNumberRange;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        return CHOICE_serviceAreaName;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        return CHOICE_intersectionName;
    default:
        return UNDEFINED_CHOICE;
    }
}

void NameLaneRangeAttributeValue::initPackingContext(NameLaneRangeAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initPackingContext(context.getAdministrativeHierarchy());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        m_objectChoice.get<::nds::name::types::HouseNumberRange>().initPackingContext(context.getHouseNumberRange());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }
}

size_t NameLaneRangeAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameLaneRangeAttributeValue::bitSizeOf(NameLaneRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberRange>().bitSizeOf(context.getHouseNumberRange(), endBitPosition);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameLaneRangeAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }

    return endBitPosition;
}

size_t NameLaneRangeAttributeValue::initializeOffsets(NameLaneRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberRange>().initializeOffsets(context.getHouseNumberRange(), endBitPosition);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }

    return endBitPosition;
}

bool NameLaneRangeAttributeValue::operator==(const NameLaneRangeAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RoadName>() == other.m_objectChoice.get<::nds::name::types::RoadName>());
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::BridgeName>() == other.m_objectChoice.get<::nds::name::types::BridgeName>());
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::TunnelName>() == other.m_objectChoice.get<::nds::name::types::TunnelName>());
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RouteName>() == other.m_objectChoice.get<::nds::name::types::RouteName>());
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RoadNumber>() == other.m_objectChoice.get<::nds::name::types::RoadNumber>());
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>() == other.m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::HouseNumberRange>() == other.m_objectChoice.get<::nds::name::types::HouseNumberRange>());
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::ServiceAreaName>() == other.m_objectChoice.get<::nds::name::types::ServiceAreaName>());
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::IntersectionName>() == other.m_objectChoice.get<::nds::name::types::IntersectionName>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }
}

uint32_t NameLaneRangeAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RoadName>());
            break;
        case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::BridgeName>());
            break;
        case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::TunnelName>());
            break;
        case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RouteName>());
            break;
        case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RoadNumber>());
            break;
        case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
            break;
        case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::HouseNumberRange>());
            break;
        case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::ServiceAreaName>());
            break;
        case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::IntersectionName>());
            break;
        default:
            break;
        }
    }

    return result;
}

void NameLaneRangeAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(out);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        m_objectChoice.get<::nds::name::types::HouseNumberRange>().write(out);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }
}

void NameLaneRangeAttributeValue::write(NameLaneRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(context.getAdministrativeHierarchy(), out);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        m_objectChoice.get<::nds::name::types::HouseNumberRange>().write(context.getHouseNumberRange(), out);
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> NameLaneRangeAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BridgeName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TunnelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RouteName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(in, allocator), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberRange(in, allocator), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::ServiceAreaName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::IntersectionName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> NameLaneRangeAttributeValue::readObject(NameLaneRangeAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BridgeName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TunnelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RouteName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(context.getAdministrativeHierarchy(), in, allocator), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberRange(context.getHouseNumberRange(), in, allocator), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::ServiceAreaName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::IntersectionName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> NameLaneRangeAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RoadName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::BRIDGE_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::BridgeName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::TUNNEL_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::TunnelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROUTE_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RouteName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::ROAD_NUMBER:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RoadNumber>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::AdministrativeHierarchy>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::HOUSE_NUMBER_RANGE:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::HouseNumberRange>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::SERVICE_AREA_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::ServiceAreaName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameLaneRangeAttributeType::INTERSECTION_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::IntersectionName>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLaneRangeAttributeValue!");
    }
}

} // namespace attributes
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/attributes/NameLanePositionAttributeValue.h>

namespace nds
{
namespace name
{
namespace attributes
{

NameLanePositionAttributeValue::NameLanePositionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

NameLanePositionAttributeValue::NameLanePositionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameLanePositionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

NameLanePositionAttributeValue::NameLanePositionAttributeValue(const NameLanePositionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameLanePositionAttributeValue& NameLanePositionAttributeValue::operator=(const NameLanePositionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameLanePositionAttributeValue::NameLanePositionAttributeValue(NameLanePositionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameLanePositionAttributeValue& NameLanePositionAttributeValue::operator=(NameLanePositionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameLanePositionAttributeValue::NameLanePositionAttributeValue(::zserio::PropagateAllocatorT,
        const NameLanePositionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void NameLanePositionAttributeValue::initialize(
        ::nds::name::attributes::NameLanePositionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool NameLanePositionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::name::attributes::NameLanePositionAttributeType NameLanePositionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'NameLanePositionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::name::types::HouseNumber& NameLanePositionAttributeValue::getHouseNumber()
{
    return m_objectChoice.get<::nds::name::types::HouseNumber>();
}

const ::nds::name::types::HouseNumber& NameLanePositionAttributeValue::getHouseNumber() const
{
    return m_objectChoice.get<::nds::name::types::HouseNumber>();
}

void NameLanePositionAttributeValue::setHouseNumber(const ::nds::name::types::HouseNumber& houseNumber_)
{
    m_objectChoice = houseNumber_;
}

void NameLanePositionAttributeValue::setHouseNumber(::nds::name::types::HouseNumber&& houseNumber_)
{
    m_objectChoice = ::std::move(houseNumber_);
}

::nds::name::types::TollStationName& NameLanePositionAttributeValue::getTollStationName()
{
    return m_objectChoice.get<::nds::name::types::TollStationName>();
}

const ::nds::name::types::TollStationName& NameLanePositionAttributeValue::getTollStationName() const
{
    return m_objectChoice.get<::nds::name::types::TollStationName>();
}

void NameLanePositionAttributeValue::setTollStationName(const ::nds::name::types::TollStationName& tollStationName_)
{
    m_objectChoice = tollStationName_;
}

void NameLanePositionAttributeValue::setTollStationName(::nds::name::types::TollStationName&& tollStationName_)
{
    m_objectChoice = ::std::move(tollStationName_);
}

NameLanePositionAttributeValue::ChoiceTag NameLanePositionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLanePositionAttributeType::HOUSE_NUMBER:
        return CHOICE_houseNumber;
    case ::nds::name::attributes::NameLanePositionAttributeType::TOLL_STATION_NAME:
        return CHOICE_tollStationName;
    default:
        return UNDEFINED_CHOICE;
    }
}

size_t NameLanePositionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameLanePositionAttributeType::HOUSE_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NameLanePositionAttributeType::TOLL_STATION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TollStationName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLanePositionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameLanePositionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameLanePositionAttributeType::HOUSE_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NameLanePositionAttributeType::TOLL_STATION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TollStationName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLanePositionAttributeValue!");
    }

    return endBitPosition;
}

bool NameLanePositionAttributeValue::operator==(const NameLanePositionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::attributes::NameLanePositionAttributeType::HOUSE_NUMBER:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::HouseNumber>() == other.m_objectChoice.get<::nds::name::types::HouseNumber>());
    case ::nds::name::attributes::NameLanePositionAttributeType::TOLL_STATION_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::TollStationName>() == other.m_objectChoice.get<::nds::name::types::TollStationName>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLanePositionAttributeValue!");
    }
}

uint32_t NameLanePositionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::attributes::NameLanePositionAttributeType::HOUSE_NUMBER:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::HouseNumber>());
            break;
        case ::nds::name::attributes::NameLanePositionAttributeType::TOLL_STATION_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::TollStationName>());
            break;
        default:
            break;
        }
    }

    return result;
}

void NameLanePositionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLanePositionAttributeType::HOUSE_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NameLanePositionAttributeType::TOLL_STATION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TollStationName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLanePositionAttributeValue!");
    }
}

::zserio::AnyHolder<> NameLanePositionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLanePositionAttributeType::HOUSE_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::HouseNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameLanePositionAttributeType::TOLL_STATION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TollStationName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLanePositionAttributeValue!");
    }
}

::zserio::AnyHolder<> NameLanePositionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameLanePositionAttributeType::HOUSE_NUMBER:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::HouseNumber>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameLanePositionAttributeType::TOLL_STATION_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::TollStationName>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameLanePositionAttributeValue!");
    }
}

} // namespace attributes
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/attributes/NameDisplayLineRangeAttributeValue.h>

namespace nds
{
namespace name
{
namespace attributes
{

NameDisplayLineRangeAttributeValue::NameDisplayLineRangeAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

NameDisplayLineRangeAttributeValue::NameDisplayLineRangeAttributeValue(::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameDisplayLineRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

NameDisplayLineRangeAttributeValue::NameDisplayLineRangeAttributeValue(NameDisplayLineRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameDisplayLineRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

NameDisplayLineRangeAttributeValue::NameDisplayLineRangeAttributeValue(const NameDisplayLineRangeAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameDisplayLineRangeAttributeValue& NameDisplayLineRangeAttributeValue::operator=(const NameDisplayLineRangeAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameDisplayLineRangeAttributeValue::NameDisplayLineRangeAttributeValue(NameDisplayLineRangeAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameDisplayLineRangeAttributeValue& NameDisplayLineRangeAttributeValue::operator=(NameDisplayLineRangeAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameDisplayLineRangeAttributeValue::NameDisplayLineRangeAttributeValue(::zserio::PropagateAllocatorT,
        const NameDisplayLineRangeAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void NameDisplayLineRangeAttributeValue::initialize(
        ::nds::name::attributes::NameDisplayLineRangeAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool NameDisplayLineRangeAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::name::attributes::NameDisplayLineRangeAttributeType NameDisplayLineRangeAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'NameDisplayLineRangeAttributeValue' is not initialized!");

    return m_type_;
}

::nds::name::types::RoadName& NameDisplayLineRangeAttributeValue::getRoadName()
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

const ::nds::name::types::RoadName& NameDisplayLineRangeAttributeValue::getRoadName() const
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

void NameDisplayLineRangeAttributeValue::setRoadName(const ::nds::name::types::RoadName& roadName_)
{
    m_objectChoice = roadName_;
}

void NameDisplayLineRangeAttributeValue::setRoadName(::nds::name::types::RoadName&& roadName_)
{
    m_objectChoice = ::std::move(roadName_);
}

::nds::name::types::BridgeName& NameDisplayLineRangeAttributeValue::getBridgeName()
{
    return m_objectChoice.get<::nds::name::types::BridgeName>();
}

const ::nds::name::types::BridgeName& NameDisplayLineRangeAttributeValue::getBridgeName() const
{
    return m_objectChoice.get<::nds::name::types::BridgeName>();
}

void NameDisplayLineRangeAttributeValue::setBridgeName(const ::nds::name::types::BridgeName& bridgeName_)
{
    m_objectChoice = bridgeName_;
}

void NameDisplayLineRangeAttributeValue::setBridgeName(::nds::name::types::BridgeName&& bridgeName_)
{
    m_objectChoice = ::std::move(bridgeName_);
}

::nds::name::types::TunnelName& NameDisplayLineRangeAttributeValue::getTunnelName()
{
    return m_objectChoice.get<::nds::name::types::TunnelName>();
}

const ::nds::name::types::TunnelName& NameDisplayLineRangeAttributeValue::getTunnelName() const
{
    return m_objectChoice.get<::nds::name::types::TunnelName>();
}

void NameDisplayLineRangeAttributeValue::setTunnelName(const ::nds::name::types::TunnelName& tunnelName_)
{
    m_objectChoice = tunnelName_;
}

void NameDisplayLineRangeAttributeValue::setTunnelName(::nds::name::types::TunnelName&& tunnelName_)
{
    m_objectChoice = ::std::move(tunnelName_);
}

::nds::name::types::RouteName& NameDisplayLineRangeAttributeValue::getRouteName()
{
    return m_objectChoice.get<::nds::name::types::RouteName>();
}

const ::nds::name::types::RouteName& NameDisplayLineRangeAttributeValue::getRouteName() const
{
    return m_objectChoice.get<::nds::name::types::RouteName>();
}

void NameDisplayLineRangeAttributeValue::setRouteName(const ::nds::name::types::RouteName& routeName_)
{
    m_objectChoice = routeName_;
}

void NameDisplayLineRangeAttributeValue::setRouteName(::nds::name::types::RouteName&& routeName_)
{
    m_objectChoice = ::std::move(routeName_);
}

::nds::name::types::RoadNumber& NameDisplayLineRangeAttributeValue::getRoadNumber()
{
    return m_objectChoice.get<::nds::name::types::RoadNumber>();
}

const ::nds::name::types::RoadNumber& NameDisplayLineRangeAttributeValue::getRoadNumber() const
{
    return m_objectChoice.get<::nds::name::types::RoadNumber>();
}

void NameDisplayLineRangeAttributeValue::setRoadNumber(const ::nds::name::types::RoadNumber& roadNumber_)
{
    m_objectChoice = roadNumber_;
}

void NameDisplayLineRangeAttributeValue::setRoadNumber(::nds::name::types::RoadNumber&& roadNumber_)
{
    m_objectChoice = ::std::move(roadNumber_);
}

::nds::name::types::AdministrativeHierarchy& NameDisplayLineRangeAttributeValue::getAdministrativeHierarchy()
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

const ::nds::name::types::AdministrativeHierarchy& NameDisplayLineRangeAttributeValue::getAdministrativeHierarchy() const
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

void NameDisplayLineRangeAttributeValue::setAdministrativeHierarchy(const ::nds::name::types::AdministrativeHierarchy& administrativeHierarchy_)
{
    m_objectChoice = administrativeHierarchy_;
}

void NameDisplayLineRangeAttributeValue::setAdministrativeHierarchy(::nds::name::types::AdministrativeHierarchy&& administrativeHierarchy_)
{
    m_objectChoice = ::std::move(administrativeHierarchy_);
}

::nds::name::types::LabelName& NameDisplayLineRangeAttributeValue::getLabelName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayLineRangeAttributeValue::getLabelName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayLineRangeAttributeValue::setLabelName(const ::nds::name::types::LabelName& labelName_)
{
    m_objectChoice = labelName_;
}

void NameDisplayLineRangeAttributeValue::setLabelName(::nds::name::types::LabelName&& labelName_)
{
    m_objectChoice = ::std::move(labelName_);
}

::nds::name::types::LabelName& NameDisplayLineRangeAttributeValue::getWaterName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayLineRangeAttributeValue::getWaterName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayLineRangeAttributeValue::setWaterName(const ::nds::name::types::LabelName& waterName_)
{
    m_objectChoice = waterName_;
}

void NameDisplayLineRangeAttributeValue::setWaterName(::nds::name::types::LabelName&& waterName_)
{
    m_objectChoice = ::std::move(waterName_);
}

::nds::name::types::LabelName& NameDisplayLineRangeAttributeValue::getPublicTransportName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayLineRangeAttributeValue::getPublicTransportName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayLineRangeAttributeValue::setPublicTransportName(const ::nds::name::types::LabelName& publicTransportName_)
{
    m_objectChoice = publicTransportName_;
}

void NameDisplayLineRangeAttributeValue::setPublicTransportName(::nds::name::types::LabelName&& publicTransportName_)
{
    m_objectChoice = ::std::move(publicTransportName_);
}

::nds::name::types::LabelName& NameDisplayLineRangeAttributeValue::getBorderName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayLineRangeAttributeValue::getBorderName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayLineRangeAttributeValue::setBorderName(const ::nds::name::types::LabelName& borderName_)
{
    m_objectChoice = borderName_;
}

void NameDisplayLineRangeAttributeValue::setBorderName(::nds::name::types::LabelName&& borderName_)
{
    m_objectChoice = ::std::move(borderName_);
}

::nds::name::types::ServiceAreaName& NameDisplayLineRangeAttributeValue::getServiceAreaName()
{
    return m_objectChoice.get<::nds::name::types::ServiceAreaName>();
}

const ::nds::name::types::ServiceAreaName& NameDisplayLineRangeAttributeValue::getServiceAreaName() const
{
    return m_objectChoice.get<::nds::name::types::ServiceAreaName>();
}

void NameDisplayLineRangeAttributeValue::setServiceAreaName(const ::nds::name::types::ServiceAreaName& serviceAreaName_)
{
    m_objectChoice = serviceAreaName_;
}

void NameDisplayLineRangeAttributeValue::setServiceAreaName(::nds::name::types::ServiceAreaName&& serviceAreaName_)
{
    m_objectChoice = ::std::move(serviceAreaName_);
}

::nds::name::types::IntersectionName& NameDisplayLineRangeAttributeValue::getIntersectionName()
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

const ::nds::name::types::IntersectionName& NameDisplayLineRangeAttributeValue::getIntersectionName() const
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

void NameDisplayLineRangeAttributeValue::setIntersectionName(const ::nds::name::types::IntersectionName& intersectionName_)
{
    m_objectChoice = intersectionName_;
}

void NameDisplayLineRangeAttributeValue::setIntersectionName(::nds::name::types::IntersectionName&& intersectionName_)
{
    m_objectChoice = ::std::move(intersectionName_);
}

NameDisplayLineRangeAttributeValue::ChoiceTag NameDisplayLineRangeAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        return CHOICE_roadName;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        return CHOICE_bridgeName;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        return CHOICE_tunnelName;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        return CHOICE_routeName;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        return CHOICE_roadNumber;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return CHOICE_administrativeHierarchy;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        return CHOICE_labelName;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        return CHOICE_waterName;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        return CHOICE_publicTransportName;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        return CHOICE_borderName;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        return CHOICE_serviceAreaName;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        return CHOICE_intersectionName;
    default:
        return UNDEFINED_CHOICE;
    }
}

void NameDisplayLineRangeAttributeValue::initPackingContext(NameDisplayLineRangeAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initPackingContext(context.getAdministrativeHierarchy());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }
}

size_t NameDisplayLineRangeAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameDisplayLineRangeAttributeValue::bitSizeOf(NameDisplayLineRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameDisplayLineRangeAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }

    return endBitPosition;
}

size_t NameDisplayLineRangeAttributeValue::initializeOffsets(NameDisplayLineRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }

    return endBitPosition;
}

bool NameDisplayLineRangeAttributeValue::operator==(const NameDisplayLineRangeAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RoadName>() == other.m_objectChoice.get<::nds::name::types::RoadName>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::BridgeName>() == other.m_objectChoice.get<::nds::name::types::BridgeName>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::TunnelName>() == other.m_objectChoice.get<::nds::name::types::TunnelName>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RouteName>() == other.m_objectChoice.get<::nds::name::types::RouteName>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RoadNumber>() == other.m_objectChoice.get<::nds::name::types::RoadNumber>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>() == other.m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::ServiceAreaName>() == other.m_objectChoice.get<::nds::name::types::ServiceAreaName>());
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::IntersectionName>() == other.m_objectChoice.get<::nds::name::types::IntersectionName>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }
}

uint32_t NameDisplayLineRangeAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RoadName>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::BridgeName>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::TunnelName>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RouteName>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RoadNumber>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::ServiceAreaName>());
            break;
        case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::IntersectionName>());
            break;
        default:
            break;
        }
    }

    return result;
}

void NameDisplayLineRangeAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(out);
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }
}

void NameDisplayLineRangeAttributeValue::write(NameDisplayLineRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RouteName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadNumber>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(context.getAdministrativeHierarchy(), out);
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> NameDisplayLineRangeAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BridgeName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TunnelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RouteName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(in, allocator), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::ServiceAreaName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::IntersectionName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> NameDisplayLineRangeAttributeValue::readObject(NameDisplayLineRangeAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BridgeName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TunnelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RouteName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(context.getAdministrativeHierarchy(), in, allocator), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::ServiceAreaName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::IntersectionName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> NameDisplayLineRangeAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RoadName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BRIDGE_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::BridgeName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::TUNNEL_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::TunnelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROUTE_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RouteName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ROAD_NUMBER:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RoadNumber>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::AdministrativeHierarchy>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::LINE_LABEL_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::WATER_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::PUBLIC_TRANSPORT_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::BORDER_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::SERVICE_AREA_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::ServiceAreaName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayLineRangeAttributeType::INTERSECTION_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::IntersectionName>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayLineRangeAttributeValue!");
    }
}

} // namespace attributes
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/attributes/NameDisplayAreaAttributeValue.h>

namespace nds
{
namespace name
{
namespace attributes
{

NameDisplayAreaAttributeValue::NameDisplayAreaAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

NameDisplayAreaAttributeValue::NameDisplayAreaAttributeValue(::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameDisplayAreaAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

NameDisplayAreaAttributeValue::NameDisplayAreaAttributeValue(NameDisplayAreaAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameDisplayAreaAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

NameDisplayAreaAttributeValue::NameDisplayAreaAttributeValue(const NameDisplayAreaAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameDisplayAreaAttributeValue& NameDisplayAreaAttributeValue::operator=(const NameDisplayAreaAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameDisplayAreaAttributeValue::NameDisplayAreaAttributeValue(NameDisplayAreaAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameDisplayAreaAttributeValue& NameDisplayAreaAttributeValue::operator=(NameDisplayAreaAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameDisplayAreaAttributeValue::NameDisplayAreaAttributeValue(::zserio::PropagateAllocatorT,
        const NameDisplayAreaAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void NameDisplayAreaAttributeValue::initialize(
        ::nds::name::attributes::NameDisplayAreaAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool NameDisplayAreaAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::name::attributes::NameDisplayAreaAttributeType NameDisplayAreaAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'NameDisplayAreaAttributeValue' is not initialized!");

    return m_type_;
}

::nds::name::types::RoadName& NameDisplayAreaAttributeValue::getRoadName()
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

const ::nds::name::types::RoadName& NameDisplayAreaAttributeValue::getRoadName() const
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

void NameDisplayAreaAttributeValue::setRoadName(const ::nds::name::types::RoadName& roadName_)
{
    m_objectChoice = roadName_;
}

void NameDisplayAreaAttributeValue::setRoadName(::nds::name::types::RoadName&& roadName_)
{
    m_objectChoice = ::std::move(roadName_);
}

::nds::name::types::BridgeName& NameDisplayAreaAttributeValue::getBridgeName()
{
    return m_objectChoice.get<::nds::name::types::BridgeName>();
}

const ::nds::name::types::BridgeName& NameDisplayAreaAttributeValue::getBridgeName() const
{
    return m_objectChoice.get<::nds::name::types::BridgeName>();
}

void NameDisplayAreaAttributeValue::setBridgeName(const ::nds::name::types::BridgeName& bridgeName_)
{
    m_objectChoice = bridgeName_;
}

void NameDisplayAreaAttributeValue::setBridgeName(::nds::name::types::BridgeName&& bridgeName_)
{
    m_objectChoice = ::std::move(bridgeName_);
}

::nds::name::types::TunnelName& NameDisplayAreaAttributeValue::getTunnelName()
{
    return m_objectChoice.get<::nds::name::types::TunnelName>();
}

const ::nds::name::types::TunnelName& NameDisplayAreaAttributeValue::getTunnelName() const
{
    return m_objectChoice.get<::nds::name::types::TunnelName>();
}

void NameDisplayAreaAttributeValue::setTunnelName(const ::nds::name::types::TunnelName& tunnelName_)
{
    m_objectChoice = tunnelName_;
}

void NameDisplayAreaAttributeValue::setTunnelName(::nds::name::types::TunnelName&& tunnelName_)
{
    m_objectChoice = ::std::move(tunnelName_);
}

::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getAreaName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getAreaName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayAreaAttributeValue::setAreaName(const ::nds::name::types::LabelName& areaName_)
{
    m_objectChoice = areaName_;
}

void NameDisplayAreaAttributeValue::setAreaName(::nds::name::types::LabelName&& areaName_)
{
    m_objectChoice = ::std::move(areaName_);
}

::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getBuildingName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getBuildingName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayAreaAttributeValue::setBuildingName(const ::nds::name::types::LabelName& buildingName_)
{
    m_objectChoice = buildingName_;
}

void NameDisplayAreaAttributeValue::setBuildingName(::nds::name::types::LabelName&& buildingName_)
{
    m_objectChoice = ::std::move(buildingName_);
}

::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getNatureAreaName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getNatureAreaName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayAreaAttributeValue::setNatureAreaName(const ::nds::name::types::LabelName& natureAreaName_)
{
    m_objectChoice = natureAreaName_;
}

void NameDisplayAreaAttributeValue::setNatureAreaName(::nds::name::types::LabelName&& natureAreaName_)
{
    m_objectChoice = ::std::move(natureAreaName_);
}

::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getWaterName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getWaterName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayAreaAttributeValue::setWaterName(const ::nds::name::types::LabelName& waterName_)
{
    m_objectChoice = waterName_;
}

void NameDisplayAreaAttributeValue::setWaterName(::nds::name::types::LabelName&& waterName_)
{
    m_objectChoice = ::std::move(waterName_);
}

::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getAdministrativeAreaName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayAreaAttributeValue::getAdministrativeAreaName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayAreaAttributeValue::setAdministrativeAreaName(const ::nds::name::types::LabelName& administrativeAreaName_)
{
    m_objectChoice = administrativeAreaName_;
}

void NameDisplayAreaAttributeValue::setAdministrativeAreaName(::nds::name::types::LabelName&& administrativeAreaName_)
{
    m_objectChoice = ::std::move(administrativeAreaName_);
}

::nds::name::types::AdministrativeHierarchy& NameDisplayAreaAttributeValue::getAdministrativeHierarchy()
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

const ::nds::name::types::AdministrativeHierarchy& NameDisplayAreaAttributeValue::getAdministrativeHierarchy() const
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

void NameDisplayAreaAttributeValue::setAdministrativeHierarchy(const ::nds::name::types::AdministrativeHierarchy& administrativeHierarchy_)
{
    m_objectChoice = administrativeHierarchy_;
}

void NameDisplayAreaAttributeValue::setAdministrativeHierarchy(::nds::name::types::AdministrativeHierarchy&& administrativeHierarchy_)
{
    m_objectChoice = ::std::move(administrativeHierarchy_);
}

::nds::name::types::ServiceAreaName& NameDisplayAreaAttributeValue::getServiceAreaName()
{
    return m_objectChoice.get<::nds::name::types::ServiceAreaName>();
}

const ::nds::name::types::ServiceAreaName& NameDisplayAreaAttributeValue::getServiceAreaName() const
{
    return m_objectChoice.get<::nds::name::types::ServiceAreaName>();
}

void NameDisplayAreaAttributeValue::setServiceAreaName(const ::nds::name::types::ServiceAreaName& serviceAreaName_)
{
    m_objectChoice = serviceAreaName_;
}

void NameDisplayAreaAttributeValue::setServiceAreaName(::nds::name::types::ServiceAreaName&& serviceAreaName_)
{
    m_objectChoice = ::std::move(serviceAreaName_);
}

::nds::name::types::IntersectionName& NameDisplayAreaAttributeValue::getIntersectionName()
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

const ::nds::name::types::IntersectionName& NameDisplayAreaAttributeValue::getIntersectionName() const
{
    return m_objectChoice.get<::nds::name::types::IntersectionName>();
}

void NameDisplayAreaAttributeValue::setIntersectionName(const ::nds::name::types::IntersectionName& intersectionName_)
{
    m_objectChoice = intersectionName_;
}

void NameDisplayAreaAttributeValue::setIntersectionName(::nds::name::types::IntersectionName&& intersectionName_)
{
    m_objectChoice = ::std::move(intersectionName_);
}

NameDisplayAreaAttributeValue::ChoiceTag NameDisplayAreaAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        return CHOICE_roadName;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        return CHOICE_bridgeName;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        return CHOICE_tunnelName;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        return CHOICE_areaName;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        return CHOICE_buildingName;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        return CHOICE_natureAreaName;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        return CHOICE_waterName;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        return CHOICE_administrativeAreaName;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        return CHOICE_administrativeHierarchy;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        return CHOICE_serviceAreaName;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        return CHOICE_intersectionName;
    default:
        return UNDEFINED_CHOICE;
    }
}

void NameDisplayAreaAttributeValue::initPackingContext(NameDisplayAreaAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initPackingContext(context.getAdministrativeHierarchy());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }
}

size_t NameDisplayAreaAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameDisplayAreaAttributeValue::bitSizeOf(NameDisplayAreaAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameDisplayAreaAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }

    return endBitPosition;
}

size_t NameDisplayAreaAttributeValue::initializeOffsets(NameDisplayAreaAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }

    return endBitPosition;
}

bool NameDisplayAreaAttributeValue::operator==(const NameDisplayAreaAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RoadName>() == other.m_objectChoice.get<::nds::name::types::RoadName>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::BridgeName>() == other.m_objectChoice.get<::nds::name::types::BridgeName>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::TunnelName>() == other.m_objectChoice.get<::nds::name::types::TunnelName>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>() == other.m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::ServiceAreaName>() == other.m_objectChoice.get<::nds::name::types::ServiceAreaName>());
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::IntersectionName>() == other.m_objectChoice.get<::nds::name::types::IntersectionName>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }
}

uint32_t NameDisplayAreaAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RoadName>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::BridgeName>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::TunnelName>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::ServiceAreaName>());
            break;
        case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::IntersectionName>());
            break;
        default:
            break;
        }
    }

    return result;
}

void NameDisplayAreaAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(out);
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }
}

void NameDisplayAreaAttributeValue::write(NameDisplayAreaAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BridgeName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TunnelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(context.getAdministrativeHierarchy(), out);
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::ServiceAreaName>());
        break;
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::IntersectionName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }
}

::zserio::AnyHolder<> NameDisplayAreaAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BridgeName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TunnelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(in, allocator), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::ServiceAreaName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::IntersectionName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }
}

::zserio::AnyHolder<> NameDisplayAreaAttributeValue::readObject(NameDisplayAreaAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BridgeName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TunnelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(context.getAdministrativeHierarchy(), in, allocator), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::ServiceAreaName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::IntersectionName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }
}

::zserio::AnyHolder<> NameDisplayAreaAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ROAD_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RoadName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BRIDGE_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::BridgeName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::TUNNEL_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::TunnelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::AREA_LABEL_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::BUILDING_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::NATURE_AREA_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::WATER_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_AREA_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::AdministrativeHierarchy>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::SERVICE_AREA_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::ServiceAreaName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayAreaAttributeType::INTERSECTION_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::IntersectionName>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayAreaAttributeValue!");
    }
}

} // namespace attributes
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/attributes/NameDisplayPointAttributeValue.h>

namespace nds
{
namespace name
{
namespace attributes
{

NameDisplayPointAttributeValue::NameDisplayPointAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

NameDisplayPointAttributeValue::NameDisplayPointAttributeValue(::zserio::BitStreamReader& in,
        ::nds::name::attributes::NameDisplayPointAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

NameDisplayPointAttributeValue::NameDisplayPointAttributeValue(const NameDisplayPointAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameDisplayPointAttributeValue& NameDisplayPointAttributeValue::operator=(const NameDisplayPointAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameDisplayPointAttributeValue::NameDisplayPointAttributeValue(NameDisplayPointAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NameDisplayPointAttributeValue& NameDisplayPointAttributeValue::operator=(NameDisplayPointAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NameDisplayPointAttributeValue::NameDisplayPointAttributeValue(::zserio::PropagateAllocatorT,
        const NameDisplayPointAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void NameDisplayPointAttributeValue::initialize(
        ::nds::name::attributes::NameDisplayPointAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool NameDisplayPointAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::name::attributes::NameDisplayPointAttributeType NameDisplayPointAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'NameDisplayPointAttributeValue' is not initialized!");

    return m_type_;
}

::nds::name::types::LabelName& NameDisplayPointAttributeValue::getPointName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayPointAttributeValue::getPointName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayPointAttributeValue::setPointName(const ::nds::name::types::LabelName& pointName_)
{
    m_objectChoice = pointName_;
}

void NameDisplayPointAttributeValue::setPointName(::nds::name::types::LabelName&& pointName_)
{
    m_objectChoice = ::std::move(pointName_);
}

::nds::name::types::LabelName& NameDisplayPointAttributeValue::getAdministrativeAreaCenterName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayPointAttributeValue::getAdministrativeAreaCenterName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayPointAttributeValue::setAdministrativeAreaCenterName(const ::nds::name::types::LabelName& administrativeAreaCenterName_)
{
    m_objectChoice = administrativeAreaCenterName_;
}

void NameDisplayPointAttributeValue::setAdministrativeAreaCenterName(::nds::name::types::LabelName&& administrativeAreaCenterName_)
{
    m_objectChoice = ::std::move(administrativeAreaCenterName_);
}

::nds::name::types::LabelName& NameDisplayPointAttributeValue::getMountainName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayPointAttributeValue::getMountainName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayPointAttributeValue::setMountainName(const ::nds::name::types::LabelName& mountainName_)
{
    m_objectChoice = mountainName_;
}

void NameDisplayPointAttributeValue::setMountainName(::nds::name::types::LabelName&& mountainName_)
{
    m_objectChoice = ::std::move(mountainName_);
}

::nds::name::types::LabelName& NameDisplayPointAttributeValue::getIslandName()
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

const ::nds::name::types::LabelName& NameDisplayPointAttributeValue::getIslandName() const
{
    return m_objectChoice.get<::nds::name::types::LabelName>();
}

void NameDisplayPointAttributeValue::setIslandName(const ::nds::name::types::LabelName& islandName_)
{
    m_objectChoice = islandName_;
}

void NameDisplayPointAttributeValue::setIslandName(::nds::name::types::LabelName&& islandName_)
{
    m_objectChoice = ::std::move(islandName_);
}

::nds::name::types::TollStationName& NameDisplayPointAttributeValue::getTollStationName()
{
    return m_objectChoice.get<::nds::name::types::TollStationName>();
}

const ::nds::name::types::TollStationName& NameDisplayPointAttributeValue::getTollStationName() const
{
    return m_objectChoice.get<::nds::name::types::TollStationName>();
}

void NameDisplayPointAttributeValue::setTollStationName(const ::nds::name::types::TollStationName& tollStationName_)
{
    m_objectChoice = tollStationName_;
}

void NameDisplayPointAttributeValue::setTollStationName(::nds::name::types::TollStationName&& tollStationName_)
{
    m_objectChoice = ::std::move(tollStationName_);
}

NameDisplayPointAttributeValue::ChoiceTag NameDisplayPointAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayPointAttributeType::POINT_LABEL_NAME:
        return CHOICE_pointName;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ADMINISTRATIVE_AREA_CENTER_NAME:
        return CHOICE_administrativeAreaCenterName;
    case ::nds::name::attributes::NameDisplayPointAttributeType::MOUNTAIN_NAME:
        return CHOICE_mountainName;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ISLAND_NAME:
        return CHOICE_islandName;
    case ::nds::name::attributes::NameDisplayPointAttributeType::TOLL_STATION_NAME:
        return CHOICE_tollStationName;
    default:
        return UNDEFINED_CHOICE;
    }
}

size_t NameDisplayPointAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayPointAttributeType::POINT_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ADMINISTRATIVE_AREA_CENTER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::MOUNTAIN_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ISLAND_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::TOLL_STATION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TollStationName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayPointAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NameDisplayPointAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayPointAttributeType::POINT_LABEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ADMINISTRATIVE_AREA_CENTER_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::MOUNTAIN_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ISLAND_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::TOLL_STATION_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::TollStationName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayPointAttributeValue!");
    }

    return endBitPosition;
}

bool NameDisplayPointAttributeValue::operator==(const NameDisplayPointAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayPointAttributeType::POINT_LABEL_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayPointAttributeType::ADMINISTRATIVE_AREA_CENTER_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayPointAttributeType::MOUNTAIN_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayPointAttributeType::ISLAND_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::LabelName>() == other.m_objectChoice.get<::nds::name::types::LabelName>());
    case ::nds::name::attributes::NameDisplayPointAttributeType::TOLL_STATION_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::TollStationName>() == other.m_objectChoice.get<::nds::name::types::TollStationName>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayPointAttributeValue!");
    }
}

uint32_t NameDisplayPointAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::attributes::NameDisplayPointAttributeType::POINT_LABEL_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayPointAttributeType::ADMINISTRATIVE_AREA_CENTER_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayPointAttributeType::MOUNTAIN_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayPointAttributeType::ISLAND_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::LabelName>());
            break;
        case ::nds::name::attributes::NameDisplayPointAttributeType::TOLL_STATION_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::TollStationName>());
            break;
        default:
            break;
        }
    }

    return result;
}

void NameDisplayPointAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayPointAttributeType::POINT_LABEL_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ADMINISTRATIVE_AREA_CENTER_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::MOUNTAIN_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::ISLAND_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::LabelName>());
        break;
    case ::nds::name::attributes::NameDisplayPointAttributeType::TOLL_STATION_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::TollStationName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayPointAttributeValue!");
    }
}

::zserio::AnyHolder<> NameDisplayPointAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayPointAttributeType::POINT_LABEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayPointAttributeType::ADMINISTRATIVE_AREA_CENTER_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayPointAttributeType::MOUNTAIN_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayPointAttributeType::ISLAND_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::LabelName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NameDisplayPointAttributeType::TOLL_STATION_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::TollStationName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayPointAttributeValue!");
    }
}

::zserio::AnyHolder<> NameDisplayPointAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NameDisplayPointAttributeType::POINT_LABEL_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayPointAttributeType::ADMINISTRATIVE_AREA_CENTER_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayPointAttributeType::MOUNTAIN_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayPointAttributeType::ISLAND_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::LabelName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NameDisplayPointAttributeType::TOLL_STATION_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::TollStationName>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NameDisplayPointAttributeValue!");
    }
}

} // namespace attributes
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/attributes/NamePoiAttributeValue.h>

namespace nds
{
namespace name
{
namespace attributes
{

NamePoiAttributeValue::NamePoiAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

NamePoiAttributeValue::NamePoiAttributeValue(::zserio::BitStreamReader& in,
        ::nds::name::attributes::NamePoiAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

NamePoiAttributeValue::NamePoiAttributeValue(NamePoiAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::name::attributes::NamePoiAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

NamePoiAttributeValue::NamePoiAttributeValue(const NamePoiAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NamePoiAttributeValue& NamePoiAttributeValue::operator=(const NamePoiAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NamePoiAttributeValue::NamePoiAttributeValue(NamePoiAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

NamePoiAttributeValue& NamePoiAttributeValue::operator=(NamePoiAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

NamePoiAttributeValue::NamePoiAttributeValue(::zserio::PropagateAllocatorT,
        const NamePoiAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void NamePoiAttributeValue::initialize(
        ::nds::name::attributes::NamePoiAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool NamePoiAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::name::attributes::NamePoiAttributeType NamePoiAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'NamePoiAttributeValue' is not initialized!");

    return m_type_;
}

::nds::name::types::PoiName& NamePoiAttributeValue::getPoiName()
{
    return m_objectChoice.get<::nds::name::types::PoiName>();
}

const ::nds::name::types::PoiName& NamePoiAttributeValue::getPoiName() const
{
    return m_objectChoice.get<::nds::name::types::PoiName>();
}

void NamePoiAttributeValue::setPoiName(const ::nds::name::types::PoiName& poiName_)
{
    m_objectChoice = poiName_;
}

void NamePoiAttributeValue::setPoiName(::nds::name::types::PoiName&& poiName_)
{
    m_objectChoice = ::std::move(poiName_);
}

::nds::name::types::AdministrativeHierarchy& NamePoiAttributeValue::getAdministrativeHierarchy()
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

const ::nds::name::types::AdministrativeHierarchy& NamePoiAttributeValue::getAdministrativeHierarchy() const
{
    return m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>();
}

void NamePoiAttributeValue::setAdministrativeHierarchy(const ::nds::name::types::AdministrativeHierarchy& administrativeHierarchy_)
{
    m_objectChoice = administrativeHierarchy_;
}

void NamePoiAttributeValue::setAdministrativeHierarchy(::nds::name::types::AdministrativeHierarchy&& administrativeHierarchy_)
{
    m_objectChoice = ::std::move(administrativeHierarchy_);
}

::nds::name::types::RoadName& NamePoiAttributeValue::getRoadName()
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

const ::nds::name::types::RoadName& NamePoiAttributeValue::getRoadName() const
{
    return m_objectChoice.get<::nds::name::types::RoadName>();
}

void NamePoiAttributeValue::setRoadName(const ::nds::name::types::RoadName& roadName_)
{
    m_objectChoice = roadName_;
}

void NamePoiAttributeValue::setRoadName(::nds::name::types::RoadName&& roadName_)
{
    m_objectChoice = ::std::move(roadName_);
}

::nds::name::types::HouseNumber& NamePoiAttributeValue::getHouseNumber()
{
    return m_objectChoice.get<::nds::name::types::HouseNumber>();
}

const ::nds::name::types::HouseNumber& NamePoiAttributeValue::getHouseNumber() const
{
    return m_objectChoice.get<::nds::name::types::HouseNumber>();
}

void NamePoiAttributeValue::setHouseNumber(const ::nds::name::types::HouseNumber& houseNumber_)
{
    m_objectChoice = houseNumber_;
}

void NamePoiAttributeValue::setHouseNumber(::nds::name::types::HouseNumber&& houseNumber_)
{
    m_objectChoice = ::std::move(houseNumber_);
}

::nds::name::types::BuildingName& NamePoiAttributeValue::getBuildingName()
{
    return m_objectChoice.get<::nds::name::types::BuildingName>();
}

const ::nds::name::types::BuildingName& NamePoiAttributeValue::getBuildingName() const
{
    return m_objectChoice.get<::nds::name::types::BuildingName>();
}

void NamePoiAttributeValue::setBuildingName(const ::nds::name::types::BuildingName& buildingName_)
{
    m_objectChoice = buildingName_;
}

void NamePoiAttributeValue::setBuildingName(::nds::name::types::BuildingName&& buildingName_)
{
    m_objectChoice = ::std::move(buildingName_);
}

::nds::name::types::FloorName& NamePoiAttributeValue::getFloorName()
{
    return m_objectChoice.get<::nds::name::types::FloorName>();
}

const ::nds::name::types::FloorName& NamePoiAttributeValue::getFloorName() const
{
    return m_objectChoice.get<::nds::name::types::FloorName>();
}

void NamePoiAttributeValue::setFloorName(const ::nds::name::types::FloorName& floorName_)
{
    m_objectChoice = floorName_;
}

void NamePoiAttributeValue::setFloorName(::nds::name::types::FloorName&& floorName_)
{
    m_objectChoice = ::std::move(floorName_);
}

NamePoiAttributeValue::ChoiceTag NamePoiAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        return CHOICE_poiName;
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        return CHOICE_administrativeHierarchy;
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        return CHOICE_roadName;
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        return CHOICE_houseNumber;
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        return CHOICE_buildingName;
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        return CHOICE_floorName;
    default:
        return UNDEFINED_CHOICE;
    }
}

void NamePoiAttributeValue::initPackingContext(NamePoiAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initPackingContext(context.getAdministrativeHierarchy());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        break;
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        break;
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        break;
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }
}

size_t NamePoiAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::PoiName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BuildingName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::FloorName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NamePoiAttributeValue::bitSizeOf(NamePoiAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::PoiName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition += m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().bitSizeOf(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BuildingName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::FloorName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t NamePoiAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::PoiName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BuildingName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::FloorName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }

    return endBitPosition;
}

size_t NamePoiAttributeValue::initializeOffsets(NamePoiAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::PoiName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        endBitPosition = m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().initializeOffsets(context.getAdministrativeHierarchy(), endBitPosition);
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::BuildingName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::name::types::FloorName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }

    return endBitPosition;
}

bool NamePoiAttributeValue::operator==(const NamePoiAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::PoiName>() == other.m_objectChoice.get<::nds::name::types::PoiName>());
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>() == other.m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::RoadName>() == other.m_objectChoice.get<::nds::name::types::RoadName>());
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::HouseNumber>() == other.m_objectChoice.get<::nds::name::types::HouseNumber>());
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::BuildingName>() == other.m_objectChoice.get<::nds::name::types::BuildingName>());
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::FloorName>() == other.m_objectChoice.get<::nds::name::types::FloorName>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }
}

uint32_t NamePoiAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::attributes::NamePoiAttributeType::NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::PoiName>());
            break;
        case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>());
            break;
        case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::RoadName>());
            break;
        case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::HouseNumber>());
            break;
        case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::BuildingName>());
            break;
        case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::FloorName>());
            break;
        default:
            break;
        }
    }

    return result;
}

void NamePoiAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::PoiName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(out);
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BuildingName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::FloorName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }
}

void NamePoiAttributeValue::write(NamePoiAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::PoiName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        m_objectChoice.get<::nds::name::types::AdministrativeHierarchy>().write(context.getAdministrativeHierarchy(), out);
        break;
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::RoadName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        out.writeString(m_objectChoice.get<::nds::name::types::HouseNumber>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::BuildingName>());
        break;
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        out.writeString(m_objectChoice.get<::nds::name::types::FloorName>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }
}

::zserio::AnyHolder<> NamePoiAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::PoiName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(in, allocator), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::HouseNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BuildingName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::FloorName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }
}

::zserio::AnyHolder<> NamePoiAttributeValue::readObject(NamePoiAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::PoiName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::AnyHolder<>(::nds::name::types::AdministrativeHierarchy(context.getAdministrativeHierarchy(), in, allocator), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::RoadName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::HouseNumber>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::BuildingName>(in.readString(allocator)), allocator);
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::name::types::FloorName>(in.readString(allocator)), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }
}

::zserio::AnyHolder<> NamePoiAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::attributes::NamePoiAttributeType::NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::PoiName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NamePoiAttributeType::ADMINISTRATIVE_HIERARCHY:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::AdministrativeHierarchy>(m_objectChoice, allocator);
    case ::nds::name::attributes::NamePoiAttributeType::ROAD_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::RoadName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NamePoiAttributeType::HOUSE_NUMBER:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::HouseNumber>(m_objectChoice, allocator);
    case ::nds::name::attributes::NamePoiAttributeType::BUILDING_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::BuildingName>(m_objectChoice, allocator);
    case ::nds::name::attributes::NamePoiAttributeType::FLOOR_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::FloorName>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice NamePoiAttributeValue!");
    }
}

} // namespace attributes
} // namespace name
} // namespace nds
