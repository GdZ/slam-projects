/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/types/NameDetailType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameDetailType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::name::types::NameDetailType>::names;
constexpr ::std::array<::nds::name::types::NameDetailType, 5> EnumTraits<::nds::name::types::NameDetailType>::values;
constexpr const char* EnumTraits<::nds::name::types::NameDetailType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::types::NameDetailType value)
{
    switch (value)
    {
    case ::nds::name::types::NameDetailType::SYNONYM:
        return 0;
    case ::nds::name::types::NameDetailType::TRANSLITERATION:
        return 1;
    case ::nds::name::types::NameDetailType::EXONYM:
        return 2;
    case ::nds::name::types::NameDetailType::ALTERNATE_SPELLING:
        return 3;
    case ::nds::name::types::NameDetailType::ABBREVIATION:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameDetailType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::types::NameDetailType>::type>(value) << "!";
    }
}

template <>
::nds::name::types::NameDetailType valueToEnum(
        typename ::std::underlying_type<::nds::name::types::NameDetailType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::name::types::NameDetailType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameDetailType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::types::NameDetailType>(::nds::name::types::NameDetailType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::types::NameDetailType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::NameDetailType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::types::NameDetailType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::types::NameDetailType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::NameDetailType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::types::NameDetailType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::types::NameDetailType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::types::NameDetailType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::NameDetailType>(
            static_cast<typename ::std::underlying_type<::nds::name::types::NameDetailType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::name::types::NameDetailType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::NameDetailType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::NameDetailType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::types::NameDetailType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::types::NameDetailType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::NameDetailType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/types/NameUsageType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NameUsageType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::name::types::NameUsageType>::names;
constexpr ::std::array<::nds::name::types::NameUsageType, 4> EnumTraits<::nds::name::types::NameUsageType>::values;
constexpr const char* EnumTraits<::nds::name::types::NameUsageType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::types::NameUsageType value)
{
    switch (value)
    {
    case ::nds::name::types::NameUsageType::DEFAULT_OFFICIAL_NAME:
        return 0;
    case ::nds::name::types::NameUsageType::OFFICIAL_NAME:
        return 1;
    case ::nds::name::types::NameUsageType::PREFERRED_ALTERNATE_NAME:
        return 2;
    case ::nds::name::types::NameUsageType::ALTERNATE_NAME:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameUsageType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::types::NameUsageType>::type>(value) << "!";
    }
}

template <>
::nds::name::types::NameUsageType valueToEnum(
        typename ::std::underlying_type<::nds::name::types::NameUsageType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::name::types::NameUsageType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NameUsageType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::types::NameUsageType>(::nds::name::types::NameUsageType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::types::NameUsageType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::NameUsageType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::types::NameUsageType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::types::NameUsageType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::NameUsageType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::types::NameUsageType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::types::NameUsageType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::types::NameUsageType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::NameUsageType>(
            static_cast<typename ::std::underlying_type<::nds::name::types::NameUsageType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::name::types::NameUsageType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::NameUsageType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::NameUsageType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::types::NameUsageType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::types::NameUsageType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::NameUsageType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/types/AdminHierarchyElementType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AdminHierarchyElementType enumeration.
constexpr ::std::array<const char*, 14> EnumTraits<::nds::name::types::AdminHierarchyElementType>::names;
constexpr ::std::array<::nds::name::types::AdminHierarchyElementType, 14> EnumTraits<::nds::name::types::AdminHierarchyElementType>::values;
constexpr const char* EnumTraits<::nds::name::types::AdminHierarchyElementType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::types::AdminHierarchyElementType value)
{
    switch (value)
    {
    case ::nds::name::types::AdminHierarchyElementType::COUNTRY:
        return 0;
    case ::nds::name::types::AdminHierarchyElementType::SUB_COUNTRY:
        return 1;
    case ::nds::name::types::AdminHierarchyElementType::SUB_COUNTRY_SET:
        return 2;
    case ::nds::name::types::AdminHierarchyElementType::COUNTY:
        return 3;
    case ::nds::name::types::AdminHierarchyElementType::MUNICIPALITY:
        return 4;
    case ::nds::name::types::AdminHierarchyElementType::MUNICIPALITY_SUBDIVISION:
        return 5;
    case ::nds::name::types::AdminHierarchyElementType::HAMLET:
        return 6;
    case ::nds::name::types::AdminHierarchyElementType::LICENSE_PLATE_ZONE:
        return 7;
    case ::nds::name::types::AdminHierarchyElementType::ZONE:
        return 8;
    case ::nds::name::types::AdminHierarchyElementType::COUNTRY_SET:
        return 9;
    case ::nds::name::types::AdminHierarchyElementType::NEIGHBORHOOD:
        return 10;
    case ::nds::name::types::AdminHierarchyElementType::NAMED_AREA:
        return 11;
    case ::nds::name::types::AdminHierarchyElementType::CITY_BLOCK:
        return 12;
    case ::nds::name::types::AdminHierarchyElementType::POSTAL_CODE:
        return 13;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdminHierarchyElementType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::types::AdminHierarchyElementType>::type>(value) << "!";
    }
}

template <>
::nds::name::types::AdminHierarchyElementType valueToEnum(
        typename ::std::underlying_type<::nds::name::types::AdminHierarchyElementType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
        return static_cast<::nds::name::types::AdminHierarchyElementType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdminHierarchyElementType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::types::AdminHierarchyElementType>(::nds::name::types::AdminHierarchyElementType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::types::AdminHierarchyElementType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::types::AdminHierarchyElementType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::types::AdminHierarchyElementType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::types::AdminHierarchyElementType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::types::AdminHierarchyElementType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::types::AdminHierarchyElementType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::types::AdminHierarchyElementType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::types::AdminHierarchyElementType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::AdminHierarchyElementType>(
            static_cast<typename ::std::underlying_type<::nds::name::types::AdminHierarchyElementType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::name::types::AdminHierarchyElementType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::AdminHierarchyElementType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::types::AdminHierarchyElementType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::types::AdminHierarchyElementType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::types::AdminHierarchyElementType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::name::types::AdminHierarchyElementType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/types/AddressFormatElementType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AddressFormatElementType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::name::types::AddressFormatElementType>::names;
constexpr ::std::array<::nds::name::types::AddressFormatElementType, 5> EnumTraits<::nds::name::types::AddressFormatElementType>::values;
constexpr const char* EnumTraits<::nds::name::types::AddressFormatElementType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::types::AddressFormatElementType value)
{
    switch (value)
    {
    case ::nds::name::types::AddressFormatElementType::ROAD:
        return 0;
    case ::nds::name::types::AddressFormatElementType::HOUSE:
        return 1;
    case ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT:
        return 2;
    case ::nds::name::types::AddressFormatElementType::ROAD_NUMBER:
        return 3;
    case ::nds::name::types::AddressFormatElementType::ROUTE_NAME:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AddressFormatElementType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::types::AddressFormatElementType>::type>(value) << "!";
    }
}

template <>
::nds::name::types::AddressFormatElementType valueToEnum(
        typename ::std::underlying_type<::nds::name::types::AddressFormatElementType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::name::types::AddressFormatElementType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AddressFormatElementType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::types::AddressFormatElementType>(::nds::name::types::AddressFormatElementType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::types::AddressFormatElementType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::name::types::AddressFormatElementType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::types::AddressFormatElementType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::types::AddressFormatElementType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::name::types::AddressFormatElementType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::types::AddressFormatElementType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::types::AddressFormatElementType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::types::AddressFormatElementType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::AddressFormatElementType>(
            static_cast<typename ::std::underlying_type<::nds::name::types::AddressFormatElementType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::name::types::AddressFormatElementType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::AddressFormatElementType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::name::types::AddressFormatElementType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::types::AddressFormatElementType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::types::AddressFormatElementType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::name::types::AddressFormatElementType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/types/HouseNumberType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for HouseNumberType enumeration.
constexpr ::std::array<const char*, 6> EnumTraits<::nds::name::types::HouseNumberType>::names;
constexpr ::std::array<::nds::name::types::HouseNumberType, 6> EnumTraits<::nds::name::types::HouseNumberType>::values;
constexpr const char* EnumTraits<::nds::name::types::HouseNumberType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::types::HouseNumberType value)
{
    switch (value)
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        return 0;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        return 1;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        return 2;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        return 3;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        return 4;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        return 5;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration HouseNumberType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::types::HouseNumberType>::type>(value) << "!";
    }
}

template <>
::nds::name::types::HouseNumberType valueToEnum(
        typename ::std::underlying_type<::nds::name::types::HouseNumberType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
        return static_cast<::nds::name::types::HouseNumberType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration HouseNumberType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::types::HouseNumberType>(::nds::name::types::HouseNumberType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::types::HouseNumberType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::HouseNumberType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::types::HouseNumberType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::types::HouseNumberType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::HouseNumberType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::types::HouseNumberType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::types::HouseNumberType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::types::HouseNumberType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::HouseNumberType>(
            static_cast<typename ::std::underlying_type<::nds::name::types::HouseNumberType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::name::types::HouseNumberType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::HouseNumberType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::HouseNumberType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::types::HouseNumberType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::types::HouseNumberType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::HouseNumberType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/types/HouseNumberIncrement.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for HouseNumberIncrement enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::name::types::HouseNumberIncrement>::names;
constexpr ::std::array<::nds::name::types::HouseNumberIncrement, 2> EnumTraits<::nds::name::types::HouseNumberIncrement>::values;
constexpr const char* EnumTraits<::nds::name::types::HouseNumberIncrement>::enumName;

template <>
size_t enumToOrdinal(::nds::name::types::HouseNumberIncrement value)
{
    switch (value)
    {
    case ::nds::name::types::HouseNumberIncrement::DECREASING:
        return 0;
    case ::nds::name::types::HouseNumberIncrement::INCREASING:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration HouseNumberIncrement: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::types::HouseNumberIncrement>::type>(value) << "!";
    }
}

template <>
::nds::name::types::HouseNumberIncrement valueToEnum(
        typename ::std::underlying_type<::nds::name::types::HouseNumberIncrement>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::name::types::HouseNumberIncrement>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration HouseNumberIncrement: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::types::HouseNumberIncrement>(::nds::name::types::HouseNumberIncrement value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::types::HouseNumberIncrement value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::HouseNumberIncrement>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::types::HouseNumberIncrement)
{
    return UINT8_C(1);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::types::HouseNumberIncrement value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::HouseNumberIncrement>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::types::HouseNumberIncrement value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::types::HouseNumberIncrement value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::types::HouseNumberIncrement read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::HouseNumberIncrement>(
            static_cast<typename ::std::underlying_type<::nds::name::types::HouseNumberIncrement>::type>(
                    in.readBits(UINT8_C(1))));
}

template <>
::nds::name::types::HouseNumberIncrement read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::HouseNumberIncrement>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::HouseNumberIncrement>::type, UINT8_C(1)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::types::HouseNumberIncrement value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(1));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::types::HouseNumberIncrement value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::HouseNumberIncrement>::type, UINT8_C(1)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/name/types/AddressPointType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AddressPointType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::name::types::AddressPointType>::names;
constexpr ::std::array<::nds::name::types::AddressPointType, 2> EnumTraits<::nds::name::types::AddressPointType>::values;
constexpr const char* EnumTraits<::nds::name::types::AddressPointType>::enumName;

template <>
size_t enumToOrdinal(::nds::name::types::AddressPointType value)
{
    switch (value)
    {
    case ::nds::name::types::AddressPointType::POSTAL_POSITION:
        return 0;
    case ::nds::name::types::AddressPointType::ACCESS_POSITION:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AddressPointType: ") <<
                static_cast<typename ::std::underlying_type<::nds::name::types::AddressPointType>::type>(value) << "!";
    }
}

template <>
::nds::name::types::AddressPointType valueToEnum(
        typename ::std::underlying_type<::nds::name::types::AddressPointType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::name::types::AddressPointType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AddressPointType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::name::types::AddressPointType>(::nds::name::types::AddressPointType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::name::types::AddressPointType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::AddressPointType>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::name::types::AddressPointType)
{
    return UINT8_C(1);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::name::types::AddressPointType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::AddressPointType>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::name::types::AddressPointType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::name::types::AddressPointType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::name::types::AddressPointType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::AddressPointType>(
            static_cast<typename ::std::underlying_type<::nds::name::types::AddressPointType>::type>(
                    in.readBits(UINT8_C(1))));
}

template <>
::nds::name::types::AddressPointType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::name::types::AddressPointType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::AddressPointType>::type, UINT8_C(1)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::name::types::AddressPointType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(1));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::name::types::AddressPointType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::name::types::AddressPointType>::type, UINT8_C(1)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/types/AdministrativeHierarchy.h>

namespace nds
{
namespace name
{
namespace types
{

AdministrativeHierarchy::AdministrativeHierarchy(const allocator_type& allocator) noexcept :
        m_numElements_(uint32_t()),
        m_adminElements_(allocator)
{
}

AdministrativeHierarchy::AdministrativeHierarchy(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numElements_(readNumElements(in)),
        m_adminElements_(readAdminElements(in, allocator))
{
}

AdministrativeHierarchy::AdministrativeHierarchy(AdministrativeHierarchy::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numElements_(readNumElements(context, in)),
        m_adminElements_(readAdminElements(context, in, allocator))
{
}

AdministrativeHierarchy::AdministrativeHierarchy(::zserio::PropagateAllocatorT,
        const AdministrativeHierarchy& other, const allocator_type& allocator) :
        m_numElements_(::zserio::allocatorPropagatingCopy(other.m_numElements_, allocator)),
        m_adminElements_(::zserio::allocatorPropagatingCopy(other.m_adminElements_, allocator))
{
}

uint32_t AdministrativeHierarchy::getNumElements() const
{
    return m_numElements_;
}

void AdministrativeHierarchy::setNumElements(uint32_t numElements_)
{
    m_numElements_ = numElements_;
}

::zserio::vector<::nds::name::types::AdminHierarchyElementId>& AdministrativeHierarchy::getAdminElements()
{
    return m_adminElements_.getRawArray();
}

const ::zserio::vector<::nds::name::types::AdminHierarchyElementId>& AdministrativeHierarchy::getAdminElements() const
{
    return m_adminElements_.getRawArray();
}

void AdministrativeHierarchy::setAdminElements(const ::zserio::vector<::nds::name::types::AdminHierarchyElementId>& adminElements_)
{
    m_adminElements_ = ZserioArrayType_adminElements(adminElements_);
}

void AdministrativeHierarchy::setAdminElements(::zserio::vector<::nds::name::types::AdminHierarchyElementId>&& adminElements_)
{
    m_adminElements_ = ZserioArrayType_adminElements(std::move(adminElements_));
}

void AdministrativeHierarchy::initPackingContext(AdministrativeHierarchy::ZserioPackingContext& context) const
{
    context.getNumElements().init<::zserio::VarSizeArrayTraits>(m_numElements_);
}

size_t AdministrativeHierarchy::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    endBitPosition += m_adminElements_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AdministrativeHierarchy::bitSizeOf(AdministrativeHierarchy::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    endBitPosition += m_adminElements_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AdministrativeHierarchy::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    endBitPosition = m_adminElements_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t AdministrativeHierarchy::initializeOffsets(AdministrativeHierarchy::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    endBitPosition = m_adminElements_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool AdministrativeHierarchy::operator==(const AdministrativeHierarchy& other) const
{
    if (this != &other)
    {
        return
                (m_numElements_ == other.m_numElements_) &&
                (m_adminElements_ == other.m_adminElements_);
    }

    return true;
}

uint32_t AdministrativeHierarchy::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numElements_);
    result = ::zserio::calcHashCode(result, m_adminElements_);

    return result;
}

void AdministrativeHierarchy::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numElements_);

    // check array length
    if (m_adminElements_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AdministrativeHierarchy.adminElements: ") <<
                m_adminElements_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_adminElements_.write(out);
}

void AdministrativeHierarchy::write(AdministrativeHierarchy::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumElements().write<::zserio::VarSizeArrayTraits>(out, m_numElements_);

    // check array length
    if (m_adminElements_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AdministrativeHierarchy.adminElements: ") <<
                m_adminElements_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_adminElements_.writePacked(out);
}

uint32_t AdministrativeHierarchy::readNumElements(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t AdministrativeHierarchy::readNumElements(AdministrativeHierarchy::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumElements().read<::zserio::VarSizeArrayTraits>(in);
}
AdministrativeHierarchy::ZserioArrayType_adminElements AdministrativeHierarchy::readAdminElements(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_adminElements readField(allocator);
    readField.read(in, static_cast<size_t>(getNumElements()));

    return readField;
}

AdministrativeHierarchy::ZserioArrayType_adminElements AdministrativeHierarchy::readAdminElements(AdministrativeHierarchy::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_adminElements readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumElements()));

    return readField;
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/types/AdministrativeHierarchyElement.h>

namespace nds
{
namespace name
{
namespace types
{

AdministrativeHierarchyElement::AdministrativeHierarchyElement(const allocator_type& allocator) noexcept :
        m_id_(::nds::name::types::AdminHierarchyElementId()),
        m_type_(::nds::name::types::AdminHierarchyElementType()),
        m_name_(allocator)
{
}

AdministrativeHierarchyElement::AdministrativeHierarchyElement(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in)),
        m_type_(readType(in)),
        m_name_(readName(in, allocator))
{
}

AdministrativeHierarchyElement::AdministrativeHierarchyElement(AdministrativeHierarchyElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in)),
        m_type_(readType(context, in)),
        m_name_(readName(in, allocator))
{
}

AdministrativeHierarchyElement::AdministrativeHierarchyElement(::zserio::PropagateAllocatorT,
        const AdministrativeHierarchyElement& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_name_(::zserio::allocatorPropagatingCopy(other.m_name_, allocator))
{
}

::nds::name::types::AdminHierarchyElementId AdministrativeHierarchyElement::getId() const
{
    return m_id_;
}

void AdministrativeHierarchyElement::setId(::nds::name::types::AdminHierarchyElementId id_)
{
    m_id_ = id_;
}

::nds::name::types::AdminHierarchyElementType AdministrativeHierarchyElement::getType() const
{
    return m_type_;
}

void AdministrativeHierarchyElement::setType(::nds::name::types::AdminHierarchyElementType type_)
{
    m_type_ = type_;
}

::nds::name::types::AdminHierarchyName& AdministrativeHierarchyElement::getName()
{
    return m_name_;
}

const ::nds::name::types::AdminHierarchyName& AdministrativeHierarchyElement::getName() const
{
    return m_name_;
}

void AdministrativeHierarchyElement::setName(const ::nds::name::types::AdminHierarchyName& name_)
{
    m_name_ = name_;
}

void AdministrativeHierarchyElement::setName(::nds::name::types::AdminHierarchyName&& name_)
{
    m_name_ = ::std::move(name_);
}

void AdministrativeHierarchyElement::initPackingContext(AdministrativeHierarchyElement::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntNNArrayTraits<::nds::name::types::AdminHierarchyElementId>>(m_id_);
    ::zserio::initPackingContext(context.getType(), m_type_);
}

size_t AdministrativeHierarchyElement::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_id_);
    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);

    return endBitPosition - bitPosition;
}

size_t AdministrativeHierarchyElement::bitSizeOf(AdministrativeHierarchyElement::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::name::types::AdminHierarchyElementId>>(m_id_);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);

    return endBitPosition - bitPosition;
}

size_t AdministrativeHierarchyElement::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_id_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);

    return endBitPosition;
}

size_t AdministrativeHierarchyElement::initializeOffsets(AdministrativeHierarchyElement::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::name::types::AdminHierarchyElementId>>(m_id_);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);

    return endBitPosition;
}

bool AdministrativeHierarchyElement::operator==(const AdministrativeHierarchyElement& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_type_ == other.m_type_) &&
                (m_name_ == other.m_name_);
    }

    return true;
}

uint32_t AdministrativeHierarchyElement::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_name_);

    return result;
}

void AdministrativeHierarchyElement::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_id_);
    ::zserio::write(out, m_type_);
    out.writeString(m_name_);
}

void AdministrativeHierarchyElement::write(AdministrativeHierarchyElement::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::VarIntNNArrayTraits<::nds::name::types::AdminHierarchyElementId>>(out, m_id_);
    ::zserio::write(context.getType(), out, m_type_);
    out.writeString(m_name_);
}

::nds::name::types::AdminHierarchyElementId AdministrativeHierarchyElement::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::name::types::AdminHierarchyElementId>(in.readVarUInt32());
}

::nds::name::types::AdminHierarchyElementId AdministrativeHierarchyElement::readId(AdministrativeHierarchyElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::VarIntNNArrayTraits<::nds::name::types::AdminHierarchyElementId>>(in);
}
::nds::name::types::AdminHierarchyElementType AdministrativeHierarchyElement::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::AdminHierarchyElementType>(in);
}

::nds::name::types::AdminHierarchyElementType AdministrativeHierarchyElement::readType(AdministrativeHierarchyElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::AdminHierarchyElementType>(context.getType(), in);
}
::nds::name::types::AdminHierarchyName AdministrativeHierarchyElement::readName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::name::types::AdminHierarchyName>(in.readString(allocator));
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/types/RoadNumberComponent.h>

namespace nds
{
namespace name
{
namespace types
{

RoadNumberComponent::RoadNumberComponent(const allocator_type& allocator) noexcept :
        m_componentString_(allocator),
        m_onIcon_(bool()),
        m_acousticOutput_(bool()),
        m_textOutput_(bool()),
        m_localPriority_(uint8_t())
{
}

RoadNumberComponent::RoadNumberComponent(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_componentString_(readComponentString(in, allocator)),
        m_onIcon_(readOnIcon(in)),
        m_acousticOutput_(readAcousticOutput(in)),
        m_textOutput_(readTextOutput(in)),
        m_localPriority_(readLocalPriority(in))
{
}

RoadNumberComponent::RoadNumberComponent(RoadNumberComponent::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_componentString_(readComponentString(in, allocator)),
        m_onIcon_(readOnIcon(in)),
        m_acousticOutput_(readAcousticOutput(in)),
        m_textOutput_(readTextOutput(in)),
        m_localPriority_(readLocalPriority(context, in))
{
}

RoadNumberComponent::RoadNumberComponent(::zserio::PropagateAllocatorT,
        const RoadNumberComponent& other, const allocator_type& allocator) :
        m_componentString_(::zserio::allocatorPropagatingCopy(other.m_componentString_, allocator)),
        m_onIcon_(::zserio::allocatorPropagatingCopy(other.m_onIcon_, allocator)),
        m_acousticOutput_(::zserio::allocatorPropagatingCopy(other.m_acousticOutput_, allocator)),
        m_textOutput_(::zserio::allocatorPropagatingCopy(other.m_textOutput_, allocator)),
        m_localPriority_(::zserio::allocatorPropagatingCopy(other.m_localPriority_, allocator))
{
}

::zserio::string<>& RoadNumberComponent::getComponentString()
{
    return m_componentString_;
}

const ::zserio::string<>& RoadNumberComponent::getComponentString() const
{
    return m_componentString_;
}

void RoadNumberComponent::setComponentString(const ::zserio::string<>& componentString_)
{
    m_componentString_ = componentString_;
}

void RoadNumberComponent::setComponentString(::zserio::string<>&& componentString_)
{
    m_componentString_ = ::std::move(componentString_);
}

bool RoadNumberComponent::getOnIcon() const
{
    return m_onIcon_;
}

void RoadNumberComponent::setOnIcon(bool onIcon_)
{
    m_onIcon_ = onIcon_;
}

bool RoadNumberComponent::getAcousticOutput() const
{
    return m_acousticOutput_;
}

void RoadNumberComponent::setAcousticOutput(bool acousticOutput_)
{
    m_acousticOutput_ = acousticOutput_;
}

bool RoadNumberComponent::getTextOutput() const
{
    return m_textOutput_;
}

void RoadNumberComponent::setTextOutput(bool textOutput_)
{
    m_textOutput_ = textOutput_;
}

uint8_t RoadNumberComponent::getLocalPriority() const
{
    return m_localPriority_;
}

void RoadNumberComponent::setLocalPriority(uint8_t localPriority_)
{
    m_localPriority_ = localPriority_;
}

void RoadNumberComponent::initPackingContext(RoadNumberComponent::ZserioPackingContext& context) const
{
    context.getLocalPriority().init<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_localPriority_);
}

size_t RoadNumberComponent::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_componentString_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(5);

    return endBitPosition - bitPosition;
}

size_t RoadNumberComponent::bitSizeOf(RoadNumberComponent::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_componentString_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += context.getLocalPriority().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_localPriority_);

    return endBitPosition - bitPosition;
}

size_t RoadNumberComponent::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_componentString_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(5);

    return endBitPosition;
}

size_t RoadNumberComponent::initializeOffsets(RoadNumberComponent::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_componentString_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += context.getLocalPriority().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_localPriority_);

    return endBitPosition;
}

bool RoadNumberComponent::operator==(const RoadNumberComponent& other) const
{
    if (this != &other)
    {
        return
                (m_componentString_ == other.m_componentString_) &&
                (m_onIcon_ == other.m_onIcon_) &&
                (m_acousticOutput_ == other.m_acousticOutput_) &&
                (m_textOutput_ == other.m_textOutput_) &&
                (m_localPriority_ == other.m_localPriority_);
    }

    return true;
}

uint32_t RoadNumberComponent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_componentString_);
    result = ::zserio::calcHashCode(result, m_onIcon_);
    result = ::zserio::calcHashCode(result, m_acousticOutput_);
    result = ::zserio::calcHashCode(result, m_textOutput_);
    result = ::zserio::calcHashCode(result, m_localPriority_);

    return result;
}

void RoadNumberComponent::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_componentString_);
    out.writeBool(m_onIcon_);
    out.writeBool(m_acousticOutput_);
    out.writeBool(m_textOutput_);
    out.writeBits(m_localPriority_, UINT8_C(5));
}

void RoadNumberComponent::write(RoadNumberComponent::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeString(m_componentString_);
    out.writeBool(m_onIcon_);
    out.writeBool(m_acousticOutput_);
    out.writeBool(m_textOutput_);
    context.getLocalPriority().write<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(out, m_localPriority_);
}

::zserio::string<> RoadNumberComponent::readComponentString(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
bool RoadNumberComponent::readOnIcon(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool RoadNumberComponent::readAcousticOutput(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool RoadNumberComponent::readTextOutput(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
uint8_t RoadNumberComponent::readLocalPriority(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(5)));
}

uint8_t RoadNumberComponent::readLocalPriority(RoadNumberComponent::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLocalPriority().read<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(in);
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/types/AddressFormat.h>

namespace nds
{
namespace name
{
namespace types
{

AddressFormat::AddressFormat(const allocator_type& allocator) noexcept :
        m_id_(::nds::name::types::AddressFormatId()),
        m_elements_(allocator)
{
}

AddressFormat::AddressFormat(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in)),
        m_elements_(readElements(in, allocator))
{
}

AddressFormat::AddressFormat(AddressFormat::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in)),
        m_elements_(readElements(context, in, allocator))
{
}

AddressFormat::AddressFormat(::zserio::PropagateAllocatorT,
        const AddressFormat& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_elements_(::zserio::allocatorPropagatingCopy(other.m_elements_, allocator))
{
}

::nds::name::types::AddressFormatId AddressFormat::getId() const
{
    return m_id_;
}

void AddressFormat::setId(::nds::name::types::AddressFormatId id_)
{
    m_id_ = id_;
}

::zserio::vector<::nds::name::types::AddressFormatElement>& AddressFormat::getElements()
{
    return m_elements_.getRawArray();
}

const ::zserio::vector<::nds::name::types::AddressFormatElement>& AddressFormat::getElements() const
{
    return m_elements_.getRawArray();
}

void AddressFormat::setElements(const ::zserio::vector<::nds::name::types::AddressFormatElement>& elements_)
{
    m_elements_ = ZserioArrayType_elements(elements_);
}

void AddressFormat::setElements(::zserio::vector<::nds::name::types::AddressFormatElement>&& elements_)
{
    m_elements_ = ZserioArrayType_elements(std::move(elements_));
}

void AddressFormat::initPackingContext(AddressFormat::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntNNArrayTraits<::nds::name::types::AddressFormatId>>(m_id_);
}

size_t AddressFormat::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_id_);
    endBitPosition += m_elements_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AddressFormat::bitSizeOf(AddressFormat::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::name::types::AddressFormatId>>(m_id_);
    endBitPosition += m_elements_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AddressFormat::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_id_);
    endBitPosition = m_elements_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t AddressFormat::initializeOffsets(AddressFormat::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::name::types::AddressFormatId>>(m_id_);
    endBitPosition = m_elements_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool AddressFormat::operator==(const AddressFormat& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_elements_ == other.m_elements_);
    }

    return true;
}

uint32_t AddressFormat::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_elements_);

    return result;
}

void AddressFormat::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_id_);
    m_elements_.write(*this, out);
}

void AddressFormat::write(AddressFormat::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::VarIntNNArrayTraits<::nds::name::types::AddressFormatId>>(out, m_id_);
    m_elements_.writePacked(*this, out);
}

void AddressFormat::ZserioElementFactory_elements::create(AddressFormat&        ,
        ::zserio::vector<::nds::name::types::AddressFormatElement>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void AddressFormat::ZserioElementFactory_elements::create(AddressFormat&        ,
        ::zserio::vector<::nds::name::types::AddressFormatElement>& array,
        ::nds::name::types::AddressFormatElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::name::types::AddressFormatId AddressFormat::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::name::types::AddressFormatId>(in.readVarUInt16());
}

::nds::name::types::AddressFormatId AddressFormat::readId(AddressFormat::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::VarIntNNArrayTraits<::nds::name::types::AddressFormatId>>(in);
}
AddressFormat::ZserioArrayType_elements AddressFormat::readElements(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_elements readField(allocator);
    readField.read(*this, in);

    return readField;
}

AddressFormat::ZserioArrayType_elements AddressFormat::readElements(AddressFormat::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_elements readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/name/types/AddressFormatElement.h>
#include <nds/name/types/AddressFormatElementType.h>

namespace nds
{
namespace name
{
namespace types
{

AddressFormatElement::AddressFormatElement(const allocator_type& allocator) noexcept :
        m_type_(::nds::name::types::AddressFormatElementType()),
        m_adminHierarchyElementType_(::zserio::NullOpt),
        m_elementSeparator_(allocator)
{
}

AddressFormatElement::AddressFormatElement(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_adminHierarchyElementType_(readAdminHierarchyElementType(in)),
        m_elementSeparator_(readElementSeparator(in, allocator))
{
}

AddressFormatElement::AddressFormatElement(AddressFormatElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_adminHierarchyElementType_(readAdminHierarchyElementType(context, in)),
        m_elementSeparator_(readElementSeparator(in, allocator))
{
}

AddressFormatElement::AddressFormatElement(::zserio::PropagateAllocatorT,
        const AddressFormatElement& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_adminHierarchyElementType_(::zserio::allocatorPropagatingCopy(other.m_adminHierarchyElementType_, allocator)),
        m_elementSeparator_(::zserio::allocatorPropagatingCopy(other.m_elementSeparator_, allocator))
{
}

::nds::name::types::AddressFormatElementType AddressFormatElement::getType() const
{
    return m_type_;
}

void AddressFormatElement::setType(::nds::name::types::AddressFormatElementType type_)
{
    m_type_ = type_;
}

::nds::name::types::AdminHierarchyElementType AddressFormatElement::getAdminHierarchyElementType() const
{
    return m_adminHierarchyElementType_.value();
}

void AddressFormatElement::setAdminHierarchyElementType(::nds::name::types::AdminHierarchyElementType adminHierarchyElementType_)
{
    m_adminHierarchyElementType_ = adminHierarchyElementType_;
}

bool AddressFormatElement::isAdminHierarchyElementTypeUsed() const
{
    return (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT);
}

bool AddressFormatElement::isAdminHierarchyElementTypeSet() const
{
    return m_adminHierarchyElementType_.hasValue();
}

void AddressFormatElement::resetAdminHierarchyElementType()
{
    m_adminHierarchyElementType_.reset();
}

::zserio::string<>& AddressFormatElement::getElementSeparator()
{
    return m_elementSeparator_;
}

const ::zserio::string<>& AddressFormatElement::getElementSeparator() const
{
    return m_elementSeparator_;
}

void AddressFormatElement::setElementSeparator(const ::zserio::string<>& elementSeparator_)
{
    m_elementSeparator_ = elementSeparator_;
}

void AddressFormatElement::setElementSeparator(::zserio::string<>&& elementSeparator_)
{
    m_elementSeparator_ = ::std::move(elementSeparator_);
}

void AddressFormatElement::initPackingContext(AddressFormatElement::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT)
    {
        ::zserio::initPackingContext(context.getAdminHierarchyElementType(), m_adminHierarchyElementType_.value());
    }
}

size_t AddressFormatElement::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT)
    {
        endBitPosition += ::zserio::bitSizeOf(m_adminHierarchyElementType_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_elementSeparator_);

    return endBitPosition - bitPosition;
}

size_t AddressFormatElement::bitSizeOf(AddressFormatElement::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT)
    {
        endBitPosition += ::zserio::bitSizeOf(context.getAdminHierarchyElementType(), m_adminHierarchyElementType_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_elementSeparator_);

    return endBitPosition - bitPosition;
}

size_t AddressFormatElement::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT)
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_adminHierarchyElementType_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_elementSeparator_);

    return endBitPosition;
}

size_t AddressFormatElement::initializeOffsets(AddressFormatElement::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT)
    {
        endBitPosition = ::zserio::initializeOffsets(context.getAdminHierarchyElementType(), endBitPosition,
        m_adminHierarchyElementType_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_elementSeparator_);

    return endBitPosition;
}

bool AddressFormatElement::operator==(const AddressFormatElement& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isAdminHierarchyElementTypeUsed() ? !other.isAdminHierarchyElementTypeUsed() : (m_adminHierarchyElementType_ == other.m_adminHierarchyElementType_)) &&
                (m_elementSeparator_ == other.m_elementSeparator_);
    }

    return true;
}

uint32_t AddressFormatElement::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isAdminHierarchyElementTypeUsed())
        result = ::zserio::calcHashCode(result, m_adminHierarchyElementType_);
    result = ::zserio::calcHashCode(result, m_elementSeparator_);

    return result;
}

void AddressFormatElement::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    if (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT)
    {
        ::zserio::write(out, m_adminHierarchyElementType_.value());
    }
    out.writeString(m_elementSeparator_);
}

void AddressFormatElement::write(AddressFormatElement::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    if (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT)
    {
        ::zserio::write(context.getAdminHierarchyElementType(), out, m_adminHierarchyElementType_.value());
    }
    out.writeString(m_elementSeparator_);
}

::nds::name::types::AddressFormatElementType AddressFormatElement::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::AddressFormatElementType>(in);
}

::nds::name::types::AddressFormatElementType AddressFormatElement::readType(AddressFormatElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::AddressFormatElementType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<::nds::name::types::AdminHierarchyElementType> AddressFormatElement::readAdminHierarchyElementType(::zserio::BitStreamReader& in)
{
    if (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT)
    {
        return ::zserio::InplaceOptionalHolder<::nds::name::types::AdminHierarchyElementType>(::zserio::read<::nds::name::types::AdminHierarchyElementType>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::name::types::AdminHierarchyElementType>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::name::types::AdminHierarchyElementType> AddressFormatElement::readAdminHierarchyElementType(AddressFormatElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() == ::nds::name::types::AddressFormatElementType::ADMINISTRATIVE_HIERARCHY_ELEMENT)
    {
        return ::zserio::InplaceOptionalHolder<::nds::name::types::AdminHierarchyElementType>(::zserio::read<::nds::name::types::AdminHierarchyElementType>(context.getAdminHierarchyElementType(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::name::types::AdminHierarchyElementType>(::zserio::NullOpt);
}
::zserio::string<> AddressFormatElement::readElementSeparator(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/types/HouseNumberRange.h>

namespace nds
{
namespace name
{
namespace types
{

HouseNumberRange::HouseNumberRange(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_type_(::nds::name::types::HouseNumberType()),
        m_numbers_(allocator)
{
}

HouseNumberRange::HouseNumberRange(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(in)),
        m_numbers_(readNumbers(in, allocator))
{
}

HouseNumberRange::HouseNumberRange(HouseNumberRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(context, in)),
        m_numbers_(readNumbers(context, in, allocator))
{
}

HouseNumberRange::HouseNumberRange(const HouseNumberRange& other) :
        m_type_(other.m_type_),
        m_numbers_(other.m_numbers_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

HouseNumberRange& HouseNumberRange::operator=(const HouseNumberRange& other)
{
    m_type_ = other.m_type_;
    m_numbers_ = other.m_numbers_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

HouseNumberRange::HouseNumberRange(HouseNumberRange&& other) :
        m_type_(::std::move(other.m_type_)),
        m_numbers_(::std::move(other.m_numbers_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

HouseNumberRange& HouseNumberRange::operator=(HouseNumberRange&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_numbers_ = ::std::move(other.m_numbers_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

HouseNumberRange::HouseNumberRange(::zserio::PropagateAllocatorT,
        const HouseNumberRange& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_numbers_(::zserio::allocatorPropagatingCopy(other.m_numbers_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void HouseNumberRange::initializeChildren()
{
    m_numbers_.initialize(static_cast<::nds::name::types::HouseNumberType>(getType()));

    m_areChildrenInitialized = true;
}

::nds::name::types::HouseNumberType HouseNumberRange::getType() const
{
    return m_type_;
}

void HouseNumberRange::setType(::nds::name::types::HouseNumberType type_)
{
    m_type_ = type_;
}

::nds::name::types::HouseNumberRangeNumbers& HouseNumberRange::getNumbers()
{
    return m_numbers_;
}

const ::nds::name::types::HouseNumberRangeNumbers& HouseNumberRange::getNumbers() const
{
    return m_numbers_;
}

void HouseNumberRange::setNumbers(const ::nds::name::types::HouseNumberRangeNumbers& numbers_)
{
    m_numbers_ = numbers_;
}

void HouseNumberRange::setNumbers(::nds::name::types::HouseNumberRangeNumbers&& numbers_)
{
    m_numbers_ = ::std::move(numbers_);
}

void HouseNumberRange::initPackingContext(HouseNumberRange::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    m_numbers_.initPackingContext(context.getNumbers());
}

size_t HouseNumberRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += m_numbers_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t HouseNumberRange::bitSizeOf(HouseNumberRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += m_numbers_.bitSizeOf(context.getNumbers(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t HouseNumberRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = m_numbers_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t HouseNumberRange::initializeOffsets(HouseNumberRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = m_numbers_.initializeOffsets(context.getNumbers(), endBitPosition);

    return endBitPosition;
}

bool HouseNumberRange::operator==(const HouseNumberRange& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_numbers_ == other.m_numbers_);
    }

    return true;
}

uint32_t HouseNumberRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_numbers_);

    return result;
}

void HouseNumberRange::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    // check parameters
    if (m_numbers_.getType() != static_cast<::nds::name::types::HouseNumberType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field HouseNumberRange.numbers: ") <<
                m_numbers_.getType() << " != " << static_cast<::nds::name::types::HouseNumberType>(getType()) << "!";
    }
    m_numbers_.write(out);
}

void HouseNumberRange::write(HouseNumberRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    // check parameters
    if (m_numbers_.getType() != static_cast<::nds::name::types::HouseNumberType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field HouseNumberRange.numbers: ") <<
                m_numbers_.getType() << " != " << static_cast<::nds::name::types::HouseNumberType>(getType()) << "!";
    }
    m_numbers_.write(context.getNumbers(), out);
}

::nds::name::types::HouseNumberType HouseNumberRange::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::HouseNumberType>(in);
}

::nds::name::types::HouseNumberType HouseNumberRange::readType(HouseNumberRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::HouseNumberType>(context.getType(), in);
}
::nds::name::types::HouseNumberRangeNumbers HouseNumberRange::readNumbers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::name::types::HouseNumberRangeNumbers(in, static_cast<::nds::name::types::HouseNumberType>(getType()), allocator);
}

::nds::name::types::HouseNumberRangeNumbers HouseNumberRange::readNumbers(HouseNumberRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::name::types::HouseNumberRangeNumbers(context.getNumbers(), in, static_cast<::nds::name::types::HouseNumberType>(getType()), allocator);
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/name/types/HouseNumberNumericRange.h>
#include <nds/name/types/HouseNumberIncrement.h>

namespace nds
{
namespace name
{
namespace types
{

HouseNumberNumericRange::HouseNumberNumericRange(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_startHouseNumber_(::nds::name::types::HouseNumberNumeric()),
        m_endHouseNumber_(::nds::name::types::HouseNumberNumeric()),
        m_pattern_(::zserio::NullOpt)
{
}

HouseNumberNumericRange::HouseNumberNumericRange(::zserio::BitStreamReader& in,
        bool hasPattern_,
        bool isEvenOdd_, const allocator_type& allocator) :
        m_hasPattern_(hasPattern_),
        m_isEvenOdd_(isEvenOdd_),
        m_isInitialized(true),
        m_startHouseNumber_(readStartHouseNumber(in)),
        m_endHouseNumber_(readEndHouseNumber(in)),
        m_pattern_(readPattern(in, allocator))
{
}

HouseNumberNumericRange::HouseNumberNumericRange(HouseNumberNumericRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool hasPattern_,
        bool isEvenOdd_, const allocator_type& allocator) :
        m_hasPattern_(hasPattern_),
        m_isEvenOdd_(isEvenOdd_),
        m_isInitialized(true),
        m_startHouseNumber_(readStartHouseNumber(context, in)),
        m_endHouseNumber_(readEndHouseNumber(context, in)),
        m_pattern_(readPattern(in, allocator))
{
}

HouseNumberNumericRange::HouseNumberNumericRange(const HouseNumberNumericRange& other) :
        m_startHouseNumber_(other.m_startHouseNumber_),
        m_endHouseNumber_(other.m_endHouseNumber_),
        m_pattern_(other.m_pattern_)
{
    if (other.m_isInitialized)
        initialize(other.m_hasPattern_, other.m_isEvenOdd_);
    else
        m_isInitialized = false;
}

HouseNumberNumericRange& HouseNumberNumericRange::operator=(const HouseNumberNumericRange& other)
{
    m_startHouseNumber_ = other.m_startHouseNumber_;
    m_endHouseNumber_ = other.m_endHouseNumber_;
    m_pattern_ = other.m_pattern_;
    if (other.m_isInitialized)
        initialize(other.m_hasPattern_, other.m_isEvenOdd_);
    else
        m_isInitialized = false;

    return *this;
}

HouseNumberNumericRange::HouseNumberNumericRange(HouseNumberNumericRange&& other) :
        m_startHouseNumber_(::std::move(other.m_startHouseNumber_)),
        m_endHouseNumber_(::std::move(other.m_endHouseNumber_)),
        m_pattern_(::std::move(other.m_pattern_))
{
    if (other.m_isInitialized)
        initialize(other.m_hasPattern_, other.m_isEvenOdd_);
    else
        m_isInitialized = false;
}

HouseNumberNumericRange& HouseNumberNumericRange::operator=(HouseNumberNumericRange&& other)
{
    m_startHouseNumber_ = ::std::move(other.m_startHouseNumber_);
    m_endHouseNumber_ = ::std::move(other.m_endHouseNumber_);
    m_pattern_ = ::std::move(other.m_pattern_);
    if (other.m_isInitialized)
        initialize(other.m_hasPattern_, other.m_isEvenOdd_);
    else
        m_isInitialized = false;

    return *this;
}

HouseNumberNumericRange::HouseNumberNumericRange(::zserio::PropagateAllocatorT,
        const HouseNumberNumericRange& other, const allocator_type& allocator) :
        m_startHouseNumber_(::zserio::allocatorPropagatingCopy(other.m_startHouseNumber_, allocator)),
        m_endHouseNumber_(::zserio::allocatorPropagatingCopy(other.m_endHouseNumber_, allocator)),
        m_pattern_(::zserio::allocatorPropagatingCopy(other.m_pattern_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_hasPattern_, other.m_isEvenOdd_);
    else
        m_isInitialized = false;
}

void HouseNumberNumericRange::initialize(
        bool hasPattern_,
        bool isEvenOdd_)
{
    m_hasPattern_ = hasPattern_;
    m_isEvenOdd_ = isEvenOdd_;
    m_isInitialized = true;
}

bool HouseNumberNumericRange::isInitialized() const
{
    return m_isInitialized;
}

bool HouseNumberNumericRange::getHasPattern() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasPattern' of compound 'HouseNumberNumericRange' is not initialized!");

    return m_hasPattern_;
}

bool HouseNumberNumericRange::getIsEvenOdd() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'isEvenOdd' of compound 'HouseNumberNumericRange' is not initialized!");

    return m_isEvenOdd_;
}

::nds::name::types::HouseNumberNumeric HouseNumberNumericRange::getStartHouseNumber() const
{
    return m_startHouseNumber_;
}

void HouseNumberNumericRange::setStartHouseNumber(::nds::name::types::HouseNumberNumeric startHouseNumber_)
{
    m_startHouseNumber_ = startHouseNumber_;
}

::nds::name::types::HouseNumberNumeric HouseNumberNumericRange::getEndHouseNumber() const
{
    return m_endHouseNumber_;
}

void HouseNumberNumericRange::setEndHouseNumber(::nds::name::types::HouseNumberNumeric endHouseNumber_)
{
    m_endHouseNumber_ = endHouseNumber_;
}

::zserio::string<>& HouseNumberNumericRange::getPattern()
{
    return m_pattern_.value();
}

const ::zserio::string<>& HouseNumberNumericRange::getPattern() const
{
    return m_pattern_.value();
}

void HouseNumberNumericRange::setPattern(const ::zserio::string<>& pattern_)
{
    m_pattern_ = pattern_;
}

void HouseNumberNumericRange::setPattern(::zserio::string<>&& pattern_)
{
    m_pattern_ = ::std::move(pattern_);
}

bool HouseNumberNumericRange::isPatternUsed() const
{
    return (getHasPattern());
}

bool HouseNumberNumericRange::isPatternSet() const
{
    return m_pattern_.hasValue();
}

void HouseNumberNumericRange::resetPattern()
{
    m_pattern_.reset();
}

::nds::name::types::HouseNumberIncrement HouseNumberNumericRange::funcGetIncrement() const
{
    return static_cast<::nds::name::types::HouseNumberIncrement>(((getStartHouseNumber() > getEndHouseNumber())) ? ::nds::name::types::HouseNumberIncrement::DECREASING : ::nds::name::types::HouseNumberIncrement::INCREASING);
}

void HouseNumberNumericRange::initPackingContext(HouseNumberNumericRange::ZserioPackingContext& context) const
{
    context.getStartHouseNumber().init<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(m_startHouseNumber_);
    context.getEndHouseNumber().init<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(m_endHouseNumber_);
}

size_t HouseNumberNumericRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_startHouseNumber_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_endHouseNumber_);
    if (getHasPattern())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_pattern_.value());
    }

    return endBitPosition - bitPosition;
}

size_t HouseNumberNumericRange::bitSizeOf(HouseNumberNumericRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStartHouseNumber().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(m_startHouseNumber_);
    endBitPosition += context.getEndHouseNumber().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(m_endHouseNumber_);
    if (getHasPattern())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_pattern_.value());
    }

    return endBitPosition - bitPosition;
}

size_t HouseNumberNumericRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_startHouseNumber_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_endHouseNumber_);
    if (getHasPattern())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_pattern_.value());
    }

    return endBitPosition;
}

size_t HouseNumberNumericRange::initializeOffsets(HouseNumberNumericRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStartHouseNumber().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(m_startHouseNumber_);
    endBitPosition += context.getEndHouseNumber().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(m_endHouseNumber_);
    if (getHasPattern())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_pattern_.value());
    }

    return endBitPosition;
}

bool HouseNumberNumericRange::operator==(const HouseNumberNumericRange& other) const
{
    if (this != &other)
    {
        return
                (getHasPattern() == other.getHasPattern()) &&
                (getIsEvenOdd() == other.getIsEvenOdd()) &&
                (m_startHouseNumber_ == other.m_startHouseNumber_) &&
                (m_endHouseNumber_ == other.m_endHouseNumber_) &&
                (!isPatternUsed() ? !other.isPatternUsed() : (m_pattern_ == other.m_pattern_));
    }

    return true;
}

uint32_t HouseNumberNumericRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHasPattern());
    result = ::zserio::calcHashCode(result, getIsEvenOdd());
    result = ::zserio::calcHashCode(result, m_startHouseNumber_);
    result = ::zserio::calcHashCode(result, m_endHouseNumber_);
    if (isPatternUsed())
        result = ::zserio::calcHashCode(result, m_pattern_);

    return result;
}

void HouseNumberNumericRange::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_startHouseNumber_);

    // check constraint
    if (!(getEndHouseNumber() != getStartHouseNumber()))
        throw ::zserio::ConstraintException("Write: Constraint violated at HouseNumberNumericRange.endHouseNumber!");
    out.writeVarUInt32(m_endHouseNumber_);

    if (getHasPattern())
    {
        out.writeString(m_pattern_.value());
    }
}

void HouseNumberNumericRange::write(HouseNumberNumericRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getStartHouseNumber().write<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(out, m_startHouseNumber_);

    // check constraint
    if (!(getEndHouseNumber() != getStartHouseNumber()))
        throw ::zserio::ConstraintException("Write: Constraint violated at HouseNumberNumericRange.endHouseNumber!");
    context.getEndHouseNumber().write<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(out, m_endHouseNumber_);

    if (getHasPattern())
    {
        out.writeString(m_pattern_.value());
    }
}

::nds::name::types::HouseNumberNumeric HouseNumberNumericRange::readStartHouseNumber(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::name::types::HouseNumberNumeric>(in.readVarUInt32());
}

::nds::name::types::HouseNumberNumeric HouseNumberNumericRange::readStartHouseNumber(HouseNumberNumericRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStartHouseNumber().read<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(in);
}
::nds::name::types::HouseNumberNumeric HouseNumberNumericRange::readEndHouseNumber(::zserio::BitStreamReader& in)
{
    ::nds::name::types::HouseNumberNumeric readField = static_cast<::nds::name::types::HouseNumberNumeric>(in.readVarUInt32());
    // check constraint
    if (!(readField != getStartHouseNumber()))
        throw ::zserio::ConstraintException("Read: Constraint violated at HouseNumberNumericRange.endHouseNumber!");

    return readField;
}

::nds::name::types::HouseNumberNumeric HouseNumberNumericRange::readEndHouseNumber(HouseNumberNumericRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::name::types::HouseNumberNumeric readField = context.getEndHouseNumber().read<::zserio::VarIntNNArrayTraits<::nds::name::types::HouseNumberNumeric>>(in);
    // check constraint
    if (!(readField != getStartHouseNumber()))
        throw ::zserio::ConstraintException("Read: Constraint violated at HouseNumberNumericRange.endHouseNumber!");

    return readField;
}
::zserio::InplaceOptionalHolder<::zserio::string<>> HouseNumberNumericRange::readPattern(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasPattern())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/name/types/RoadAddressPoint.h>
#include <nds/name/types/AddressPointType.h>

namespace nds
{
namespace name
{
namespace types
{

RoadAddressPoint::RoadAddressPoint(const allocator_type&) noexcept :
        m_type_(::nds::name::types::AddressPointType()),
        m_accessPositions_(::zserio::NullOpt),
        m_postalPosition_(::zserio::NullOpt)
{
}

RoadAddressPoint::RoadAddressPoint(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_accessPositions_(readAccessPositions(in, allocator)),
        m_postalPosition_(readPostalPosition(in, allocator))
{
}

RoadAddressPoint::RoadAddressPoint(RoadAddressPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_accessPositions_(readAccessPositions(context, in, allocator)),
        m_postalPosition_(readPostalPosition(context, in, allocator))
{
}

RoadAddressPoint::RoadAddressPoint(::zserio::PropagateAllocatorT,
        const RoadAddressPoint& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_accessPositions_(::zserio::allocatorPropagatingCopy(other.m_accessPositions_, allocator)),
        m_postalPosition_(::zserio::allocatorPropagatingCopy(other.m_postalPosition_, allocator))
{
}

void RoadAddressPoint::initializeChildren()
{
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
        m_accessPositions_.value().initializeElements(*this);
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
        m_postalPosition_.value().initializeChildren();
}

::nds::name::types::AddressPointType RoadAddressPoint::getType() const
{
    return m_type_;
}

void RoadAddressPoint::setType(::nds::name::types::AddressPointType type_)
{
    m_type_ = type_;
}

::zserio::vector<::nds::name::types::RoadAddressPointReference>& RoadAddressPoint::getAccessPositions()
{
    return m_accessPositions_.value().getRawArray();
}

const ::zserio::vector<::nds::name::types::RoadAddressPointReference>& RoadAddressPoint::getAccessPositions() const
{
    return m_accessPositions_.value().getRawArray();
}

void RoadAddressPoint::setAccessPositions(const ::zserio::vector<::nds::name::types::RoadAddressPointReference>& accessPositions_)
{
    m_accessPositions_ = ZserioArrayType_accessPositions(accessPositions_);
}

void RoadAddressPoint::setAccessPositions(::zserio::vector<::nds::name::types::RoadAddressPointReference>&& accessPositions_)
{
    m_accessPositions_ = ZserioArrayType_accessPositions(std::move(accessPositions_));
}

bool RoadAddressPoint::isAccessPositionsUsed() const
{
    return (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION);
}

bool RoadAddressPoint::isAccessPositionsSet() const
{
    return m_accessPositions_.hasValue();
}

void RoadAddressPoint::resetAccessPositions()
{
    m_accessPositions_.reset();
}

::nds::name::types::RoadAddressPointReference& RoadAddressPoint::getPostalPosition()
{
    return m_postalPosition_.value();
}

const ::nds::name::types::RoadAddressPointReference& RoadAddressPoint::getPostalPosition() const
{
    return m_postalPosition_.value();
}

void RoadAddressPoint::setPostalPosition(const ::nds::name::types::RoadAddressPointReference& postalPosition_)
{
    m_postalPosition_ = postalPosition_;
}

void RoadAddressPoint::setPostalPosition(::nds::name::types::RoadAddressPointReference&& postalPosition_)
{
    m_postalPosition_ = ::std::move(postalPosition_);
}

bool RoadAddressPoint::isPostalPositionUsed() const
{
    return (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION);
}

bool RoadAddressPoint::isPostalPositionSet() const
{
    return m_postalPosition_.hasValue();
}

void RoadAddressPoint::resetPostalPosition()
{
    m_postalPosition_.reset();
}

void RoadAddressPoint::initPackingContext(RoadAddressPoint::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        m_postalPosition_.value().initPackingContext(context.getPostalPosition());
    }
}

size_t RoadAddressPoint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        endBitPosition += m_accessPositions_.value().bitSizeOf(*this, endBitPosition);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        endBitPosition += m_postalPosition_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadAddressPoint::bitSizeOf(RoadAddressPoint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        endBitPosition += m_accessPositions_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        endBitPosition += m_postalPosition_.value().bitSizeOf(context.getPostalPosition(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadAddressPoint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        endBitPosition = m_accessPositions_.value().initializeOffsets(*this, endBitPosition);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        endBitPosition = m_postalPosition_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RoadAddressPoint::initializeOffsets(RoadAddressPoint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        endBitPosition = m_accessPositions_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        endBitPosition = m_postalPosition_.value().initializeOffsets(context.getPostalPosition(), endBitPosition);
    }

    return endBitPosition;
}

bool RoadAddressPoint::operator==(const RoadAddressPoint& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isAccessPositionsUsed() ? !other.isAccessPositionsUsed() : (m_accessPositions_ == other.m_accessPositions_)) &&
                (!isPostalPositionUsed() ? !other.isPostalPositionUsed() : (m_postalPosition_ == other.m_postalPosition_));
    }

    return true;
}

uint32_t RoadAddressPoint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isAccessPositionsUsed())
        result = ::zserio::calcHashCode(result, m_accessPositions_);
    if (isPostalPositionUsed())
        result = ::zserio::calcHashCode(result, m_postalPosition_);

    return result;
}

void RoadAddressPoint::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        m_accessPositions_.value().write(*this, out);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        m_postalPosition_.value().write(out);
    }
}

void RoadAddressPoint::write(RoadAddressPoint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        m_accessPositions_.value().writePacked(*this, out);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        m_postalPosition_.value().write(context.getPostalPosition(), out);
    }
}

void RoadAddressPoint::ZserioArrayExpressions_accessPositions::initializeElement(RoadAddressPoint&,
        ::nds::name::types::RoadAddressPointReference& element, size_t)
{
    element.initializeChildren();
}

void RoadAddressPoint::ZserioElementFactory_accessPositions::create(RoadAddressPoint&        ,
        ::zserio::vector<::nds::name::types::RoadAddressPointReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoadAddressPoint::ZserioElementFactory_accessPositions::create(RoadAddressPoint&        ,
        ::zserio::vector<::nds::name::types::RoadAddressPointReference>& array,
        ::nds::name::types::RoadAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::name::types::AddressPointType RoadAddressPoint::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::AddressPointType>(in);
}

::nds::name::types::AddressPointType RoadAddressPoint::readType(RoadAddressPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::AddressPointType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<RoadAddressPoint::ZserioArrayType_accessPositions> RoadAddressPoint::readAccessPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        ZserioArrayType_accessPositions readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_accessPositions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_accessPositions>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoadAddressPoint::ZserioArrayType_accessPositions> RoadAddressPoint::readAccessPositions(RoadAddressPoint::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        ZserioArrayType_accessPositions readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_accessPositions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_accessPositions>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::name::types::RoadAddressPointReference> RoadAddressPoint::readPostalPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::name::types::RoadAddressPointReference>(::nds::name::types::RoadAddressPointReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::name::types::RoadAddressPointReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::name::types::RoadAddressPointReference> RoadAddressPoint::readPostalPosition(RoadAddressPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::name::types::RoadAddressPointReference>(::nds::name::types::RoadAddressPointReference(context.getPostalPosition(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::name::types::RoadAddressPointReference>(::zserio::NullOpt);
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/name/types/LaneAddressPoint.h>
#include <nds/name/types/AddressPointType.h>

namespace nds
{
namespace name
{
namespace types
{

LaneAddressPoint::LaneAddressPoint(const allocator_type&) noexcept :
        m_type_(::nds::name::types::AddressPointType()),
        m_accessPositions_(::zserio::NullOpt),
        m_postalPosition_(::zserio::NullOpt)
{
}

LaneAddressPoint::LaneAddressPoint(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_accessPositions_(readAccessPositions(in, allocator)),
        m_postalPosition_(readPostalPosition(in, allocator))
{
}

LaneAddressPoint::LaneAddressPoint(LaneAddressPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_accessPositions_(readAccessPositions(context, in, allocator)),
        m_postalPosition_(readPostalPosition(context, in, allocator))
{
}

LaneAddressPoint::LaneAddressPoint(::zserio::PropagateAllocatorT,
        const LaneAddressPoint& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_accessPositions_(::zserio::allocatorPropagatingCopy(other.m_accessPositions_, allocator)),
        m_postalPosition_(::zserio::allocatorPropagatingCopy(other.m_postalPosition_, allocator))
{
}

void LaneAddressPoint::initializeChildren()
{
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
        m_accessPositions_.value().initializeElements(*this);
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
        m_postalPosition_.value().initializeChildren();
}

::nds::name::types::AddressPointType LaneAddressPoint::getType() const
{
    return m_type_;
}

void LaneAddressPoint::setType(::nds::name::types::AddressPointType type_)
{
    m_type_ = type_;
}

::zserio::vector<::nds::name::types::LaneAddressPointReference>& LaneAddressPoint::getAccessPositions()
{
    return m_accessPositions_.value().getRawArray();
}

const ::zserio::vector<::nds::name::types::LaneAddressPointReference>& LaneAddressPoint::getAccessPositions() const
{
    return m_accessPositions_.value().getRawArray();
}

void LaneAddressPoint::setAccessPositions(const ::zserio::vector<::nds::name::types::LaneAddressPointReference>& accessPositions_)
{
    m_accessPositions_ = ZserioArrayType_accessPositions(accessPositions_);
}

void LaneAddressPoint::setAccessPositions(::zserio::vector<::nds::name::types::LaneAddressPointReference>&& accessPositions_)
{
    m_accessPositions_ = ZserioArrayType_accessPositions(std::move(accessPositions_));
}

bool LaneAddressPoint::isAccessPositionsUsed() const
{
    return (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION);
}

bool LaneAddressPoint::isAccessPositionsSet() const
{
    return m_accessPositions_.hasValue();
}

void LaneAddressPoint::resetAccessPositions()
{
    m_accessPositions_.reset();
}

::nds::name::types::LaneAddressPointReference& LaneAddressPoint::getPostalPosition()
{
    return m_postalPosition_.value();
}

const ::nds::name::types::LaneAddressPointReference& LaneAddressPoint::getPostalPosition() const
{
    return m_postalPosition_.value();
}

void LaneAddressPoint::setPostalPosition(const ::nds::name::types::LaneAddressPointReference& postalPosition_)
{
    m_postalPosition_ = postalPosition_;
}

void LaneAddressPoint::setPostalPosition(::nds::name::types::LaneAddressPointReference&& postalPosition_)
{
    m_postalPosition_ = ::std::move(postalPosition_);
}

bool LaneAddressPoint::isPostalPositionUsed() const
{
    return (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION);
}

bool LaneAddressPoint::isPostalPositionSet() const
{
    return m_postalPosition_.hasValue();
}

void LaneAddressPoint::resetPostalPosition()
{
    m_postalPosition_.reset();
}

void LaneAddressPoint::initPackingContext(LaneAddressPoint::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        m_postalPosition_.value().initPackingContext(context.getPostalPosition());
    }
}

size_t LaneAddressPoint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        endBitPosition += m_accessPositions_.value().bitSizeOf(*this, endBitPosition);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        endBitPosition += m_postalPosition_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneAddressPoint::bitSizeOf(LaneAddressPoint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        endBitPosition += m_accessPositions_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        endBitPosition += m_postalPosition_.value().bitSizeOf(context.getPostalPosition(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneAddressPoint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        endBitPosition = m_accessPositions_.value().initializeOffsets(*this, endBitPosition);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        endBitPosition = m_postalPosition_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LaneAddressPoint::initializeOffsets(LaneAddressPoint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        endBitPosition = m_accessPositions_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        endBitPosition = m_postalPosition_.value().initializeOffsets(context.getPostalPosition(), endBitPosition);
    }

    return endBitPosition;
}

bool LaneAddressPoint::operator==(const LaneAddressPoint& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isAccessPositionsUsed() ? !other.isAccessPositionsUsed() : (m_accessPositions_ == other.m_accessPositions_)) &&
                (!isPostalPositionUsed() ? !other.isPostalPositionUsed() : (m_postalPosition_ == other.m_postalPosition_));
    }

    return true;
}

uint32_t LaneAddressPoint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isAccessPositionsUsed())
        result = ::zserio::calcHashCode(result, m_accessPositions_);
    if (isPostalPositionUsed())
        result = ::zserio::calcHashCode(result, m_postalPosition_);

    return result;
}

void LaneAddressPoint::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        m_accessPositions_.value().write(*this, out);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        m_postalPosition_.value().write(out);
    }
}

void LaneAddressPoint::write(LaneAddressPoint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        m_accessPositions_.value().writePacked(*this, out);
    }
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        m_postalPosition_.value().write(context.getPostalPosition(), out);
    }
}

void LaneAddressPoint::ZserioArrayExpressions_accessPositions::initializeElement(LaneAddressPoint&,
        ::nds::name::types::LaneAddressPointReference& element, size_t)
{
    element.initializeChildren();
}

void LaneAddressPoint::ZserioElementFactory_accessPositions::create(LaneAddressPoint&        ,
        ::zserio::vector<::nds::name::types::LaneAddressPointReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneAddressPoint::ZserioElementFactory_accessPositions::create(LaneAddressPoint&        ,
        ::zserio::vector<::nds::name::types::LaneAddressPointReference>& array,
        ::nds::name::types::LaneAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::name::types::AddressPointType LaneAddressPoint::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::AddressPointType>(in);
}

::nds::name::types::AddressPointType LaneAddressPoint::readType(LaneAddressPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::name::types::AddressPointType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<LaneAddressPoint::ZserioArrayType_accessPositions> LaneAddressPoint::readAccessPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        ZserioArrayType_accessPositions readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_accessPositions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_accessPositions>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LaneAddressPoint::ZserioArrayType_accessPositions> LaneAddressPoint::readAccessPositions(LaneAddressPoint::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::name::types::AddressPointType::POSTAL_POSITION)
    {
        ZserioArrayType_accessPositions readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_accessPositions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_accessPositions>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::name::types::LaneAddressPointReference> LaneAddressPoint::readPostalPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::name::types::LaneAddressPointReference>(::nds::name::types::LaneAddressPointReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::name::types::LaneAddressPointReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::name::types::LaneAddressPointReference> LaneAddressPoint::readPostalPosition(LaneAddressPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::name::types::AddressPointType::ACCESS_POSITION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::name::types::LaneAddressPointReference>(::nds::name::types::LaneAddressPointReference(context.getPostalPosition(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::name::types::LaneAddressPointReference>(::zserio::NullOpt);
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/types/RoadAddressPointReference.h>

namespace nds
{
namespace name
{
namespace types
{

RoadAddressPointReference::RoadAddressPointReference(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_indirectReference_(allocator),
        m_position_(allocator)
{
}

RoadAddressPointReference::RoadAddressPointReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_indirectReference_(readIndirectReference(in, allocator)),
        m_position_(readPosition(in, allocator))
{
}

RoadAddressPointReference::RoadAddressPointReference(RoadAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_indirectReference_(readIndirectReference(context, in, allocator)),
        m_position_(readPosition(context, in, allocator))
{
}

RoadAddressPointReference::RoadAddressPointReference(const RoadAddressPointReference& other) :
        m_indirectReference_(other.m_indirectReference_),
        m_position_(other.m_position_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadAddressPointReference& RoadAddressPointReference::operator=(const RoadAddressPointReference& other)
{
    m_indirectReference_ = other.m_indirectReference_;
    m_position_ = other.m_position_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadAddressPointReference::RoadAddressPointReference(RoadAddressPointReference&& other) :
        m_indirectReference_(::std::move(other.m_indirectReference_)),
        m_position_(::std::move(other.m_position_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadAddressPointReference& RoadAddressPointReference::operator=(RoadAddressPointReference&& other)
{
    m_indirectReference_ = ::std::move(other.m_indirectReference_);
    m_position_ = ::std::move(other.m_position_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadAddressPointReference::RoadAddressPointReference(::zserio::PropagateAllocatorT,
        const RoadAddressPointReference& other, const allocator_type& allocator) :
        m_indirectReference_(::zserio::allocatorPropagatingCopy(other.m_indirectReference_, allocator)),
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadAddressPointReference::initializeChildren()
{
    m_indirectReference_.initializeChildren();
    m_position_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::road::reference::types::RoadReferenceIndirect& RoadAddressPointReference::getIndirectReference()
{
    return m_indirectReference_;
}

const ::nds::road::reference::types::RoadReferenceIndirect& RoadAddressPointReference::getIndirectReference() const
{
    return m_indirectReference_;
}

void RoadAddressPointReference::setIndirectReference(const ::nds::road::reference::types::RoadReferenceIndirect& indirectReference_)
{
    m_indirectReference_ = indirectReference_;
}

void RoadAddressPointReference::setIndirectReference(::nds::road::reference::types::RoadReferenceIndirect&& indirectReference_)
{
    m_indirectReference_ = ::std::move(indirectReference_);
}

::nds::road::reference::types::RoadPositionValidity& RoadAddressPointReference::getPosition()
{
    return m_position_;
}

const ::nds::road::reference::types::RoadPositionValidity& RoadAddressPointReference::getPosition() const
{
    return m_position_;
}

void RoadAddressPointReference::setPosition(const ::nds::road::reference::types::RoadPositionValidity& position_)
{
    m_position_ = position_;
}

void RoadAddressPointReference::setPosition(::nds::road::reference::types::RoadPositionValidity&& position_)
{
    m_position_ = ::std::move(position_);
}

void RoadAddressPointReference::initPackingContext(RoadAddressPointReference::ZserioPackingContext& context) const
{
    m_indirectReference_.initPackingContext(context.getIndirectReference());
    m_position_.initPackingContext(context.getPosition());
}

size_t RoadAddressPointReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_indirectReference_.bitSizeOf(endBitPosition);
    endBitPosition += m_position_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadAddressPointReference::bitSizeOf(RoadAddressPointReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_indirectReference_.bitSizeOf(context.getIndirectReference(), endBitPosition);
    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadAddressPointReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_indirectReference_.initializeOffsets(endBitPosition);
    endBitPosition = m_position_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadAddressPointReference::initializeOffsets(RoadAddressPointReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_indirectReference_.initializeOffsets(context.getIndirectReference(), endBitPosition);
    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);

    return endBitPosition;
}

bool RoadAddressPointReference::operator==(const RoadAddressPointReference& other) const
{
    if (this != &other)
    {
        return
                (m_indirectReference_ == other.m_indirectReference_) &&
                (m_position_ == other.m_position_);
    }

    return true;
}

uint32_t RoadAddressPointReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_indirectReference_);
    result = ::zserio::calcHashCode(result, m_position_);

    return result;
}

void RoadAddressPointReference::write(::zserio::BitStreamWriter& out) const
{
    m_indirectReference_.write(out);

    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadAddressPointReference.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(out);
}

void RoadAddressPointReference::write(RoadAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_indirectReference_.write(context.getIndirectReference(), out);

    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadAddressPointReference.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(context.getPosition(), out);
}

::nds::road::reference::types::RoadReferenceIndirect RoadAddressPointReference::readIndirectReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadReferenceIndirect(in, allocator);
}

::nds::road::reference::types::RoadReferenceIndirect RoadAddressPointReference::readIndirectReference(RoadAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadReferenceIndirect(context.getIndirectReference(), in, allocator);
}
::nds::road::reference::types::RoadPositionValidity RoadAddressPointReference::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadPositionValidity(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::road::reference::types::RoadPositionValidity RoadAddressPointReference::readPosition(RoadAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadPositionValidity(context.getPosition(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/types/LaneAddressPointReference.h>

namespace nds
{
namespace name
{
namespace types
{

LaneAddressPointReference::LaneAddressPointReference(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_indirectReference_(allocator),
        m_position_(allocator)
{
}

LaneAddressPointReference::LaneAddressPointReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_indirectReference_(readIndirectReference(in, allocator)),
        m_position_(readPosition(in, allocator))
{
}

LaneAddressPointReference::LaneAddressPointReference(LaneAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_indirectReference_(readIndirectReference(context, in, allocator)),
        m_position_(readPosition(context, in, allocator))
{
}

LaneAddressPointReference::LaneAddressPointReference(const LaneAddressPointReference& other) :
        m_indirectReference_(other.m_indirectReference_),
        m_position_(other.m_position_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneAddressPointReference& LaneAddressPointReference::operator=(const LaneAddressPointReference& other)
{
    m_indirectReference_ = other.m_indirectReference_;
    m_position_ = other.m_position_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneAddressPointReference::LaneAddressPointReference(LaneAddressPointReference&& other) :
        m_indirectReference_(::std::move(other.m_indirectReference_)),
        m_position_(::std::move(other.m_position_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneAddressPointReference& LaneAddressPointReference::operator=(LaneAddressPointReference&& other)
{
    m_indirectReference_ = ::std::move(other.m_indirectReference_);
    m_position_ = ::std::move(other.m_position_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneAddressPointReference::LaneAddressPointReference(::zserio::PropagateAllocatorT,
        const LaneAddressPointReference& other, const allocator_type& allocator) :
        m_indirectReference_(::zserio::allocatorPropagatingCopy(other.m_indirectReference_, allocator)),
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneAddressPointReference::initializeChildren()
{
    m_indirectReference_.initializeChildren();
    m_position_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::lane::reference::types::LaneGroupReferenceIndirect& LaneAddressPointReference::getIndirectReference()
{
    return m_indirectReference_;
}

const ::nds::lane::reference::types::LaneGroupReferenceIndirect& LaneAddressPointReference::getIndirectReference() const
{
    return m_indirectReference_;
}

void LaneAddressPointReference::setIndirectReference(const ::nds::lane::reference::types::LaneGroupReferenceIndirect& indirectReference_)
{
    m_indirectReference_ = indirectReference_;
}

void LaneAddressPointReference::setIndirectReference(::nds::lane::reference::types::LaneGroupReferenceIndirect&& indirectReference_)
{
    m_indirectReference_ = ::std::move(indirectReference_);
}

::nds::lane::reference::types::LaneGroupPositionValidity& LaneAddressPointReference::getPosition()
{
    return m_position_;
}

const ::nds::lane::reference::types::LaneGroupPositionValidity& LaneAddressPointReference::getPosition() const
{
    return m_position_;
}

void LaneAddressPointReference::setPosition(const ::nds::lane::reference::types::LaneGroupPositionValidity& position_)
{
    m_position_ = position_;
}

void LaneAddressPointReference::setPosition(::nds::lane::reference::types::LaneGroupPositionValidity&& position_)
{
    m_position_ = ::std::move(position_);
}

void LaneAddressPointReference::initPackingContext(LaneAddressPointReference::ZserioPackingContext& context) const
{
    m_indirectReference_.initPackingContext(context.getIndirectReference());
    m_position_.initPackingContext(context.getPosition());
}

size_t LaneAddressPointReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_indirectReference_.bitSizeOf(endBitPosition);
    endBitPosition += m_position_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneAddressPointReference::bitSizeOf(LaneAddressPointReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_indirectReference_.bitSizeOf(context.getIndirectReference(), endBitPosition);
    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneAddressPointReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_indirectReference_.initializeOffsets(endBitPosition);
    endBitPosition = m_position_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneAddressPointReference::initializeOffsets(LaneAddressPointReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_indirectReference_.initializeOffsets(context.getIndirectReference(), endBitPosition);
    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);

    return endBitPosition;
}

bool LaneAddressPointReference::operator==(const LaneAddressPointReference& other) const
{
    if (this != &other)
    {
        return
                (m_indirectReference_ == other.m_indirectReference_) &&
                (m_position_ == other.m_position_);
    }

    return true;
}

uint32_t LaneAddressPointReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_indirectReference_);
    result = ::zserio::calcHashCode(result, m_position_);

    return result;
}

void LaneAddressPointReference::write(::zserio::BitStreamWriter& out) const
{
    m_indirectReference_.write(out);

    // check parameters
    if (m_position_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field LaneAddressPointReference.position: ") <<
                m_position_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(out);
}

void LaneAddressPointReference::write(LaneAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_indirectReference_.write(context.getIndirectReference(), out);

    // check parameters
    if (m_position_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field LaneAddressPointReference.position: ") <<
                m_position_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(context.getPosition(), out);
}

::nds::lane::reference::types::LaneGroupReferenceIndirect LaneAddressPointReference::readIndirectReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupReferenceIndirect(in, allocator);
}

::nds::lane::reference::types::LaneGroupReferenceIndirect LaneAddressPointReference::readIndirectReference(LaneAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupReferenceIndirect(context.getIndirectReference(), in, allocator);
}
::nds::lane::reference::types::LaneGroupPositionValidity LaneAddressPointReference::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupPositionValidity(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::lane::reference::types::LaneGroupPositionValidity LaneAddressPointReference::readPosition(LaneAddressPointReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupPositionValidity(context.getPosition(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace types
} // namespace name
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/name/types/HouseNumberRangeNumbers.h>

namespace nds
{
namespace name
{
namespace types
{

HouseNumberRangeNumbers::HouseNumberRangeNumbers(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

HouseNumberRangeNumbers::HouseNumberRangeNumbers(::zserio::BitStreamReader& in,
        ::nds::name::types::HouseNumberType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

HouseNumberRangeNumbers::HouseNumberRangeNumbers(HouseNumberRangeNumbers::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::name::types::HouseNumberType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

HouseNumberRangeNumbers::HouseNumberRangeNumbers(const HouseNumberRangeNumbers& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

HouseNumberRangeNumbers& HouseNumberRangeNumbers::operator=(const HouseNumberRangeNumbers& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

HouseNumberRangeNumbers::HouseNumberRangeNumbers(HouseNumberRangeNumbers&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

HouseNumberRangeNumbers& HouseNumberRangeNumbers::operator=(HouseNumberRangeNumbers&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

HouseNumberRangeNumbers::HouseNumberRangeNumbers(::zserio::PropagateAllocatorT,
        const HouseNumberRangeNumbers& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void HouseNumberRangeNumbers::initialize(
        ::nds::name::types::HouseNumberType type_)
{
    m_type_ = type_;
    m_isInitialized = true;

    initializeChildren();
}

bool HouseNumberRangeNumbers::isInitialized() const
{
    return m_isInitialized;
}

void HouseNumberRangeNumbers::initializeChildren()
{
    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initialize(static_cast<bool>(false), static_cast<bool>(true));
        break;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initialize(static_cast<bool>(true), static_cast<bool>(true));
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initialize(static_cast<bool>(false), static_cast<bool>(false));
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initialize(static_cast<bool>(true), static_cast<bool>(false));
        break;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        break;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }
}

::nds::name::types::HouseNumberType HouseNumberRangeNumbers::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'HouseNumberRangeNumbers' is not initialized!");

    return m_type_;
}

::nds::name::types::HouseNumberNumericRange& HouseNumberRangeNumbers::getHouseNumberRangeEvenOdd()
{
    return m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>();
}

const ::nds::name::types::HouseNumberNumericRange& HouseNumberRangeNumbers::getHouseNumberRangeEvenOdd() const
{
    return m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>();
}

void HouseNumberRangeNumbers::setHouseNumberRangeEvenOdd(const ::nds::name::types::HouseNumberNumericRange& houseNumberRangeEvenOdd_)
{
    m_objectChoice = houseNumberRangeEvenOdd_;
}

void HouseNumberRangeNumbers::setHouseNumberRangeEvenOdd(::nds::name::types::HouseNumberNumericRange&& houseNumberRangeEvenOdd_)
{
    m_objectChoice = ::std::move(houseNumberRangeEvenOdd_);
}

::nds::name::types::HouseNumberNumericRange& HouseNumberRangeNumbers::getHouseNumberRangeEvenOddPattern()
{
    return m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>();
}

const ::nds::name::types::HouseNumberNumericRange& HouseNumberRangeNumbers::getHouseNumberRangeEvenOddPattern() const
{
    return m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>();
}

void HouseNumberRangeNumbers::setHouseNumberRangeEvenOddPattern(const ::nds::name::types::HouseNumberNumericRange& houseNumberRangeEvenOddPattern_)
{
    m_objectChoice = houseNumberRangeEvenOddPattern_;
}

void HouseNumberRangeNumbers::setHouseNumberRangeEvenOddPattern(::nds::name::types::HouseNumberNumericRange&& houseNumberRangeEvenOddPattern_)
{
    m_objectChoice = ::std::move(houseNumberRangeEvenOddPattern_);
}

::nds::name::types::HouseNumberNumericRange& HouseNumberRangeNumbers::getHouseNumberRangeContinuous()
{
    return m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>();
}

const ::nds::name::types::HouseNumberNumericRange& HouseNumberRangeNumbers::getHouseNumberRangeContinuous() const
{
    return m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>();
}

void HouseNumberRangeNumbers::setHouseNumberRangeContinuous(const ::nds::name::types::HouseNumberNumericRange& houseNumberRangeContinuous_)
{
    m_objectChoice = houseNumberRangeContinuous_;
}

void HouseNumberRangeNumbers::setHouseNumberRangeContinuous(::nds::name::types::HouseNumberNumericRange&& houseNumberRangeContinuous_)
{
    m_objectChoice = ::std::move(houseNumberRangeContinuous_);
}

::nds::name::types::HouseNumberNumericRange& HouseNumberRangeNumbers::getHouseNumberRangeContinuousPattern()
{
    return m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>();
}

const ::nds::name::types::HouseNumberNumericRange& HouseNumberRangeNumbers::getHouseNumberRangeContinuousPattern() const
{
    return m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>();
}

void HouseNumberRangeNumbers::setHouseNumberRangeContinuousPattern(const ::nds::name::types::HouseNumberNumericRange& houseNumberRangeContinuousPattern_)
{
    m_objectChoice = houseNumberRangeContinuousPattern_;
}

void HouseNumberRangeNumbers::setHouseNumberRangeContinuousPattern(::nds::name::types::HouseNumberNumericRange&& houseNumberRangeContinuousPattern_)
{
    m_objectChoice = ::std::move(houseNumberRangeContinuousPattern_);
}

::zserio::vector<::nds::name::types::HouseNumberNumeric>& HouseNumberRangeNumbers::getHouseNumberNumeric()
{
    return m_objectChoice.get<ZserioArrayType_houseNumberNumeric>().getRawArray();
}

const ::zserio::vector<::nds::name::types::HouseNumberNumeric>& HouseNumberRangeNumbers::getHouseNumberNumeric() const
{
    return m_objectChoice.get<ZserioArrayType_houseNumberNumeric>().getRawArray();
}

void HouseNumberRangeNumbers::setHouseNumberNumeric(const ::zserio::vector<::nds::name::types::HouseNumberNumeric>& houseNumberNumeric_)
{
    m_objectChoice = ZserioArrayType_houseNumberNumeric(houseNumberNumeric_);
}

void HouseNumberRangeNumbers::setHouseNumberNumeric(::zserio::vector<::nds::name::types::HouseNumberNumeric>&& houseNumberNumeric_)
{
    m_objectChoice = ZserioArrayType_houseNumberNumeric(std::move(houseNumberNumeric_));
}

::zserio::vector<::nds::name::types::HouseNumber>& HouseNumberRangeNumbers::getHouseNumber()
{
    return m_objectChoice.get<ZserioArrayType_houseNumber>().getRawArray();
}

const ::zserio::vector<::nds::name::types::HouseNumber>& HouseNumberRangeNumbers::getHouseNumber() const
{
    return m_objectChoice.get<ZserioArrayType_houseNumber>().getRawArray();
}

void HouseNumberRangeNumbers::setHouseNumber(const ::zserio::vector<::nds::name::types::HouseNumber>& houseNumber_)
{
    m_objectChoice = ZserioArrayType_houseNumber(houseNumber_);
}

void HouseNumberRangeNumbers::setHouseNumber(::zserio::vector<::nds::name::types::HouseNumber>&& houseNumber_)
{
    m_objectChoice = ZserioArrayType_houseNumber(std::move(houseNumber_));
}

HouseNumberRangeNumbers::ChoiceTag HouseNumberRangeNumbers::choiceTag() const
{
    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        return CHOICE_houseNumberRangeEvenOdd;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        return CHOICE_houseNumberRangeEvenOddPattern;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        return CHOICE_houseNumberRangeContinuous;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        return CHOICE_houseNumberRangeContinuousPattern;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        return CHOICE_houseNumberNumeric;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        return CHOICE_houseNumber;
    default:
        return UNDEFINED_CHOICE;
    }
}

void HouseNumberRangeNumbers::initPackingContext(HouseNumberRangeNumbers::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initPackingContext(context.getHouseNumberRangeEvenOdd());
        break;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initPackingContext(context.getHouseNumberRangeEvenOddPattern());
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initPackingContext(context.getHouseNumberRangeContinuous());
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initPackingContext(context.getHouseNumberRangeContinuousPattern());
        break;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        break;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }
}

size_t HouseNumberRangeNumbers::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        endBitPosition += m_objectChoice.get<ZserioArrayType_houseNumberNumeric>().bitSizeOf(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        endBitPosition += m_objectChoice.get<ZserioArrayType_houseNumber>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }

    return endBitPosition - bitPosition;
}

size_t HouseNumberRangeNumbers::bitSizeOf(HouseNumberRangeNumbers::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().bitSizeOf(context.getHouseNumberRangeEvenOdd(), endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().bitSizeOf(context.getHouseNumberRangeEvenOddPattern(), endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().bitSizeOf(context.getHouseNumberRangeContinuous(), endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        endBitPosition += m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().bitSizeOf(context.getHouseNumberRangeContinuousPattern(), endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        endBitPosition += m_objectChoice.get<ZserioArrayType_houseNumberNumeric>().bitSizeOfPacked(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        endBitPosition += m_objectChoice.get<ZserioArrayType_houseNumber>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }

    return endBitPosition - bitPosition;
}

size_t HouseNumberRangeNumbers::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        endBitPosition = m_objectChoice.get<ZserioArrayType_houseNumberNumeric>().initializeOffsets(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        endBitPosition = m_objectChoice.get<ZserioArrayType_houseNumber>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }

    return endBitPosition;
}

size_t HouseNumberRangeNumbers::initializeOffsets(HouseNumberRangeNumbers::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initializeOffsets(context.getHouseNumberRangeEvenOdd(), endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initializeOffsets(context.getHouseNumberRangeEvenOddPattern(), endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initializeOffsets(context.getHouseNumberRangeContinuous(), endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        endBitPosition = m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().initializeOffsets(context.getHouseNumberRangeContinuousPattern(), endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        endBitPosition = m_objectChoice.get<ZserioArrayType_houseNumberNumeric>().initializeOffsetsPacked(endBitPosition);
        break;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        endBitPosition = m_objectChoice.get<ZserioArrayType_houseNumber>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }

    return endBitPosition;
}

bool HouseNumberRangeNumbers::operator==(const HouseNumberRangeNumbers& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>() == other.m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>());
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>() == other.m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>());
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>() == other.m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>());
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>() == other.m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>());
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<ZserioArrayType_houseNumberNumeric>() == other.m_objectChoice.get<ZserioArrayType_houseNumberNumeric>());
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<ZserioArrayType_houseNumber>() == other.m_objectChoice.get<ZserioArrayType_houseNumber>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }
}

uint32_t HouseNumberRangeNumbers::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>());
            break;
        case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>());
            break;
        case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>());
            break;
        case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>());
            break;
        case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<ZserioArrayType_houseNumberNumeric>());
            break;
        case ::nds::name::types::HouseNumberType::LIST_STRING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<ZserioArrayType_houseNumber>());
            break;
        default:
            break;
        }
    }

    return result;
}

void HouseNumberRangeNumbers::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        // check parameters
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() != static_cast<bool>(false))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeEvenOdd: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() << " != " << static_cast<bool>(false) << "!";
        }
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeEvenOdd: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() << " != " << static_cast<bool>(true) << "!";
        }
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().write(out);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        // check parameters
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeEvenOddPattern: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() << " != " << static_cast<bool>(true) << "!";
        }
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeEvenOddPattern: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() << " != " << static_cast<bool>(true) << "!";
        }
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().write(out);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        // check parameters
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() != static_cast<bool>(false))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeContinuous: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() << " != " << static_cast<bool>(false) << "!";
        }
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() != static_cast<bool>(false))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeContinuous: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() << " != " << static_cast<bool>(false) << "!";
        }
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().write(out);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        // check parameters
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeContinuousPattern: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() << " != " << static_cast<bool>(true) << "!";
        }
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() != static_cast<bool>(false))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeContinuousPattern: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() << " != " << static_cast<bool>(false) << "!";
        }
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().write(out);
        break;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        m_objectChoice.get<ZserioArrayType_houseNumberNumeric>().write(out);
        break;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        m_objectChoice.get<ZserioArrayType_houseNumber>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }
}

void HouseNumberRangeNumbers::write(HouseNumberRangeNumbers::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        // check parameters
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() != static_cast<bool>(false))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeEvenOdd: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() << " != " << static_cast<bool>(false) << "!";
        }
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeEvenOdd: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() << " != " << static_cast<bool>(true) << "!";
        }
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().write(context.getHouseNumberRangeEvenOdd(), out);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        // check parameters
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeEvenOddPattern: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() << " != " << static_cast<bool>(true) << "!";
        }
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeEvenOddPattern: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() << " != " << static_cast<bool>(true) << "!";
        }
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().write(context.getHouseNumberRangeEvenOddPattern(), out);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        // check parameters
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() != static_cast<bool>(false))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeContinuous: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() << " != " << static_cast<bool>(false) << "!";
        }
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() != static_cast<bool>(false))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeContinuous: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() << " != " << static_cast<bool>(false) << "!";
        }
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().write(context.getHouseNumberRangeContinuous(), out);
        break;
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        // check parameters
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasPattern for field HouseNumberRangeNumbers.houseNumberRangeContinuousPattern: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getHasPattern() << " != " << static_cast<bool>(true) << "!";
        }
        if (m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() != static_cast<bool>(false))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter isEvenOdd for field HouseNumberRangeNumbers.houseNumberRangeContinuousPattern: ") <<
                    m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().getIsEvenOdd() << " != " << static_cast<bool>(false) << "!";
        }
        m_objectChoice.get<::nds::name::types::HouseNumberNumericRange>().write(context.getHouseNumberRangeContinuousPattern(), out);
        break;
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        m_objectChoice.get<ZserioArrayType_houseNumberNumeric>().writePacked(out);
        break;
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        m_objectChoice.get<ZserioArrayType_houseNumber>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }
}

::zserio::AnyHolder<> HouseNumberRangeNumbers::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberNumericRange(in, static_cast<bool>(false), static_cast<bool>(true), allocator), allocator);
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberNumericRange(in, static_cast<bool>(true), static_cast<bool>(true), allocator), allocator);
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberNumericRange(in, static_cast<bool>(false), static_cast<bool>(false), allocator), allocator);
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberNumericRange(in, static_cast<bool>(true), static_cast<bool>(false), allocator), allocator);
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        {
            ZserioArrayType_houseNumberNumeric readField(allocator);
            readField.read(in);

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        {
            ZserioArrayType_houseNumber readField(allocator);
            readField.read(in);

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }
}

::zserio::AnyHolder<> HouseNumberRangeNumbers::readObject(HouseNumberRangeNumbers::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberNumericRange(context.getHouseNumberRangeEvenOdd(), in, static_cast<bool>(false), static_cast<bool>(true), allocator), allocator);
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberNumericRange(context.getHouseNumberRangeEvenOddPattern(), in, static_cast<bool>(true), static_cast<bool>(true), allocator), allocator);
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberNumericRange(context.getHouseNumberRangeContinuous(), in, static_cast<bool>(false), static_cast<bool>(false), allocator), allocator);
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        return ::zserio::AnyHolder<>(::nds::name::types::HouseNumberNumericRange(context.getHouseNumberRangeContinuousPattern(), in, static_cast<bool>(true), static_cast<bool>(false), allocator), allocator);
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        {
            ZserioArrayType_houseNumberNumeric readField(allocator);
            readField.readPacked(in);

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        {
            ZserioArrayType_houseNumber readField(allocator);
            readField.read(in);

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }
}

::zserio::AnyHolder<> HouseNumberRangeNumbers::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::HouseNumberNumericRange>(m_objectChoice, allocator);
    case ::nds::name::types::HouseNumberType::RANGE_EVEN_ODD_PATTERN:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::HouseNumberNumericRange>(m_objectChoice, allocator);
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::HouseNumberNumericRange>(m_objectChoice, allocator);
    case ::nds::name::types::HouseNumberType::RANGE_CONTINUOUS_PATTERN:
        return ::zserio::allocatorPropagatingCopy<::nds::name::types::HouseNumberNumericRange>(m_objectChoice, allocator);
    case ::nds::name::types::HouseNumberType::LIST_NUMERIC:
        return ::zserio::allocatorPropagatingCopy<ZserioArrayType_houseNumberNumeric>(m_objectChoice, allocator);
    case ::nds::name::types::HouseNumberType::LIST_STRING:
        return ::zserio::allocatorPropagatingCopy<ZserioArrayType_houseNumber>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice HouseNumberRangeNumbers!");
    }
}

} // namespace types
} // namespace name
} // namespace nds
