/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/road/Road.h>

namespace nds
{
namespace road
{
namespace road
{

Road::Road(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_length_(::nds::road::reference::types::RoadLength())
{
}

Road::Road(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_length_(readLength(in))
{
}

Road::Road(Road::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_length_(readLength(context, in))
{
}

Road::Road(::zserio::PropagateAllocatorT,
        const Road& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator))
{
}

::nds::road::reference::types::RoadId& Road::getId()
{
    return m_id_;
}

const ::nds::road::reference::types::RoadId& Road::getId() const
{
    return m_id_;
}

void Road::setId(const ::nds::road::reference::types::RoadId& id_)
{
    m_id_ = id_;
}

void Road::setId(::nds::road::reference::types::RoadId&& id_)
{
    m_id_ = ::std::move(id_);
}

::nds::road::reference::types::RoadLength Road::getLength() const
{
    return m_length_;
}

void Road::setLength(::nds::road::reference::types::RoadLength length_)
{
    m_length_ = length_;
}

void Road::initPackingContext(Road::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(m_length_);
}

size_t Road::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);

    return endBitPosition - bitPosition;
}

size_t Road::bitSizeOf(Road::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(m_length_);

    return endBitPosition - bitPosition;
}

size_t Road::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);

    return endBitPosition;
}

size_t Road::initializeOffsets(Road::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(m_length_);

    return endBitPosition;
}

bool Road::operator==(const Road& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_length_ == other.m_length_);
    }

    return true;
}

uint32_t Road::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_length_);

    return result;
}

void Road::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);
    out.writeVarUInt32(m_length_);
}

void Road::write(Road::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);
    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(out, m_length_);
}

::nds::road::reference::types::RoadId Road::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadId(in, allocator);
}

::nds::road::reference::types::RoadId Road::readId(Road::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadId(context.getId(), in, allocator);
}
::nds::road::reference::types::RoadLength Road::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::road::reference::types::RoadLength>(in.readVarUInt32());
}

::nds::road::reference::types::RoadLength Road::readLength(Road::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(in);
}

} // namespace road
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/road/road/Intersection.h>

namespace nds
{
namespace road
{
namespace road
{

Intersection::Intersection(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_id_(::nds::road::reference::types::IntersectionId()),
        m_isArtificial_(bool()),
        m_zLevel_(::nds::road::reference::types::IntersectionZLevel()),
        m_numRoads_(uint8_t()),
        m_position_(allocator),
        m_connectedRoads_(allocator)
{
}

Intersection::Intersection(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_id_(readId(in)),
        m_isArtificial_(readIsArtificial(in)),
        m_zLevel_(readZLevel(in)),
        m_numRoads_(readNumRoads(in)),
        m_position_(readPosition(in, allocator)),
        m_connectedRoads_(readConnectedRoads(in, allocator))
{
}

Intersection::Intersection(Intersection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_id_(readId(context, in)),
        m_isArtificial_(readIsArtificial(in)),
        m_zLevel_(readZLevel(context, in)),
        m_numRoads_(readNumRoads(context, in)),
        m_position_(readPosition(context, in, allocator)),
        m_connectedRoads_(readConnectedRoads(context, in, allocator))
{
}

Intersection::Intersection(const Intersection& other) :
        m_id_(other.m_id_),
        m_isArtificial_(other.m_isArtificial_),
        m_zLevel_(other.m_zLevel_),
        m_numRoads_(other.m_numRoads_),
        m_position_(other.m_position_),
        m_connectedRoads_(other.m_connectedRoads_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

Intersection& Intersection::operator=(const Intersection& other)
{
    m_id_ = other.m_id_;
    m_isArtificial_ = other.m_isArtificial_;
    m_zLevel_ = other.m_zLevel_;
    m_numRoads_ = other.m_numRoads_;
    m_position_ = other.m_position_;
    m_connectedRoads_ = other.m_connectedRoads_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

Intersection::Intersection(Intersection&& other) :
        m_id_(::std::move(other.m_id_)),
        m_isArtificial_(::std::move(other.m_isArtificial_)),
        m_zLevel_(::std::move(other.m_zLevel_)),
        m_numRoads_(::std::move(other.m_numRoads_)),
        m_position_(::std::move(other.m_position_)),
        m_connectedRoads_(::std::move(other.m_connectedRoads_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

Intersection& Intersection::operator=(Intersection&& other)
{
    m_id_ = ::std::move(other.m_id_);
    m_isArtificial_ = ::std::move(other.m_isArtificial_);
    m_zLevel_ = ::std::move(other.m_zLevel_);
    m_numRoads_ = ::std::move(other.m_numRoads_);
    m_position_ = ::std::move(other.m_position_);
    m_connectedRoads_ = ::std::move(other.m_connectedRoads_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

Intersection::Intersection(::zserio::PropagateAllocatorT,
        const Intersection& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_isArtificial_(::zserio::allocatorPropagatingCopy(other.m_isArtificial_, allocator)),
        m_zLevel_(::zserio::allocatorPropagatingCopy(other.m_zLevel_, allocator)),
        m_numRoads_(::zserio::allocatorPropagatingCopy(other.m_numRoads_, allocator)),
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator)),
        m_connectedRoads_(::zserio::allocatorPropagatingCopy(other.m_connectedRoads_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void Intersection::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool Intersection::isInitialized() const
{
    return m_isInitialized;
}

void Intersection::initializeChildren()
{
    m_position_.initialize(static_cast<::nds::core::geometry::CoordShift>(getCoordShift()));
    m_connectedRoads_.initializeElements(*this);
}

::nds::core::geometry::CoordShift Intersection::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'Intersection' is not initialized!");

    return m_coordShift_;
}

::nds::road::reference::types::IntersectionId Intersection::getId() const
{
    return m_id_;
}

void Intersection::setId(::nds::road::reference::types::IntersectionId id_)
{
    m_id_ = id_;
}

bool Intersection::getIsArtificial() const
{
    return m_isArtificial_;
}

void Intersection::setIsArtificial(bool isArtificial_)
{
    m_isArtificial_ = isArtificial_;
}

::nds::road::reference::types::IntersectionZLevel Intersection::getZLevel() const
{
    return m_zLevel_;
}

void Intersection::setZLevel(::nds::road::reference::types::IntersectionZLevel zLevel_)
{
    m_zLevel_ = zLevel_;
}

uint8_t Intersection::getNumRoads() const
{
    return m_numRoads_;
}

void Intersection::setNumRoads(uint8_t numRoads_)
{
    m_numRoads_ = numRoads_;
}

::nds::core::geometry::Position2D& Intersection::getPosition()
{
    return m_position_;
}

const ::nds::core::geometry::Position2D& Intersection::getPosition() const
{
    return m_position_;
}

void Intersection::setPosition(const ::nds::core::geometry::Position2D& position_)
{
    m_position_ = position_;
}

void Intersection::setPosition(::nds::core::geometry::Position2D&& position_)
{
    m_position_ = ::std::move(position_);
}

::zserio::vector<::nds::road::reference::types::IntersectionRoadReference>& Intersection::getConnectedRoads()
{
    return m_connectedRoads_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::IntersectionRoadReference>& Intersection::getConnectedRoads() const
{
    return m_connectedRoads_.getRawArray();
}

void Intersection::setConnectedRoads(const ::zserio::vector<::nds::road::reference::types::IntersectionRoadReference>& connectedRoads_)
{
    m_connectedRoads_ = ZserioArrayType_connectedRoads(connectedRoads_);
}

void Intersection::setConnectedRoads(::zserio::vector<::nds::road::reference::types::IntersectionRoadReference>&& connectedRoads_)
{
    m_connectedRoads_ = ZserioArrayType_connectedRoads(std::move(connectedRoads_));
}

void Intersection::initPackingContext(Intersection::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(m_id_);
    context.getZLevel().init<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(m_zLevel_);
    context.getNumRoads().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numRoads_);
    m_position_.initPackingContext(context.getPosition());
}

size_t Intersection::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_id_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(7);
    endBitPosition += UINT8_C(8);
    endBitPosition += m_position_.bitSizeOf(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_connectedRoads_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Intersection::bitSizeOf(Intersection::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(m_id_);
    endBitPosition += UINT8_C(1);
    endBitPosition += context.getZLevel().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(m_zLevel_);
    endBitPosition += context.getNumRoads().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numRoads_);
    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_connectedRoads_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Intersection::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_id_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(7);
    endBitPosition += UINT8_C(8);
    endBitPosition = m_position_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_connectedRoads_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t Intersection::initializeOffsets(Intersection::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(m_id_);
    endBitPosition += UINT8_C(1);
    endBitPosition += context.getZLevel().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(m_zLevel_);
    endBitPosition += context.getNumRoads().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numRoads_);
    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_connectedRoads_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Intersection::operator==(const Intersection& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_id_ == other.m_id_) &&
                (m_isArtificial_ == other.m_isArtificial_) &&
                (m_zLevel_ == other.m_zLevel_) &&
                (m_numRoads_ == other.m_numRoads_) &&
                (m_position_ == other.m_position_) &&
                (m_connectedRoads_ == other.m_connectedRoads_);
    }

    return true;
}

uint32_t Intersection::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_isArtificial_);
    result = ::zserio::calcHashCode(result, m_zLevel_);
    result = ::zserio::calcHashCode(result, m_numRoads_);
    result = ::zserio::calcHashCode(result, m_position_);
    result = ::zserio::calcHashCode(result, m_connectedRoads_);

    return result;
}

void Intersection::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_id_);

    out.writeBool(m_isArtificial_);

    out.writeBits(m_zLevel_, UINT8_C(7));

    // check constraint
    if (!((getNumRoads() < 181) && (getNumRoads() > 0 || getIsArtificial())))
        throw ::zserio::ConstraintException("Write: Constraint violated at Intersection.numRoads!");
    out.writeBits(m_numRoads_, UINT8_C(8));

    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getCoordShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field Intersection.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShift()) << "!";
    }
    m_position_.write(out);

    out.alignTo(8);
    // check array length
    if (m_connectedRoads_.getRawArray().size() != static_cast<size_t>(getNumRoads()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Intersection.connectedRoads: ") <<
                m_connectedRoads_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRoads()) << "!";
    }
    m_connectedRoads_.write(*this, out);
}

void Intersection::write(Intersection::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(out, m_id_);

    out.writeBool(m_isArtificial_);

    context.getZLevel().write<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(out, m_zLevel_);

    // check constraint
    if (!((getNumRoads() < 181) && (getNumRoads() > 0 || getIsArtificial())))
        throw ::zserio::ConstraintException("Write: Constraint violated at Intersection.numRoads!");
    context.getNumRoads().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numRoads_);

    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getCoordShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field Intersection.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShift()) << "!";
    }
    m_position_.write(context.getPosition(), out);

    out.alignTo(8);
    // check array length
    if (m_connectedRoads_.getRawArray().size() != static_cast<size_t>(getNumRoads()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Intersection.connectedRoads: ") <<
                m_connectedRoads_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRoads()) << "!";
    }
    m_connectedRoads_.writePacked(*this, out);
}

void Intersection::ZserioArrayExpressions_connectedRoads::initializeElement(Intersection& owner,
        ::nds::road::reference::types::IntersectionRoadReference& element, size_t)
{
    element.initialize(static_cast<bool>(owner.getIsArtificial()));
}

void Intersection::ZserioElementFactory_connectedRoads::create(Intersection&         owner,
        ::zserio::vector<::nds::road::reference::types::IntersectionRoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(owner.getIsArtificial()), array.get_allocator());
}

void Intersection::ZserioElementFactory_connectedRoads::create(Intersection&         owner,
        ::zserio::vector<::nds::road::reference::types::IntersectionRoadReference>& array,
        ::nds::road::reference::types::IntersectionRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(owner.getIsArtificial()), array.get_allocator());
}

::nds::road::reference::types::IntersectionId Intersection::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::road::reference::types::IntersectionId>(in.readVarUInt32());
}

::nds::road::reference::types::IntersectionId Intersection::readId(Intersection::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(in);
}
bool Intersection::readIsArtificial(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::road::reference::types::IntersectionZLevel Intersection::readZLevel(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::road::reference::types::IntersectionZLevel>(in.readBits(UINT8_C(7)));
}

::nds::road::reference::types::IntersectionZLevel Intersection::readZLevel(Intersection::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getZLevel().read<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(in);
}
uint8_t Intersection::readNumRoads(::zserio::BitStreamReader& in)
{
    uint8_t readField = static_cast<uint8_t>(in.readBits(UINT8_C(8)));
    // check constraint
    if (!((readField < 181) && (readField > 0 || getIsArtificial())))
        throw ::zserio::ConstraintException("Read: Constraint violated at Intersection.numRoads!");

    return readField;
}

uint8_t Intersection::readNumRoads(Intersection::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint8_t readField = context.getNumRoads().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
    // check constraint
    if (!((readField < 181) && (readField > 0 || getIsArtificial())))
        throw ::zserio::ConstraintException("Read: Constraint violated at Intersection.numRoads!");

    return readField;
}
::nds::core::geometry::Position2D Intersection::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(getCoordShift()), allocator);
}

::nds::core::geometry::Position2D Intersection::readPosition(Intersection::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getCoordShift()), allocator);
}
Intersection::ZserioArrayType_connectedRoads Intersection::readConnectedRoads(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_connectedRoads readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumRoads()));

    return readField;
}

Intersection::ZserioArrayType_connectedRoads Intersection::readConnectedRoads(Intersection::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_connectedRoads readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumRoads()));

    return readField;
}

} // namespace road
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/road/RoadList.h>

namespace nds
{
namespace road
{
namespace road
{

RoadList::RoadList(const allocator_type& allocator) noexcept :
        m_roads_(allocator)
{
}

RoadList::RoadList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_roads_(readRoads(in, allocator))
{
}

RoadList::RoadList(RoadList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_roads_(readRoads(context, in, allocator))
{
}

RoadList::RoadList(::zserio::PropagateAllocatorT,
        const RoadList& other, const allocator_type& allocator) :
        m_roads_(::zserio::allocatorPropagatingCopy(other.m_roads_, allocator))
{
}

::zserio::vector<::nds::road::road::Road>& RoadList::getRoads()
{
    return m_roads_.getRawArray();
}

const ::zserio::vector<::nds::road::road::Road>& RoadList::getRoads() const
{
    return m_roads_.getRawArray();
}

void RoadList::setRoads(const ::zserio::vector<::nds::road::road::Road>& roads_)
{
    m_roads_ = ZserioArrayType_roads(roads_);
}

void RoadList::setRoads(::zserio::vector<::nds::road::road::Road>&& roads_)
{
    m_roads_ = ZserioArrayType_roads(std::move(roads_));
}

void RoadList::initPackingContext(RoadList::ZserioPackingContext&) const
{
}

size_t RoadList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roads_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadList::bitSizeOf(RoadList::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roads_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roads_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoadList::initializeOffsets(RoadList::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roads_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoadList::operator==(const RoadList& other) const
{
    if (this != &other)
    {
        return
                (m_roads_ == other.m_roads_);
    }

    return true;
}

uint32_t RoadList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_roads_);

    return result;
}

void RoadList::write(::zserio::BitStreamWriter& out) const
{
    m_roads_.writePacked(*this, out);
}

void RoadList::write(RoadList::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_roads_.writePacked(*this, out);
}

void RoadList::ZserioElementFactory_roads::create(RoadList&        ,
        ::zserio::vector<::nds::road::road::Road>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoadList::ZserioElementFactory_roads::create(RoadList&        ,
        ::zserio::vector<::nds::road::road::Road>& array,
        ::nds::road::road::Road::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RoadList::ZserioArrayType_roads RoadList::readRoads(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_roads readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RoadList::ZserioArrayType_roads RoadList::readRoads(RoadList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_roads readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace road
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/road/IntersectionList.h>

namespace nds
{
namespace road
{
namespace road
{

IntersectionList::IntersectionList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_intersections_(allocator)
{
}

IntersectionList::IntersectionList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_intersections_(readIntersections(in, allocator))
{
}

IntersectionList::IntersectionList(IntersectionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_intersections_(readIntersections(context, in, allocator))
{
}

IntersectionList::IntersectionList(const IntersectionList& other) :
        m_intersections_(other.m_intersections_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

IntersectionList& IntersectionList::operator=(const IntersectionList& other)
{
    m_intersections_ = other.m_intersections_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

IntersectionList::IntersectionList(IntersectionList&& other) :
        m_intersections_(::std::move(other.m_intersections_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

IntersectionList& IntersectionList::operator=(IntersectionList&& other)
{
    m_intersections_ = ::std::move(other.m_intersections_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

IntersectionList::IntersectionList(::zserio::PropagateAllocatorT,
        const IntersectionList& other, const allocator_type& allocator) :
        m_intersections_(::zserio::allocatorPropagatingCopy(other.m_intersections_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void IntersectionList::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool IntersectionList::isInitialized() const
{
    return m_isInitialized;
}

void IntersectionList::initializeChildren()
{
    m_intersections_.initializeElements(*this);
}

::nds::core::geometry::CoordShift IntersectionList::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'IntersectionList' is not initialized!");

    return m_shift_;
}

::zserio::vector<::nds::road::road::Intersection>& IntersectionList::getIntersections()
{
    return m_intersections_.getRawArray();
}

const ::zserio::vector<::nds::road::road::Intersection>& IntersectionList::getIntersections() const
{
    return m_intersections_.getRawArray();
}

void IntersectionList::setIntersections(const ::zserio::vector<::nds::road::road::Intersection>& intersections_)
{
    m_intersections_ = ZserioArrayType_intersections(intersections_);
}

void IntersectionList::setIntersections(::zserio::vector<::nds::road::road::Intersection>&& intersections_)
{
    m_intersections_ = ZserioArrayType_intersections(std::move(intersections_));
}

void IntersectionList::initPackingContext(IntersectionList::ZserioPackingContext&) const
{
}

size_t IntersectionList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_intersections_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t IntersectionList::bitSizeOf(IntersectionList::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_intersections_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t IntersectionList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_intersections_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t IntersectionList::initializeOffsets(IntersectionList::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_intersections_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool IntersectionList::operator==(const IntersectionList& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_intersections_ == other.m_intersections_);
    }

    return true;
}

uint32_t IntersectionList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_intersections_);

    return result;
}

void IntersectionList::write(::zserio::BitStreamWriter& out) const
{
    m_intersections_.writePacked(*this, out);
}

void IntersectionList::write(IntersectionList::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_intersections_.writePacked(*this, out);
}

void IntersectionList::ZserioArrayExpressions_intersections::initializeElement(IntersectionList& owner,
        ::nds::road::road::Intersection& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void IntersectionList::ZserioElementFactory_intersections::create(IntersectionList&         owner,
        ::zserio::vector<::nds::road::road::Intersection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void IntersectionList::ZserioElementFactory_intersections::create(IntersectionList&         owner,
        ::zserio::vector<::nds::road::road::Intersection>& array,
        ::nds::road::road::Intersection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

IntersectionList::ZserioArrayType_intersections IntersectionList::readIntersections(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_intersections readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

IntersectionList::ZserioArrayType_intersections IntersectionList::readIntersections(IntersectionList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_intersections readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace road
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/road/MatchedRoadSegment.h>

namespace nds
{
namespace road
{
namespace road
{

MatchedRoadSegment::MatchedRoadSegment(const allocator_type& allocator) noexcept :
        m_matchedRoads_(allocator)
{
}

MatchedRoadSegment::MatchedRoadSegment(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_matchedRoads_(readMatchedRoads(in, allocator))
{
}

MatchedRoadSegment::MatchedRoadSegment(MatchedRoadSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_matchedRoads_(readMatchedRoads(context, in, allocator))
{
}

MatchedRoadSegment::MatchedRoadSegment(::zserio::PropagateAllocatorT,
        const MatchedRoadSegment& other, const allocator_type& allocator) :
        m_matchedRoads_(::zserio::allocatorPropagatingCopy(other.m_matchedRoads_, allocator))
{
}

::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& MatchedRoadSegment::getMatchedRoads()
{
    return m_matchedRoads_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& MatchedRoadSegment::getMatchedRoads() const
{
    return m_matchedRoads_.getRawArray();
}

void MatchedRoadSegment::setMatchedRoads(const ::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& matchedRoads_)
{
    m_matchedRoads_ = ZserioArrayType_matchedRoads(matchedRoads_);
}

void MatchedRoadSegment::setMatchedRoads(::zserio::vector<::nds::road::reference::types::DirectedRoadReference>&& matchedRoads_)
{
    m_matchedRoads_ = ZserioArrayType_matchedRoads(std::move(matchedRoads_));
}

void MatchedRoadSegment::initPackingContext(MatchedRoadSegment::ZserioPackingContext&) const
{
}

size_t MatchedRoadSegment::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_matchedRoads_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MatchedRoadSegment::bitSizeOf(MatchedRoadSegment::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_matchedRoads_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MatchedRoadSegment::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_matchedRoads_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t MatchedRoadSegment::initializeOffsets(MatchedRoadSegment::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_matchedRoads_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool MatchedRoadSegment::operator==(const MatchedRoadSegment& other) const
{
    if (this != &other)
    {
        return
                (m_matchedRoads_ == other.m_matchedRoads_);
    }

    return true;
}

uint32_t MatchedRoadSegment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_matchedRoads_);

    return result;
}

void MatchedRoadSegment::write(::zserio::BitStreamWriter& out) const
{
    m_matchedRoads_.writePacked(*this, out);
}

void MatchedRoadSegment::write(MatchedRoadSegment::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_matchedRoads_.writePacked(*this, out);
}

void MatchedRoadSegment::ZserioElementFactory_matchedRoads::create(MatchedRoadSegment&        ,
        ::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void MatchedRoadSegment::ZserioElementFactory_matchedRoads::create(MatchedRoadSegment&        ,
        ::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& array,
        ::nds::road::reference::types::DirectedRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

MatchedRoadSegment::ZserioArrayType_matchedRoads MatchedRoadSegment::readMatchedRoads(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_matchedRoads readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

MatchedRoadSegment::ZserioArrayType_matchedRoads MatchedRoadSegment::readMatchedRoads(MatchedRoadSegment::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_matchedRoads readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace road
} // namespace road
} // namespace nds
