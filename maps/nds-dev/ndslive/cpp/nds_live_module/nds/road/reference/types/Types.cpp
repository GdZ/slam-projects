/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/road/reference/types/TransitionReferenceType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TransitionReferenceType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::road::reference::types::TransitionReferenceType>::names;
constexpr ::std::array<::nds::road::reference::types::TransitionReferenceType, 4> EnumTraits<::nds::road::reference::types::TransitionReferenceType>::values;
constexpr const char* EnumTraits<::nds::road::reference::types::TransitionReferenceType>::enumName;

template <>
size_t enumToOrdinal(::nds::road::reference::types::TransitionReferenceType value)
{
    switch (value)
    {
    case ::nds::road::reference::types::TransitionReferenceType::INTERSECTION:
        return 0;
    case ::nds::road::reference::types::TransitionReferenceType::TRANSITION:
        return 1;
    case ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH:
        return 2;
    case ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TransitionReferenceType: ") <<
                static_cast<typename ::std::underlying_type<::nds::road::reference::types::TransitionReferenceType>::type>(value) << "!";
    }
}

template <>
::nds::road::reference::types::TransitionReferenceType valueToEnum(
        typename ::std::underlying_type<::nds::road::reference::types::TransitionReferenceType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::road::reference::types::TransitionReferenceType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TransitionReferenceType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::road::reference::types::TransitionReferenceType>(::nds::road::reference::types::TransitionReferenceType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::road::reference::types::TransitionReferenceType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::types::TransitionReferenceType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::road::reference::types::TransitionReferenceType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::road::reference::types::TransitionReferenceType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::types::TransitionReferenceType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::road::reference::types::TransitionReferenceType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::road::reference::types::TransitionReferenceType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::road::reference::types::TransitionReferenceType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::reference::types::TransitionReferenceType>(
            static_cast<typename ::std::underlying_type<::nds::road::reference::types::TransitionReferenceType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::road::reference::types::TransitionReferenceType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::reference::types::TransitionReferenceType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::types::TransitionReferenceType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::road::reference::types::TransitionReferenceType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::road::reference::types::TransitionReferenceType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::types::TransitionReferenceType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/road/reference/types/RoadValidityType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadValidityType enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::road::reference::types::RoadValidityType>::names;
constexpr ::std::array<::nds::road::reference::types::RoadValidityType, 7> EnumTraits<::nds::road::reference::types::RoadValidityType>::values;
constexpr const char* EnumTraits<::nds::road::reference::types::RoadValidityType>::enumName;

template <>
size_t enumToOrdinal(::nds::road::reference::types::RoadValidityType value)
{
    switch (value)
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return 0;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return 1;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return 2;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return 3;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return 4;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return 5;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadValidityType: ") <<
                static_cast<typename ::std::underlying_type<::nds::road::reference::types::RoadValidityType>::type>(value) << "!";
    }
}

template <>
::nds::road::reference::types::RoadValidityType valueToEnum(
        typename ::std::underlying_type<::nds::road::reference::types::RoadValidityType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::road::reference::types::RoadValidityType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadValidityType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::road::reference::types::RoadValidityType>(::nds::road::reference::types::RoadValidityType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::road::reference::types::RoadValidityType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::types::RoadValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::road::reference::types::RoadValidityType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::road::reference::types::RoadValidityType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::types::RoadValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::road::reference::types::RoadValidityType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::road::reference::types::RoadValidityType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::road::reference::types::RoadValidityType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::reference::types::RoadValidityType>(
            static_cast<typename ::std::underlying_type<::nds::road::reference::types::RoadValidityType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::road::reference::types::RoadValidityType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::reference::types::RoadValidityType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::types::RoadValidityType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::road::reference::types::RoadValidityType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::road::reference::types::RoadValidityType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::types::RoadValidityType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/RoadReference.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadReference::RoadReference(const allocator_type&) noexcept :
        m_isDirected_(bool()),
        m_directedRoadReference_(::zserio::NullOpt),
        m_roadId_(::zserio::NullOpt)
{
}

RoadReference::RoadReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_isDirected_(readIsDirected(in)),
        m_directedRoadReference_(readDirectedRoadReference(in, allocator)),
        m_roadId_(readRoadId(in, allocator))
{
}

RoadReference::RoadReference(RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_isDirected_(readIsDirected(in)),
        m_directedRoadReference_(readDirectedRoadReference(context, in, allocator)),
        m_roadId_(readRoadId(context, in, allocator))
{
}

RoadReference::RoadReference(::zserio::PropagateAllocatorT,
        const RoadReference& other, const allocator_type& allocator) :
        m_isDirected_(::zserio::allocatorPropagatingCopy(other.m_isDirected_, allocator)),
        m_directedRoadReference_(::zserio::allocatorPropagatingCopy(other.m_directedRoadReference_, allocator)),
        m_roadId_(::zserio::allocatorPropagatingCopy(other.m_roadId_, allocator))
{
}

bool RoadReference::getIsDirected() const
{
    return m_isDirected_;
}

void RoadReference::setIsDirected(bool isDirected_)
{
    m_isDirected_ = isDirected_;
}

::nds::road::reference::types::DirectedRoadReference& RoadReference::getDirectedRoadReference()
{
    return m_directedRoadReference_.value();
}

const ::nds::road::reference::types::DirectedRoadReference& RoadReference::getDirectedRoadReference() const
{
    return m_directedRoadReference_.value();
}

void RoadReference::setDirectedRoadReference(const ::nds::road::reference::types::DirectedRoadReference& directedRoadReference_)
{
    m_directedRoadReference_ = directedRoadReference_;
}

void RoadReference::setDirectedRoadReference(::nds::road::reference::types::DirectedRoadReference&& directedRoadReference_)
{
    m_directedRoadReference_ = ::std::move(directedRoadReference_);
}

bool RoadReference::isDirectedRoadReferenceUsed() const
{
    return (getIsDirected());
}

bool RoadReference::isDirectedRoadReferenceSet() const
{
    return m_directedRoadReference_.hasValue();
}

void RoadReference::resetDirectedRoadReference()
{
    m_directedRoadReference_.reset();
}

::nds::road::reference::types::RoadId& RoadReference::getRoadId()
{
    return m_roadId_.value();
}

const ::nds::road::reference::types::RoadId& RoadReference::getRoadId() const
{
    return m_roadId_.value();
}

void RoadReference::setRoadId(const ::nds::road::reference::types::RoadId& roadId_)
{
    m_roadId_ = roadId_;
}

void RoadReference::setRoadId(::nds::road::reference::types::RoadId&& roadId_)
{
    m_roadId_ = ::std::move(roadId_);
}

bool RoadReference::isRoadIdUsed() const
{
    return (!getIsDirected());
}

bool RoadReference::isRoadIdSet() const
{
    return m_roadId_.hasValue();
}

void RoadReference::resetRoadId()
{
    m_roadId_.reset();
}

void RoadReference::initPackingContext(RoadReference::ZserioPackingContext& context) const
{
    if (getIsDirected())
    {
        m_directedRoadReference_.value().initPackingContext(context.getDirectedRoadReference());
    }
    if (!getIsDirected())
    {
        m_roadId_.value().initPackingContext(context.getRoadId());
    }
}

size_t RoadReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirected())
    {
        endBitPosition += m_directedRoadReference_.value().bitSizeOf(endBitPosition);
    }
    if (!getIsDirected())
    {
        endBitPosition += m_roadId_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadReference::bitSizeOf(RoadReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirected())
    {
        endBitPosition += m_directedRoadReference_.value().bitSizeOf(context.getDirectedRoadReference(), endBitPosition);
    }
    if (!getIsDirected())
    {
        endBitPosition += m_roadId_.value().bitSizeOf(context.getRoadId(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirected())
    {
        endBitPosition = m_directedRoadReference_.value().initializeOffsets(endBitPosition);
    }
    if (!getIsDirected())
    {
        endBitPosition = m_roadId_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RoadReference::initializeOffsets(RoadReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirected())
    {
        endBitPosition = m_directedRoadReference_.value().initializeOffsets(context.getDirectedRoadReference(), endBitPosition);
    }
    if (!getIsDirected())
    {
        endBitPosition = m_roadId_.value().initializeOffsets(context.getRoadId(), endBitPosition);
    }

    return endBitPosition;
}

bool RoadReference::operator==(const RoadReference& other) const
{
    if (this != &other)
    {
        return
                (m_isDirected_ == other.m_isDirected_) &&
                (!isDirectedRoadReferenceUsed() ? !other.isDirectedRoadReferenceUsed() : (m_directedRoadReference_ == other.m_directedRoadReference_)) &&
                (!isRoadIdUsed() ? !other.isRoadIdUsed() : (m_roadId_ == other.m_roadId_));
    }

    return true;
}

uint32_t RoadReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_isDirected_);
    if (isDirectedRoadReferenceUsed())
        result = ::zserio::calcHashCode(result, m_directedRoadReference_);
    if (isRoadIdUsed())
        result = ::zserio::calcHashCode(result, m_roadId_);

    return result;
}

void RoadReference::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirected_);
    if (getIsDirected())
    {
        m_directedRoadReference_.value().write(out);
    }
    if (!getIsDirected())
    {
        m_roadId_.value().write(out);
    }
}

void RoadReference::write(RoadReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirected_);
    if (getIsDirected())
    {
        m_directedRoadReference_.value().write(context.getDirectedRoadReference(), out);
    }
    if (!getIsDirected())
    {
        m_roadId_.value().write(context.getRoadId(), out);
    }
}

bool RoadReference::readIsDirected(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::DirectedRoadReference> RoadReference::readDirectedRoadReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getIsDirected())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::DirectedRoadReference>(::nds::road::reference::types::DirectedRoadReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::DirectedRoadReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::DirectedRoadReference> RoadReference::readDirectedRoadReference(RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getIsDirected())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::DirectedRoadReference>(::nds::road::reference::types::DirectedRoadReference(context.getDirectedRoadReference(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::DirectedRoadReference>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadId> RoadReference::readRoadId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getIsDirected())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadId>(::nds::road::reference::types::RoadId(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadId> RoadReference::readRoadId(RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getIsDirected())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadId>(::nds::road::reference::types::RoadId(context.getRoadId(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadId>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/RoadReferenceIndirect.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadReferenceIndirect::RoadReferenceIndirect(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_isDirected_(bool()),
        m_referenceGeometry_(allocator),
        m_referenceSegments_(allocator),
        m_intersectionZLevel_(::zserio::NullOpt)
{
}

RoadReferenceIndirect::RoadReferenceIndirect(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_isDirected_(readIsDirected(in)),
        m_referenceGeometry_(readReferenceGeometry(in, allocator)),
        m_referenceSegments_(readReferenceSegments(in, allocator)),
        m_intersectionZLevel_(readIntersectionZLevel(in, allocator))
{
}

RoadReferenceIndirect::RoadReferenceIndirect(RoadReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_isDirected_(readIsDirected(in)),
        m_referenceGeometry_(readReferenceGeometry(context, in, allocator)),
        m_referenceSegments_(readReferenceSegments(context, in, allocator)),
        m_intersectionZLevel_(readIntersectionZLevel(context, in, allocator))
{
}

RoadReferenceIndirect::RoadReferenceIndirect(const RoadReferenceIndirect& other) :
        m_isDirected_(other.m_isDirected_),
        m_referenceGeometry_(other.m_referenceGeometry_),
        m_referenceSegments_(other.m_referenceSegments_),
        m_intersectionZLevel_(other.m_intersectionZLevel_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadReferenceIndirect& RoadReferenceIndirect::operator=(const RoadReferenceIndirect& other)
{
    m_isDirected_ = other.m_isDirected_;
    m_referenceGeometry_ = other.m_referenceGeometry_;
    m_referenceSegments_ = other.m_referenceSegments_;
    m_intersectionZLevel_ = other.m_intersectionZLevel_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadReferenceIndirect::RoadReferenceIndirect(RoadReferenceIndirect&& other) :
        m_isDirected_(::std::move(other.m_isDirected_)),
        m_referenceGeometry_(::std::move(other.m_referenceGeometry_)),
        m_referenceSegments_(::std::move(other.m_referenceSegments_)),
        m_intersectionZLevel_(::std::move(other.m_intersectionZLevel_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadReferenceIndirect& RoadReferenceIndirect::operator=(RoadReferenceIndirect&& other)
{
    m_isDirected_ = ::std::move(other.m_isDirected_);
    m_referenceGeometry_ = ::std::move(other.m_referenceGeometry_);
    m_referenceSegments_ = ::std::move(other.m_referenceSegments_);
    m_intersectionZLevel_ = ::std::move(other.m_intersectionZLevel_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadReferenceIndirect::RoadReferenceIndirect(::zserio::PropagateAllocatorT,
        const RoadReferenceIndirect& other, const allocator_type& allocator) :
        m_isDirected_(::zserio::allocatorPropagatingCopy(other.m_isDirected_, allocator)),
        m_referenceGeometry_(::zserio::allocatorPropagatingCopy(other.m_referenceGeometry_, allocator)),
        m_referenceSegments_(::zserio::allocatorPropagatingCopy(other.m_referenceSegments_, allocator)),
        m_intersectionZLevel_(::zserio::allocatorPropagatingCopy(other.m_intersectionZLevel_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadReferenceIndirect::initializeChildren()
{
    m_referenceGeometry_.initializeChildren();
    m_referenceSegments_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

bool RoadReferenceIndirect::getIsDirected() const
{
    return m_isDirected_;
}

void RoadReferenceIndirect::setIsDirected(bool isDirected_)
{
    m_isDirected_ = isDirected_;
}

::nds::core::location::LocationGeometry& RoadReferenceIndirect::getReferenceGeometry()
{
    return m_referenceGeometry_;
}

const ::nds::core::location::LocationGeometry& RoadReferenceIndirect::getReferenceGeometry() const
{
    return m_referenceGeometry_;
}

void RoadReferenceIndirect::setReferenceGeometry(const ::nds::core::location::LocationGeometry& referenceGeometry_)
{
    m_referenceGeometry_ = referenceGeometry_;
}

void RoadReferenceIndirect::setReferenceGeometry(::nds::core::location::LocationGeometry&& referenceGeometry_)
{
    m_referenceGeometry_ = ::std::move(referenceGeometry_);
}

::zserio::vector<::nds::core::location::LocationSegment>& RoadReferenceIndirect::getReferenceSegments()
{
    return m_referenceSegments_.getRawArray();
}

const ::zserio::vector<::nds::core::location::LocationSegment>& RoadReferenceIndirect::getReferenceSegments() const
{
    return m_referenceSegments_.getRawArray();
}

void RoadReferenceIndirect::setReferenceSegments(const ::zserio::vector<::nds::core::location::LocationSegment>& referenceSegments_)
{
    m_referenceSegments_ = ZserioArrayType_referenceSegments(referenceSegments_);
}

void RoadReferenceIndirect::setReferenceSegments(::zserio::vector<::nds::core::location::LocationSegment>&& referenceSegments_)
{
    m_referenceSegments_ = ZserioArrayType_referenceSegments(std::move(referenceSegments_));
}

::zserio::vector<::nds::road::reference::types::ReferenceGeometryIntersectionZLevel>& RoadReferenceIndirect::getIntersectionZLevel()
{
    return m_intersectionZLevel_.value().getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::ReferenceGeometryIntersectionZLevel>& RoadReferenceIndirect::getIntersectionZLevel() const
{
    return m_intersectionZLevel_.value().getRawArray();
}

void RoadReferenceIndirect::setIntersectionZLevel(const ::zserio::vector<::nds::road::reference::types::ReferenceGeometryIntersectionZLevel>& intersectionZLevel_)
{
    m_intersectionZLevel_ = ZserioArrayType_intersectionZLevel(intersectionZLevel_);
}

void RoadReferenceIndirect::setIntersectionZLevel(::zserio::vector<::nds::road::reference::types::ReferenceGeometryIntersectionZLevel>&& intersectionZLevel_)
{
    m_intersectionZLevel_ = ZserioArrayType_intersectionZLevel(std::move(intersectionZLevel_));
}

bool RoadReferenceIndirect::isIntersectionZLevelUsed() const
{
    return (isIntersectionZLevelSet());
}

bool RoadReferenceIndirect::isIntersectionZLevelSet() const
{
    return m_intersectionZLevel_.hasValue();
}

void RoadReferenceIndirect::resetIntersectionZLevel()
{
    m_intersectionZLevel_.reset();
}

void RoadReferenceIndirect::initPackingContext(RoadReferenceIndirect::ZserioPackingContext& context) const
{
    m_referenceGeometry_.initPackingContext(context.getReferenceGeometry());
}

size_t RoadReferenceIndirect::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += m_referenceGeometry_.bitSizeOf(endBitPosition);
    endBitPosition += m_referenceSegments_.bitSizeOf(*this, endBitPosition);
    endBitPosition += 1;
    if (isIntersectionZLevelSet())
    {
        endBitPosition += m_intersectionZLevel_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadReferenceIndirect::bitSizeOf(RoadReferenceIndirect::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += m_referenceGeometry_.bitSizeOf(context.getReferenceGeometry(), endBitPosition);
    endBitPosition += m_referenceSegments_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isIntersectionZLevelSet())
    {
        endBitPosition += m_intersectionZLevel_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadReferenceIndirect::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition = m_referenceGeometry_.initializeOffsets(endBitPosition);
    endBitPosition = m_referenceSegments_.initializeOffsets(*this, endBitPosition);
    endBitPosition += 1;
    if (isIntersectionZLevelSet())
    {
        endBitPosition = m_intersectionZLevel_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t RoadReferenceIndirect::initializeOffsets(RoadReferenceIndirect::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition = m_referenceGeometry_.initializeOffsets(context.getReferenceGeometry(), endBitPosition);
    endBitPosition = m_referenceSegments_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isIntersectionZLevelSet())
    {
        endBitPosition = m_intersectionZLevel_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool RoadReferenceIndirect::operator==(const RoadReferenceIndirect& other) const
{
    if (this != &other)
    {
        return
                (m_isDirected_ == other.m_isDirected_) &&
                (m_referenceGeometry_ == other.m_referenceGeometry_) &&
                (m_referenceSegments_ == other.m_referenceSegments_) &&
                (!isIntersectionZLevelUsed() ? !other.isIntersectionZLevelUsed() : (m_intersectionZLevel_ == other.m_intersectionZLevel_));
    }

    return true;
}

uint32_t RoadReferenceIndirect::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_isDirected_);
    result = ::zserio::calcHashCode(result, m_referenceGeometry_);
    result = ::zserio::calcHashCode(result, m_referenceSegments_);
    if (isIntersectionZLevelUsed())
        result = ::zserio::calcHashCode(result, m_intersectionZLevel_);

    return result;
}

void RoadReferenceIndirect::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirected_);

    m_referenceGeometry_.write(out);

    m_referenceSegments_.write(*this, out);

    if (isIntersectionZLevelSet())
    {
        out.writeBool(true);
        // check array length
        if (m_intersectionZLevel_.value().getRawArray().size() != static_cast<size_t>(getReferenceGeometry().getLine().getNumPositions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadReferenceIndirect.intersectionZLevel: ") <<
                    m_intersectionZLevel_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getReferenceGeometry().getLine().getNumPositions()) << "!";
        }
        m_intersectionZLevel_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoadReferenceIndirect::write(RoadReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirected_);

    m_referenceGeometry_.write(context.getReferenceGeometry(), out);

    m_referenceSegments_.writePacked(*this, out);

    if (isIntersectionZLevelSet())
    {
        out.writeBool(true);
        // check array length
        if (m_intersectionZLevel_.value().getRawArray().size() != static_cast<size_t>(getReferenceGeometry().getLine().getNumPositions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadReferenceIndirect.intersectionZLevel: ") <<
                    m_intersectionZLevel_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getReferenceGeometry().getLine().getNumPositions()) << "!";
        }
        m_intersectionZLevel_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoadReferenceIndirect::ZserioArrayExpressions_referenceSegments::initializeElement(RoadReferenceIndirect& owner,
        ::nds::core::location::LocationSegment& element, size_t)
{
    element.initialize(owner.getReferenceGeometry());
}

void RoadReferenceIndirect::ZserioElementFactory_referenceSegments::create(RoadReferenceIndirect&         owner,
        ::zserio::vector<::nds::core::location::LocationSegment>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getReferenceGeometry(), array.get_allocator());
}

void RoadReferenceIndirect::ZserioElementFactory_referenceSegments::create(RoadReferenceIndirect&         owner,
        ::zserio::vector<::nds::core::location::LocationSegment>& array,
        ::nds::core::location::LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getReferenceGeometry(), array.get_allocator());
}

void RoadReferenceIndirect::ZserioElementFactory_intersectionZLevel::create(RoadReferenceIndirect&        ,
        ::zserio::vector<::nds::road::reference::types::ReferenceGeometryIntersectionZLevel>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoadReferenceIndirect::ZserioElementFactory_intersectionZLevel::create(RoadReferenceIndirect&        ,
        ::zserio::vector<::nds::road::reference::types::ReferenceGeometryIntersectionZLevel>& array,
        ::nds::road::reference::types::ReferenceGeometryIntersectionZLevel::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

bool RoadReferenceIndirect::readIsDirected(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::core::location::LocationGeometry RoadReferenceIndirect::readReferenceGeometry(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::LocationGeometry(in, allocator);
}

::nds::core::location::LocationGeometry RoadReferenceIndirect::readReferenceGeometry(RoadReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::LocationGeometry(context.getReferenceGeometry(), in, allocator);
}
RoadReferenceIndirect::ZserioArrayType_referenceSegments RoadReferenceIndirect::readReferenceSegments(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_referenceSegments readField(allocator);
    readField.read(*this, in);

    return readField;
}

RoadReferenceIndirect::ZserioArrayType_referenceSegments RoadReferenceIndirect::readReferenceSegments(RoadReferenceIndirect::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_referenceSegments readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::zserio::InplaceOptionalHolder<RoadReferenceIndirect::ZserioArrayType_intersectionZLevel> RoadReferenceIndirect::readIntersectionZLevel(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_intersectionZLevel readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getReferenceGeometry().getLine().getNumPositions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_intersectionZLevel>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_intersectionZLevel>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoadReferenceIndirect::ZserioArrayType_intersectionZLevel> RoadReferenceIndirect::readIntersectionZLevel(RoadReferenceIndirect::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_intersectionZLevel readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getReferenceGeometry().getLine().getNumPositions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_intersectionZLevel>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_intersectionZLevel>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/ReferenceGeometryIntersectionZLevel.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

ReferenceGeometryIntersectionZLevel::ReferenceGeometryIntersectionZLevel(const allocator_type&) noexcept :
        m_hasValue_(bool()),
        m_value_(::zserio::NullOpt)
{
}

ReferenceGeometryIntersectionZLevel::ReferenceGeometryIntersectionZLevel(::zserio::BitStreamReader& in, const allocator_type&) :
        m_hasValue_(readHasValue(in)),
        m_value_(readValue(in))
{
}

ReferenceGeometryIntersectionZLevel::ReferenceGeometryIntersectionZLevel(ReferenceGeometryIntersectionZLevel::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_hasValue_(readHasValue(in)),
        m_value_(readValue(context, in))
{
}

ReferenceGeometryIntersectionZLevel::ReferenceGeometryIntersectionZLevel(::zserio::PropagateAllocatorT,
        const ReferenceGeometryIntersectionZLevel& other, const allocator_type& allocator) :
        m_hasValue_(::zserio::allocatorPropagatingCopy(other.m_hasValue_, allocator)),
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator))
{
}

bool ReferenceGeometryIntersectionZLevel::getHasValue() const
{
    return m_hasValue_;
}

void ReferenceGeometryIntersectionZLevel::setHasValue(bool hasValue_)
{
    m_hasValue_ = hasValue_;
}

::nds::road::reference::types::IntersectionZLevel ReferenceGeometryIntersectionZLevel::getValue() const
{
    return m_value_.value();
}

void ReferenceGeometryIntersectionZLevel::setValue(::nds::road::reference::types::IntersectionZLevel value_)
{
    m_value_ = value_;
}

bool ReferenceGeometryIntersectionZLevel::isValueUsed() const
{
    return (getHasValue());
}

bool ReferenceGeometryIntersectionZLevel::isValueSet() const
{
    return m_value_.hasValue();
}

void ReferenceGeometryIntersectionZLevel::resetValue()
{
    m_value_.reset();
}

void ReferenceGeometryIntersectionZLevel::initPackingContext(ReferenceGeometryIntersectionZLevel::ZserioPackingContext& context) const
{
    if (getHasValue())
    {
        context.getValue().init<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(m_value_.value());
    }
}

size_t ReferenceGeometryIntersectionZLevel::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasValue())
    {
        endBitPosition += UINT8_C(7);
    }

    return endBitPosition - bitPosition;
}

size_t ReferenceGeometryIntersectionZLevel::bitSizeOf(ReferenceGeometryIntersectionZLevel::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasValue())
    {
        endBitPosition += context.getValue().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(m_value_.value());
    }

    return endBitPosition - bitPosition;
}

size_t ReferenceGeometryIntersectionZLevel::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasValue())
    {
        endBitPosition += UINT8_C(7);
    }

    return endBitPosition;
}

size_t ReferenceGeometryIntersectionZLevel::initializeOffsets(ReferenceGeometryIntersectionZLevel::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasValue())
    {
        endBitPosition += context.getValue().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(m_value_.value());
    }

    return endBitPosition;
}

bool ReferenceGeometryIntersectionZLevel::operator==(const ReferenceGeometryIntersectionZLevel& other) const
{
    if (this != &other)
    {
        return
                (m_hasValue_ == other.m_hasValue_) &&
                (!isValueUsed() ? !other.isValueUsed() : (m_value_ == other.m_value_));
    }

    return true;
}

uint32_t ReferenceGeometryIntersectionZLevel::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_hasValue_);
    if (isValueUsed())
        result = ::zserio::calcHashCode(result, m_value_);

    return result;
}

void ReferenceGeometryIntersectionZLevel::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasValue_);
    if (getHasValue())
    {
        out.writeBits(m_value_.value(), UINT8_C(7));
    }
}

void ReferenceGeometryIntersectionZLevel::write(ReferenceGeometryIntersectionZLevel::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasValue_);
    if (getHasValue())
    {
        context.getValue().write<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(out, m_value_.value());
    }
}

bool ReferenceGeometryIntersectionZLevel::readHasValue(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionZLevel> ReferenceGeometryIntersectionZLevel::readValue(::zserio::BitStreamReader& in)
{
    if (getHasValue())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionZLevel>(static_cast<::nds::road::reference::types::IntersectionZLevel>(in.readBits(UINT8_C(7))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionZLevel>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionZLevel> ReferenceGeometryIntersectionZLevel::readValue(ReferenceGeometryIntersectionZLevel::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getHasValue())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionZLevel>(context.getValue().read<::zserio::BitFieldArrayTraits<::nds::road::reference::types::IntersectionZLevel, UINT8_C(7)>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionZLevel>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/IntersectionRoadReference.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

IntersectionRoadReference::IntersectionRoadReference(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_road_(allocator),
        m_angle_(::zserio::NullOpt)
{
}

IntersectionRoadReference::IntersectionRoadReference(::zserio::BitStreamReader& in,
        bool isArtificial_, const allocator_type& allocator) :
        m_isArtificial_(isArtificial_),
        m_isInitialized(true),
        m_road_(readRoad(in, allocator)),
        m_angle_(readAngle(in))
{
}

IntersectionRoadReference::IntersectionRoadReference(IntersectionRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool isArtificial_, const allocator_type& allocator) :
        m_isArtificial_(isArtificial_),
        m_isInitialized(true),
        m_road_(readRoad(context, in, allocator)),
        m_angle_(readAngle(context, in))
{
}

IntersectionRoadReference::IntersectionRoadReference(const IntersectionRoadReference& other) :
        m_road_(other.m_road_),
        m_angle_(other.m_angle_)
{
    if (other.m_isInitialized)
        initialize(other.m_isArtificial_);
    else
        m_isInitialized = false;
}

IntersectionRoadReference& IntersectionRoadReference::operator=(const IntersectionRoadReference& other)
{
    m_road_ = other.m_road_;
    m_angle_ = other.m_angle_;
    if (other.m_isInitialized)
        initialize(other.m_isArtificial_);
    else
        m_isInitialized = false;

    return *this;
}

IntersectionRoadReference::IntersectionRoadReference(IntersectionRoadReference&& other) :
        m_road_(::std::move(other.m_road_)),
        m_angle_(::std::move(other.m_angle_))
{
    if (other.m_isInitialized)
        initialize(other.m_isArtificial_);
    else
        m_isInitialized = false;
}

IntersectionRoadReference& IntersectionRoadReference::operator=(IntersectionRoadReference&& other)
{
    m_road_ = ::std::move(other.m_road_);
    m_angle_ = ::std::move(other.m_angle_);
    if (other.m_isInitialized)
        initialize(other.m_isArtificial_);
    else
        m_isInitialized = false;

    return *this;
}

IntersectionRoadReference::IntersectionRoadReference(::zserio::PropagateAllocatorT,
        const IntersectionRoadReference& other, const allocator_type& allocator) :
        m_road_(::zserio::allocatorPropagatingCopy(other.m_road_, allocator)),
        m_angle_(::zserio::allocatorPropagatingCopy(other.m_angle_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_isArtificial_);
    else
        m_isInitialized = false;
}

void IntersectionRoadReference::initialize(
        bool isArtificial_)
{
    m_isArtificial_ = isArtificial_;
    m_isInitialized = true;
}

bool IntersectionRoadReference::isInitialized() const
{
    return m_isInitialized;
}

bool IntersectionRoadReference::getIsArtificial() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'isArtificial' of compound 'IntersectionRoadReference' is not initialized!");

    return m_isArtificial_;
}

::nds::road::reference::types::DirectedRoadReference& IntersectionRoadReference::getRoad()
{
    return m_road_;
}

const ::nds::road::reference::types::DirectedRoadReference& IntersectionRoadReference::getRoad() const
{
    return m_road_;
}

void IntersectionRoadReference::setRoad(const ::nds::road::reference::types::DirectedRoadReference& road_)
{
    m_road_ = road_;
}

void IntersectionRoadReference::setRoad(::nds::road::reference::types::DirectedRoadReference&& road_)
{
    m_road_ = ::std::move(road_);
}

::nds::core::types::IntersectionSector IntersectionRoadReference::getAngle() const
{
    return m_angle_.value();
}

void IntersectionRoadReference::setAngle(::nds::core::types::IntersectionSector angle_)
{
    m_angle_ = angle_;
}

bool IntersectionRoadReference::isAngleUsed() const
{
    return (!getIsArtificial());
}

bool IntersectionRoadReference::isAngleSet() const
{
    return m_angle_.hasValue();
}

void IntersectionRoadReference::resetAngle()
{
    m_angle_.reset();
}

void IntersectionRoadReference::initPackingContext(IntersectionRoadReference::ZserioPackingContext& context) const
{
    m_road_.initPackingContext(context.getRoad());
    if (!getIsArtificial())
    {
        context.getAngle().init<::zserio::StdIntArrayTraits<::nds::core::types::IntersectionSector>>(m_angle_.value());
    }
}

size_t IntersectionRoadReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_road_.bitSizeOf(endBitPosition);
    if (!getIsArtificial())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition - bitPosition;
}

size_t IntersectionRoadReference::bitSizeOf(IntersectionRoadReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_road_.bitSizeOf(context.getRoad(), endBitPosition);
    if (!getIsArtificial())
    {
        endBitPosition += context.getAngle().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::IntersectionSector>>(m_angle_.value());
    }

    return endBitPosition - bitPosition;
}

size_t IntersectionRoadReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_road_.initializeOffsets(endBitPosition);
    if (!getIsArtificial())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition;
}

size_t IntersectionRoadReference::initializeOffsets(IntersectionRoadReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_road_.initializeOffsets(context.getRoad(), endBitPosition);
    if (!getIsArtificial())
    {
        endBitPosition += context.getAngle().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::IntersectionSector>>(m_angle_.value());
    }

    return endBitPosition;
}

bool IntersectionRoadReference::operator==(const IntersectionRoadReference& other) const
{
    if (this != &other)
    {
        return
                (getIsArtificial() == other.getIsArtificial()) &&
                (m_road_ == other.m_road_) &&
                (!isAngleUsed() ? !other.isAngleUsed() : (m_angle_ == other.m_angle_));
    }

    return true;
}

uint32_t IntersectionRoadReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getIsArtificial());
    result = ::zserio::calcHashCode(result, m_road_);
    if (isAngleUsed())
        result = ::zserio::calcHashCode(result, m_angle_);

    return result;
}

void IntersectionRoadReference::write(::zserio::BitStreamWriter& out) const
{
    m_road_.write(out);
    if (!getIsArtificial())
    {
        out.writeBits(m_angle_.value(), UINT8_C(8));
    }
}

void IntersectionRoadReference::write(IntersectionRoadReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_road_.write(context.getRoad(), out);
    if (!getIsArtificial())
    {
        context.getAngle().write<::zserio::StdIntArrayTraits<::nds::core::types::IntersectionSector>>(out, m_angle_.value());
    }
}

::nds::road::reference::types::DirectedRoadReference IntersectionRoadReference::readRoad(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::DirectedRoadReference(in, allocator);
}

::nds::road::reference::types::DirectedRoadReference IntersectionRoadReference::readRoad(IntersectionRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::DirectedRoadReference(context.getRoad(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::types::IntersectionSector> IntersectionRoadReference::readAngle(::zserio::BitStreamReader& in)
{
    if (!getIsArtificial())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::IntersectionSector>(static_cast<::nds::core::types::IntersectionSector>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::IntersectionSector>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::IntersectionSector> IntersectionRoadReference::readAngle(IntersectionRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (!getIsArtificial())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::IntersectionSector>(context.getAngle().read<::zserio::StdIntArrayTraits<::nds::core::types::IntersectionSector>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::IntersectionSector>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/road/reference/types/TransitionReference.h>
#include <nds/road/reference/types/TransitionReferenceType.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

TransitionReference::TransitionReference(const allocator_type&) noexcept :
        m_areChildrenInitialized(false),
        m_type_(::nds::road::reference::types::TransitionReferenceType()),
        m_intersectionTransition_(::zserio::NullOpt),
        m_transitionPathReference_(::zserio::NullOpt),
        m_transitionGeoPathReference_(::zserio::NullOpt)
{
}

TransitionReference::TransitionReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(in)),
        m_intersectionTransition_(readIntersectionTransition(in, allocator)),
        m_transitionPathReference_(readTransitionPathReference(in, allocator)),
        m_transitionGeoPathReference_(readTransitionGeoPathReference(in, allocator))
{
}

TransitionReference::TransitionReference(TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(context, in)),
        m_intersectionTransition_(readIntersectionTransition(context, in, allocator)),
        m_transitionPathReference_(readTransitionPathReference(context, in, allocator)),
        m_transitionGeoPathReference_(readTransitionGeoPathReference(context, in, allocator))
{
}

TransitionReference::TransitionReference(const TransitionReference& other) :
        m_type_(other.m_type_),
        m_intersectionTransition_(other.m_intersectionTransition_),
        m_transitionPathReference_(other.m_transitionPathReference_),
        m_transitionGeoPathReference_(other.m_transitionGeoPathReference_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TransitionReference& TransitionReference::operator=(const TransitionReference& other)
{
    m_type_ = other.m_type_;
    m_intersectionTransition_ = other.m_intersectionTransition_;
    m_transitionPathReference_ = other.m_transitionPathReference_;
    m_transitionGeoPathReference_ = other.m_transitionGeoPathReference_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TransitionReference::TransitionReference(TransitionReference&& other) :
        m_type_(::std::move(other.m_type_)),
        m_intersectionTransition_(::std::move(other.m_intersectionTransition_)),
        m_transitionPathReference_(::std::move(other.m_transitionPathReference_)),
        m_transitionGeoPathReference_(::std::move(other.m_transitionGeoPathReference_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TransitionReference& TransitionReference::operator=(TransitionReference&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_intersectionTransition_ = ::std::move(other.m_intersectionTransition_);
    m_transitionPathReference_ = ::std::move(other.m_transitionPathReference_);
    m_transitionGeoPathReference_ = ::std::move(other.m_transitionGeoPathReference_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TransitionReference::TransitionReference(::zserio::PropagateAllocatorT,
        const TransitionReference& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_intersectionTransition_(::zserio::allocatorPropagatingCopy(other.m_intersectionTransition_, allocator)),
        m_transitionPathReference_(::zserio::allocatorPropagatingCopy(other.m_transitionPathReference_, allocator)),
        m_transitionGeoPathReference_(::zserio::allocatorPropagatingCopy(other.m_transitionGeoPathReference_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void TransitionReference::initializeChildren()
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
        m_intersectionTransition_.value().initialize(static_cast<::nds::road::reference::types::TransitionReferenceType>(getType()));
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
        m_transitionGeoPathReference_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::road::reference::types::TransitionReferenceType TransitionReference::getType() const
{
    return m_type_;
}

void TransitionReference::setType(::nds::road::reference::types::TransitionReferenceType type_)
{
    m_type_ = type_;
}

::nds::road::reference::types::IntersectionTransition& TransitionReference::getIntersectionTransition()
{
    return m_intersectionTransition_.value();
}

const ::nds::road::reference::types::IntersectionTransition& TransitionReference::getIntersectionTransition() const
{
    return m_intersectionTransition_.value();
}

void TransitionReference::setIntersectionTransition(const ::nds::road::reference::types::IntersectionTransition& intersectionTransition_)
{
    m_intersectionTransition_ = intersectionTransition_;
}

void TransitionReference::setIntersectionTransition(::nds::road::reference::types::IntersectionTransition&& intersectionTransition_)
{
    m_intersectionTransition_ = ::std::move(intersectionTransition_);
}

bool TransitionReference::isIntersectionTransitionUsed() const
{
    return (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION);
}

bool TransitionReference::isIntersectionTransitionSet() const
{
    return m_intersectionTransition_.hasValue();
}

void TransitionReference::resetIntersectionTransition()
{
    m_intersectionTransition_.reset();
}

::nds::road::reference::types::TransitionPathReference& TransitionReference::getTransitionPathReference()
{
    return m_transitionPathReference_.value();
}

const ::nds::road::reference::types::TransitionPathReference& TransitionReference::getTransitionPathReference() const
{
    return m_transitionPathReference_.value();
}

void TransitionReference::setTransitionPathReference(const ::nds::road::reference::types::TransitionPathReference& transitionPathReference_)
{
    m_transitionPathReference_ = transitionPathReference_;
}

void TransitionReference::setTransitionPathReference(::nds::road::reference::types::TransitionPathReference&& transitionPathReference_)
{
    m_transitionPathReference_ = ::std::move(transitionPathReference_);
}

bool TransitionReference::isTransitionPathReferenceUsed() const
{
    return (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH);
}

bool TransitionReference::isTransitionPathReferenceSet() const
{
    return m_transitionPathReference_.hasValue();
}

void TransitionReference::resetTransitionPathReference()
{
    m_transitionPathReference_.reset();
}

::nds::road::reference::types::TransitionGeoPathReference& TransitionReference::getTransitionGeoPathReference()
{
    return m_transitionGeoPathReference_.value();
}

const ::nds::road::reference::types::TransitionGeoPathReference& TransitionReference::getTransitionGeoPathReference() const
{
    return m_transitionGeoPathReference_.value();
}

void TransitionReference::setTransitionGeoPathReference(const ::nds::road::reference::types::TransitionGeoPathReference& transitionGeoPathReference_)
{
    m_transitionGeoPathReference_ = transitionGeoPathReference_;
}

void TransitionReference::setTransitionGeoPathReference(::nds::road::reference::types::TransitionGeoPathReference&& transitionGeoPathReference_)
{
    m_transitionGeoPathReference_ = ::std::move(transitionGeoPathReference_);
}

bool TransitionReference::isTransitionGeoPathReferenceUsed() const
{
    return (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH);
}

bool TransitionReference::isTransitionGeoPathReferenceSet() const
{
    return m_transitionGeoPathReference_.hasValue();
}

void TransitionReference::resetTransitionGeoPathReference()
{
    m_transitionGeoPathReference_.reset();
}

void TransitionReference::initPackingContext(TransitionReference::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        m_intersectionTransition_.value().initPackingContext(context.getIntersectionTransition());
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH)
    {
        m_transitionPathReference_.value().initPackingContext(context.getTransitionPathReference());
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
    {
        m_transitionGeoPathReference_.value().initPackingContext(context.getTransitionGeoPathReference());
    }
}

size_t TransitionReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition += m_intersectionTransition_.value().bitSizeOf(endBitPosition);
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH)
    {
        endBitPosition += m_transitionPathReference_.value().bitSizeOf(endBitPosition);
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
    {
        endBitPosition += m_transitionGeoPathReference_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TransitionReference::bitSizeOf(TransitionReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition += m_intersectionTransition_.value().bitSizeOf(context.getIntersectionTransition(), endBitPosition);
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH)
    {
        endBitPosition += m_transitionPathReference_.value().bitSizeOf(context.getTransitionPathReference(), endBitPosition);
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
    {
        endBitPosition += m_transitionGeoPathReference_.value().bitSizeOf(context.getTransitionGeoPathReference(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TransitionReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition = m_intersectionTransition_.value().initializeOffsets(endBitPosition);
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH)
    {
        endBitPosition = m_transitionPathReference_.value().initializeOffsets(endBitPosition);
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
    {
        endBitPosition = m_transitionGeoPathReference_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t TransitionReference::initializeOffsets(TransitionReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition = m_intersectionTransition_.value().initializeOffsets(context.getIntersectionTransition(), endBitPosition);
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH)
    {
        endBitPosition = m_transitionPathReference_.value().initializeOffsets(context.getTransitionPathReference(), endBitPosition);
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
    {
        endBitPosition = m_transitionGeoPathReference_.value().initializeOffsets(context.getTransitionGeoPathReference(), endBitPosition);
    }

    return endBitPosition;
}

bool TransitionReference::operator==(const TransitionReference& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isIntersectionTransitionUsed() ? !other.isIntersectionTransitionUsed() : (m_intersectionTransition_ == other.m_intersectionTransition_)) &&
                (!isTransitionPathReferenceUsed() ? !other.isTransitionPathReferenceUsed() : (m_transitionPathReference_ == other.m_transitionPathReference_)) &&
                (!isTransitionGeoPathReferenceUsed() ? !other.isTransitionGeoPathReferenceUsed() : (m_transitionGeoPathReference_ == other.m_transitionGeoPathReference_));
    }

    return true;
}

uint32_t TransitionReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isIntersectionTransitionUsed())
        result = ::zserio::calcHashCode(result, m_intersectionTransition_);
    if (isTransitionPathReferenceUsed())
        result = ::zserio::calcHashCode(result, m_transitionPathReference_);
    if (isTransitionGeoPathReferenceUsed())
        result = ::zserio::calcHashCode(result, m_transitionGeoPathReference_);

    return result;
}

void TransitionReference::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        // check parameters
        if (m_intersectionTransition_.value().getType() != static_cast<::nds::road::reference::types::TransitionReferenceType>(getType()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TransitionReference.intersectionTransition: ") <<
                    m_intersectionTransition_.value().getType() << " != " << static_cast<::nds::road::reference::types::TransitionReferenceType>(getType()) << "!";
        }
        m_intersectionTransition_.value().write(out);
    }

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH)
    {
        m_transitionPathReference_.value().write(out);
    }

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
    {
        m_transitionGeoPathReference_.value().write(out);
    }
}

void TransitionReference::write(TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        // check parameters
        if (m_intersectionTransition_.value().getType() != static_cast<::nds::road::reference::types::TransitionReferenceType>(getType()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field TransitionReference.intersectionTransition: ") <<
                    m_intersectionTransition_.value().getType() << " != " << static_cast<::nds::road::reference::types::TransitionReferenceType>(getType()) << "!";
        }
        m_intersectionTransition_.value().write(context.getIntersectionTransition(), out);
    }

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH)
    {
        m_transitionPathReference_.value().write(context.getTransitionPathReference(), out);
    }

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
    {
        m_transitionGeoPathReference_.value().write(context.getTransitionGeoPathReference(), out);
    }
}

::nds::road::reference::types::TransitionReferenceType TransitionReference::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::reference::types::TransitionReferenceType>(in);
}

::nds::road::reference::types::TransitionReferenceType TransitionReference::readType(TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::reference::types::TransitionReferenceType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionTransition> TransitionReference::readIntersectionTransition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionTransition>(::nds::road::reference::types::IntersectionTransition(in, static_cast<::nds::road::reference::types::TransitionReferenceType>(getType()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionTransition>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionTransition> TransitionReference::readIntersectionTransition(TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::INTERSECTION || getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionTransition>(::nds::road::reference::types::IntersectionTransition(context.getIntersectionTransition(), in, static_cast<::nds::road::reference::types::TransitionReferenceType>(getType()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::IntersectionTransition>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionPathReference> TransitionReference::readTransitionPathReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH)
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionPathReference>(::nds::road::reference::types::TransitionPathReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionPathReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionPathReference> TransitionReference::readTransitionPathReference(TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_PATH)
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionPathReference>(::nds::road::reference::types::TransitionPathReference(context.getTransitionPathReference(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionPathReference>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionGeoPathReference> TransitionReference::readTransitionGeoPathReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionGeoPathReference>(::nds::road::reference::types::TransitionGeoPathReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionGeoPathReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionGeoPathReference> TransitionReference::readTransitionGeoPathReference(TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION_GEO_PATH)
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionGeoPathReference>(::nds::road::reference::types::TransitionGeoPathReference(context.getTransitionGeoPathReference(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::TransitionGeoPathReference>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/road/reference/types/IntersectionTransition.h>
#include <nds/road/reference/types/TransitionReferenceType.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

IntersectionTransition::IntersectionTransition(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_intersectionId_(::nds::road::reference::types::IntersectionId()),
        m_numTransitions_(::zserio::NullOpt),
        m_transitionNumber_(::zserio::NullOpt)
{
}

IntersectionTransition::IntersectionTransition(::zserio::BitStreamReader& in,
        ::nds::road::reference::types::TransitionReferenceType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_intersectionId_(readIntersectionId(in)),
        m_numTransitions_(readNumTransitions(in)),
        m_transitionNumber_(readTransitionNumber(in, allocator))
{
}

IntersectionTransition::IntersectionTransition(IntersectionTransition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::road::reference::types::TransitionReferenceType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_intersectionId_(readIntersectionId(context, in)),
        m_numTransitions_(readNumTransitions(context, in)),
        m_transitionNumber_(readTransitionNumber(context, in, allocator))
{
}

IntersectionTransition::IntersectionTransition(const IntersectionTransition& other) :
        m_intersectionId_(other.m_intersectionId_),
        m_numTransitions_(other.m_numTransitions_),
        m_transitionNumber_(other.m_transitionNumber_)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

IntersectionTransition& IntersectionTransition::operator=(const IntersectionTransition& other)
{
    m_intersectionId_ = other.m_intersectionId_;
    m_numTransitions_ = other.m_numTransitions_;
    m_transitionNumber_ = other.m_transitionNumber_;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

IntersectionTransition::IntersectionTransition(IntersectionTransition&& other) :
        m_intersectionId_(::std::move(other.m_intersectionId_)),
        m_numTransitions_(::std::move(other.m_numTransitions_)),
        m_transitionNumber_(::std::move(other.m_transitionNumber_))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

IntersectionTransition& IntersectionTransition::operator=(IntersectionTransition&& other)
{
    m_intersectionId_ = ::std::move(other.m_intersectionId_);
    m_numTransitions_ = ::std::move(other.m_numTransitions_);
    m_transitionNumber_ = ::std::move(other.m_transitionNumber_);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

IntersectionTransition::IntersectionTransition(::zserio::PropagateAllocatorT,
        const IntersectionTransition& other, const allocator_type& allocator) :
        m_intersectionId_(::zserio::allocatorPropagatingCopy(other.m_intersectionId_, allocator)),
        m_numTransitions_(::zserio::allocatorPropagatingCopy(other.m_numTransitions_, allocator)),
        m_transitionNumber_(::zserio::allocatorPropagatingCopy(other.m_transitionNumber_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void IntersectionTransition::initialize(
        ::nds::road::reference::types::TransitionReferenceType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool IntersectionTransition::isInitialized() const
{
    return m_isInitialized;
}

::nds::road::reference::types::TransitionReferenceType IntersectionTransition::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'IntersectionTransition' is not initialized!");

    return m_type_;
}

::nds::road::reference::types::IntersectionId IntersectionTransition::getIntersectionId() const
{
    return m_intersectionId_;
}

void IntersectionTransition::setIntersectionId(::nds::road::reference::types::IntersectionId intersectionId_)
{
    m_intersectionId_ = intersectionId_;
}

uint32_t IntersectionTransition::getNumTransitions() const
{
    return m_numTransitions_.value();
}

void IntersectionTransition::setNumTransitions(uint32_t numTransitions_)
{
    m_numTransitions_ = numTransitions_;
}

bool IntersectionTransition::isNumTransitionsUsed() const
{
    return (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION);
}

bool IntersectionTransition::isNumTransitionsSet() const
{
    return m_numTransitions_.hasValue();
}

void IntersectionTransition::resetNumTransitions()
{
    m_numTransitions_.reset();
}

::zserio::vector<::nds::road::reference::types::TransitionNumber>& IntersectionTransition::getTransitionNumber()
{
    return m_transitionNumber_.value().getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::TransitionNumber>& IntersectionTransition::getTransitionNumber() const
{
    return m_transitionNumber_.value().getRawArray();
}

void IntersectionTransition::setTransitionNumber(const ::zserio::vector<::nds::road::reference::types::TransitionNumber>& transitionNumber_)
{
    m_transitionNumber_ = ZserioArrayType_transitionNumber(transitionNumber_);
}

void IntersectionTransition::setTransitionNumber(::zserio::vector<::nds::road::reference::types::TransitionNumber>&& transitionNumber_)
{
    m_transitionNumber_ = ZserioArrayType_transitionNumber(std::move(transitionNumber_));
}

bool IntersectionTransition::isTransitionNumberUsed() const
{
    return (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION);
}

bool IntersectionTransition::isTransitionNumberSet() const
{
    return m_transitionNumber_.hasValue();
}

void IntersectionTransition::resetTransitionNumber()
{
    m_transitionNumber_.reset();
}

void IntersectionTransition::initPackingContext(IntersectionTransition::ZserioPackingContext& context) const
{
    context.getIntersectionId().init<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(m_intersectionId_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        context.getNumTransitions().init<::zserio::VarSizeArrayTraits>(m_numTransitions_.value());
    }
}

size_t IntersectionTransition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_intersectionId_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numTransitions_.value());
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition += m_transitionNumber_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t IntersectionTransition::bitSizeOf(IntersectionTransition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getIntersectionId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(m_intersectionId_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition += context.getNumTransitions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTransitions_.value());
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition += m_transitionNumber_.value().bitSizeOfPacked(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t IntersectionTransition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_intersectionId_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numTransitions_.value());
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition = m_transitionNumber_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t IntersectionTransition::initializeOffsets(IntersectionTransition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getIntersectionId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(m_intersectionId_);
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition += context.getNumTransitions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTransitions_.value());
    }
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        endBitPosition = m_transitionNumber_.value().initializeOffsetsPacked(endBitPosition);
    }

    return endBitPosition;
}

bool IntersectionTransition::operator==(const IntersectionTransition& other) const
{
    if (this != &other)
    {
        return
                (getType() == other.getType()) &&
                (m_intersectionId_ == other.m_intersectionId_) &&
                (!isNumTransitionsUsed() ? !other.isNumTransitionsUsed() : (m_numTransitions_ == other.m_numTransitions_)) &&
                (!isTransitionNumberUsed() ? !other.isTransitionNumberUsed() : (m_transitionNumber_ == other.m_transitionNumber_));
    }

    return true;
}

uint32_t IntersectionTransition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, m_intersectionId_);
    if (isNumTransitionsUsed())
        result = ::zserio::calcHashCode(result, m_numTransitions_);
    if (isTransitionNumberUsed())
        result = ::zserio::calcHashCode(result, m_transitionNumber_);

    return result;
}

void IntersectionTransition::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_intersectionId_);

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        out.writeVarSize(m_numTransitions_.value());
    }

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        // check array length
        if (m_transitionNumber_.value().getRawArray().size() != static_cast<size_t>(getNumTransitions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field IntersectionTransition.transitionNumber: ") <<
                    m_transitionNumber_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumTransitions()) << "!";
        }
        m_transitionNumber_.value().write(out);
    }
}

void IntersectionTransition::write(IntersectionTransition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getIntersectionId().write<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(out, m_intersectionId_);

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        context.getNumTransitions().write<::zserio::VarSizeArrayTraits>(out, m_numTransitions_.value());
    }

    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        // check array length
        if (m_transitionNumber_.value().getRawArray().size() != static_cast<size_t>(getNumTransitions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field IntersectionTransition.transitionNumber: ") <<
                    m_transitionNumber_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumTransitions()) << "!";
        }
        m_transitionNumber_.value().writePacked(out);
    }
}

::nds::road::reference::types::IntersectionId IntersectionTransition::readIntersectionId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::road::reference::types::IntersectionId>(in.readVarUInt32());
}

::nds::road::reference::types::IntersectionId IntersectionTransition::readIntersectionId(IntersectionTransition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getIntersectionId().read<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::IntersectionId>>(in);
}
::zserio::InplaceOptionalHolder<uint32_t> IntersectionTransition::readNumTransitions(::zserio::BitStreamReader& in)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> IntersectionTransition::readNumTransitions(IntersectionTransition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(context.getNumTransitions().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<IntersectionTransition::ZserioArrayType_transitionNumber> IntersectionTransition::readTransitionNumber(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        ZserioArrayType_transitionNumber readField(allocator);
        readField.read(in, static_cast<size_t>(getNumTransitions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_transitionNumber>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_transitionNumber>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<IntersectionTransition::ZserioArrayType_transitionNumber> IntersectionTransition::readTransitionNumber(IntersectionTransition::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::road::reference::types::TransitionReferenceType::TRANSITION)
    {
        ZserioArrayType_transitionNumber readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumTransitions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_transitionNumber>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_transitionNumber>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/TransitionPathReference.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

TransitionPathReference::TransitionPathReference(const allocator_type& allocator) noexcept :
        m_numRoads_(uint8_t()),
        m_roads_(allocator)
{
}

TransitionPathReference::TransitionPathReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numRoads_(readNumRoads(in)),
        m_roads_(readRoads(in, allocator))
{
}

TransitionPathReference::TransitionPathReference(TransitionPathReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numRoads_(readNumRoads(context, in)),
        m_roads_(readRoads(context, in, allocator))
{
}

TransitionPathReference::TransitionPathReference(::zserio::PropagateAllocatorT,
        const TransitionPathReference& other, const allocator_type& allocator) :
        m_numRoads_(::zserio::allocatorPropagatingCopy(other.m_numRoads_, allocator)),
        m_roads_(::zserio::allocatorPropagatingCopy(other.m_roads_, allocator))
{
}

uint8_t TransitionPathReference::getNumRoads() const
{
    return m_numRoads_;
}

void TransitionPathReference::setNumRoads(uint8_t numRoads_)
{
    m_numRoads_ = numRoads_;
}

::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& TransitionPathReference::getRoads()
{
    return m_roads_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& TransitionPathReference::getRoads() const
{
    return m_roads_.getRawArray();
}

void TransitionPathReference::setRoads(const ::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& roads_)
{
    m_roads_ = ZserioArrayType_roads(roads_);
}

void TransitionPathReference::setRoads(::zserio::vector<::nds::road::reference::types::DirectedRoadReference>&& roads_)
{
    m_roads_ = ZserioArrayType_roads(std::move(roads_));
}

void TransitionPathReference::initPackingContext(TransitionPathReference::ZserioPackingContext& context) const
{
    context.getNumRoads().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numRoads_);
}

size_t TransitionPathReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_roads_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TransitionPathReference::bitSizeOf(TransitionPathReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumRoads().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numRoads_);
    endBitPosition += m_roads_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TransitionPathReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_roads_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t TransitionPathReference::initializeOffsets(TransitionPathReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumRoads().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numRoads_);
    endBitPosition = m_roads_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TransitionPathReference::operator==(const TransitionPathReference& other) const
{
    if (this != &other)
    {
        return
                (m_numRoads_ == other.m_numRoads_) &&
                (m_roads_ == other.m_roads_);
    }

    return true;
}

uint32_t TransitionPathReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numRoads_);
    result = ::zserio::calcHashCode(result, m_roads_);

    return result;
}

void TransitionPathReference::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numRoads_, UINT8_C(8));

    // check array length
    if (m_roads_.getRawArray().size() != static_cast<size_t>(getNumRoads()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TransitionPathReference.roads: ") <<
                m_roads_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRoads()) << "!";
    }
    m_roads_.write(*this, out);
}

void TransitionPathReference::write(TransitionPathReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumRoads().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numRoads_);

    // check array length
    if (m_roads_.getRawArray().size() != static_cast<size_t>(getNumRoads()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TransitionPathReference.roads: ") <<
                m_roads_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRoads()) << "!";
    }
    m_roads_.writePacked(*this, out);
}

void TransitionPathReference::ZserioElementFactory_roads::create(TransitionPathReference&        ,
        ::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TransitionPathReference::ZserioElementFactory_roads::create(TransitionPathReference&        ,
        ::zserio::vector<::nds::road::reference::types::DirectedRoadReference>& array,
        ::nds::road::reference::types::DirectedRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t TransitionPathReference::readNumRoads(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t TransitionPathReference::readNumRoads(TransitionPathReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumRoads().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
TransitionPathReference::ZserioArrayType_roads TransitionPathReference::readRoads(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_roads readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumRoads()));

    return readField;
}

TransitionPathReference::ZserioArrayType_roads TransitionPathReference::readRoads(TransitionPathReference::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_roads readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumRoads()));

    return readField;
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/TransitionGeoPathReference.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

TransitionGeoPathReference::TransitionGeoPathReference(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_startRoad_(allocator),
        m_path_(allocator)
{
}

TransitionGeoPathReference::TransitionGeoPathReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_startRoad_(readStartRoad(in, allocator)),
        m_path_(readPath(in, allocator))
{
}

TransitionGeoPathReference::TransitionGeoPathReference(TransitionGeoPathReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_startRoad_(readStartRoad(context, in, allocator)),
        m_path_(readPath(context, in, allocator))
{
}

TransitionGeoPathReference::TransitionGeoPathReference(const TransitionGeoPathReference& other) :
        m_startRoad_(other.m_startRoad_),
        m_path_(other.m_path_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TransitionGeoPathReference& TransitionGeoPathReference::operator=(const TransitionGeoPathReference& other)
{
    m_startRoad_ = other.m_startRoad_;
    m_path_ = other.m_path_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TransitionGeoPathReference::TransitionGeoPathReference(TransitionGeoPathReference&& other) :
        m_startRoad_(::std::move(other.m_startRoad_)),
        m_path_(::std::move(other.m_path_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TransitionGeoPathReference& TransitionGeoPathReference::operator=(TransitionGeoPathReference&& other)
{
    m_startRoad_ = ::std::move(other.m_startRoad_);
    m_path_ = ::std::move(other.m_path_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TransitionGeoPathReference::TransitionGeoPathReference(::zserio::PropagateAllocatorT,
        const TransitionGeoPathReference& other, const allocator_type& allocator) :
        m_startRoad_(::zserio::allocatorPropagatingCopy(other.m_startRoad_, allocator)),
        m_path_(::zserio::allocatorPropagatingCopy(other.m_path_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void TransitionGeoPathReference::initializeChildren()
{
    m_path_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::road::reference::types::DirectedRoadReference& TransitionGeoPathReference::getStartRoad()
{
    return m_startRoad_;
}

const ::nds::road::reference::types::DirectedRoadReference& TransitionGeoPathReference::getStartRoad() const
{
    return m_startRoad_;
}

void TransitionGeoPathReference::setStartRoad(const ::nds::road::reference::types::DirectedRoadReference& startRoad_)
{
    m_startRoad_ = startRoad_;
}

void TransitionGeoPathReference::setStartRoad(::nds::road::reference::types::DirectedRoadReference&& startRoad_)
{
    m_startRoad_ = ::std::move(startRoad_);
}

::nds::core::geometry::Line2D& TransitionGeoPathReference::getPath()
{
    return m_path_;
}

const ::nds::core::geometry::Line2D& TransitionGeoPathReference::getPath() const
{
    return m_path_;
}

void TransitionGeoPathReference::setPath(const ::nds::core::geometry::Line2D& path_)
{
    m_path_ = path_;
}

void TransitionGeoPathReference::setPath(::nds::core::geometry::Line2D&& path_)
{
    m_path_ = ::std::move(path_);
}

void TransitionGeoPathReference::initPackingContext(TransitionGeoPathReference::ZserioPackingContext& context) const
{
    m_startRoad_.initPackingContext(context.getStartRoad());
    m_path_.initPackingContext(context.getPath());
}

size_t TransitionGeoPathReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startRoad_.bitSizeOf(endBitPosition);
    endBitPosition += m_path_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TransitionGeoPathReference::bitSizeOf(TransitionGeoPathReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startRoad_.bitSizeOf(context.getStartRoad(), endBitPosition);
    endBitPosition += m_path_.bitSizeOf(context.getPath(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TransitionGeoPathReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startRoad_.initializeOffsets(endBitPosition);
    endBitPosition = m_path_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TransitionGeoPathReference::initializeOffsets(TransitionGeoPathReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startRoad_.initializeOffsets(context.getStartRoad(), endBitPosition);
    endBitPosition = m_path_.initializeOffsets(context.getPath(), endBitPosition);

    return endBitPosition;
}

bool TransitionGeoPathReference::operator==(const TransitionGeoPathReference& other) const
{
    if (this != &other)
    {
        return
                (m_startRoad_ == other.m_startRoad_) &&
                (m_path_ == other.m_path_);
    }

    return true;
}

uint32_t TransitionGeoPathReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_startRoad_);
    result = ::zserio::calcHashCode(result, m_path_);

    return result;
}

void TransitionGeoPathReference::write(::zserio::BitStreamWriter& out) const
{
    m_startRoad_.write(out);

    // check parameters
    if (m_path_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field TransitionGeoPathReference.path: ") <<
                m_path_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_path_.write(out);
}

void TransitionGeoPathReference::write(TransitionGeoPathReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_startRoad_.write(context.getStartRoad(), out);

    // check parameters
    if (m_path_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field TransitionGeoPathReference.path: ") <<
                m_path_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_path_.write(context.getPath(), out);
}

::nds::road::reference::types::DirectedRoadReference TransitionGeoPathReference::readStartRoad(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::DirectedRoadReference(in, allocator);
}

::nds::road::reference::types::DirectedRoadReference TransitionGeoPathReference::readStartRoad(TransitionGeoPathReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::DirectedRoadReference(context.getStartRoad(), in, allocator);
}
::nds::core::geometry::Line2D TransitionGeoPathReference::readPath(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Line2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::core::geometry::Line2D TransitionGeoPathReference::readPath(TransitionGeoPathReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Line2D(context.getPath(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/road/reference/types/RoadPositionValidity.h>
#include <nds/road/reference/types/RoadValidityType.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadPositionValidity::RoadPositionValidity(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_type_(::nds::road::reference::types::RoadValidityType()),
        m_numPositions_(::zserio::NullOpt),
        m_positions_(::zserio::NullOpt)
{
}

RoadPositionValidity::RoadPositionValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(in)),
        m_numPositions_(readNumPositions(in)),
        m_positions_(readPositions(in, allocator))
{
}

RoadPositionValidity::RoadPositionValidity(RoadPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(context, in)),
        m_numPositions_(readNumPositions(context, in)),
        m_positions_(readPositions(context, in, allocator))
{
}

RoadPositionValidity::RoadPositionValidity(const RoadPositionValidity& other) :
        m_type_(other.m_type_),
        m_numPositions_(other.m_numPositions_),
        m_positions_(other.m_positions_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadPositionValidity& RoadPositionValidity::operator=(const RoadPositionValidity& other)
{
    m_type_ = other.m_type_;
    m_numPositions_ = other.m_numPositions_;
    m_positions_ = other.m_positions_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadPositionValidity::RoadPositionValidity(RoadPositionValidity&& other) :
        m_type_(::std::move(other.m_type_)),
        m_numPositions_(::std::move(other.m_numPositions_)),
        m_positions_(::std::move(other.m_positions_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadPositionValidity& RoadPositionValidity::operator=(RoadPositionValidity&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_numPositions_ = ::std::move(other.m_numPositions_);
    m_positions_ = ::std::move(other.m_positions_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadPositionValidity::RoadPositionValidity(::zserio::PropagateAllocatorT,
        const RoadPositionValidity& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator)),
        m_positions_(::zserio::allocatorPropagatingCopy(other.m_positions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void RoadPositionValidity::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoadPositionValidity::isInitialized() const
{
    return m_isInitialized;
}

void RoadPositionValidity::initializeChildren()
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
        m_positions_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift RoadPositionValidity::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'RoadPositionValidity' is not initialized!");

    return m_shift_;
}

::nds::road::reference::types::RoadValidityType RoadPositionValidity::getType() const
{
    return m_type_;
}

void RoadPositionValidity::setType(::nds::road::reference::types::RoadValidityType type_)
{
    m_type_ = type_;
}

uint32_t RoadPositionValidity::getNumPositions() const
{
    return m_numPositions_.value();
}

void RoadPositionValidity::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

bool RoadPositionValidity::isNumPositionsUsed() const
{
    return (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE);
}

bool RoadPositionValidity::isNumPositionsSet() const
{
    return m_numPositions_.hasValue();
}

void RoadPositionValidity::resetNumPositions()
{
    m_numPositions_.reset();
}

::zserio::vector<::nds::road::reference::types::RoadPositionChoice>& RoadPositionValidity::getPositions()
{
    return m_positions_.value().getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadPositionChoice>& RoadPositionValidity::getPositions() const
{
    return m_positions_.value().getRawArray();
}

void RoadPositionValidity::setPositions(const ::zserio::vector<::nds::road::reference::types::RoadPositionChoice>& positions_)
{
    m_positions_ = ZserioArrayType_positions(positions_);
}

void RoadPositionValidity::setPositions(::zserio::vector<::nds::road::reference::types::RoadPositionChoice>&& positions_)
{
    m_positions_ = ZserioArrayType_positions(std::move(positions_));
}

bool RoadPositionValidity::isPositionsUsed() const
{
    return (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE);
}

bool RoadPositionValidity::isPositionsSet() const
{
    return m_positions_.hasValue();
}

void RoadPositionValidity::resetPositions()
{
    m_positions_.reset();
}

void RoadPositionValidity::initPackingContext(RoadPositionValidity::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_.value());
    }
}

size_t RoadPositionValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_.value());
    }
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += m_positions_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadPositionValidity::bitSizeOf(RoadPositionValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_.value());
    }
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += m_positions_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadPositionValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_.value());
    }
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition = m_positions_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t RoadPositionValidity::initializeOffsets(RoadPositionValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_.value());
    }
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition = m_positions_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool RoadPositionValidity::operator==(const RoadPositionValidity& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_type_ == other.m_type_) &&
                (!isNumPositionsUsed() ? !other.isNumPositionsUsed() : (m_numPositions_ == other.m_numPositions_)) &&
                (!isPositionsUsed() ? !other.isPositionsUsed() : (m_positions_ == other.m_positions_));
    }

    return true;
}

uint32_t RoadPositionValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_type_);
    if (isNumPositionsUsed())
        result = ::zserio::calcHashCode(result, m_numPositions_);
    if (isPositionsUsed())
        result = ::zserio::calcHashCode(result, m_positions_);

    return result;
}

void RoadPositionValidity::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Write: Constraint violated at RoadPositionValidity.type!");
    ::zserio::write(out, m_type_);

    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumPositions() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at RoadPositionValidity.numPositions!");
        out.writeVarSize(m_numPositions_.value());
    }

    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        // check array length
        if (m_positions_.value().getRawArray().size() != static_cast<size_t>(getNumPositions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadPositionValidity.positions: ") <<
                    m_positions_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumPositions()) << "!";
        }
        m_positions_.value().write(*this, out);
    }
}

void RoadPositionValidity::write(RoadPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Write: Constraint violated at RoadPositionValidity.type!");
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumPositions() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at RoadPositionValidity.numPositions!");
        context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_.value());
    }

    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        // check array length
        if (m_positions_.value().getRawArray().size() != static_cast<size_t>(getNumPositions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadPositionValidity.positions: ") <<
                    m_positions_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumPositions()) << "!";
        }
        m_positions_.value().writePacked(*this, out);
    }
}

void RoadPositionValidity::ZserioArrayExpressions_positions::initializeElement(RoadPositionValidity& owner,
        ::nds::road::reference::types::RoadPositionChoice& element, size_t)
{
    element.initialize(static_cast<::nds::road::reference::types::RoadValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void RoadPositionValidity::ZserioElementFactory_positions::create(RoadPositionValidity&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionChoice>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::road::reference::types::RoadValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void RoadPositionValidity::ZserioElementFactory_positions::create(RoadPositionValidity&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionChoice>& array,
        ::nds::road::reference::types::RoadPositionChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::road::reference::types::RoadValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

::nds::road::reference::types::RoadValidityType RoadPositionValidity::readType(::zserio::BitStreamReader& in)
{
    ::nds::road::reference::types::RoadValidityType readField = ::zserio::read<::nds::road::reference::types::RoadValidityType>(in);
    // check constraint
    if (!(readField != ::nds::road::reference::types::RoadValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Read: Constraint violated at RoadPositionValidity.type!");

    return readField;
}

::nds::road::reference::types::RoadValidityType RoadPositionValidity::readType(RoadPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::road::reference::types::RoadValidityType readField = ::zserio::read<::nds::road::reference::types::RoadValidityType>(context.getType(), in);
    // check constraint
    if (!(readField != ::nds::road::reference::types::RoadValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Read: Constraint violated at RoadPositionValidity.type!");

    return readField;
}
::zserio::InplaceOptionalHolder<uint32_t> RoadPositionValidity::readNumPositions(::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at RoadPositionValidity.numPositions!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> RoadPositionValidity::readNumPositions(RoadPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        uint32_t readField = context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at RoadPositionValidity.numPositions!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<RoadPositionValidity::ZserioArrayType_positions> RoadPositionValidity::readPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        ZserioArrayType_positions readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumPositions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoadPositionValidity::ZserioArrayType_positions> RoadPositionValidity::readPositions(RoadPositionValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        ZserioArrayType_positions readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/road/reference/types/RoadRangeValidity.h>
#include <nds/road/reference/types/RoadValidityType.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadRangeValidity::RoadRangeValidity(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_type_(::nds::road::reference::types::RoadValidityType()),
        m_numRanges_(::zserio::NullOpt),
        m_ranges_(::zserio::NullOpt)
{
}

RoadRangeValidity::RoadRangeValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(in)),
        m_numRanges_(readNumRanges(in)),
        m_ranges_(readRanges(in, allocator))
{
}

RoadRangeValidity::RoadRangeValidity(RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(context, in)),
        m_numRanges_(readNumRanges(context, in)),
        m_ranges_(readRanges(context, in, allocator))
{
}

RoadRangeValidity::RoadRangeValidity(const RoadRangeValidity& other) :
        m_type_(other.m_type_),
        m_numRanges_(other.m_numRanges_),
        m_ranges_(other.m_ranges_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadRangeValidity& RoadRangeValidity::operator=(const RoadRangeValidity& other)
{
    m_type_ = other.m_type_;
    m_numRanges_ = other.m_numRanges_;
    m_ranges_ = other.m_ranges_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadRangeValidity::RoadRangeValidity(RoadRangeValidity&& other) :
        m_type_(::std::move(other.m_type_)),
        m_numRanges_(::std::move(other.m_numRanges_)),
        m_ranges_(::std::move(other.m_ranges_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadRangeValidity& RoadRangeValidity::operator=(RoadRangeValidity&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_numRanges_ = ::std::move(other.m_numRanges_);
    m_ranges_ = ::std::move(other.m_ranges_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadRangeValidity::RoadRangeValidity(::zserio::PropagateAllocatorT,
        const RoadRangeValidity& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_numRanges_(::zserio::allocatorPropagatingCopy(other.m_numRanges_, allocator)),
        m_ranges_(::zserio::allocatorPropagatingCopy(other.m_ranges_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void RoadRangeValidity::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoadRangeValidity::isInitialized() const
{
    return m_isInitialized;
}

void RoadRangeValidity::initializeChildren()
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
        m_ranges_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift RoadRangeValidity::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'RoadRangeValidity' is not initialized!");

    return m_shift_;
}

::nds::road::reference::types::RoadValidityType RoadRangeValidity::getType() const
{
    return m_type_;
}

void RoadRangeValidity::setType(::nds::road::reference::types::RoadValidityType type_)
{
    m_type_ = type_;
}

uint32_t RoadRangeValidity::getNumRanges() const
{
    return m_numRanges_.value();
}

void RoadRangeValidity::setNumRanges(uint32_t numRanges_)
{
    m_numRanges_ = numRanges_;
}

bool RoadRangeValidity::isNumRangesUsed() const
{
    return (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE);
}

bool RoadRangeValidity::isNumRangesSet() const
{
    return m_numRanges_.hasValue();
}

void RoadRangeValidity::resetNumRanges()
{
    m_numRanges_.reset();
}

::zserio::vector<::nds::road::reference::types::RoadRangeChoice>& RoadRangeValidity::getRanges()
{
    return m_ranges_.value().getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeChoice>& RoadRangeValidity::getRanges() const
{
    return m_ranges_.value().getRawArray();
}

void RoadRangeValidity::setRanges(const ::zserio::vector<::nds::road::reference::types::RoadRangeChoice>& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(ranges_);
}

void RoadRangeValidity::setRanges(::zserio::vector<::nds::road::reference::types::RoadRangeChoice>&& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(std::move(ranges_));
}

bool RoadRangeValidity::isRangesUsed() const
{
    return (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE);
}

bool RoadRangeValidity::isRangesSet() const
{
    return m_ranges_.hasValue();
}

void RoadRangeValidity::resetRanges()
{
    m_ranges_.reset();
}

void RoadRangeValidity::initPackingContext(RoadRangeValidity::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        context.getNumRanges().init<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
}

size_t RoadRangeValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numRanges_.value());
    }
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += m_ranges_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadRangeValidity::bitSizeOf(RoadRangeValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += context.getNumRanges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += m_ranges_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadRangeValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numRanges_.value());
    }
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition = m_ranges_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t RoadRangeValidity::initializeOffsets(RoadRangeValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition += context.getNumRanges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        endBitPosition = m_ranges_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool RoadRangeValidity::operator==(const RoadRangeValidity& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_type_ == other.m_type_) &&
                (!isNumRangesUsed() ? !other.isNumRangesUsed() : (m_numRanges_ == other.m_numRanges_)) &&
                (!isRangesUsed() ? !other.isRangesUsed() : (m_ranges_ == other.m_ranges_));
    }

    return true;
}

uint32_t RoadRangeValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_type_);
    if (isNumRangesUsed())
        result = ::zserio::calcHashCode(result, m_numRanges_);
    if (isRangesUsed())
        result = ::zserio::calcHashCode(result, m_ranges_);

    return result;
}

void RoadRangeValidity::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumRanges() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at RoadRangeValidity.numRanges!");
        out.writeVarSize(m_numRanges_.value());
    }

    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        // check array length
        if (m_ranges_.value().getRawArray().size() != static_cast<size_t>(getNumRanges()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadRangeValidity.ranges: ") <<
                    m_ranges_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRanges()) << "!";
        }
        m_ranges_.value().write(*this, out);
    }
}

void RoadRangeValidity::write(RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumRanges() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at RoadRangeValidity.numRanges!");
        context.getNumRanges().write<::zserio::VarSizeArrayTraits>(out, m_numRanges_.value());
    }

    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        // check array length
        if (m_ranges_.value().getRawArray().size() != static_cast<size_t>(getNumRanges()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadRangeValidity.ranges: ") <<
                    m_ranges_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRanges()) << "!";
        }
        m_ranges_.value().writePacked(*this, out);
    }
}

void RoadRangeValidity::ZserioArrayExpressions_ranges::initializeElement(RoadRangeValidity& owner,
        ::nds::road::reference::types::RoadRangeChoice& element, size_t)
{
    element.initialize(static_cast<::nds::road::reference::types::RoadValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void RoadRangeValidity::ZserioElementFactory_ranges::create(RoadRangeValidity&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeChoice>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::road::reference::types::RoadValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void RoadRangeValidity::ZserioElementFactory_ranges::create(RoadRangeValidity&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeChoice>& array,
        ::nds::road::reference::types::RoadRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::road::reference::types::RoadValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

::nds::road::reference::types::RoadValidityType RoadRangeValidity::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::reference::types::RoadValidityType>(in);
}

::nds::road::reference::types::RoadValidityType RoadRangeValidity::readType(RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::reference::types::RoadValidityType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<uint32_t> RoadRangeValidity::readNumRanges(::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at RoadRangeValidity.numRanges!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> RoadRangeValidity::readNumRanges(RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        uint32_t readField = context.getNumRanges().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at RoadRangeValidity.numRanges!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<RoadRangeValidity::ZserioArrayType_ranges> RoadRangeValidity::readRanges(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        ZserioArrayType_ranges readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumRanges()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoadRangeValidity::ZserioArrayType_ranges> RoadRangeValidity::readRanges(RoadRangeValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() != ::nds::road::reference::types::RoadValidityType::COMPLETE)
    {
        ZserioArrayType_ranges readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumRanges()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/TransitionValidity.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

TransitionValidity::TransitionValidity(const allocator_type&) noexcept
{
}

TransitionValidity::TransitionValidity(::zserio::BitStreamReader&, const allocator_type&)
{
}

TransitionValidity::TransitionValidity(::zserio::PropagateAllocatorT,
        const TransitionValidity&, const allocator_type&)
{
}

size_t TransitionValidity::bitSizeOf(size_t) const
{
    return 0;
}

size_t TransitionValidity::initializeOffsets(size_t bitPosition)
{
    return bitPosition;
}

bool TransitionValidity::operator==(const TransitionValidity&) const
{
    return true;
}

uint32_t TransitionValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    return result;
}

void TransitionValidity::write(::zserio::BitStreamWriter&) const
{
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/RoadValidityPosition.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadValidityPosition::RoadValidityPosition(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_position_(allocator),
        m_positionIndication_(::zserio::NullOpt)
{
}

RoadValidityPosition::RoadValidityPosition(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_position_(readPosition(in, allocator)),
        m_positionIndication_(readPositionIndication(in))
{
}

RoadValidityPosition::RoadValidityPosition(RoadValidityPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_position_(readPosition(context, in, allocator)),
        m_positionIndication_(readPositionIndication(in))
{
}

RoadValidityPosition::RoadValidityPosition(const RoadValidityPosition& other) :
        m_position_(other.m_position_),
        m_positionIndication_(other.m_positionIndication_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadValidityPosition& RoadValidityPosition::operator=(const RoadValidityPosition& other)
{
    m_position_ = other.m_position_;
    m_positionIndication_ = other.m_positionIndication_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadValidityPosition::RoadValidityPosition(RoadValidityPosition&& other) :
        m_position_(::std::move(other.m_position_)),
        m_positionIndication_(::std::move(other.m_positionIndication_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadValidityPosition& RoadValidityPosition::operator=(RoadValidityPosition&& other)
{
    m_position_ = ::std::move(other.m_position_);
    m_positionIndication_ = ::std::move(other.m_positionIndication_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadValidityPosition::RoadValidityPosition(::zserio::PropagateAllocatorT,
        const RoadValidityPosition& other, const allocator_type& allocator) :
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator)),
        m_positionIndication_(::zserio::allocatorPropagatingCopy(other.m_positionIndication_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void RoadValidityPosition::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoadValidityPosition::isInitialized() const
{
    return m_isInitialized;
}

void RoadValidityPosition::initializeChildren()
{
    m_position_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
}

::nds::core::geometry::CoordShift RoadValidityPosition::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'RoadValidityPosition' is not initialized!");

    return m_shift_;
}

::nds::core::geometry::Position2D& RoadValidityPosition::getPosition()
{
    return m_position_;
}

const ::nds::core::geometry::Position2D& RoadValidityPosition::getPosition() const
{
    return m_position_;
}

void RoadValidityPosition::setPosition(const ::nds::core::geometry::Position2D& position_)
{
    m_position_ = position_;
}

void RoadValidityPosition::setPosition(::nds::core::geometry::Position2D&& position_)
{
    m_position_ = ::std::move(position_);
}

::nds::road::reference::types::PercentageIndication RoadValidityPosition::getPositionIndication() const
{
    return m_positionIndication_.value();
}

void RoadValidityPosition::setPositionIndication(::nds::road::reference::types::PercentageIndication positionIndication_)
{
    m_positionIndication_ = positionIndication_;
}

bool RoadValidityPosition::isPositionIndicationUsed() const
{
    return (isPositionIndicationSet());
}

bool RoadValidityPosition::isPositionIndicationSet() const
{
    return m_positionIndication_.hasValue();
}

void RoadValidityPosition::resetPositionIndication()
{
    m_positionIndication_.reset();
}

void RoadValidityPosition::initPackingContext(RoadValidityPosition::ZserioPackingContext& context) const
{
    m_position_.initPackingContext(context.getPosition());
}

size_t RoadValidityPosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition - bitPosition;
}

size_t RoadValidityPosition::bitSizeOf(RoadValidityPosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition - bitPosition;
}

size_t RoadValidityPosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition;
}

size_t RoadValidityPosition::initializeOffsets(RoadValidityPosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition;
}

bool RoadValidityPosition::operator==(const RoadValidityPosition& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_position_ == other.m_position_) &&
                (!isPositionIndicationUsed() ? !other.isPositionIndicationUsed() : (m_positionIndication_ == other.m_positionIndication_));
    }

    return true;
}

uint32_t RoadValidityPosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_position_);
    if (isPositionIndicationUsed())
        result = ::zserio::calcHashCode(result, m_positionIndication_);

    return result;
}

void RoadValidityPosition::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadValidityPosition.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_position_.write(out);

    if (isPositionIndicationSet())
    {
        out.writeBool(true);
        out.writeFloat16(m_positionIndication_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void RoadValidityPosition::write(RoadValidityPosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadValidityPosition.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_position_.write(context.getPosition(), out);

    if (isPositionIndicationSet())
    {
        out.writeBool(true);
        out.writeFloat16(m_positionIndication_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::geometry::Position2D RoadValidityPosition::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::Position2D RoadValidityPosition::readPosition(RoadValidityPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::PercentageIndication> RoadValidityPosition::readPositionIndication(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::PercentageIndication>(static_cast<::nds::road::reference::types::PercentageIndication>(in.readFloat16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::PercentageIndication>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/RoadValidityRange.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadValidityRange::RoadValidityRange(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_start_(allocator),
        m_end_(allocator)
{
}

RoadValidityRange::RoadValidityRange(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_start_(readStart(in, allocator)),
        m_end_(readEnd(in, allocator))
{
}

RoadValidityRange::RoadValidityRange(RoadValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_start_(readStart(context, in, allocator)),
        m_end_(readEnd(context, in, allocator))
{
}

RoadValidityRange::RoadValidityRange(const RoadValidityRange& other) :
        m_start_(other.m_start_),
        m_end_(other.m_end_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadValidityRange& RoadValidityRange::operator=(const RoadValidityRange& other)
{
    m_start_ = other.m_start_;
    m_end_ = other.m_end_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadValidityRange::RoadValidityRange(RoadValidityRange&& other) :
        m_start_(::std::move(other.m_start_)),
        m_end_(::std::move(other.m_end_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadValidityRange& RoadValidityRange::operator=(RoadValidityRange&& other)
{
    m_start_ = ::std::move(other.m_start_);
    m_end_ = ::std::move(other.m_end_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadValidityRange::RoadValidityRange(::zserio::PropagateAllocatorT,
        const RoadValidityRange& other, const allocator_type& allocator) :
        m_start_(::zserio::allocatorPropagatingCopy(other.m_start_, allocator)),
        m_end_(::zserio::allocatorPropagatingCopy(other.m_end_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void RoadValidityRange::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoadValidityRange::isInitialized() const
{
    return m_isInitialized;
}

void RoadValidityRange::initializeChildren()
{
    m_start_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
    m_end_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
}

::nds::core::geometry::CoordShift RoadValidityRange::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'RoadValidityRange' is not initialized!");

    return m_shift_;
}

::nds::road::reference::types::RoadValidityPosition& RoadValidityRange::getStart()
{
    return m_start_;
}

const ::nds::road::reference::types::RoadValidityPosition& RoadValidityRange::getStart() const
{
    return m_start_;
}

void RoadValidityRange::setStart(const ::nds::road::reference::types::RoadValidityPosition& start_)
{
    m_start_ = start_;
}

void RoadValidityRange::setStart(::nds::road::reference::types::RoadValidityPosition&& start_)
{
    m_start_ = ::std::move(start_);
}

::nds::road::reference::types::RoadValidityPosition& RoadValidityRange::getEnd()
{
    return m_end_;
}

const ::nds::road::reference::types::RoadValidityPosition& RoadValidityRange::getEnd() const
{
    return m_end_;
}

void RoadValidityRange::setEnd(const ::nds::road::reference::types::RoadValidityPosition& end_)
{
    m_end_ = end_;
}

void RoadValidityRange::setEnd(::nds::road::reference::types::RoadValidityPosition&& end_)
{
    m_end_ = ::std::move(end_);
}

void RoadValidityRange::initPackingContext(RoadValidityRange::ZserioPackingContext& context) const
{
    m_start_.initPackingContext(context.getStart());
    m_end_.initPackingContext(context.getEnd());
}

size_t RoadValidityRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_start_.bitSizeOf(endBitPosition);
    endBitPosition += m_end_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadValidityRange::bitSizeOf(RoadValidityRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_start_.bitSizeOf(context.getStart(), endBitPosition);
    endBitPosition += m_end_.bitSizeOf(context.getEnd(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadValidityRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_start_.initializeOffsets(endBitPosition);
    endBitPosition = m_end_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadValidityRange::initializeOffsets(RoadValidityRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_start_.initializeOffsets(context.getStart(), endBitPosition);
    endBitPosition = m_end_.initializeOffsets(context.getEnd(), endBitPosition);

    return endBitPosition;
}

bool RoadValidityRange::operator==(const RoadValidityRange& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_start_ == other.m_start_) &&
                (m_end_ == other.m_end_);
    }

    return true;
}

uint32_t RoadValidityRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_start_);
    result = ::zserio::calcHashCode(result, m_end_);

    return result;
}

void RoadValidityRange::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_start_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadValidityRange.start: ") <<
                m_start_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_start_.write(out);

    // check parameters
    if (m_end_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadValidityRange.end: ") <<
                m_end_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_end_.write(out);
}

void RoadValidityRange::write(RoadValidityRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_start_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadValidityRange.start: ") <<
                m_start_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_start_.write(context.getStart(), out);

    // check parameters
    if (m_end_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadValidityRange.end: ") <<
                m_end_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_end_.write(context.getEnd(), out);
}

::nds::road::reference::types::RoadValidityPosition RoadValidityRange::readStart(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadValidityPosition(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::road::reference::types::RoadValidityPosition RoadValidityRange::readStart(RoadValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadValidityPosition(context.getStart(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}
::nds::road::reference::types::RoadValidityPosition RoadValidityRange::readEnd(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadValidityPosition(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::road::reference::types::RoadValidityPosition RoadValidityRange::readEnd(RoadValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadValidityPosition(context.getEnd(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/RoadLengthPosition.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadLengthPosition::RoadLengthPosition(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_length_(::nds::road::reference::types::RoadLength()),
        m_position_(allocator)
{
}

RoadLengthPosition::RoadLengthPosition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_length_(readLength(in)),
        m_position_(readPosition(in, allocator))
{
}

RoadLengthPosition::RoadLengthPosition(RoadLengthPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_length_(readLength(context, in)),
        m_position_(readPosition(context, in, allocator))
{
}

RoadLengthPosition::RoadLengthPosition(const RoadLengthPosition& other) :
        m_length_(other.m_length_),
        m_position_(other.m_position_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLengthPosition& RoadLengthPosition::operator=(const RoadLengthPosition& other)
{
    m_length_ = other.m_length_;
    m_position_ = other.m_position_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLengthPosition::RoadLengthPosition(RoadLengthPosition&& other) :
        m_length_(::std::move(other.m_length_)),
        m_position_(::std::move(other.m_position_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLengthPosition& RoadLengthPosition::operator=(RoadLengthPosition&& other)
{
    m_length_ = ::std::move(other.m_length_);
    m_position_ = ::std::move(other.m_position_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLengthPosition::RoadLengthPosition(::zserio::PropagateAllocatorT,
        const RoadLengthPosition& other, const allocator_type& allocator) :
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator)),
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadLengthPosition::initializeChildren()
{
    m_position_.initialize(static_cast<uint32_t>(getLength()));

    m_areChildrenInitialized = true;
}

::nds::road::reference::types::RoadLength RoadLengthPosition::getLength() const
{
    return m_length_;
}

void RoadLengthPosition::setLength(::nds::road::reference::types::RoadLength length_)
{
    m_length_ = length_;
}

::nds::core::types::RangePosition& RoadLengthPosition::getPosition()
{
    return m_position_;
}

const ::nds::core::types::RangePosition& RoadLengthPosition::getPosition() const
{
    return m_position_;
}

void RoadLengthPosition::setPosition(const ::nds::core::types::RangePosition& position_)
{
    m_position_ = position_;
}

void RoadLengthPosition::setPosition(::nds::core::types::RangePosition&& position_)
{
    m_position_ = ::std::move(position_);
}

void RoadLengthPosition::initPackingContext(RoadLengthPosition::ZserioPackingContext& context) const
{
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(m_length_);
    m_position_.initPackingContext(context.getPosition());
}

size_t RoadLengthPosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += m_position_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLengthPosition::bitSizeOf(RoadLengthPosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(m_length_);
    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLengthPosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition = m_position_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadLengthPosition::initializeOffsets(RoadLengthPosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(m_length_);
    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);

    return endBitPosition;
}

bool RoadLengthPosition::operator==(const RoadLengthPosition& other) const
{
    if (this != &other)
    {
        return
                (m_length_ == other.m_length_) &&
                (m_position_ == other.m_position_);
    }

    return true;
}

uint32_t RoadLengthPosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_length_);
    result = ::zserio::calcHashCode(result, m_position_);

    return result;
}

void RoadLengthPosition::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_length_);

    // check parameters
    if (m_position_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field RoadLengthPosition.position: ") <<
                m_position_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_position_.write(out);
}

void RoadLengthPosition::write(RoadLengthPosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(out, m_length_);

    // check parameters
    if (m_position_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field RoadLengthPosition.position: ") <<
                m_position_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_position_.write(context.getPosition(), out);
}

::nds::road::reference::types::RoadLength RoadLengthPosition::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::road::reference::types::RoadLength>(in.readVarUInt32());
}

::nds::road::reference::types::RoadLength RoadLengthPosition::readLength(RoadLengthPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(in);
}
::nds::core::types::RangePosition RoadLengthPosition::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::RangePosition(in, static_cast<uint32_t>(getLength()), allocator);
}

::nds::core::types::RangePosition RoadLengthPosition::readPosition(RoadLengthPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::RangePosition(context.getPosition(), in, static_cast<uint32_t>(getLength()), allocator);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/RoadLengthRange.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadLengthRange::RoadLengthRange(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_length_(::nds::road::reference::types::RoadLength()),
        m_range_(allocator)
{
}

RoadLengthRange::RoadLengthRange(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_length_(readLength(in)),
        m_range_(readRange(in, allocator))
{
}

RoadLengthRange::RoadLengthRange(RoadLengthRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_length_(readLength(context, in)),
        m_range_(readRange(context, in, allocator))
{
}

RoadLengthRange::RoadLengthRange(const RoadLengthRange& other) :
        m_length_(other.m_length_),
        m_range_(other.m_range_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLengthRange& RoadLengthRange::operator=(const RoadLengthRange& other)
{
    m_length_ = other.m_length_;
    m_range_ = other.m_range_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLengthRange::RoadLengthRange(RoadLengthRange&& other) :
        m_length_(::std::move(other.m_length_)),
        m_range_(::std::move(other.m_range_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLengthRange& RoadLengthRange::operator=(RoadLengthRange&& other)
{
    m_length_ = ::std::move(other.m_length_);
    m_range_ = ::std::move(other.m_range_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLengthRange::RoadLengthRange(::zserio::PropagateAllocatorT,
        const RoadLengthRange& other, const allocator_type& allocator) :
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator)),
        m_range_(::zserio::allocatorPropagatingCopy(other.m_range_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadLengthRange::initializeChildren()
{
    m_range_.initialize(static_cast<uint32_t>(getLength()));

    m_areChildrenInitialized = true;
}

::nds::road::reference::types::RoadLength RoadLengthRange::getLength() const
{
    return m_length_;
}

void RoadLengthRange::setLength(::nds::road::reference::types::RoadLength length_)
{
    m_length_ = length_;
}

::nds::core::types::Range& RoadLengthRange::getRange()
{
    return m_range_;
}

const ::nds::core::types::Range& RoadLengthRange::getRange() const
{
    return m_range_;
}

void RoadLengthRange::setRange(const ::nds::core::types::Range& range_)
{
    m_range_ = range_;
}

void RoadLengthRange::setRange(::nds::core::types::Range&& range_)
{
    m_range_ = ::std::move(range_);
}

void RoadLengthRange::initPackingContext(RoadLengthRange::ZserioPackingContext& context) const
{
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(m_length_);
    m_range_.initPackingContext(context.getRange());
}

size_t RoadLengthRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += m_range_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLengthRange::bitSizeOf(RoadLengthRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(m_length_);
    endBitPosition += m_range_.bitSizeOf(context.getRange(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLengthRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition = m_range_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadLengthRange::initializeOffsets(RoadLengthRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(m_length_);
    endBitPosition = m_range_.initializeOffsets(context.getRange(), endBitPosition);

    return endBitPosition;
}

bool RoadLengthRange::operator==(const RoadLengthRange& other) const
{
    if (this != &other)
    {
        return
                (m_length_ == other.m_length_) &&
                (m_range_ == other.m_range_);
    }

    return true;
}

uint32_t RoadLengthRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_length_);
    result = ::zserio::calcHashCode(result, m_range_);

    return result;
}

void RoadLengthRange::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_length_);

    // check parameters
    if (m_range_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field RoadLengthRange.range: ") <<
                m_range_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_range_.write(out);
}

void RoadLengthRange::write(RoadLengthRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(out, m_length_);

    // check parameters
    if (m_range_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field RoadLengthRange.range: ") <<
                m_range_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_range_.write(context.getRange(), out);
}

::nds::road::reference::types::RoadLength RoadLengthRange::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::road::reference::types::RoadLength>(in.readVarUInt32());
}

::nds::road::reference::types::RoadLength RoadLengthRange::readLength(RoadLengthRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLength>>(in);
}
::nds::core::types::Range RoadLengthRange::readRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::Range(in, static_cast<uint32_t>(getLength()), allocator);
}

::nds::core::types::Range RoadLengthRange::readRange(RoadLengthRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::Range(context.getRange(), in, static_cast<uint32_t>(getLength()), allocator);
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/RoadPositionChoice.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadPositionChoice::RoadPositionChoice(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RoadPositionChoice::RoadPositionChoice(::zserio::BitStreamReader& in,
        ::nds::road::reference::types::RoadValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RoadPositionChoice::RoadPositionChoice(RoadPositionChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::road::reference::types::RoadValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RoadPositionChoice::RoadPositionChoice(const RoadPositionChoice& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

RoadPositionChoice& RoadPositionChoice::operator=(const RoadPositionChoice& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadPositionChoice::RoadPositionChoice(RoadPositionChoice&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

RoadPositionChoice& RoadPositionChoice::operator=(RoadPositionChoice&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadPositionChoice::RoadPositionChoice(::zserio::PropagateAllocatorT,
        const RoadPositionChoice& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

void RoadPositionChoice::initialize(
        ::nds::road::reference::types::RoadValidityType type_,
        ::nds::core::geometry::CoordShift shift_)
{
    m_type_ = type_;
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoadPositionChoice::isInitialized() const
{
    return m_isInitialized;
}

void RoadPositionChoice::initializeChildren()
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>().initializeChildren();
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }
}

::nds::road::reference::types::RoadValidityType RoadPositionChoice::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RoadPositionChoice' is not initialized!");

    return m_type_;
}

::nds::core::geometry::CoordShift RoadPositionChoice::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'RoadPositionChoice' is not initialized!");

    return m_shift_;
}

::nds::road::reference::types::RoadValidityPosition& RoadPositionChoice::getValidityPosition()
{
    return m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>();
}

const ::nds::road::reference::types::RoadValidityPosition& RoadPositionChoice::getValidityPosition() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>();
}

void RoadPositionChoice::setValidityPosition(const ::nds::road::reference::types::RoadValidityPosition& validityPosition_)
{
    m_objectChoice = validityPosition_;
}

void RoadPositionChoice::setValidityPosition(::nds::road::reference::types::RoadValidityPosition&& validityPosition_)
{
    m_objectChoice = ::std::move(validityPosition_);
}

::nds::road::reference::types::RoadLengthPosition& RoadPositionChoice::getLengthPosition()
{
    return m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>();
}

const ::nds::road::reference::types::RoadLengthPosition& RoadPositionChoice::getLengthPosition() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>();
}

void RoadPositionChoice::setLengthPosition(const ::nds::road::reference::types::RoadLengthPosition& lengthPosition_)
{
    m_objectChoice = lengthPosition_;
}

void RoadPositionChoice::setLengthPosition(::nds::road::reference::types::RoadLengthPosition&& lengthPosition_)
{
    m_objectChoice = ::std::move(lengthPosition_);
}

::nds::road::reference::types::RoadGeometryPosition RoadPositionChoice::getGeometryPosition() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>();
}

void RoadPositionChoice::setGeometryPosition(::nds::road::reference::types::RoadGeometryPosition geometryPosition_)
{
    m_objectChoice = geometryPosition_;
}

::nds::road::reference::types::RoadGeometryOffsetPosition& RoadPositionChoice::getGeometryOffsetPosition()
{
    return m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>();
}

const ::nds::road::reference::types::RoadGeometryOffsetPosition& RoadPositionChoice::getGeometryOffsetPosition() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>();
}

void RoadPositionChoice::setGeometryOffsetPosition(const ::nds::road::reference::types::RoadGeometryOffsetPosition& geometryOffsetPosition_)
{
    m_objectChoice = geometryOffsetPosition_;
}

void RoadPositionChoice::setGeometryOffsetPosition(::nds::road::reference::types::RoadGeometryOffsetPosition&& geometryOffsetPosition_)
{
    m_objectChoice = ::std::move(geometryOffsetPosition_);
}

::nds::road::reference::types::RoadPercentagePosition& RoadPositionChoice::getPercentagePosition()
{
    return m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>();
}

const ::nds::road::reference::types::RoadPercentagePosition& RoadPositionChoice::getPercentagePosition() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>();
}

void RoadPositionChoice::setPercentagePosition(const ::nds::road::reference::types::RoadPercentagePosition& percentagePosition_)
{
    m_objectChoice = percentagePosition_;
}

void RoadPositionChoice::setPercentagePosition(::nds::road::reference::types::RoadPercentagePosition&& percentagePosition_)
{
    m_objectChoice = ::std::move(percentagePosition_);
}

RoadPositionChoice::ChoiceTag RoadPositionChoice::choiceTag() const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return UNDEFINED_CHOICE;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return CHOICE_validityPosition;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return CHOICE_lengthPosition;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return CHOICE_geometryPosition;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return CHOICE_geometryOffsetPosition;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return CHOICE_percentagePosition;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RoadPositionChoice::initPackingContext(RoadPositionChoice::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().initPackingContext(context.getValidityPosition());
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>().initPackingContext(context.getLengthPosition());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        context.getGeometryPosition().init<::zserio::VarSizeArrayTraits>(m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().initPackingContext(context.getGeometryOffsetPosition());
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>().initPackingContext(context.getPercentagePosition());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }
}

size_t RoadPositionChoice::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        endBitPosition += ::zserio::bitSizeOfVarSize(m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t RoadPositionChoice::bitSizeOf(RoadPositionChoice::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().bitSizeOf(context.getValidityPosition(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>().bitSizeOf(context.getLengthPosition(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        endBitPosition += context.getGeometryPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().bitSizeOf(context.getGeometryOffsetPosition(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>().bitSizeOf(context.getPercentagePosition(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t RoadPositionChoice::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        endBitPosition += ::zserio::bitSizeOfVarSize(m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }

    return endBitPosition;
}

size_t RoadPositionChoice::initializeOffsets(RoadPositionChoice::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().initializeOffsets(context.getValidityPosition(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>().initializeOffsets(context.getLengthPosition(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        endBitPosition += context.getGeometryPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().initializeOffsets(context.getGeometryOffsetPosition(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>().initializeOffsets(context.getPercentagePosition(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }

    return endBitPosition;
}

bool RoadPositionChoice::operator==(const RoadPositionChoice& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType())||
            !(getShift() == other.getShift()))
        return false;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return true; // empty
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>() == other.m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>());
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>() == other.m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>());
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>() == other.m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>());
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>() == other.m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>());
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>() == other.m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }
}

uint32_t RoadPositionChoice::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getShift());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::road::reference::types::RoadValidityType::COMPLETE:
            // empty
            break;
        case ::nds::road::reference::types::RoadValidityType::POSITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>());
            break;
        case ::nds::road::reference::types::RoadValidityType::LENGTH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>());
            break;
        case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>());
            break;
        case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>());
            break;
        case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RoadPositionChoice::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        // check parameters
        if (m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadPositionChoice.validityPosition: ") <<
                    m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().write(out);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>().write(out);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        out.writeVarSize(m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadPositionChoice.geometryOffsetPosition: ") <<
                    m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().write(out);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }
}

void RoadPositionChoice::write(RoadPositionChoice::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        // check parameters
        if (m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadPositionChoice.validityPosition: ") <<
                    m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::road::reference::types::RoadValidityPosition>().write(context.getValidityPosition(), out);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        m_objectChoice.get<::nds::road::reference::types::RoadLengthPosition>().write(context.getLengthPosition(), out);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        context.getGeometryPosition().write<::zserio::VarSizeArrayTraits>(out, m_objectChoice.get<::nds::road::reference::types::RoadGeometryPosition>());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadPositionChoice.geometryOffsetPosition: ") <<
                    m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetPosition>().write(context.getGeometryOffsetPosition(), out);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::road::reference::types::RoadPercentagePosition>().write(context.getPercentagePosition(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }
}

::zserio::AnyHolder<> RoadPositionChoice::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadValidityPosition(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadLengthPosition(in, allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(static_cast<::nds::road::reference::types::RoadGeometryPosition>(in.readVarSize()), allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadGeometryOffsetPosition(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadPercentagePosition(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }
}

::zserio::AnyHolder<> RoadPositionChoice::readObject(RoadPositionChoice::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadValidityPosition(context.getValidityPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadLengthPosition(context.getLengthPosition(), in, allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(context.getGeometryPosition().read<::zserio::VarSizeArrayTraits>(in), allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadGeometryOffsetPosition(context.getGeometryOffsetPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadPercentagePosition(context.getPercentagePosition(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }
}

::zserio::AnyHolder<> RoadPositionChoice::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadValidityPosition>(m_objectChoice, allocator);
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadLengthPosition>(m_objectChoice, allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadGeometryPosition>(m_objectChoice, allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadGeometryOffsetPosition>(m_objectChoice, allocator);
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadPercentagePosition>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadPositionChoice!");
    }
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/types/RoadRangeChoice.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace types
{

RoadRangeChoice::RoadRangeChoice(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RoadRangeChoice::RoadRangeChoice(::zserio::BitStreamReader& in,
        ::nds::road::reference::types::RoadValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RoadRangeChoice::RoadRangeChoice(RoadRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::road::reference::types::RoadValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RoadRangeChoice::RoadRangeChoice(const RoadRangeChoice& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

RoadRangeChoice& RoadRangeChoice::operator=(const RoadRangeChoice& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadRangeChoice::RoadRangeChoice(RoadRangeChoice&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

RoadRangeChoice& RoadRangeChoice::operator=(RoadRangeChoice&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadRangeChoice::RoadRangeChoice(::zserio::PropagateAllocatorT,
        const RoadRangeChoice& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

void RoadRangeChoice::initialize(
        ::nds::road::reference::types::RoadValidityType type_,
        ::nds::core::geometry::CoordShift shift_)
{
    m_type_ = type_;
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoadRangeChoice::isInitialized() const
{
    return m_isInitialized;
}

void RoadRangeChoice::initializeChildren()
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>().initializeChildren();
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        break;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }
}

::nds::road::reference::types::RoadValidityType RoadRangeChoice::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RoadRangeChoice' is not initialized!");

    return m_type_;
}

::nds::core::geometry::CoordShift RoadRangeChoice::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'RoadRangeChoice' is not initialized!");

    return m_shift_;
}

::nds::road::reference::types::RoadValidityRange& RoadRangeChoice::getValidityRange()
{
    return m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>();
}

const ::nds::road::reference::types::RoadValidityRange& RoadRangeChoice::getValidityRange() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>();
}

void RoadRangeChoice::setValidityRange(const ::nds::road::reference::types::RoadValidityRange& validityRange_)
{
    m_objectChoice = validityRange_;
}

void RoadRangeChoice::setValidityRange(::nds::road::reference::types::RoadValidityRange&& validityRange_)
{
    m_objectChoice = ::std::move(validityRange_);
}

::nds::road::reference::types::RoadLengthRange& RoadRangeChoice::getLengthRange()
{
    return m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>();
}

const ::nds::road::reference::types::RoadLengthRange& RoadRangeChoice::getLengthRange() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>();
}

void RoadRangeChoice::setLengthRange(const ::nds::road::reference::types::RoadLengthRange& lengthRange_)
{
    m_objectChoice = lengthRange_;
}

void RoadRangeChoice::setLengthRange(::nds::road::reference::types::RoadLengthRange&& lengthRange_)
{
    m_objectChoice = ::std::move(lengthRange_);
}

::nds::road::reference::types::RoadGeometryRange& RoadRangeChoice::getGeometryRange()
{
    return m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>();
}

const ::nds::road::reference::types::RoadGeometryRange& RoadRangeChoice::getGeometryRange() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>();
}

void RoadRangeChoice::setGeometryRange(const ::nds::road::reference::types::RoadGeometryRange& geometryRange_)
{
    m_objectChoice = geometryRange_;
}

void RoadRangeChoice::setGeometryRange(::nds::road::reference::types::RoadGeometryRange&& geometryRange_)
{
    m_objectChoice = ::std::move(geometryRange_);
}

::nds::road::reference::types::RoadGeometryOffsetRange& RoadRangeChoice::getGeometryOffsetRange()
{
    return m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>();
}

const ::nds::road::reference::types::RoadGeometryOffsetRange& RoadRangeChoice::getGeometryOffsetRange() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>();
}

void RoadRangeChoice::setGeometryOffsetRange(const ::nds::road::reference::types::RoadGeometryOffsetRange& geometryOffsetRange_)
{
    m_objectChoice = geometryOffsetRange_;
}

void RoadRangeChoice::setGeometryOffsetRange(::nds::road::reference::types::RoadGeometryOffsetRange&& geometryOffsetRange_)
{
    m_objectChoice = ::std::move(geometryOffsetRange_);
}

::nds::road::reference::types::RoadPercentageRange& RoadRangeChoice::getPercentageRange()
{
    return m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>();
}

const ::nds::road::reference::types::RoadPercentageRange& RoadRangeChoice::getPercentageRange() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>();
}

void RoadRangeChoice::setPercentageRange(const ::nds::road::reference::types::RoadPercentageRange& percentageRange_)
{
    m_objectChoice = percentageRange_;
}

void RoadRangeChoice::setPercentageRange(::nds::road::reference::types::RoadPercentageRange&& percentageRange_)
{
    m_objectChoice = ::std::move(percentageRange_);
}

::nds::road::reference::types::RoadLengthExtent RoadRangeChoice::getRoadLengthExtent() const
{
    return m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>();
}

void RoadRangeChoice::setRoadLengthExtent(::nds::road::reference::types::RoadLengthExtent roadLengthExtent_)
{
    m_objectChoice = roadLengthExtent_;
}

RoadRangeChoice::ChoiceTag RoadRangeChoice::choiceTag() const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return UNDEFINED_CHOICE;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return CHOICE_validityRange;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return CHOICE_lengthRange;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return CHOICE_geometryRange;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return CHOICE_geometryOffsetRange;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return CHOICE_percentageRange;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        return CHOICE_roadLengthExtent;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RoadRangeChoice::initPackingContext(RoadRangeChoice::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().initPackingContext(context.getValidityRange());
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>().initPackingContext(context.getLengthRange());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>().initPackingContext(context.getGeometryRange());
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().initPackingContext(context.getGeometryOffsetRange());
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>().initPackingContext(context.getPercentageRange());
        break;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        context.getRoadLengthExtent().init<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLengthExtent>>(m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }
}

size_t RoadRangeChoice::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t RoadRangeChoice::bitSizeOf(RoadRangeChoice::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().bitSizeOf(context.getValidityRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>().bitSizeOf(context.getLengthRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>().bitSizeOf(context.getGeometryRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().bitSizeOf(context.getGeometryOffsetRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>().bitSizeOf(context.getPercentageRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        endBitPosition += context.getRoadLengthExtent().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLengthExtent>>(m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t RoadRangeChoice::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }

    return endBitPosition;
}

size_t RoadRangeChoice::initializeOffsets(RoadRangeChoice::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().initializeOffsets(context.getValidityRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>().initializeOffsets(context.getLengthRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>().initializeOffsets(context.getGeometryRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().initializeOffsets(context.getGeometryOffsetRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>().initializeOffsets(context.getPercentageRange(), endBitPosition);
        break;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        endBitPosition += context.getRoadLengthExtent().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLengthExtent>>(m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }

    return endBitPosition;
}

bool RoadRangeChoice::operator==(const RoadRangeChoice& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType())||
            !(getShift() == other.getShift()))
        return false;

    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return true; // empty
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>() == other.m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>());
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>() == other.m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>());
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>() == other.m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>());
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>() == other.m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>());
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>() == other.m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>());
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>() == other.m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }
}

uint32_t RoadRangeChoice::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getShift());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::road::reference::types::RoadValidityType::COMPLETE:
            // empty
            break;
        case ::nds::road::reference::types::RoadValidityType::POSITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>());
            break;
        case ::nds::road::reference::types::RoadValidityType::LENGTH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>());
            break;
        case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>());
            break;
        case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>());
            break;
        case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>());
            break;
        case ::nds::road::reference::types::RoadValidityType::EXTENT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RoadRangeChoice::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        // check parameters
        if (m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadRangeChoice.validityRange: ") <<
                    m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().write(out);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>().write(out);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>().write(out);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadRangeChoice.geometryOffsetRange: ") <<
                    m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().write(out);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>().write(out);
        break;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        out.writeVarUInt32(m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }
}

void RoadRangeChoice::write(RoadRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        // check parameters
        if (m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadRangeChoice.validityRange: ") <<
                    m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::road::reference::types::RoadValidityRange>().write(context.getValidityRange(), out);
        break;
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        m_objectChoice.get<::nds::road::reference::types::RoadLengthRange>().write(context.getLengthRange(), out);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryRange>().write(context.getGeometryRange(), out);
        break;
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadRangeChoice.geometryOffsetRange: ") <<
                    m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::road::reference::types::RoadGeometryOffsetRange>().write(context.getGeometryOffsetRange(), out);
        break;
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::road::reference::types::RoadPercentageRange>().write(context.getPercentageRange(), out);
        break;
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        context.getRoadLengthExtent().write<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLengthExtent>>(out, m_objectChoice.get<::nds::road::reference::types::RoadLengthExtent>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }
}

::zserio::AnyHolder<> RoadRangeChoice::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadValidityRange(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadLengthRange(in, allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadGeometryRange(in, allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadGeometryOffsetRange(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadPercentageRange(in, allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        return ::zserio::AnyHolder<>(static_cast<::nds::road::reference::types::RoadLengthExtent>(in.readVarUInt32()), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }
}

::zserio::AnyHolder<> RoadRangeChoice::readObject(RoadRangeChoice::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadValidityRange(context.getValidityRange(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadLengthRange(context.getLengthRange(), in, allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadGeometryRange(context.getGeometryRange(), in, allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadGeometryOffsetRange(context.getGeometryOffsetRange(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::road::reference::types::RoadPercentageRange(context.getPercentageRange(), in, allocator), allocator);
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        return ::zserio::AnyHolder<>(context.getRoadLengthExtent().read<::zserio::VarIntNNArrayTraits<::nds::road::reference::types::RoadLengthExtent>>(in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }
}

::zserio::AnyHolder<> RoadRangeChoice::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::road::reference::types::RoadValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::road::reference::types::RoadValidityType::POSITION:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadValidityRange>(m_objectChoice, allocator);
    case ::nds::road::reference::types::RoadValidityType::LENGTH:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadLengthRange>(m_objectChoice, allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadGeometryRange>(m_objectChoice, allocator);
    case ::nds::road::reference::types::RoadValidityType::GEOMETRY_OFFSET:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadGeometryOffsetRange>(m_objectChoice, allocator);
    case ::nds::road::reference::types::RoadValidityType::PERCENTAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadPercentageRange>(m_objectChoice, allocator);
    case ::nds::road::reference::types::RoadValidityType::EXTENT:
        return ::zserio::allocatorPropagatingCopy<::nds::road::reference::types::RoadLengthExtent>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadRangeChoice!");
    }
}

} // namespace types
} // namespace reference
} // namespace road
} // namespace nds
