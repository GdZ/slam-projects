/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/road/reference/location/RoadLocationRangeValidityType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadLocationRangeValidityType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::road::reference::location::RoadLocationRangeValidityType>::names;
constexpr ::std::array<::nds::road::reference::location::RoadLocationRangeValidityType, 2> EnumTraits<::nds::road::reference::location::RoadLocationRangeValidityType>::values;
constexpr const char* EnumTraits<::nds::road::reference::location::RoadLocationRangeValidityType>::enumName;

template <>
size_t enumToOrdinal(::nds::road::reference::location::RoadLocationRangeValidityType value)
{
    switch (value)
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        return 0;
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadLocationRangeValidityType: ") <<
                static_cast<typename ::std::underlying_type<::nds::road::reference::location::RoadLocationRangeValidityType>::type>(value) << "!";
    }
}

template <>
::nds::road::reference::location::RoadLocationRangeValidityType valueToEnum(
        typename ::std::underlying_type<::nds::road::reference::location::RoadLocationRangeValidityType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::road::reference::location::RoadLocationRangeValidityType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadLocationRangeValidityType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::road::reference::location::RoadLocationRangeValidityType>(::nds::road::reference::location::RoadLocationRangeValidityType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::road::reference::location::RoadLocationRangeValidityType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::location::RoadLocationRangeValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::road::reference::location::RoadLocationRangeValidityType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::road::reference::location::RoadLocationRangeValidityType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::location::RoadLocationRangeValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::road::reference::location::RoadLocationRangeValidityType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::road::reference::location::RoadLocationRangeValidityType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::road::reference::location::RoadLocationRangeValidityType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::reference::location::RoadLocationRangeValidityType>(
            static_cast<typename ::std::underlying_type<::nds::road::reference::location::RoadLocationRangeValidityType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::road::reference::location::RoadLocationRangeValidityType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::reference::location::RoadLocationRangeValidityType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::location::RoadLocationRangeValidityType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::road::reference::location::RoadLocationRangeValidityType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::road::reference::location::RoadLocationRangeValidityType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::reference::location::RoadLocationRangeValidityType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/location/RoadLocationReference.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace location
{

RoadLocationReference::RoadLocationReference(const allocator_type& allocator) noexcept :
        m_direction_(::nds::core::types::Direction()),
        m_locationId_(allocator)
{
}

RoadLocationReference::RoadLocationReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_direction_(readDirection(in)),
        m_locationId_(readLocationId(in, allocator))
{
}

RoadLocationReference::RoadLocationReference(RoadLocationReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_direction_(readDirection(context, in)),
        m_locationId_(readLocationId(context, in, allocator))
{
}

RoadLocationReference::RoadLocationReference(::zserio::PropagateAllocatorT,
        const RoadLocationReference& other, const allocator_type& allocator) :
        m_direction_(::zserio::allocatorPropagatingCopy(other.m_direction_, allocator)),
        m_locationId_(::zserio::allocatorPropagatingCopy(other.m_locationId_, allocator))
{
}

::nds::core::types::Direction RoadLocationReference::getDirection() const
{
    return m_direction_;
}

void RoadLocationReference::setDirection(::nds::core::types::Direction direction_)
{
    m_direction_ = direction_;
}

::nds::core::location::RoadLocationId& RoadLocationReference::getLocationId()
{
    return m_locationId_;
}

const ::nds::core::location::RoadLocationId& RoadLocationReference::getLocationId() const
{
    return m_locationId_;
}

void RoadLocationReference::setLocationId(const ::nds::core::location::RoadLocationId& locationId_)
{
    m_locationId_ = locationId_;
}

void RoadLocationReference::setLocationId(::nds::core::location::RoadLocationId&& locationId_)
{
    m_locationId_ = ::std::move(locationId_);
}

void RoadLocationReference::initPackingContext(RoadLocationReference::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getDirection(), m_direction_);
    m_locationId_.initPackingContext(context.getLocationId());
}

size_t RoadLocationReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_direction_);
    endBitPosition += m_locationId_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLocationReference::bitSizeOf(RoadLocationReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getDirection(), m_direction_);
    endBitPosition += m_locationId_.bitSizeOf(context.getLocationId(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLocationReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_direction_);
    endBitPosition = m_locationId_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadLocationReference::initializeOffsets(RoadLocationReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getDirection(), endBitPosition,
        m_direction_);
    endBitPosition = m_locationId_.initializeOffsets(context.getLocationId(), endBitPosition);

    return endBitPosition;
}

bool RoadLocationReference::operator==(const RoadLocationReference& other) const
{
    if (this != &other)
    {
        return
                (m_direction_ == other.m_direction_) &&
                (m_locationId_ == other.m_locationId_);
    }

    return true;
}

uint32_t RoadLocationReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_direction_);
    result = ::zserio::calcHashCode(result, m_locationId_);

    return result;
}

void RoadLocationReference::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_direction_);
    m_locationId_.write(out);
}

void RoadLocationReference::write(RoadLocationReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getDirection(), out, m_direction_);
    m_locationId_.write(context.getLocationId(), out);
}

::nds::core::types::Direction RoadLocationReference::readDirection(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::Direction>(in);
}

::nds::core::types::Direction RoadLocationReference::readDirection(RoadLocationReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::Direction>(context.getDirection(), in);
}
::nds::core::location::RoadLocationId RoadLocationReference::readLocationId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(in, allocator);
}

::nds::core::location::RoadLocationId RoadLocationReference::readLocationId(RoadLocationReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(context.getLocationId(), in, allocator);
}

} // namespace location
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/location/RoadLocationTransitionReference.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace location
{

RoadLocationTransitionReference::RoadLocationTransitionReference(const allocator_type& allocator) noexcept :
        m_startLocation_(allocator),
        m_endLocation_(allocator),
        m_intermediateLocations_(::zserio::NullOpt)
{
}

RoadLocationTransitionReference::RoadLocationTransitionReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_startLocation_(readStartLocation(in, allocator)),
        m_endLocation_(readEndLocation(in, allocator)),
        m_intermediateLocations_(readIntermediateLocations(in, allocator))
{
}

RoadLocationTransitionReference::RoadLocationTransitionReference(RoadLocationTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_startLocation_(readStartLocation(context, in, allocator)),
        m_endLocation_(readEndLocation(context, in, allocator)),
        m_intermediateLocations_(readIntermediateLocations(context, in, allocator))
{
}

RoadLocationTransitionReference::RoadLocationTransitionReference(::zserio::PropagateAllocatorT,
        const RoadLocationTransitionReference& other, const allocator_type& allocator) :
        m_startLocation_(::zserio::allocatorPropagatingCopy(other.m_startLocation_, allocator)),
        m_endLocation_(::zserio::allocatorPropagatingCopy(other.m_endLocation_, allocator)),
        m_intermediateLocations_(::zserio::allocatorPropagatingCopy(other.m_intermediateLocations_, allocator))
{
}

::nds::core::location::RoadLocationId& RoadLocationTransitionReference::getStartLocation()
{
    return m_startLocation_;
}

const ::nds::core::location::RoadLocationId& RoadLocationTransitionReference::getStartLocation() const
{
    return m_startLocation_;
}

void RoadLocationTransitionReference::setStartLocation(const ::nds::core::location::RoadLocationId& startLocation_)
{
    m_startLocation_ = startLocation_;
}

void RoadLocationTransitionReference::setStartLocation(::nds::core::location::RoadLocationId&& startLocation_)
{
    m_startLocation_ = ::std::move(startLocation_);
}

::nds::core::location::RoadLocationId& RoadLocationTransitionReference::getEndLocation()
{
    return m_endLocation_;
}

const ::nds::core::location::RoadLocationId& RoadLocationTransitionReference::getEndLocation() const
{
    return m_endLocation_;
}

void RoadLocationTransitionReference::setEndLocation(const ::nds::core::location::RoadLocationId& endLocation_)
{
    m_endLocation_ = endLocation_;
}

void RoadLocationTransitionReference::setEndLocation(::nds::core::location::RoadLocationId&& endLocation_)
{
    m_endLocation_ = ::std::move(endLocation_);
}

::zserio::vector<::nds::core::location::RoadLocationId>& RoadLocationTransitionReference::getIntermediateLocations()
{
    return m_intermediateLocations_.value().getRawArray();
}

const ::zserio::vector<::nds::core::location::RoadLocationId>& RoadLocationTransitionReference::getIntermediateLocations() const
{
    return m_intermediateLocations_.value().getRawArray();
}

void RoadLocationTransitionReference::setIntermediateLocations(const ::zserio::vector<::nds::core::location::RoadLocationId>& intermediateLocations_)
{
    m_intermediateLocations_ = ZserioArrayType_intermediateLocations(intermediateLocations_);
}

void RoadLocationTransitionReference::setIntermediateLocations(::zserio::vector<::nds::core::location::RoadLocationId>&& intermediateLocations_)
{
    m_intermediateLocations_ = ZserioArrayType_intermediateLocations(std::move(intermediateLocations_));
}

bool RoadLocationTransitionReference::isIntermediateLocationsUsed() const
{
    return (isIntermediateLocationsSet());
}

bool RoadLocationTransitionReference::isIntermediateLocationsSet() const
{
    return m_intermediateLocations_.hasValue();
}

void RoadLocationTransitionReference::resetIntermediateLocations()
{
    m_intermediateLocations_.reset();
}

void RoadLocationTransitionReference::initPackingContext(RoadLocationTransitionReference::ZserioPackingContext& context) const
{
    m_startLocation_.initPackingContext(context.getStartLocation());
    m_endLocation_.initPackingContext(context.getEndLocation());
}

size_t RoadLocationTransitionReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startLocation_.bitSizeOf(endBitPosition);
    endBitPosition += m_endLocation_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isIntermediateLocationsSet())
    {
        endBitPosition += m_intermediateLocations_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadLocationTransitionReference::bitSizeOf(RoadLocationTransitionReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startLocation_.bitSizeOf(context.getStartLocation(), endBitPosition);
    endBitPosition += m_endLocation_.bitSizeOf(context.getEndLocation(), endBitPosition);
    endBitPosition += 1;
    if (isIntermediateLocationsSet())
    {
        endBitPosition += m_intermediateLocations_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadLocationTransitionReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startLocation_.initializeOffsets(endBitPosition);
    endBitPosition = m_endLocation_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isIntermediateLocationsSet())
    {
        endBitPosition = m_intermediateLocations_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t RoadLocationTransitionReference::initializeOffsets(RoadLocationTransitionReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startLocation_.initializeOffsets(context.getStartLocation(), endBitPosition);
    endBitPosition = m_endLocation_.initializeOffsets(context.getEndLocation(), endBitPosition);
    endBitPosition += 1;
    if (isIntermediateLocationsSet())
    {
        endBitPosition = m_intermediateLocations_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool RoadLocationTransitionReference::operator==(const RoadLocationTransitionReference& other) const
{
    if (this != &other)
    {
        return
                (m_startLocation_ == other.m_startLocation_) &&
                (m_endLocation_ == other.m_endLocation_) &&
                (!isIntermediateLocationsUsed() ? !other.isIntermediateLocationsUsed() : (m_intermediateLocations_ == other.m_intermediateLocations_));
    }

    return true;
}

uint32_t RoadLocationTransitionReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_startLocation_);
    result = ::zserio::calcHashCode(result, m_endLocation_);
    if (isIntermediateLocationsUsed())
        result = ::zserio::calcHashCode(result, m_intermediateLocations_);

    return result;
}

void RoadLocationTransitionReference::write(::zserio::BitStreamWriter& out) const
{
    m_startLocation_.write(out);
    m_endLocation_.write(out);
    if (isIntermediateLocationsSet())
    {
        out.writeBool(true);
        m_intermediateLocations_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoadLocationTransitionReference::write(RoadLocationTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_startLocation_.write(context.getStartLocation(), out);
    m_endLocation_.write(context.getEndLocation(), out);
    if (isIntermediateLocationsSet())
    {
        out.writeBool(true);
        m_intermediateLocations_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoadLocationTransitionReference::ZserioElementFactory_intermediateLocations::create(RoadLocationTransitionReference&        ,
        ::zserio::vector<::nds::core::location::RoadLocationId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoadLocationTransitionReference::ZserioElementFactory_intermediateLocations::create(RoadLocationTransitionReference&        ,
        ::zserio::vector<::nds::core::location::RoadLocationId>& array,
        ::nds::core::location::RoadLocationId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::location::RoadLocationId RoadLocationTransitionReference::readStartLocation(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(in, allocator);
}

::nds::core::location::RoadLocationId RoadLocationTransitionReference::readStartLocation(RoadLocationTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(context.getStartLocation(), in, allocator);
}
::nds::core::location::RoadLocationId RoadLocationTransitionReference::readEndLocation(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(in, allocator);
}

::nds::core::location::RoadLocationId RoadLocationTransitionReference::readEndLocation(RoadLocationTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(context.getEndLocation(), in, allocator);
}
::zserio::InplaceOptionalHolder<RoadLocationTransitionReference::ZserioArrayType_intermediateLocations> RoadLocationTransitionReference::readIntermediateLocations(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_intermediateLocations readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_intermediateLocations>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_intermediateLocations>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoadLocationTransitionReference::ZserioArrayType_intermediateLocations> RoadLocationTransitionReference::readIntermediateLocations(RoadLocationTransitionReference::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_intermediateLocations readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_intermediateLocations>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_intermediateLocations>(::zserio::NullOpt);
}

} // namespace location
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/road/reference/location/RoadLocationRangeValidity.h>
#include <nds/road/reference/location/RoadLocationRangeValidityType.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace location
{

RoadLocationRangeValidity::RoadLocationRangeValidity(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_type_(::nds::road::reference::location::RoadLocationRangeValidityType()),
        m_numRanges_(::zserio::NullOpt),
        m_ranges_(::zserio::NullOpt)
{
}

RoadLocationRangeValidity::RoadLocationRangeValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(in)),
        m_numRanges_(readNumRanges(in)),
        m_ranges_(readRanges(in, allocator))
{
}

RoadLocationRangeValidity::RoadLocationRangeValidity(RoadLocationRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(context, in)),
        m_numRanges_(readNumRanges(context, in)),
        m_ranges_(readRanges(context, in, allocator))
{
}

RoadLocationRangeValidity::RoadLocationRangeValidity(const RoadLocationRangeValidity& other) :
        m_type_(other.m_type_),
        m_numRanges_(other.m_numRanges_),
        m_ranges_(other.m_ranges_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadLocationRangeValidity& RoadLocationRangeValidity::operator=(const RoadLocationRangeValidity& other)
{
    m_type_ = other.m_type_;
    m_numRanges_ = other.m_numRanges_;
    m_ranges_ = other.m_ranges_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadLocationRangeValidity::RoadLocationRangeValidity(RoadLocationRangeValidity&& other) :
        m_type_(::std::move(other.m_type_)),
        m_numRanges_(::std::move(other.m_numRanges_)),
        m_ranges_(::std::move(other.m_ranges_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadLocationRangeValidity& RoadLocationRangeValidity::operator=(RoadLocationRangeValidity&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_numRanges_ = ::std::move(other.m_numRanges_);
    m_ranges_ = ::std::move(other.m_ranges_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadLocationRangeValidity::RoadLocationRangeValidity(::zserio::PropagateAllocatorT,
        const RoadLocationRangeValidity& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_numRanges_(::zserio::allocatorPropagatingCopy(other.m_numRanges_, allocator)),
        m_ranges_(::zserio::allocatorPropagatingCopy(other.m_ranges_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void RoadLocationRangeValidity::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoadLocationRangeValidity::isInitialized() const
{
    return m_isInitialized;
}

void RoadLocationRangeValidity::initializeChildren()
{
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
        m_ranges_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift RoadLocationRangeValidity::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'RoadLocationRangeValidity' is not initialized!");

    return m_shift_;
}

::nds::road::reference::location::RoadLocationRangeValidityType RoadLocationRangeValidity::getType() const
{
    return m_type_;
}

void RoadLocationRangeValidity::setType(::nds::road::reference::location::RoadLocationRangeValidityType type_)
{
    m_type_ = type_;
}

uint32_t RoadLocationRangeValidity::getNumRanges() const
{
    return m_numRanges_.value();
}

void RoadLocationRangeValidity::setNumRanges(uint32_t numRanges_)
{
    m_numRanges_ = numRanges_;
}

bool RoadLocationRangeValidity::isNumRangesUsed() const
{
    return (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE);
}

bool RoadLocationRangeValidity::isNumRangesSet() const
{
    return m_numRanges_.hasValue();
}

void RoadLocationRangeValidity::resetNumRanges()
{
    m_numRanges_.reset();
}

::zserio::vector<::nds::road::reference::location::RoadLocationRangeChoice>& RoadLocationRangeValidity::getRanges()
{
    return m_ranges_.value().getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeChoice>& RoadLocationRangeValidity::getRanges() const
{
    return m_ranges_.value().getRawArray();
}

void RoadLocationRangeValidity::setRanges(const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeChoice>& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(ranges_);
}

void RoadLocationRangeValidity::setRanges(::zserio::vector<::nds::road::reference::location::RoadLocationRangeChoice>&& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(std::move(ranges_));
}

bool RoadLocationRangeValidity::isRangesUsed() const
{
    return (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE);
}

bool RoadLocationRangeValidity::isRangesSet() const
{
    return m_ranges_.hasValue();
}

void RoadLocationRangeValidity::resetRanges()
{
    m_ranges_.reset();
}

void RoadLocationRangeValidity::initPackingContext(RoadLocationRangeValidity::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        context.getNumRanges().init<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
}

size_t RoadLocationRangeValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numRanges_.value());
    }
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        endBitPosition += m_ranges_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadLocationRangeValidity::bitSizeOf(RoadLocationRangeValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        endBitPosition += context.getNumRanges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        endBitPosition += m_ranges_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadLocationRangeValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numRanges_.value());
    }
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        endBitPosition = m_ranges_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t RoadLocationRangeValidity::initializeOffsets(RoadLocationRangeValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        endBitPosition += context.getNumRanges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        endBitPosition = m_ranges_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool RoadLocationRangeValidity::operator==(const RoadLocationRangeValidity& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_type_ == other.m_type_) &&
                (!isNumRangesUsed() ? !other.isNumRangesUsed() : (m_numRanges_ == other.m_numRanges_)) &&
                (!isRangesUsed() ? !other.isRangesUsed() : (m_ranges_ == other.m_ranges_));
    }

    return true;
}

uint32_t RoadLocationRangeValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_type_);
    if (isNumRangesUsed())
        result = ::zserio::calcHashCode(result, m_numRanges_);
    if (isRangesUsed())
        result = ::zserio::calcHashCode(result, m_ranges_);

    return result;
}

void RoadLocationRangeValidity::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        out.writeVarSize(m_numRanges_.value());
    }

    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        // check array length
        if (m_ranges_.value().getRawArray().size() != static_cast<size_t>(getNumRanges()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadLocationRangeValidity.ranges: ") <<
                    m_ranges_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRanges()) << "!";
        }
        m_ranges_.value().write(*this, out);
    }
}

void RoadLocationRangeValidity::write(RoadLocationRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        context.getNumRanges().write<::zserio::VarSizeArrayTraits>(out, m_numRanges_.value());
    }

    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        // check array length
        if (m_ranges_.value().getRawArray().size() != static_cast<size_t>(getNumRanges()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadLocationRangeValidity.ranges: ") <<
                    m_ranges_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRanges()) << "!";
        }
        m_ranges_.value().writePacked(*this, out);
    }
}

void RoadLocationRangeValidity::ZserioArrayExpressions_ranges::initializeElement(RoadLocationRangeValidity& owner,
        ::nds::road::reference::location::RoadLocationRangeChoice& element, size_t)
{
    element.initialize(static_cast<::nds::road::reference::location::RoadLocationRangeValidityType>(owner.getType()));
}

void RoadLocationRangeValidity::ZserioElementFactory_ranges::create(RoadLocationRangeValidity&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeChoice>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::road::reference::location::RoadLocationRangeValidityType>(owner.getType()), array.get_allocator());
}

void RoadLocationRangeValidity::ZserioElementFactory_ranges::create(RoadLocationRangeValidity&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeChoice>& array,
        ::nds::road::reference::location::RoadLocationRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::road::reference::location::RoadLocationRangeValidityType>(owner.getType()), array.get_allocator());
}

::nds::road::reference::location::RoadLocationRangeValidityType RoadLocationRangeValidity::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::reference::location::RoadLocationRangeValidityType>(in);
}

::nds::road::reference::location::RoadLocationRangeValidityType RoadLocationRangeValidity::readType(RoadLocationRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::reference::location::RoadLocationRangeValidityType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<uint32_t> RoadLocationRangeValidity::readNumRanges(::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> RoadLocationRangeValidity::readNumRanges(RoadLocationRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(context.getNumRanges().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<RoadLocationRangeValidity::ZserioArrayType_ranges> RoadLocationRangeValidity::readRanges(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        ZserioArrayType_ranges readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumRanges()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoadLocationRangeValidity::ZserioArrayType_ranges> RoadLocationRangeValidity::readRanges(RoadLocationRangeValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() != ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE)
    {
        ZserioArrayType_ranges readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumRanges()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::zserio::NullOpt);
}

} // namespace location
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/location/RoadLocationPositionValidity.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace location
{

RoadLocationPositionValidity::RoadLocationPositionValidity(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numPositions_(uint32_t()),
        m_positions_(allocator)
{
}

RoadLocationPositionValidity::RoadLocationPositionValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(in)),
        m_positions_(readPositions(in, allocator))
{
}

RoadLocationPositionValidity::RoadLocationPositionValidity(RoadLocationPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(context, in)),
        m_positions_(readPositions(context, in, allocator))
{
}

RoadLocationPositionValidity::RoadLocationPositionValidity(const RoadLocationPositionValidity& other) :
        m_numPositions_(other.m_numPositions_),
        m_positions_(other.m_positions_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadLocationPositionValidity& RoadLocationPositionValidity::operator=(const RoadLocationPositionValidity& other)
{
    m_numPositions_ = other.m_numPositions_;
    m_positions_ = other.m_positions_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadLocationPositionValidity::RoadLocationPositionValidity(RoadLocationPositionValidity&& other) :
        m_numPositions_(::std::move(other.m_numPositions_)),
        m_positions_(::std::move(other.m_positions_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RoadLocationPositionValidity& RoadLocationPositionValidity::operator=(RoadLocationPositionValidity&& other)
{
    m_numPositions_ = ::std::move(other.m_numPositions_);
    m_positions_ = ::std::move(other.m_positions_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RoadLocationPositionValidity::RoadLocationPositionValidity(::zserio::PropagateAllocatorT,
        const RoadLocationPositionValidity& other, const allocator_type& allocator) :
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator)),
        m_positions_(::zserio::allocatorPropagatingCopy(other.m_positions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void RoadLocationPositionValidity::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;
}

bool RoadLocationPositionValidity::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::CoordShift RoadLocationPositionValidity::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'RoadLocationPositionValidity' is not initialized!");

    return m_shift_;
}

uint32_t RoadLocationPositionValidity::getNumPositions() const
{
    return m_numPositions_;
}

void RoadLocationPositionValidity::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

::zserio::vector<::nds::core::location::RoadLocationIdPosition>& RoadLocationPositionValidity::getPositions()
{
    return m_positions_.getRawArray();
}

const ::zserio::vector<::nds::core::location::RoadLocationIdPosition>& RoadLocationPositionValidity::getPositions() const
{
    return m_positions_.getRawArray();
}

void RoadLocationPositionValidity::setPositions(const ::zserio::vector<::nds::core::location::RoadLocationIdPosition>& positions_)
{
    m_positions_ = ZserioArrayType_positions(positions_);
}

void RoadLocationPositionValidity::setPositions(::zserio::vector<::nds::core::location::RoadLocationIdPosition>&& positions_)
{
    m_positions_ = ZserioArrayType_positions(std::move(positions_));
}

void RoadLocationPositionValidity::initPackingContext(RoadLocationPositionValidity::ZserioPackingContext& context) const
{
    context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_);
}

size_t RoadLocationPositionValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLocationPositionValidity::bitSizeOf(RoadLocationPositionValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLocationPositionValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadLocationPositionValidity::initializeOffsets(RoadLocationPositionValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool RoadLocationPositionValidity::operator==(const RoadLocationPositionValidity& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_numPositions_ == other.m_numPositions_) &&
                (m_positions_ == other.m_positions_);
    }

    return true;
}

uint32_t RoadLocationPositionValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_numPositions_);
    result = ::zserio::calcHashCode(result, m_positions_);

    return result;
}

void RoadLocationPositionValidity::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadLocationPositionValidity.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.write(out);
}

void RoadLocationPositionValidity::write(RoadLocationPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadLocationPositionValidity.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(out);
}

uint32_t RoadLocationPositionValidity::readNumPositions(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoadLocationPositionValidity::readNumPositions(RoadLocationPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
}
RoadLocationPositionValidity::ZserioArrayType_positions RoadLocationPositionValidity::readPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.read(in, static_cast<size_t>(getNumPositions()));

    return readField;
}

RoadLocationPositionValidity::ZserioArrayType_positions RoadLocationPositionValidity::readPositions(RoadLocationPositionValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumPositions()));

    return readField;
}

} // namespace location
} // namespace reference
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/reference/location/RoadLocationRangeChoice.h>

namespace nds
{
namespace road
{
namespace reference
{
namespace location
{

RoadLocationRangeChoice::RoadLocationRangeChoice(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RoadLocationRangeChoice::RoadLocationRangeChoice(::zserio::BitStreamReader& in,
        ::nds::road::reference::location::RoadLocationRangeValidityType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RoadLocationRangeChoice::RoadLocationRangeChoice(RoadLocationRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::road::reference::location::RoadLocationRangeValidityType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RoadLocationRangeChoice::RoadLocationRangeChoice(const RoadLocationRangeChoice& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RoadLocationRangeChoice& RoadLocationRangeChoice::operator=(const RoadLocationRangeChoice& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RoadLocationRangeChoice::RoadLocationRangeChoice(RoadLocationRangeChoice&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RoadLocationRangeChoice& RoadLocationRangeChoice::operator=(RoadLocationRangeChoice&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RoadLocationRangeChoice::RoadLocationRangeChoice(::zserio::PropagateAllocatorT,
        const RoadLocationRangeChoice& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RoadLocationRangeChoice::initialize(
        ::nds::road::reference::location::RoadLocationRangeValidityType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RoadLocationRangeChoice::isInitialized() const
{
    return m_isInitialized;
}

::nds::road::reference::location::RoadLocationRangeValidityType RoadLocationRangeChoice::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RoadLocationRangeChoice' is not initialized!");

    return m_type_;
}

::nds::core::location::RoadLocationIdRange& RoadLocationRangeChoice::getRange()
{
    return m_objectChoice.get<::nds::core::location::RoadLocationIdRange>();
}

const ::nds::core::location::RoadLocationIdRange& RoadLocationRangeChoice::getRange() const
{
    return m_objectChoice.get<::nds::core::location::RoadLocationIdRange>();
}

void RoadLocationRangeChoice::setRange(const ::nds::core::location::RoadLocationIdRange& range_)
{
    m_objectChoice = range_;
}

void RoadLocationRangeChoice::setRange(::nds::core::location::RoadLocationIdRange&& range_)
{
    m_objectChoice = ::std::move(range_);
}

RoadLocationRangeChoice::ChoiceTag RoadLocationRangeChoice::choiceTag() const
{
    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        return UNDEFINED_CHOICE;
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        return CHOICE_range;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RoadLocationRangeChoice::initPackingContext(RoadLocationRangeChoice::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        m_objectChoice.get<::nds::core::location::RoadLocationIdRange>().initPackingContext(context.getRange());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }
}

size_t RoadLocationRangeChoice::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        endBitPosition += m_objectChoice.get<::nds::core::location::RoadLocationIdRange>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t RoadLocationRangeChoice::bitSizeOf(RoadLocationRangeChoice::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        endBitPosition += m_objectChoice.get<::nds::core::location::RoadLocationIdRange>().bitSizeOf(context.getRange(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t RoadLocationRangeChoice::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        endBitPosition = m_objectChoice.get<::nds::core::location::RoadLocationIdRange>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }

    return endBitPosition;
}

size_t RoadLocationRangeChoice::initializeOffsets(RoadLocationRangeChoice::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        endBitPosition = m_objectChoice.get<::nds::core::location::RoadLocationIdRange>().initializeOffsets(context.getRange(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }

    return endBitPosition;
}

bool RoadLocationRangeChoice::operator==(const RoadLocationRangeChoice& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        return true; // empty
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::location::RoadLocationIdRange>() == other.m_objectChoice.get<::nds::core::location::RoadLocationIdRange>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }
}

uint32_t RoadLocationRangeChoice::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
            // empty
            break;
        case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::location::RoadLocationIdRange>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RoadLocationRangeChoice::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        m_objectChoice.get<::nds::core::location::RoadLocationIdRange>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }
}

void RoadLocationRangeChoice::write(RoadLocationRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        // empty
        break;
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        m_objectChoice.get<::nds::core::location::RoadLocationIdRange>().write(context.getRange(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }
}

::zserio::AnyHolder<> RoadLocationRangeChoice::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        return ::zserio::AnyHolder<>(::nds::core::location::RoadLocationIdRange(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }
}

::zserio::AnyHolder<> RoadLocationRangeChoice::readObject(RoadLocationRangeChoice::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        return ::zserio::AnyHolder<>(::nds::core::location::RoadLocationIdRange(context.getRange(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }
}

::zserio::AnyHolder<> RoadLocationRangeChoice::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::road::reference::location::RoadLocationRangeValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::road::reference::location::RoadLocationRangeValidityType::RANGE:
        return ::zserio::allocatorPropagatingCopy<::nds::core::location::RoadLocationIdRange>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoadLocationRangeChoice!");
    }
}

} // namespace location
} // namespace reference
} // namespace road
} // namespace nds
