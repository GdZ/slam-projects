/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/road/layer/RoadLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace road
{
namespace layer
{

RoadLayer::RoadLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_coordShift_(::nds::core::geometry::CoordShift()),
        m_roadList_(allocator),
        m_intersectionList_(allocator)
{
}

RoadLayer::RoadLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_coordShift_(readCoordShift(in)),
        m_roadList_(readRoadList(in, allocator)),
        m_intersectionList_(readIntersectionList(in, allocator))
{
}

RoadLayer::RoadLayer(RoadLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_coordShift_(readCoordShift(context, in)),
        m_roadList_(readRoadList(context, in, allocator)),
        m_intersectionList_(readIntersectionList(context, in, allocator))
{
}

RoadLayer::RoadLayer(const RoadLayer& other) :
        m_coordShift_(other.m_coordShift_),
        m_roadList_(other.m_roadList_),
        m_intersectionList_(other.m_intersectionList_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLayer& RoadLayer::operator=(const RoadLayer& other)
{
    m_coordShift_ = other.m_coordShift_;
    m_roadList_ = other.m_roadList_;
    m_intersectionList_ = other.m_intersectionList_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLayer::RoadLayer(RoadLayer&& other) :
        m_coordShift_(::std::move(other.m_coordShift_)),
        m_roadList_(::std::move(other.m_roadList_)),
        m_intersectionList_(::std::move(other.m_intersectionList_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLayer& RoadLayer::operator=(RoadLayer&& other)
{
    m_coordShift_ = ::std::move(other.m_coordShift_);
    m_roadList_ = ::std::move(other.m_roadList_);
    m_intersectionList_ = ::std::move(other.m_intersectionList_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLayer::RoadLayer(::zserio::PropagateAllocatorT,
        const RoadLayer& other, const allocator_type& allocator) :
        m_coordShift_(::zserio::allocatorPropagatingCopy(other.m_coordShift_, allocator)),
        m_roadList_(::zserio::allocatorPropagatingCopy(other.m_roadList_, allocator)),
        m_intersectionList_(::zserio::allocatorPropagatingCopy(other.m_intersectionList_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadLayer::initializeChildren()
{
    m_intersectionList_.initialize(static_cast<::nds::core::geometry::CoordShift>(getCoordShift()));

    m_areChildrenInitialized = true;
}

::nds::core::geometry::CoordShift RoadLayer::getCoordShift() const
{
    return m_coordShift_;
}

void RoadLayer::setCoordShift(::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
}

::nds::road::road::RoadList& RoadLayer::getRoadList()
{
    return m_roadList_;
}

const ::nds::road::road::RoadList& RoadLayer::getRoadList() const
{
    return m_roadList_;
}

void RoadLayer::setRoadList(const ::nds::road::road::RoadList& roadList_)
{
    m_roadList_ = roadList_;
}

void RoadLayer::setRoadList(::nds::road::road::RoadList&& roadList_)
{
    m_roadList_ = ::std::move(roadList_);
}

::nds::road::road::IntersectionList& RoadLayer::getIntersectionList()
{
    return m_intersectionList_;
}

const ::nds::road::road::IntersectionList& RoadLayer::getIntersectionList() const
{
    return m_intersectionList_;
}

void RoadLayer::setIntersectionList(const ::nds::road::road::IntersectionList& intersectionList_)
{
    m_intersectionList_ = intersectionList_;
}

void RoadLayer::setIntersectionList(::nds::road::road::IntersectionList&& intersectionList_)
{
    m_intersectionList_ = ::std::move(intersectionList_);
}

::nds::system::types::LayerType RoadLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::FEATURE);
}

void RoadLayer::initPackingContext(RoadLayer::ZserioPackingContext& context) const
{
    context.getCoordShift().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShift_);
    m_roadList_.initPackingContext(context.getRoadList());
    m_intersectionList_.initPackingContext(context.getIntersectionList());
}

size_t RoadLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += m_roadList_.bitSizeOf(endBitPosition);
    endBitPosition += m_intersectionList_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLayer::bitSizeOf(RoadLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShift_);
    endBitPosition += m_roadList_.bitSizeOf(context.getRoadList(), endBitPosition);
    endBitPosition += m_intersectionList_.bitSizeOf(context.getIntersectionList(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition = m_roadList_.initializeOffsets(endBitPosition);
    endBitPosition = m_intersectionList_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadLayer::initializeOffsets(RoadLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShift_);
    endBitPosition = m_roadList_.initializeOffsets(context.getRoadList(), endBitPosition);
    endBitPosition = m_intersectionList_.initializeOffsets(context.getIntersectionList(), endBitPosition);

    return endBitPosition;
}

bool RoadLayer::operator==(const RoadLayer& other) const
{
    if (this != &other)
    {
        return
                (m_coordShift_ == other.m_coordShift_) &&
                (m_roadList_ == other.m_roadList_) &&
                (m_intersectionList_ == other.m_intersectionList_);
    }

    return true;
}

uint32_t RoadLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_coordShift_);
    result = ::zserio::calcHashCode(result, m_roadList_);
    result = ::zserio::calcHashCode(result, m_intersectionList_);

    return result;
}

void RoadLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_coordShift_, UINT8_C(5));

    m_roadList_.write(out);

    // check parameters
    if (m_intersectionList_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getCoordShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadLayer.intersectionList: ") <<
                m_intersectionList_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShift()) << "!";
    }
    m_intersectionList_.write(out);
}

void RoadLayer::write(RoadLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getCoordShift().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShift_);

    m_roadList_.write(context.getRoadList(), out);

    // check parameters
    if (m_intersectionList_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getCoordShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadLayer.intersectionList: ") <<
                m_intersectionList_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShift()) << "!";
    }
    m_intersectionList_.write(context.getIntersectionList(), out);
}

::nds::core::geometry::CoordShift RoadLayer::readCoordShift(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift RoadLayer::readCoordShift(RoadLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShift().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::road::road::RoadList RoadLayer::readRoadList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::road::RoadList(in, allocator);
}

::nds::road::road::RoadList RoadLayer::readRoadList(RoadLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::road::RoadList(context.getRoadList(), in, allocator);
}
::nds::road::road::IntersectionList RoadLayer::readIntersectionList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::road::IntersectionList(in, static_cast<::nds::core::geometry::CoordShift>(getCoordShift()), allocator);
}

::nds::road::road::IntersectionList RoadLayer::readIntersectionList(RoadLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::road::IntersectionList(context.getIntersectionList(), in, static_cast<::nds::core::geometry::CoordShift>(getCoordShift()), allocator);
}

} // namespace layer
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/road/layer/RoadGeometryLayer.h>
#include <nds/core/geometry/GeometryLayerType.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace road
{
namespace layer
{

RoadGeometryLayer::RoadGeometryLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_roadShapes_(allocator)
{
}

RoadGeometryLayer::RoadGeometryLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_roadShapes_(readRoadShapes(in, allocator))
{
}

RoadGeometryLayer::RoadGeometryLayer(RoadGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_roadShapes_(readRoadShapes(context, in, allocator))
{
}

RoadGeometryLayer::RoadGeometryLayer(const RoadGeometryLayer& other) :
        m_roadShapes_(other.m_roadShapes_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadGeometryLayer& RoadGeometryLayer::operator=(const RoadGeometryLayer& other)
{
    m_roadShapes_ = other.m_roadShapes_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadGeometryLayer::RoadGeometryLayer(RoadGeometryLayer&& other) :
        m_roadShapes_(::std::move(other.m_roadShapes_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadGeometryLayer& RoadGeometryLayer::operator=(RoadGeometryLayer&& other)
{
    m_roadShapes_ = ::std::move(other.m_roadShapes_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadGeometryLayer::RoadGeometryLayer(::zserio::PropagateAllocatorT,
        const RoadGeometryLayer& other, const allocator_type& allocator) :
        m_roadShapes_(::zserio::allocatorPropagatingCopy(other.m_roadShapes_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadGeometryLayer::initializeChildren()
{
    m_roadShapes_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_2D), static_cast<bool>(true), static_cast<bool>(false));

    m_areChildrenInitialized = true;
}

::nds::road::instantiations::RoadShapesLayer& RoadGeometryLayer::getRoadShapes()
{
    return m_roadShapes_;
}

const ::nds::road::instantiations::RoadShapesLayer& RoadGeometryLayer::getRoadShapes() const
{
    return m_roadShapes_;
}

void RoadGeometryLayer::setRoadShapes(const ::nds::road::instantiations::RoadShapesLayer& roadShapes_)
{
    m_roadShapes_ = roadShapes_;
}

void RoadGeometryLayer::setRoadShapes(::nds::road::instantiations::RoadShapesLayer&& roadShapes_)
{
    m_roadShapes_ = ::std::move(roadShapes_);
}

::nds::system::types::LayerType RoadGeometryLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::GEOMETRY);
}

void RoadGeometryLayer::initPackingContext(RoadGeometryLayer::ZserioPackingContext& context) const
{
    m_roadShapes_.initPackingContext(context.getRoadShapes());
}

size_t RoadGeometryLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roadShapes_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadGeometryLayer::bitSizeOf(RoadGeometryLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roadShapes_.bitSizeOf(context.getRoadShapes(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadGeometryLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roadShapes_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadGeometryLayer::initializeOffsets(RoadGeometryLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roadShapes_.initializeOffsets(context.getRoadShapes(), endBitPosition);

    return endBitPosition;
}

bool RoadGeometryLayer::operator==(const RoadGeometryLayer& other) const
{
    if (this != &other)
    {
        return
                (m_roadShapes_ == other.m_roadShapes_);
    }

    return true;
}

uint32_t RoadGeometryLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_roadShapes_);

    return result;
}

void RoadGeometryLayer::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_roadShapes_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_2D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoadGeometryLayer.roadShapes: ") <<
                m_roadShapes_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_2D) << "!";
    }
    if (m_roadShapes_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field RoadGeometryLayer.roadShapes: ") <<
                m_roadShapes_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_roadShapes_.getHasTypes() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field RoadGeometryLayer.roadShapes: ") <<
                m_roadShapes_.getHasTypes() << " != " << static_cast<bool>(false) << "!";
    }
    m_roadShapes_.write(out);
}

void RoadGeometryLayer::write(RoadGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_roadShapes_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_2D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoadGeometryLayer.roadShapes: ") <<
                m_roadShapes_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_2D) << "!";
    }
    if (m_roadShapes_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field RoadGeometryLayer.roadShapes: ") <<
                m_roadShapes_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_roadShapes_.getHasTypes() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field RoadGeometryLayer.roadShapes: ") <<
                m_roadShapes_.getHasTypes() << " != " << static_cast<bool>(false) << "!";
    }
    m_roadShapes_.write(context.getRoadShapes(), out);
}

::nds::road::instantiations::RoadShapesLayer RoadGeometryLayer::readRoadShapes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::instantiations::RoadShapesLayer(in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_2D), static_cast<bool>(true), static_cast<bool>(false), allocator);
}

::nds::road::instantiations::RoadShapesLayer RoadGeometryLayer::readRoadShapes(RoadGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::instantiations::RoadShapesLayer(context.getRoadShapes(), in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_2D), static_cast<bool>(true), static_cast<bool>(false), allocator);
}

} // namespace layer
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/road/layer/MatchedRoadPathLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace road
{
namespace layer
{

MatchedRoadPathLayer::MatchedRoadPathLayer(const allocator_type& allocator) noexcept :
        m_numSegments_(uint16_t()),
        m_segments_(allocator),
        m_pathEnds_(bool())
{
}

MatchedRoadPathLayer::MatchedRoadPathLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numSegments_(readNumSegments(in)),
        m_segments_(readSegments(in, allocator)),
        m_pathEnds_(readPathEnds(in))
{
}

MatchedRoadPathLayer::MatchedRoadPathLayer(MatchedRoadPathLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numSegments_(readNumSegments(context, in)),
        m_segments_(readSegments(context, in, allocator)),
        m_pathEnds_(readPathEnds(in))
{
}

MatchedRoadPathLayer::MatchedRoadPathLayer(::zserio::PropagateAllocatorT,
        const MatchedRoadPathLayer& other, const allocator_type& allocator) :
        m_numSegments_(::zserio::allocatorPropagatingCopy(other.m_numSegments_, allocator)),
        m_segments_(::zserio::allocatorPropagatingCopy(other.m_segments_, allocator)),
        m_pathEnds_(::zserio::allocatorPropagatingCopy(other.m_pathEnds_, allocator))
{
}

uint16_t MatchedRoadPathLayer::getNumSegments() const
{
    return m_numSegments_;
}

void MatchedRoadPathLayer::setNumSegments(uint16_t numSegments_)
{
    m_numSegments_ = numSegments_;
}

::zserio::vector<::nds::road::road::MatchedRoadSegment>& MatchedRoadPathLayer::getSegments()
{
    return m_segments_.getRawArray();
}

const ::zserio::vector<::nds::road::road::MatchedRoadSegment>& MatchedRoadPathLayer::getSegments() const
{
    return m_segments_.getRawArray();
}

void MatchedRoadPathLayer::setSegments(const ::zserio::vector<::nds::road::road::MatchedRoadSegment>& segments_)
{
    m_segments_ = ZserioArrayType_segments(segments_);
}

void MatchedRoadPathLayer::setSegments(::zserio::vector<::nds::road::road::MatchedRoadSegment>&& segments_)
{
    m_segments_ = ZserioArrayType_segments(std::move(segments_));
}

bool MatchedRoadPathLayer::getPathEnds() const
{
    return m_pathEnds_;
}

void MatchedRoadPathLayer::setPathEnds(bool pathEnds_)
{
    m_pathEnds_ = pathEnds_;
}

::nds::system::types::LayerType MatchedRoadPathLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::FEATURE);
}

void MatchedRoadPathLayer::initPackingContext(MatchedRoadPathLayer::ZserioPackingContext& context) const
{
    context.getNumSegments().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numSegments_);
}

size_t MatchedRoadPathLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numSegments_);
    endBitPosition += m_segments_.bitSizeOf(*this, endBitPosition);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t MatchedRoadPathLayer::bitSizeOf(MatchedRoadPathLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumSegments().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numSegments_);
    endBitPosition += m_segments_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t MatchedRoadPathLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numSegments_);
    endBitPosition = m_segments_.initializeOffsets(*this, endBitPosition);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t MatchedRoadPathLayer::initializeOffsets(MatchedRoadPathLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumSegments().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numSegments_);
    endBitPosition = m_segments_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool MatchedRoadPathLayer::operator==(const MatchedRoadPathLayer& other) const
{
    if (this != &other)
    {
        return
                (m_numSegments_ == other.m_numSegments_) &&
                (m_segments_ == other.m_segments_) &&
                (m_pathEnds_ == other.m_pathEnds_);
    }

    return true;
}

uint32_t MatchedRoadPathLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numSegments_);
    result = ::zserio::calcHashCode(result, m_segments_);
    result = ::zserio::calcHashCode(result, m_pathEnds_);

    return result;
}

void MatchedRoadPathLayer::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumSegments() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at MatchedRoadPathLayer.numSegments!");
    out.writeVarUInt16(m_numSegments_);

    // check array length
    if (m_segments_.getRawArray().size() != static_cast<size_t>(getNumSegments()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MatchedRoadPathLayer.segments: ") <<
                m_segments_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSegments()) << "!";
    }
    m_segments_.write(*this, out);

    out.writeBool(m_pathEnds_);
}

void MatchedRoadPathLayer::write(MatchedRoadPathLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumSegments() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at MatchedRoadPathLayer.numSegments!");
    context.getNumSegments().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numSegments_);

    // check array length
    if (m_segments_.getRawArray().size() != static_cast<size_t>(getNumSegments()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MatchedRoadPathLayer.segments: ") <<
                m_segments_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSegments()) << "!";
    }
    m_segments_.writePacked(*this, out);

    out.writeBool(m_pathEnds_);
}

void MatchedRoadPathLayer::ZserioElementFactory_segments::create(MatchedRoadPathLayer&        ,
        ::zserio::vector<::nds::road::road::MatchedRoadSegment>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void MatchedRoadPathLayer::ZserioElementFactory_segments::create(MatchedRoadPathLayer&        ,
        ::zserio::vector<::nds::road::road::MatchedRoadSegment>& array,
        ::nds::road::road::MatchedRoadSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint16_t MatchedRoadPathLayer::readNumSegments(::zserio::BitStreamReader& in)
{
    uint16_t readField = static_cast<uint16_t>(in.readVarUInt16());
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at MatchedRoadPathLayer.numSegments!");

    return readField;
}

uint16_t MatchedRoadPathLayer::readNumSegments(MatchedRoadPathLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint16_t readField = context.getNumSegments().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at MatchedRoadPathLayer.numSegments!");

    return readField;
}
MatchedRoadPathLayer::ZserioArrayType_segments MatchedRoadPathLayer::readSegments(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumSegments()));

    return readField;
}

MatchedRoadPathLayer::ZserioArrayType_segments MatchedRoadPathLayer::readSegments(MatchedRoadPathLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumSegments()));

    return readField;
}
bool MatchedRoadPathLayer::readPathEnds(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace layer
} // namespace road
} // namespace nds
