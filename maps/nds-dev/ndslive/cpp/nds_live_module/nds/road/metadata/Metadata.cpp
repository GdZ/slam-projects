/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/road/metadata/FeatureLayerType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for FeatureLayerType enumeration.
constexpr ::std::array<const char*, 1> EnumTraits<::nds::road::metadata::FeatureLayerType>::names;
constexpr ::std::array<::nds::road::metadata::FeatureLayerType, 1> EnumTraits<::nds::road::metadata::FeatureLayerType>::values;
constexpr const char* EnumTraits<::nds::road::metadata::FeatureLayerType>::enumName;

template <>
size_t enumToOrdinal(::nds::road::metadata::FeatureLayerType value)
{
    switch (value)
    {
    case ::nds::road::metadata::FeatureLayerType::ROADS_INTERSECTIONS:
        return 0;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration FeatureLayerType: ") <<
                static_cast<typename ::std::underlying_type<::nds::road::metadata::FeatureLayerType>::type>(value) << "!";
    }
}

template <>
::nds::road::metadata::FeatureLayerType valueToEnum(
        typename ::std::underlying_type<::nds::road::metadata::FeatureLayerType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(1):
        return static_cast<::nds::road::metadata::FeatureLayerType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration FeatureLayerType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::road::metadata::FeatureLayerType>(::nds::road::metadata::FeatureLayerType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::road::metadata::FeatureLayerType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::metadata::FeatureLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::road::metadata::FeatureLayerType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::road::metadata::FeatureLayerType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::metadata::FeatureLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::road::metadata::FeatureLayerType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::road::metadata::FeatureLayerType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::road::metadata::FeatureLayerType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::metadata::FeatureLayerType>(
            static_cast<typename ::std::underlying_type<::nds::road::metadata::FeatureLayerType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::road::metadata::FeatureLayerType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::metadata::FeatureLayerType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::metadata::FeatureLayerType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::road::metadata::FeatureLayerType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::road::metadata::FeatureLayerType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::metadata::FeatureLayerType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/road/metadata/GeometryLayerType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for GeometryLayerType enumeration.
constexpr ::std::array<const char*, 1> EnumTraits<::nds::road::metadata::GeometryLayerType>::names;
constexpr ::std::array<::nds::road::metadata::GeometryLayerType, 1> EnumTraits<::nds::road::metadata::GeometryLayerType>::values;
constexpr const char* EnumTraits<::nds::road::metadata::GeometryLayerType>::enumName;

template <>
size_t enumToOrdinal(::nds::road::metadata::GeometryLayerType value)
{
    switch (value)
    {
    case ::nds::road::metadata::GeometryLayerType::ROAD_GEOMETRY:
        return 0;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GeometryLayerType: ") <<
                static_cast<typename ::std::underlying_type<::nds::road::metadata::GeometryLayerType>::type>(value) << "!";
    }
}

template <>
::nds::road::metadata::GeometryLayerType valueToEnum(
        typename ::std::underlying_type<::nds::road::metadata::GeometryLayerType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
        return static_cast<::nds::road::metadata::GeometryLayerType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GeometryLayerType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::road::metadata::GeometryLayerType>(::nds::road::metadata::GeometryLayerType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::road::metadata::GeometryLayerType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::metadata::GeometryLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::road::metadata::GeometryLayerType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::road::metadata::GeometryLayerType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::metadata::GeometryLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::road::metadata::GeometryLayerType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::road::metadata::GeometryLayerType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::road::metadata::GeometryLayerType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::metadata::GeometryLayerType>(
            static_cast<typename ::std::underlying_type<::nds::road::metadata::GeometryLayerType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::road::metadata::GeometryLayerType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::road::metadata::GeometryLayerType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::metadata::GeometryLayerType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::road::metadata::GeometryLayerType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::road::metadata::GeometryLayerType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::road::metadata::GeometryLayerType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/metadata/FeatureLayerMetadata.h>

namespace nds
{
namespace road
{
namespace metadata
{

FeatureLayerMetadata::FeatureLayerMetadata(const allocator_type& allocator) noexcept :
        m_layerType_(::nds::road::metadata::FeatureLayerType()),
        m_includedRoadTypes_(allocator)
{
}

FeatureLayerMetadata::FeatureLayerMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_layerType_(readLayerType(in)),
        m_includedRoadTypes_(readIncludedRoadTypes(in, allocator))
{
}

FeatureLayerMetadata::FeatureLayerMetadata(FeatureLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_layerType_(readLayerType(context, in)),
        m_includedRoadTypes_(readIncludedRoadTypes(context, in, allocator))
{
}

FeatureLayerMetadata::FeatureLayerMetadata(::zserio::PropagateAllocatorT,
        const FeatureLayerMetadata& other, const allocator_type& allocator) :
        m_layerType_(::zserio::allocatorPropagatingCopy(other.m_layerType_, allocator)),
        m_includedRoadTypes_(::zserio::allocatorPropagatingCopy(other.m_includedRoadTypes_, allocator))
{
}

::nds::road::metadata::FeatureLayerType FeatureLayerMetadata::getLayerType() const
{
    return m_layerType_;
}

void FeatureLayerMetadata::setLayerType(::nds::road::metadata::FeatureLayerType layerType_)
{
    m_layerType_ = layerType_;
}

::zserio::vector<::nds::core::types::RoadType>& FeatureLayerMetadata::getIncludedRoadTypes()
{
    return m_includedRoadTypes_.getRawArray();
}

const ::zserio::vector<::nds::core::types::RoadType>& FeatureLayerMetadata::getIncludedRoadTypes() const
{
    return m_includedRoadTypes_.getRawArray();
}

void FeatureLayerMetadata::setIncludedRoadTypes(const ::zserio::vector<::nds::core::types::RoadType>& includedRoadTypes_)
{
    m_includedRoadTypes_ = ZserioArrayType_includedRoadTypes(includedRoadTypes_);
}

void FeatureLayerMetadata::setIncludedRoadTypes(::zserio::vector<::nds::core::types::RoadType>&& includedRoadTypes_)
{
    m_includedRoadTypes_ = ZserioArrayType_includedRoadTypes(std::move(includedRoadTypes_));
}

void FeatureLayerMetadata::initPackingContext(FeatureLayerMetadata::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getLayerType(), m_layerType_);
}

size_t FeatureLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_layerType_);
    endBitPosition += m_includedRoadTypes_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t FeatureLayerMetadata::bitSizeOf(FeatureLayerMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getLayerType(), m_layerType_);
    endBitPosition += m_includedRoadTypes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t FeatureLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_layerType_);
    endBitPosition = m_includedRoadTypes_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t FeatureLayerMetadata::initializeOffsets(FeatureLayerMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getLayerType(), endBitPosition,
        m_layerType_);
    endBitPosition = m_includedRoadTypes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool FeatureLayerMetadata::operator==(const FeatureLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_layerType_ == other.m_layerType_) &&
                (m_includedRoadTypes_ == other.m_includedRoadTypes_);
    }

    return true;
}

uint32_t FeatureLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_layerType_);
    result = ::zserio::calcHashCode(result, m_includedRoadTypes_);

    return result;
}

void FeatureLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_layerType_);
    m_includedRoadTypes_.write(*this, out);
}

void FeatureLayerMetadata::write(FeatureLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getLayerType(), out, m_layerType_);
    m_includedRoadTypes_.writePacked(*this, out);
}

void FeatureLayerMetadata::ZserioElementFactory_includedRoadTypes::create(FeatureLayerMetadata&        ,
        ::zserio::vector<::nds::core::types::RoadType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void FeatureLayerMetadata::ZserioElementFactory_includedRoadTypes::create(FeatureLayerMetadata&        ,
        ::zserio::vector<::nds::core::types::RoadType>& array,
        ::nds::core::types::RoadType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::road::metadata::FeatureLayerType FeatureLayerMetadata::readLayerType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::metadata::FeatureLayerType>(in);
}

::nds::road::metadata::FeatureLayerType FeatureLayerMetadata::readLayerType(FeatureLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::metadata::FeatureLayerType>(context.getLayerType(), in);
}
FeatureLayerMetadata::ZserioArrayType_includedRoadTypes FeatureLayerMetadata::readIncludedRoadTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_includedRoadTypes readField(allocator);
    readField.read(*this, in);

    return readField;
}

FeatureLayerMetadata::ZserioArrayType_includedRoadTypes FeatureLayerMetadata::readIncludedRoadTypes(FeatureLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_includedRoadTypes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace metadata
} // namespace road
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/road/metadata/GeometryLayerMetadata.h>

namespace nds
{
namespace road
{
namespace metadata
{

GeometryLayerMetadata::GeometryLayerMetadata(const allocator_type&) noexcept :
        m_layerType_(::nds::road::metadata::GeometryLayerType())
{
}

GeometryLayerMetadata::GeometryLayerMetadata(::zserio::BitStreamReader& in, const allocator_type&) :
        m_layerType_(readLayerType(in))
{
}

GeometryLayerMetadata::GeometryLayerMetadata(GeometryLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_layerType_(readLayerType(context, in))
{
}

GeometryLayerMetadata::GeometryLayerMetadata(::zserio::PropagateAllocatorT,
        const GeometryLayerMetadata& other, const allocator_type& allocator) :
        m_layerType_(::zserio::allocatorPropagatingCopy(other.m_layerType_, allocator))
{
}

::nds::road::metadata::GeometryLayerType GeometryLayerMetadata::getLayerType() const
{
    return m_layerType_;
}

void GeometryLayerMetadata::setLayerType(::nds::road::metadata::GeometryLayerType layerType_)
{
    m_layerType_ = layerType_;
}

void GeometryLayerMetadata::initPackingContext(GeometryLayerMetadata::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getLayerType(), m_layerType_);
}

size_t GeometryLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_layerType_);

    return endBitPosition - bitPosition;
}

size_t GeometryLayerMetadata::bitSizeOf(GeometryLayerMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getLayerType(), m_layerType_);

    return endBitPosition - bitPosition;
}

size_t GeometryLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_layerType_);

    return endBitPosition;
}

size_t GeometryLayerMetadata::initializeOffsets(GeometryLayerMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getLayerType(), endBitPosition,
        m_layerType_);

    return endBitPosition;
}

bool GeometryLayerMetadata::operator==(const GeometryLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_layerType_ == other.m_layerType_);
    }

    return true;
}

uint32_t GeometryLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_layerType_);

    return result;
}

void GeometryLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_layerType_);
}

void GeometryLayerMetadata::write(GeometryLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getLayerType(), out, m_layerType_);
}

::nds::road::metadata::GeometryLayerType GeometryLayerMetadata::readLayerType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::metadata::GeometryLayerType>(in);
}

::nds::road::metadata::GeometryLayerType GeometryLayerMetadata::readLayerType(GeometryLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::road::metadata::GeometryLayerType>(context.getLayerType(), in);
}

} // namespace metadata
} // namespace road
} // namespace nds
