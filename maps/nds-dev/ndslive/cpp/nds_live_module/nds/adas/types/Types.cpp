/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/adas/types/AdasAccuracy.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AdasAccuracy enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::adas::types::AdasAccuracy>::names;
constexpr ::std::array<::nds::adas::types::AdasAccuracy, 4> EnumTraits<::nds::adas::types::AdasAccuracy>::values;
constexpr const char* EnumTraits<::nds::adas::types::AdasAccuracy>::enumName;

template <>
size_t enumToOrdinal(::nds::adas::types::AdasAccuracy value)
{
    switch (value)
    {
    case ::nds::adas::types::AdasAccuracy::UNKNOWN:
        return 0;
    case ::nds::adas::types::AdasAccuracy::LOW:
        return 1;
    case ::nds::adas::types::AdasAccuracy::MIDDLE:
        return 2;
    case ::nds::adas::types::AdasAccuracy::HIGH:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdasAccuracy: ") <<
                static_cast<typename ::std::underlying_type<::nds::adas::types::AdasAccuracy>::type>(value) << "!";
    }
}

template <>
::nds::adas::types::AdasAccuracy valueToEnum(
        typename ::std::underlying_type<::nds::adas::types::AdasAccuracy>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::adas::types::AdasAccuracy>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdasAccuracy: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::adas::types::AdasAccuracy>(::nds::adas::types::AdasAccuracy value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::adas::types::AdasAccuracy value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::adas::types::AdasAccuracy>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::adas::types::AdasAccuracy)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::adas::types::AdasAccuracy value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::adas::types::AdasAccuracy>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::adas::types::AdasAccuracy value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::adas::types::AdasAccuracy value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::adas::types::AdasAccuracy read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::adas::types::AdasAccuracy>(
            static_cast<typename ::std::underlying_type<::nds::adas::types::AdasAccuracy>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::adas::types::AdasAccuracy read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::adas::types::AdasAccuracy>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::adas::types::AdasAccuracy>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::adas::types::AdasAccuracy value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::adas::types::AdasAccuracy value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::adas::types::AdasAccuracy>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/AdasGeometryList.h>

namespace nds
{
namespace adas
{
namespace types
{

AdasGeometryList::AdasGeometryList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numRoadReferences_(uint32_t()),
        m_road_(allocator),
        m_adasGeometry_(allocator)
{
}

AdasGeometryList::AdasGeometryList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numRoadReferences_(readNumRoadReferences(in)),
        m_road_(readRoad(in, allocator)),
        m_adasGeometry_(readAdasGeometry(in, allocator))
{
}

AdasGeometryList::AdasGeometryList(AdasGeometryList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numRoadReferences_(readNumRoadReferences(context, in)),
        m_road_(readRoad(context, in, allocator)),
        m_adasGeometry_(readAdasGeometry(context, in, allocator))
{
}

AdasGeometryList::AdasGeometryList(const AdasGeometryList& other) :
        m_numRoadReferences_(other.m_numRoadReferences_),
        m_road_(other.m_road_),
        m_adasGeometry_(other.m_adasGeometry_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

AdasGeometryList& AdasGeometryList::operator=(const AdasGeometryList& other)
{
    m_numRoadReferences_ = other.m_numRoadReferences_;
    m_road_ = other.m_road_;
    m_adasGeometry_ = other.m_adasGeometry_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

AdasGeometryList::AdasGeometryList(AdasGeometryList&& other) :
        m_numRoadReferences_(::std::move(other.m_numRoadReferences_)),
        m_road_(::std::move(other.m_road_)),
        m_adasGeometry_(::std::move(other.m_adasGeometry_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

AdasGeometryList& AdasGeometryList::operator=(AdasGeometryList&& other)
{
    m_numRoadReferences_ = ::std::move(other.m_numRoadReferences_);
    m_road_ = ::std::move(other.m_road_);
    m_adasGeometry_ = ::std::move(other.m_adasGeometry_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

AdasGeometryList::AdasGeometryList(::zserio::PropagateAllocatorT,
        const AdasGeometryList& other, const allocator_type& allocator) :
        m_numRoadReferences_(::zserio::allocatorPropagatingCopy(other.m_numRoadReferences_, allocator)),
        m_road_(::zserio::allocatorPropagatingCopy(other.m_road_, allocator)),
        m_adasGeometry_(::zserio::allocatorPropagatingCopy(other.m_adasGeometry_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void AdasGeometryList::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool AdasGeometryList::isInitialized() const
{
    return m_isInitialized;
}

void AdasGeometryList::initializeChildren()
{
    m_adasGeometry_.initializeElements(*this);
}

::nds::core::geometry::CoordShift AdasGeometryList::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'AdasGeometryList' is not initialized!");

    return m_shift_;
}

uint32_t AdasGeometryList::getNumRoadReferences() const
{
    return m_numRoadReferences_;
}

void AdasGeometryList::setNumRoadReferences(uint32_t numRoadReferences_)
{
    m_numRoadReferences_ = numRoadReferences_;
}

::zserio::vector<::nds::road::reference::types::RoadId>& AdasGeometryList::getRoad()
{
    return m_road_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadId>& AdasGeometryList::getRoad() const
{
    return m_road_.getRawArray();
}

void AdasGeometryList::setRoad(const ::zserio::vector<::nds::road::reference::types::RoadId>& road_)
{
    m_road_ = ZserioArrayType_road(road_);
}

void AdasGeometryList::setRoad(::zserio::vector<::nds::road::reference::types::RoadId>&& road_)
{
    m_road_ = ZserioArrayType_road(std::move(road_));
}

::zserio::vector<::nds::core::geometry::Line2D>& AdasGeometryList::getAdasGeometry()
{
    return m_adasGeometry_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Line2D>& AdasGeometryList::getAdasGeometry() const
{
    return m_adasGeometry_.getRawArray();
}

void AdasGeometryList::setAdasGeometry(const ::zserio::vector<::nds::core::geometry::Line2D>& adasGeometry_)
{
    m_adasGeometry_ = ZserioArrayType_adasGeometry(adasGeometry_);
}

void AdasGeometryList::setAdasGeometry(::zserio::vector<::nds::core::geometry::Line2D>&& adasGeometry_)
{
    m_adasGeometry_ = ZserioArrayType_adasGeometry(std::move(adasGeometry_));
}

void AdasGeometryList::initPackingContext(AdasGeometryList::ZserioPackingContext& context) const
{
    context.getNumRoadReferences().init<::zserio::VarSizeArrayTraits>(m_numRoadReferences_);
}

size_t AdasGeometryList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numRoadReferences_);
    endBitPosition += m_road_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_adasGeometry_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AdasGeometryList::bitSizeOf(AdasGeometryList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumRoadReferences().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRoadReferences_);
    endBitPosition += m_road_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_adasGeometry_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AdasGeometryList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numRoadReferences_);
    endBitPosition = m_road_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_adasGeometry_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t AdasGeometryList::initializeOffsets(AdasGeometryList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumRoadReferences().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRoadReferences_);
    endBitPosition = m_road_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_adasGeometry_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool AdasGeometryList::operator==(const AdasGeometryList& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_numRoadReferences_ == other.m_numRoadReferences_) &&
                (m_road_ == other.m_road_) &&
                (m_adasGeometry_ == other.m_adasGeometry_);
    }

    return true;
}

uint32_t AdasGeometryList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_numRoadReferences_);
    result = ::zserio::calcHashCode(result, m_road_);
    result = ::zserio::calcHashCode(result, m_adasGeometry_);

    return result;
}

void AdasGeometryList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numRoadReferences_);

    // check array length
    if (m_road_.getRawArray().size() != static_cast<size_t>(getNumRoadReferences()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AdasGeometryList.road: ") <<
                m_road_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRoadReferences()) << "!";
    }
    m_road_.write(*this, out);

    // check array length
    if (m_adasGeometry_.getRawArray().size() != static_cast<size_t>(getNumRoadReferences()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AdasGeometryList.adasGeometry: ") <<
                m_adasGeometry_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRoadReferences()) << "!";
    }
    m_adasGeometry_.write(*this, out);
}

void AdasGeometryList::write(AdasGeometryList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumRoadReferences().write<::zserio::VarSizeArrayTraits>(out, m_numRoadReferences_);

    // check array length
    if (m_road_.getRawArray().size() != static_cast<size_t>(getNumRoadReferences()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AdasGeometryList.road: ") <<
                m_road_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRoadReferences()) << "!";
    }
    m_road_.writePacked(*this, out);

    // check array length
    if (m_adasGeometry_.getRawArray().size() != static_cast<size_t>(getNumRoadReferences()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field AdasGeometryList.adasGeometry: ") <<
                m_adasGeometry_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRoadReferences()) << "!";
    }
    m_adasGeometry_.writePacked(*this, out);
}

void AdasGeometryList::ZserioElementFactory_road::create(AdasGeometryList&        ,
        ::zserio::vector<::nds::road::reference::types::RoadId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void AdasGeometryList::ZserioElementFactory_road::create(AdasGeometryList&        ,
        ::zserio::vector<::nds::road::reference::types::RoadId>& array,
        ::nds::road::reference::types::RoadId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void AdasGeometryList::ZserioArrayExpressions_adasGeometry::initializeElement(AdasGeometryList& owner,
        ::nds::core::geometry::Line2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void AdasGeometryList::ZserioElementFactory_adasGeometry::create(AdasGeometryList&         owner,
        ::zserio::vector<::nds::core::geometry::Line2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void AdasGeometryList::ZserioElementFactory_adasGeometry::create(AdasGeometryList&         owner,
        ::zserio::vector<::nds::core::geometry::Line2D>& array,
        ::nds::core::geometry::Line2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

uint32_t AdasGeometryList::readNumRoadReferences(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t AdasGeometryList::readNumRoadReferences(AdasGeometryList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumRoadReferences().read<::zserio::VarSizeArrayTraits>(in);
}
AdasGeometryList::ZserioArrayType_road AdasGeometryList::readRoad(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_road readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumRoadReferences()));

    return readField;
}

AdasGeometryList::ZserioArrayType_road AdasGeometryList::readRoad(AdasGeometryList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_road readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumRoadReferences()));

    return readField;
}
AdasGeometryList::ZserioArrayType_adasGeometry AdasGeometryList::readAdasGeometry(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_adasGeometry readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumRoadReferences()));

    return readField;
}

AdasGeometryList::ZserioArrayType_adasGeometry AdasGeometryList::readAdasGeometry(AdasGeometryList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_adasGeometry readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumRoadReferences()));

    return readField;
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/ComfortableSpeedPath.h>

namespace nds
{
namespace adas
{
namespace types
{

ComfortableSpeedPath::ComfortableSpeedPath(const allocator_type& allocator) noexcept :
        m_numOfRoads_(uint8_t()),
        m_speedPoints_(allocator),
        m_road_(allocator)
{
}

ComfortableSpeedPath::ComfortableSpeedPath(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfRoads_(readNumOfRoads(in)),
        m_speedPoints_(readSpeedPoints(in, allocator)),
        m_road_(readRoad(in, allocator))
{
}

ComfortableSpeedPath::ComfortableSpeedPath(ComfortableSpeedPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfRoads_(readNumOfRoads(context, in)),
        m_speedPoints_(readSpeedPoints(context, in, allocator)),
        m_road_(readRoad(context, in, allocator))
{
}

ComfortableSpeedPath::ComfortableSpeedPath(::zserio::PropagateAllocatorT,
        const ComfortableSpeedPath& other, const allocator_type& allocator) :
        m_numOfRoads_(::zserio::allocatorPropagatingCopy(other.m_numOfRoads_, allocator)),
        m_speedPoints_(::zserio::allocatorPropagatingCopy(other.m_speedPoints_, allocator)),
        m_road_(::zserio::allocatorPropagatingCopy(other.m_road_, allocator))
{
}

uint8_t ComfortableSpeedPath::getNumOfRoads() const
{
    return m_numOfRoads_;
}

void ComfortableSpeedPath::setNumOfRoads(uint8_t numOfRoads_)
{
    m_numOfRoads_ = numOfRoads_;
}

::nds::adas::types::ComfortableSpeedPointList& ComfortableSpeedPath::getSpeedPoints()
{
    return m_speedPoints_;
}

const ::nds::adas::types::ComfortableSpeedPointList& ComfortableSpeedPath::getSpeedPoints() const
{
    return m_speedPoints_;
}

void ComfortableSpeedPath::setSpeedPoints(const ::nds::adas::types::ComfortableSpeedPointList& speedPoints_)
{
    m_speedPoints_ = speedPoints_;
}

void ComfortableSpeedPath::setSpeedPoints(::nds::adas::types::ComfortableSpeedPointList&& speedPoints_)
{
    m_speedPoints_ = ::std::move(speedPoints_);
}

::zserio::vector<::nds::adas::types::ComfortableSpeedRoad>& ComfortableSpeedPath::getRoad()
{
    return m_road_.getRawArray();
}

const ::zserio::vector<::nds::adas::types::ComfortableSpeedRoad>& ComfortableSpeedPath::getRoad() const
{
    return m_road_.getRawArray();
}

void ComfortableSpeedPath::setRoad(const ::zserio::vector<::nds::adas::types::ComfortableSpeedRoad>& road_)
{
    m_road_ = ZserioArrayType_road(road_);
}

void ComfortableSpeedPath::setRoad(::zserio::vector<::nds::adas::types::ComfortableSpeedRoad>&& road_)
{
    m_road_ = ZserioArrayType_road(std::move(road_));
}

void ComfortableSpeedPath::initPackingContext(ComfortableSpeedPath::ZserioPackingContext& context) const
{
    context.getNumOfRoads().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numOfRoads_);
    m_speedPoints_.initPackingContext(context.getSpeedPoints());
}

size_t ComfortableSpeedPath::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_speedPoints_.bitSizeOf(endBitPosition);
    endBitPosition += m_road_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ComfortableSpeedPath::bitSizeOf(ComfortableSpeedPath::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfRoads().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numOfRoads_);
    endBitPosition += m_speedPoints_.bitSizeOf(context.getSpeedPoints(), endBitPosition);
    endBitPosition += m_road_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ComfortableSpeedPath::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_speedPoints_.initializeOffsets(endBitPosition);
    endBitPosition = m_road_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ComfortableSpeedPath::initializeOffsets(ComfortableSpeedPath::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfRoads().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numOfRoads_);
    endBitPosition = m_speedPoints_.initializeOffsets(context.getSpeedPoints(), endBitPosition);
    endBitPosition = m_road_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ComfortableSpeedPath::operator==(const ComfortableSpeedPath& other) const
{
    if (this != &other)
    {
        return
                (m_numOfRoads_ == other.m_numOfRoads_) &&
                (m_speedPoints_ == other.m_speedPoints_) &&
                (m_road_ == other.m_road_);
    }

    return true;
}

uint32_t ComfortableSpeedPath::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numOfRoads_);
    result = ::zserio::calcHashCode(result, m_speedPoints_);
    result = ::zserio::calcHashCode(result, m_road_);

    return result;
}

void ComfortableSpeedPath::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numOfRoads_, UINT8_C(8));

    m_speedPoints_.write(out);

    // check array length
    if (m_road_.getRawArray().size() != static_cast<size_t>(getNumOfRoads()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ComfortableSpeedPath.road: ") <<
                m_road_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfRoads()) << "!";
    }
    m_road_.write(*this, out);
}

void ComfortableSpeedPath::write(ComfortableSpeedPath::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumOfRoads().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numOfRoads_);

    m_speedPoints_.write(context.getSpeedPoints(), out);

    // check array length
    if (m_road_.getRawArray().size() != static_cast<size_t>(getNumOfRoads()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ComfortableSpeedPath.road: ") <<
                m_road_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfRoads()) << "!";
    }
    m_road_.writePacked(*this, out);
}

void ComfortableSpeedPath::ZserioElementFactory_road::create(ComfortableSpeedPath&        ,
        ::zserio::vector<::nds::adas::types::ComfortableSpeedRoad>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ComfortableSpeedPath::ZserioElementFactory_road::create(ComfortableSpeedPath&        ,
        ::zserio::vector<::nds::adas::types::ComfortableSpeedRoad>& array,
        ::nds::adas::types::ComfortableSpeedRoad::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t ComfortableSpeedPath::readNumOfRoads(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ComfortableSpeedPath::readNumOfRoads(ComfortableSpeedPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumOfRoads().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::nds::adas::types::ComfortableSpeedPointList ComfortableSpeedPath::readSpeedPoints(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::adas::types::ComfortableSpeedPointList(in, allocator);
}

::nds::adas::types::ComfortableSpeedPointList ComfortableSpeedPath::readSpeedPoints(ComfortableSpeedPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::adas::types::ComfortableSpeedPointList(context.getSpeedPoints(), in, allocator);
}
ComfortableSpeedPath::ZserioArrayType_road ComfortableSpeedPath::readRoad(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_road readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumOfRoads()));

    return readField;
}

ComfortableSpeedPath::ZserioArrayType_road ComfortableSpeedPath::readRoad(ComfortableSpeedPath::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_road readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumOfRoads()));

    return readField;
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/ComfortableSpeedRoad.h>

namespace nds
{
namespace adas
{
namespace types
{

ComfortableSpeedRoad::ComfortableSpeedRoad(const allocator_type& allocator) noexcept :
        m_featureReference_(allocator),
        m_speedPoints_(allocator)
{
}

ComfortableSpeedRoad::ComfortableSpeedRoad(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_featureReference_(readFeatureReference(in, allocator)),
        m_speedPoints_(readSpeedPoints(in, allocator))
{
}

ComfortableSpeedRoad::ComfortableSpeedRoad(ComfortableSpeedRoad::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_featureReference_(readFeatureReference(context, in, allocator)),
        m_speedPoints_(readSpeedPoints(context, in, allocator))
{
}

ComfortableSpeedRoad::ComfortableSpeedRoad(::zserio::PropagateAllocatorT,
        const ComfortableSpeedRoad& other, const allocator_type& allocator) :
        m_featureReference_(::zserio::allocatorPropagatingCopy(other.m_featureReference_, allocator)),
        m_speedPoints_(::zserio::allocatorPropagatingCopy(other.m_speedPoints_, allocator))
{
}

::nds::road::reference::types::DirectedRoadReference& ComfortableSpeedRoad::getFeatureReference()
{
    return m_featureReference_;
}

const ::nds::road::reference::types::DirectedRoadReference& ComfortableSpeedRoad::getFeatureReference() const
{
    return m_featureReference_;
}

void ComfortableSpeedRoad::setFeatureReference(const ::nds::road::reference::types::DirectedRoadReference& featureReference_)
{
    m_featureReference_ = featureReference_;
}

void ComfortableSpeedRoad::setFeatureReference(::nds::road::reference::types::DirectedRoadReference&& featureReference_)
{
    m_featureReference_ = ::std::move(featureReference_);
}

::nds::adas::types::ComfortableSpeedPointList& ComfortableSpeedRoad::getSpeedPoints()
{
    return m_speedPoints_;
}

const ::nds::adas::types::ComfortableSpeedPointList& ComfortableSpeedRoad::getSpeedPoints() const
{
    return m_speedPoints_;
}

void ComfortableSpeedRoad::setSpeedPoints(const ::nds::adas::types::ComfortableSpeedPointList& speedPoints_)
{
    m_speedPoints_ = speedPoints_;
}

void ComfortableSpeedRoad::setSpeedPoints(::nds::adas::types::ComfortableSpeedPointList&& speedPoints_)
{
    m_speedPoints_ = ::std::move(speedPoints_);
}

void ComfortableSpeedRoad::initPackingContext(ComfortableSpeedRoad::ZserioPackingContext& context) const
{
    m_featureReference_.initPackingContext(context.getFeatureReference());
    m_speedPoints_.initPackingContext(context.getSpeedPoints());
}

size_t ComfortableSpeedRoad::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_featureReference_.bitSizeOf(endBitPosition);
    endBitPosition += m_speedPoints_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ComfortableSpeedRoad::bitSizeOf(ComfortableSpeedRoad::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_featureReference_.bitSizeOf(context.getFeatureReference(), endBitPosition);
    endBitPosition += m_speedPoints_.bitSizeOf(context.getSpeedPoints(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ComfortableSpeedRoad::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_featureReference_.initializeOffsets(endBitPosition);
    endBitPosition = m_speedPoints_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ComfortableSpeedRoad::initializeOffsets(ComfortableSpeedRoad::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_featureReference_.initializeOffsets(context.getFeatureReference(), endBitPosition);
    endBitPosition = m_speedPoints_.initializeOffsets(context.getSpeedPoints(), endBitPosition);

    return endBitPosition;
}

bool ComfortableSpeedRoad::operator==(const ComfortableSpeedRoad& other) const
{
    if (this != &other)
    {
        return
                (m_featureReference_ == other.m_featureReference_) &&
                (m_speedPoints_ == other.m_speedPoints_);
    }

    return true;
}

uint32_t ComfortableSpeedRoad::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_featureReference_);
    result = ::zserio::calcHashCode(result, m_speedPoints_);

    return result;
}

void ComfortableSpeedRoad::write(::zserio::BitStreamWriter& out) const
{
    m_featureReference_.write(out);
    m_speedPoints_.write(out);
}

void ComfortableSpeedRoad::write(ComfortableSpeedRoad::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_featureReference_.write(context.getFeatureReference(), out);
    m_speedPoints_.write(context.getSpeedPoints(), out);
}

::nds::road::reference::types::DirectedRoadReference ComfortableSpeedRoad::readFeatureReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::DirectedRoadReference(in, allocator);
}

::nds::road::reference::types::DirectedRoadReference ComfortableSpeedRoad::readFeatureReference(ComfortableSpeedRoad::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::DirectedRoadReference(context.getFeatureReference(), in, allocator);
}
::nds::adas::types::ComfortableSpeedPointList ComfortableSpeedRoad::readSpeedPoints(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::adas::types::ComfortableSpeedPointList(in, allocator);
}

::nds::adas::types::ComfortableSpeedPointList ComfortableSpeedRoad::readSpeedPoints(ComfortableSpeedRoad::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::adas::types::ComfortableSpeedPointList(context.getSpeedPoints(), in, allocator);
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/ComfortableSpeedPointList.h>

namespace nds
{
namespace adas
{
namespace types
{

ComfortableSpeedPointList::ComfortableSpeedPointList(const allocator_type& allocator) noexcept :
        m_numOfValues_(uint16_t()),
        m_speedPoints_(allocator)
{
}

ComfortableSpeedPointList::ComfortableSpeedPointList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(in)),
        m_speedPoints_(readSpeedPoints(in, allocator))
{
}

ComfortableSpeedPointList::ComfortableSpeedPointList(ComfortableSpeedPointList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(context, in)),
        m_speedPoints_(readSpeedPoints(context, in, allocator))
{
}

ComfortableSpeedPointList::ComfortableSpeedPointList(::zserio::PropagateAllocatorT,
        const ComfortableSpeedPointList& other, const allocator_type& allocator) :
        m_numOfValues_(::zserio::allocatorPropagatingCopy(other.m_numOfValues_, allocator)),
        m_speedPoints_(::zserio::allocatorPropagatingCopy(other.m_speedPoints_, allocator))
{
}

uint16_t ComfortableSpeedPointList::getNumOfValues() const
{
    return m_numOfValues_;
}

void ComfortableSpeedPointList::setNumOfValues(uint16_t numOfValues_)
{
    m_numOfValues_ = numOfValues_;
}

::zserio::vector<::nds::adas::types::ComfortableSpeedPoint>& ComfortableSpeedPointList::getSpeedPoints()
{
    return m_speedPoints_.getRawArray();
}

const ::zserio::vector<::nds::adas::types::ComfortableSpeedPoint>& ComfortableSpeedPointList::getSpeedPoints() const
{
    return m_speedPoints_.getRawArray();
}

void ComfortableSpeedPointList::setSpeedPoints(const ::zserio::vector<::nds::adas::types::ComfortableSpeedPoint>& speedPoints_)
{
    m_speedPoints_ = ZserioArrayType_speedPoints(speedPoints_);
}

void ComfortableSpeedPointList::setSpeedPoints(::zserio::vector<::nds::adas::types::ComfortableSpeedPoint>&& speedPoints_)
{
    m_speedPoints_ = ZserioArrayType_speedPoints(std::move(speedPoints_));
}

void ComfortableSpeedPointList::initPackingContext(ComfortableSpeedPointList::ZserioPackingContext& context) const
{
    context.getNumOfValues().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
}

size_t ComfortableSpeedPointList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition += m_speedPoints_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ComfortableSpeedPointList::bitSizeOf(ComfortableSpeedPointList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition += m_speedPoints_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ComfortableSpeedPointList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition = m_speedPoints_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ComfortableSpeedPointList::initializeOffsets(ComfortableSpeedPointList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition = m_speedPoints_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ComfortableSpeedPointList::operator==(const ComfortableSpeedPointList& other) const
{
    if (this != &other)
    {
        return
                (m_numOfValues_ == other.m_numOfValues_) &&
                (m_speedPoints_ == other.m_speedPoints_);
    }

    return true;
}

uint32_t ComfortableSpeedPointList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numOfValues_);
    result = ::zserio::calcHashCode(result, m_speedPoints_);

    return result;
}

void ComfortableSpeedPointList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numOfValues_);

    // check array length
    if (m_speedPoints_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ComfortableSpeedPointList.speedPoints: ") <<
                m_speedPoints_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_speedPoints_.write(*this, out);
}

void ComfortableSpeedPointList::write(ComfortableSpeedPointList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumOfValues().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numOfValues_);

    // check array length
    if (m_speedPoints_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ComfortableSpeedPointList.speedPoints: ") <<
                m_speedPoints_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_speedPoints_.writePacked(*this, out);
}

void ComfortableSpeedPointList::ZserioElementFactory_speedPoints::create(ComfortableSpeedPointList&        ,
        ::zserio::vector<::nds::adas::types::ComfortableSpeedPoint>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ComfortableSpeedPointList::ZserioElementFactory_speedPoints::create(ComfortableSpeedPointList&        ,
        ::zserio::vector<::nds::adas::types::ComfortableSpeedPoint>& array,
        ::nds::adas::types::ComfortableSpeedPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint16_t ComfortableSpeedPointList::readNumOfValues(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t ComfortableSpeedPointList::readNumOfValues(ComfortableSpeedPointList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumOfValues().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
ComfortableSpeedPointList::ZserioArrayType_speedPoints ComfortableSpeedPointList::readSpeedPoints(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_speedPoints readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

ComfortableSpeedPointList::ZserioArrayType_speedPoints ComfortableSpeedPointList::readSpeedPoints(ComfortableSpeedPointList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_speedPoints readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/ComfortableSpeedPoint.h>

namespace nds
{
namespace adas
{
namespace types
{

ComfortableSpeedPoint::ComfortableSpeedPoint(const allocator_type&) noexcept :
        m_position_(::nds::adas::types::AdasGeometryPosition()),
        m_comfortableSpeed_(::nds::adas::types::ComfortableSpeed())
{
}

ComfortableSpeedPoint::ComfortableSpeedPoint(::zserio::BitStreamReader& in, const allocator_type&) :
        m_position_(readPosition(in)),
        m_comfortableSpeed_(readComfortableSpeed(in))
{
}

ComfortableSpeedPoint::ComfortableSpeedPoint(ComfortableSpeedPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_position_(readPosition(context, in)),
        m_comfortableSpeed_(readComfortableSpeed(context, in))
{
}

ComfortableSpeedPoint::ComfortableSpeedPoint(::zserio::PropagateAllocatorT,
        const ComfortableSpeedPoint& other, const allocator_type& allocator) :
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator)),
        m_comfortableSpeed_(::zserio::allocatorPropagatingCopy(other.m_comfortableSpeed_, allocator))
{
}

::nds::adas::types::AdasGeometryPosition ComfortableSpeedPoint::getPosition() const
{
    return m_position_;
}

void ComfortableSpeedPoint::setPosition(::nds::adas::types::AdasGeometryPosition position_)
{
    m_position_ = position_;
}

::nds::adas::types::ComfortableSpeed ComfortableSpeedPoint::getComfortableSpeed() const
{
    return m_comfortableSpeed_;
}

void ComfortableSpeedPoint::setComfortableSpeed(::nds::adas::types::ComfortableSpeed comfortableSpeed_)
{
    m_comfortableSpeed_ = comfortableSpeed_;
}

void ComfortableSpeedPoint::initPackingContext(ComfortableSpeedPoint::ZserioPackingContext& context) const
{
    context.getPosition().init<::zserio::VarSizeArrayTraits>(m_position_);
    context.getComfortableSpeed().init<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(m_comfortableSpeed_);
}

size_t ComfortableSpeedPoint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_position_);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t ComfortableSpeedPoint::bitSizeOf(ComfortableSpeedPoint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_position_);
    endBitPosition += context.getComfortableSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(m_comfortableSpeed_);

    return endBitPosition - bitPosition;
}

size_t ComfortableSpeedPoint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_position_);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t ComfortableSpeedPoint::initializeOffsets(ComfortableSpeedPoint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_position_);
    endBitPosition += context.getComfortableSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(m_comfortableSpeed_);

    return endBitPosition;
}

bool ComfortableSpeedPoint::operator==(const ComfortableSpeedPoint& other) const
{
    if (this != &other)
    {
        return
                (m_position_ == other.m_position_) &&
                (m_comfortableSpeed_ == other.m_comfortableSpeed_);
    }

    return true;
}

uint32_t ComfortableSpeedPoint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_position_);
    result = ::zserio::calcHashCode(result, m_comfortableSpeed_);

    return result;
}

void ComfortableSpeedPoint::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_position_);
    out.writeBits(m_comfortableSpeed_, UINT8_C(8));
}

void ComfortableSpeedPoint::write(ComfortableSpeedPoint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getPosition().write<::zserio::VarSizeArrayTraits>(out, m_position_);
    context.getComfortableSpeed().write<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(out, m_comfortableSpeed_);
}

::nds::adas::types::AdasGeometryPosition ComfortableSpeedPoint::readPosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::AdasGeometryPosition>(in.readVarSize());
}

::nds::adas::types::AdasGeometryPosition ComfortableSpeedPoint::readPosition(ComfortableSpeedPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getPosition().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::adas::types::ComfortableSpeed ComfortableSpeedPoint::readComfortableSpeed(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::ComfortableSpeed>(in.readBits(UINT8_C(8)));
}

::nds::adas::types::ComfortableSpeed ComfortableSpeedPoint::readComfortableSpeed(ComfortableSpeedPoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getComfortableSpeed().read<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(in);
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/SlopeArray.h>

namespace nds
{
namespace adas
{
namespace types
{

SlopeArray::SlopeArray(const allocator_type& allocator) noexcept :
        m_numOfValues_(uint16_t()),
        m_slopePoint_(allocator)
{
}

SlopeArray::SlopeArray(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(in)),
        m_slopePoint_(readSlopePoint(in, allocator))
{
}

SlopeArray::SlopeArray(SlopeArray::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(context, in)),
        m_slopePoint_(readSlopePoint(context, in, allocator))
{
}

SlopeArray::SlopeArray(::zserio::PropagateAllocatorT,
        const SlopeArray& other, const allocator_type& allocator) :
        m_numOfValues_(::zserio::allocatorPropagatingCopy(other.m_numOfValues_, allocator)),
        m_slopePoint_(::zserio::allocatorPropagatingCopy(other.m_slopePoint_, allocator))
{
}

uint16_t SlopeArray::getNumOfValues() const
{
    return m_numOfValues_;
}

void SlopeArray::setNumOfValues(uint16_t numOfValues_)
{
    m_numOfValues_ = numOfValues_;
}

::zserio::vector<::nds::adas::types::SlopePoint>& SlopeArray::getSlopePoint()
{
    return m_slopePoint_.getRawArray();
}

const ::zserio::vector<::nds::adas::types::SlopePoint>& SlopeArray::getSlopePoint() const
{
    return m_slopePoint_.getRawArray();
}

void SlopeArray::setSlopePoint(const ::zserio::vector<::nds::adas::types::SlopePoint>& slopePoint_)
{
    m_slopePoint_ = ZserioArrayType_slopePoint(slopePoint_);
}

void SlopeArray::setSlopePoint(::zserio::vector<::nds::adas::types::SlopePoint>&& slopePoint_)
{
    m_slopePoint_ = ZserioArrayType_slopePoint(std::move(slopePoint_));
}

void SlopeArray::initPackingContext(SlopeArray::ZserioPackingContext& context) const
{
    context.getNumOfValues().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
}

size_t SlopeArray::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition += m_slopePoint_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SlopeArray::bitSizeOf(SlopeArray::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition += m_slopePoint_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SlopeArray::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition = m_slopePoint_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SlopeArray::initializeOffsets(SlopeArray::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition = m_slopePoint_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SlopeArray::operator==(const SlopeArray& other) const
{
    if (this != &other)
    {
        return
                (m_numOfValues_ == other.m_numOfValues_) &&
                (m_slopePoint_ == other.m_slopePoint_);
    }

    return true;
}

uint32_t SlopeArray::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numOfValues_);
    result = ::zserio::calcHashCode(result, m_slopePoint_);

    return result;
}

void SlopeArray::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numOfValues_);

    // check array length
    if (m_slopePoint_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SlopeArray.slopePoint: ") <<
                m_slopePoint_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_slopePoint_.write(*this, out);
}

void SlopeArray::write(SlopeArray::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumOfValues().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numOfValues_);

    // check array length
    if (m_slopePoint_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SlopeArray.slopePoint: ") <<
                m_slopePoint_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_slopePoint_.writePacked(*this, out);
}

void SlopeArray::ZserioElementFactory_slopePoint::create(SlopeArray&        ,
        ::zserio::vector<::nds::adas::types::SlopePoint>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SlopeArray::ZserioElementFactory_slopePoint::create(SlopeArray&        ,
        ::zserio::vector<::nds::adas::types::SlopePoint>& array,
        ::nds::adas::types::SlopePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint16_t SlopeArray::readNumOfValues(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t SlopeArray::readNumOfValues(SlopeArray::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumOfValues().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
SlopeArray::ZserioArrayType_slopePoint SlopeArray::readSlopePoint(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_slopePoint readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

SlopeArray::ZserioArrayType_slopePoint SlopeArray::readSlopePoint(SlopeArray::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_slopePoint readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/SlopePoint.h>

namespace nds
{
namespace adas
{
namespace types
{

SlopePoint::SlopePoint(const allocator_type&) noexcept :
        m_point_(::nds::adas::types::AdasGeometryPosition()),
        m_slope_(::nds::adas::types::Slope())
{
}

SlopePoint::SlopePoint(::zserio::BitStreamReader& in, const allocator_type&) :
        m_point_(readPoint(in)),
        m_slope_(readSlope(in))
{
}

SlopePoint::SlopePoint(SlopePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_point_(readPoint(context, in)),
        m_slope_(readSlope(context, in))
{
}

SlopePoint::SlopePoint(::zserio::PropagateAllocatorT,
        const SlopePoint& other, const allocator_type& allocator) :
        m_point_(::zserio::allocatorPropagatingCopy(other.m_point_, allocator)),
        m_slope_(::zserio::allocatorPropagatingCopy(other.m_slope_, allocator))
{
}

::nds::adas::types::AdasGeometryPosition SlopePoint::getPoint() const
{
    return m_point_;
}

void SlopePoint::setPoint(::nds::adas::types::AdasGeometryPosition point_)
{
    m_point_ = point_;
}

::nds::adas::types::Slope SlopePoint::getSlope() const
{
    return m_slope_;
}

void SlopePoint::setSlope(::nds::adas::types::Slope slope_)
{
    m_slope_ = slope_;
}

void SlopePoint::initPackingContext(SlopePoint::ZserioPackingContext& context) const
{
    context.getPoint().init<::zserio::VarSizeArrayTraits>(m_point_);
    context.getSlope().init<::zserio::StdIntArrayTraits<::nds::adas::types::Slope>>(m_slope_);
}

size_t SlopePoint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_point_);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t SlopePoint::bitSizeOf(SlopePoint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPoint().bitSizeOf<::zserio::VarSizeArrayTraits>(m_point_);
    endBitPosition += context.getSlope().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::Slope>>(m_slope_);

    return endBitPosition - bitPosition;
}

size_t SlopePoint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_point_);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t SlopePoint::initializeOffsets(SlopePoint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPoint().bitSizeOf<::zserio::VarSizeArrayTraits>(m_point_);
    endBitPosition += context.getSlope().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::Slope>>(m_slope_);

    return endBitPosition;
}

bool SlopePoint::operator==(const SlopePoint& other) const
{
    if (this != &other)
    {
        return
                (m_point_ == other.m_point_) &&
                (m_slope_ == other.m_slope_);
    }

    return true;
}

uint32_t SlopePoint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_point_);
    result = ::zserio::calcHashCode(result, m_slope_);

    return result;
}

void SlopePoint::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_point_);
    out.writeSignedBits(m_slope_, UINT8_C(8));
}

void SlopePoint::write(SlopePoint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getPoint().write<::zserio::VarSizeArrayTraits>(out, m_point_);
    context.getSlope().write<::zserio::StdIntArrayTraits<::nds::adas::types::Slope>>(out, m_slope_);
}

::nds::adas::types::AdasGeometryPosition SlopePoint::readPoint(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::AdasGeometryPosition>(in.readVarSize());
}

::nds::adas::types::AdasGeometryPosition SlopePoint::readPoint(SlopePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getPoint().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::adas::types::Slope SlopePoint::readSlope(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::Slope>(in.readSignedBits(UINT8_C(8)));
}

::nds::adas::types::Slope SlopePoint::readSlope(SlopePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getSlope().read<::zserio::StdIntArrayTraits<::nds::adas::types::Slope>>(in);
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/CurvaturePath.h>

namespace nds
{
namespace adas
{
namespace types
{

CurvaturePath::CurvaturePath(const allocator_type& allocator) noexcept :
        m_numOfRoads_(uint8_t()),
        m_curvaturePoints_(allocator),
        m_road_(allocator)
{
}

CurvaturePath::CurvaturePath(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfRoads_(readNumOfRoads(in)),
        m_curvaturePoints_(readCurvaturePoints(in, allocator)),
        m_road_(readRoad(in, allocator))
{
}

CurvaturePath::CurvaturePath(CurvaturePath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfRoads_(readNumOfRoads(context, in)),
        m_curvaturePoints_(readCurvaturePoints(context, in, allocator)),
        m_road_(readRoad(context, in, allocator))
{
}

CurvaturePath::CurvaturePath(::zserio::PropagateAllocatorT,
        const CurvaturePath& other, const allocator_type& allocator) :
        m_numOfRoads_(::zserio::allocatorPropagatingCopy(other.m_numOfRoads_, allocator)),
        m_curvaturePoints_(::zserio::allocatorPropagatingCopy(other.m_curvaturePoints_, allocator)),
        m_road_(::zserio::allocatorPropagatingCopy(other.m_road_, allocator))
{
}

uint8_t CurvaturePath::getNumOfRoads() const
{
    return m_numOfRoads_;
}

void CurvaturePath::setNumOfRoads(uint8_t numOfRoads_)
{
    m_numOfRoads_ = numOfRoads_;
}

::nds::adas::types::CurvaturePointList& CurvaturePath::getCurvaturePoints()
{
    return m_curvaturePoints_;
}

const ::nds::adas::types::CurvaturePointList& CurvaturePath::getCurvaturePoints() const
{
    return m_curvaturePoints_;
}

void CurvaturePath::setCurvaturePoints(const ::nds::adas::types::CurvaturePointList& curvaturePoints_)
{
    m_curvaturePoints_ = curvaturePoints_;
}

void CurvaturePath::setCurvaturePoints(::nds::adas::types::CurvaturePointList&& curvaturePoints_)
{
    m_curvaturePoints_ = ::std::move(curvaturePoints_);
}

::zserio::vector<::nds::adas::types::CurvaturePathRoad>& CurvaturePath::getRoad()
{
    return m_road_.getRawArray();
}

const ::zserio::vector<::nds::adas::types::CurvaturePathRoad>& CurvaturePath::getRoad() const
{
    return m_road_.getRawArray();
}

void CurvaturePath::setRoad(const ::zserio::vector<::nds::adas::types::CurvaturePathRoad>& road_)
{
    m_road_ = ZserioArrayType_road(road_);
}

void CurvaturePath::setRoad(::zserio::vector<::nds::adas::types::CurvaturePathRoad>&& road_)
{
    m_road_ = ZserioArrayType_road(std::move(road_));
}

void CurvaturePath::initPackingContext(CurvaturePath::ZserioPackingContext& context) const
{
    context.getNumOfRoads().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numOfRoads_);
    m_curvaturePoints_.initPackingContext(context.getCurvaturePoints());
}

size_t CurvaturePath::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_curvaturePoints_.bitSizeOf(endBitPosition);
    endBitPosition += m_road_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CurvaturePath::bitSizeOf(CurvaturePath::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfRoads().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numOfRoads_);
    endBitPosition += m_curvaturePoints_.bitSizeOf(context.getCurvaturePoints(), endBitPosition);
    endBitPosition += m_road_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CurvaturePath::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_curvaturePoints_.initializeOffsets(endBitPosition);
    endBitPosition = m_road_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t CurvaturePath::initializeOffsets(CurvaturePath::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfRoads().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numOfRoads_);
    endBitPosition = m_curvaturePoints_.initializeOffsets(context.getCurvaturePoints(), endBitPosition);
    endBitPosition = m_road_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool CurvaturePath::operator==(const CurvaturePath& other) const
{
    if (this != &other)
    {
        return
                (m_numOfRoads_ == other.m_numOfRoads_) &&
                (m_curvaturePoints_ == other.m_curvaturePoints_) &&
                (m_road_ == other.m_road_);
    }

    return true;
}

uint32_t CurvaturePath::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numOfRoads_);
    result = ::zserio::calcHashCode(result, m_curvaturePoints_);
    result = ::zserio::calcHashCode(result, m_road_);

    return result;
}

void CurvaturePath::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numOfRoads_, UINT8_C(8));

    m_curvaturePoints_.write(out);

    // check array length
    if (m_road_.getRawArray().size() != static_cast<size_t>(getNumOfRoads()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CurvaturePath.road: ") <<
                m_road_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfRoads()) << "!";
    }
    m_road_.write(*this, out);
}

void CurvaturePath::write(CurvaturePath::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumOfRoads().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numOfRoads_);

    m_curvaturePoints_.write(context.getCurvaturePoints(), out);

    // check array length
    if (m_road_.getRawArray().size() != static_cast<size_t>(getNumOfRoads()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CurvaturePath.road: ") <<
                m_road_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfRoads()) << "!";
    }
    m_road_.writePacked(*this, out);
}

void CurvaturePath::ZserioElementFactory_road::create(CurvaturePath&        ,
        ::zserio::vector<::nds::adas::types::CurvaturePathRoad>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void CurvaturePath::ZserioElementFactory_road::create(CurvaturePath&        ,
        ::zserio::vector<::nds::adas::types::CurvaturePathRoad>& array,
        ::nds::adas::types::CurvaturePathRoad::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t CurvaturePath::readNumOfRoads(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t CurvaturePath::readNumOfRoads(CurvaturePath::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumOfRoads().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::nds::adas::types::CurvaturePointList CurvaturePath::readCurvaturePoints(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::adas::types::CurvaturePointList(in, allocator);
}

::nds::adas::types::CurvaturePointList CurvaturePath::readCurvaturePoints(CurvaturePath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::adas::types::CurvaturePointList(context.getCurvaturePoints(), in, allocator);
}
CurvaturePath::ZserioArrayType_road CurvaturePath::readRoad(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_road readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumOfRoads()));

    return readField;
}

CurvaturePath::ZserioArrayType_road CurvaturePath::readRoad(CurvaturePath::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_road readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumOfRoads()));

    return readField;
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/CurvaturePathRoad.h>

namespace nds
{
namespace adas
{
namespace types
{

CurvaturePathRoad::CurvaturePathRoad(const allocator_type& allocator) noexcept :
        m_featureReference_(allocator),
        m_curvaturePoints_(allocator)
{
}

CurvaturePathRoad::CurvaturePathRoad(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_featureReference_(readFeatureReference(in, allocator)),
        m_curvaturePoints_(readCurvaturePoints(in, allocator))
{
}

CurvaturePathRoad::CurvaturePathRoad(CurvaturePathRoad::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_featureReference_(readFeatureReference(context, in, allocator)),
        m_curvaturePoints_(readCurvaturePoints(context, in, allocator))
{
}

CurvaturePathRoad::CurvaturePathRoad(::zserio::PropagateAllocatorT,
        const CurvaturePathRoad& other, const allocator_type& allocator) :
        m_featureReference_(::zserio::allocatorPropagatingCopy(other.m_featureReference_, allocator)),
        m_curvaturePoints_(::zserio::allocatorPropagatingCopy(other.m_curvaturePoints_, allocator))
{
}

::nds::road::reference::types::DirectedRoadReference& CurvaturePathRoad::getFeatureReference()
{
    return m_featureReference_;
}

const ::nds::road::reference::types::DirectedRoadReference& CurvaturePathRoad::getFeatureReference() const
{
    return m_featureReference_;
}

void CurvaturePathRoad::setFeatureReference(const ::nds::road::reference::types::DirectedRoadReference& featureReference_)
{
    m_featureReference_ = featureReference_;
}

void CurvaturePathRoad::setFeatureReference(::nds::road::reference::types::DirectedRoadReference&& featureReference_)
{
    m_featureReference_ = ::std::move(featureReference_);
}

::nds::adas::types::CurvaturePointList& CurvaturePathRoad::getCurvaturePoints()
{
    return m_curvaturePoints_;
}

const ::nds::adas::types::CurvaturePointList& CurvaturePathRoad::getCurvaturePoints() const
{
    return m_curvaturePoints_;
}

void CurvaturePathRoad::setCurvaturePoints(const ::nds::adas::types::CurvaturePointList& curvaturePoints_)
{
    m_curvaturePoints_ = curvaturePoints_;
}

void CurvaturePathRoad::setCurvaturePoints(::nds::adas::types::CurvaturePointList&& curvaturePoints_)
{
    m_curvaturePoints_ = ::std::move(curvaturePoints_);
}

void CurvaturePathRoad::initPackingContext(CurvaturePathRoad::ZserioPackingContext& context) const
{
    m_featureReference_.initPackingContext(context.getFeatureReference());
    m_curvaturePoints_.initPackingContext(context.getCurvaturePoints());
}

size_t CurvaturePathRoad::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_featureReference_.bitSizeOf(endBitPosition);
    endBitPosition += m_curvaturePoints_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CurvaturePathRoad::bitSizeOf(CurvaturePathRoad::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_featureReference_.bitSizeOf(context.getFeatureReference(), endBitPosition);
    endBitPosition += m_curvaturePoints_.bitSizeOf(context.getCurvaturePoints(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CurvaturePathRoad::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_featureReference_.initializeOffsets(endBitPosition);
    endBitPosition = m_curvaturePoints_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t CurvaturePathRoad::initializeOffsets(CurvaturePathRoad::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_featureReference_.initializeOffsets(context.getFeatureReference(), endBitPosition);
    endBitPosition = m_curvaturePoints_.initializeOffsets(context.getCurvaturePoints(), endBitPosition);

    return endBitPosition;
}

bool CurvaturePathRoad::operator==(const CurvaturePathRoad& other) const
{
    if (this != &other)
    {
        return
                (m_featureReference_ == other.m_featureReference_) &&
                (m_curvaturePoints_ == other.m_curvaturePoints_);
    }

    return true;
}

uint32_t CurvaturePathRoad::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_featureReference_);
    result = ::zserio::calcHashCode(result, m_curvaturePoints_);

    return result;
}

void CurvaturePathRoad::write(::zserio::BitStreamWriter& out) const
{
    m_featureReference_.write(out);
    m_curvaturePoints_.write(out);
}

void CurvaturePathRoad::write(CurvaturePathRoad::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_featureReference_.write(context.getFeatureReference(), out);
    m_curvaturePoints_.write(context.getCurvaturePoints(), out);
}

::nds::road::reference::types::DirectedRoadReference CurvaturePathRoad::readFeatureReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::DirectedRoadReference(in, allocator);
}

::nds::road::reference::types::DirectedRoadReference CurvaturePathRoad::readFeatureReference(CurvaturePathRoad::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::DirectedRoadReference(context.getFeatureReference(), in, allocator);
}
::nds::adas::types::CurvaturePointList CurvaturePathRoad::readCurvaturePoints(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::adas::types::CurvaturePointList(in, allocator);
}

::nds::adas::types::CurvaturePointList CurvaturePathRoad::readCurvaturePoints(CurvaturePathRoad::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::adas::types::CurvaturePointList(context.getCurvaturePoints(), in, allocator);
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/CurvaturePointList.h>

namespace nds
{
namespace adas
{
namespace types
{

CurvaturePointList::CurvaturePointList(const allocator_type& allocator) noexcept :
        m_numOfValues_(uint16_t()),
        m_curvaturePoint_(allocator)
{
}

CurvaturePointList::CurvaturePointList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(in)),
        m_curvaturePoint_(readCurvaturePoint(in, allocator))
{
}

CurvaturePointList::CurvaturePointList(CurvaturePointList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(context, in)),
        m_curvaturePoint_(readCurvaturePoint(context, in, allocator))
{
}

CurvaturePointList::CurvaturePointList(::zserio::PropagateAllocatorT,
        const CurvaturePointList& other, const allocator_type& allocator) :
        m_numOfValues_(::zserio::allocatorPropagatingCopy(other.m_numOfValues_, allocator)),
        m_curvaturePoint_(::zserio::allocatorPropagatingCopy(other.m_curvaturePoint_, allocator))
{
}

uint16_t CurvaturePointList::getNumOfValues() const
{
    return m_numOfValues_;
}

void CurvaturePointList::setNumOfValues(uint16_t numOfValues_)
{
    m_numOfValues_ = numOfValues_;
}

::zserio::vector<::nds::adas::types::CurvaturePoint>& CurvaturePointList::getCurvaturePoint()
{
    return m_curvaturePoint_.getRawArray();
}

const ::zserio::vector<::nds::adas::types::CurvaturePoint>& CurvaturePointList::getCurvaturePoint() const
{
    return m_curvaturePoint_.getRawArray();
}

void CurvaturePointList::setCurvaturePoint(const ::zserio::vector<::nds::adas::types::CurvaturePoint>& curvaturePoint_)
{
    m_curvaturePoint_ = ZserioArrayType_curvaturePoint(curvaturePoint_);
}

void CurvaturePointList::setCurvaturePoint(::zserio::vector<::nds::adas::types::CurvaturePoint>&& curvaturePoint_)
{
    m_curvaturePoint_ = ZserioArrayType_curvaturePoint(std::move(curvaturePoint_));
}

void CurvaturePointList::initPackingContext(CurvaturePointList::ZserioPackingContext& context) const
{
    context.getNumOfValues().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
}

size_t CurvaturePointList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition += m_curvaturePoint_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CurvaturePointList::bitSizeOf(CurvaturePointList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition += m_curvaturePoint_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CurvaturePointList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition = m_curvaturePoint_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t CurvaturePointList::initializeOffsets(CurvaturePointList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition = m_curvaturePoint_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool CurvaturePointList::operator==(const CurvaturePointList& other) const
{
    if (this != &other)
    {
        return
                (m_numOfValues_ == other.m_numOfValues_) &&
                (m_curvaturePoint_ == other.m_curvaturePoint_);
    }

    return true;
}

uint32_t CurvaturePointList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numOfValues_);
    result = ::zserio::calcHashCode(result, m_curvaturePoint_);

    return result;
}

void CurvaturePointList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numOfValues_);

    // check array length
    if (m_curvaturePoint_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CurvaturePointList.curvaturePoint: ") <<
                m_curvaturePoint_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_curvaturePoint_.write(*this, out);
}

void CurvaturePointList::write(CurvaturePointList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumOfValues().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numOfValues_);

    // check array length
    if (m_curvaturePoint_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CurvaturePointList.curvaturePoint: ") <<
                m_curvaturePoint_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_curvaturePoint_.writePacked(*this, out);
}

void CurvaturePointList::ZserioElementFactory_curvaturePoint::create(CurvaturePointList&        ,
        ::zserio::vector<::nds::adas::types::CurvaturePoint>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void CurvaturePointList::ZserioElementFactory_curvaturePoint::create(CurvaturePointList&        ,
        ::zserio::vector<::nds::adas::types::CurvaturePoint>& array,
        ::nds::adas::types::CurvaturePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint16_t CurvaturePointList::readNumOfValues(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t CurvaturePointList::readNumOfValues(CurvaturePointList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumOfValues().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
CurvaturePointList::ZserioArrayType_curvaturePoint CurvaturePointList::readCurvaturePoint(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_curvaturePoint readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

CurvaturePointList::ZserioArrayType_curvaturePoint CurvaturePointList::readCurvaturePoint(CurvaturePointList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_curvaturePoint readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/CurvaturePoint.h>

namespace nds
{
namespace adas
{
namespace types
{

CurvaturePoint::CurvaturePoint(const allocator_type&) noexcept :
        m_point_(::nds::adas::types::AdasGeometryPosition()),
        m_curvature_(::nds::adas::types::Curvature())
{
}

CurvaturePoint::CurvaturePoint(::zserio::BitStreamReader& in, const allocator_type&) :
        m_point_(readPoint(in)),
        m_curvature_(readCurvature(in))
{
}

CurvaturePoint::CurvaturePoint(CurvaturePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_point_(readPoint(context, in)),
        m_curvature_(readCurvature(context, in))
{
}

CurvaturePoint::CurvaturePoint(::zserio::PropagateAllocatorT,
        const CurvaturePoint& other, const allocator_type& allocator) :
        m_point_(::zserio::allocatorPropagatingCopy(other.m_point_, allocator)),
        m_curvature_(::zserio::allocatorPropagatingCopy(other.m_curvature_, allocator))
{
}

::nds::adas::types::AdasGeometryPosition CurvaturePoint::getPoint() const
{
    return m_point_;
}

void CurvaturePoint::setPoint(::nds::adas::types::AdasGeometryPosition point_)
{
    m_point_ = point_;
}

::nds::adas::types::Curvature CurvaturePoint::getCurvature() const
{
    return m_curvature_;
}

void CurvaturePoint::setCurvature(::nds::adas::types::Curvature curvature_)
{
    m_curvature_ = curvature_;
}

void CurvaturePoint::initPackingContext(CurvaturePoint::ZserioPackingContext& context) const
{
    context.getPoint().init<::zserio::VarSizeArrayTraits>(m_point_);
    context.getCurvature().init<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(m_curvature_);
}

size_t CurvaturePoint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_point_);
    endBitPosition += UINT8_C(10);

    return endBitPosition - bitPosition;
}

size_t CurvaturePoint::bitSizeOf(CurvaturePoint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPoint().bitSizeOf<::zserio::VarSizeArrayTraits>(m_point_);
    endBitPosition += context.getCurvature().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(m_curvature_);

    return endBitPosition - bitPosition;
}

size_t CurvaturePoint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_point_);
    endBitPosition += UINT8_C(10);

    return endBitPosition;
}

size_t CurvaturePoint::initializeOffsets(CurvaturePoint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPoint().bitSizeOf<::zserio::VarSizeArrayTraits>(m_point_);
    endBitPosition += context.getCurvature().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(m_curvature_);

    return endBitPosition;
}

bool CurvaturePoint::operator==(const CurvaturePoint& other) const
{
    if (this != &other)
    {
        return
                (m_point_ == other.m_point_) &&
                (m_curvature_ == other.m_curvature_);
    }

    return true;
}

uint32_t CurvaturePoint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_point_);
    result = ::zserio::calcHashCode(result, m_curvature_);

    return result;
}

void CurvaturePoint::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_point_);
    out.writeBits(m_curvature_, UINT8_C(10));
}

void CurvaturePoint::write(CurvaturePoint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getPoint().write<::zserio::VarSizeArrayTraits>(out, m_point_);
    context.getCurvature().write<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(out, m_curvature_);
}

::nds::adas::types::AdasGeometryPosition CurvaturePoint::readPoint(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::AdasGeometryPosition>(in.readVarSize());
}

::nds::adas::types::AdasGeometryPosition CurvaturePoint::readPoint(CurvaturePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getPoint().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::adas::types::Curvature CurvaturePoint::readCurvature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::Curvature>(in.readBits(UINT8_C(10)));
}

::nds::adas::types::Curvature CurvaturePoint::readCurvature(CurvaturePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCurvature().read<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(in);
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/Clothoid.h>

namespace nds
{
namespace adas
{
namespace types
{

Clothoid::Clothoid(const allocator_type& allocator) noexcept :
        m_numOfValues_(uint16_t()),
        m_clothoidData_(allocator)
{
}

Clothoid::Clothoid(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(in)),
        m_clothoidData_(readClothoidData(in, allocator))
{
}

Clothoid::Clothoid(Clothoid::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(context, in)),
        m_clothoidData_(readClothoidData(context, in, allocator))
{
}

Clothoid::Clothoid(::zserio::PropagateAllocatorT,
        const Clothoid& other, const allocator_type& allocator) :
        m_numOfValues_(::zserio::allocatorPropagatingCopy(other.m_numOfValues_, allocator)),
        m_clothoidData_(::zserio::allocatorPropagatingCopy(other.m_clothoidData_, allocator))
{
}

uint16_t Clothoid::getNumOfValues() const
{
    return m_numOfValues_;
}

void Clothoid::setNumOfValues(uint16_t numOfValues_)
{
    m_numOfValues_ = numOfValues_;
}

::zserio::vector<::nds::adas::types::ClothoidData>& Clothoid::getClothoidData()
{
    return m_clothoidData_.getRawArray();
}

const ::zserio::vector<::nds::adas::types::ClothoidData>& Clothoid::getClothoidData() const
{
    return m_clothoidData_.getRawArray();
}

void Clothoid::setClothoidData(const ::zserio::vector<::nds::adas::types::ClothoidData>& clothoidData_)
{
    m_clothoidData_ = ZserioArrayType_clothoidData(clothoidData_);
}

void Clothoid::setClothoidData(::zserio::vector<::nds::adas::types::ClothoidData>&& clothoidData_)
{
    m_clothoidData_ = ZserioArrayType_clothoidData(std::move(clothoidData_));
}

void Clothoid::initPackingContext(Clothoid::ZserioPackingContext& context) const
{
    context.getNumOfValues().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
}

size_t Clothoid::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition += m_clothoidData_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Clothoid::bitSizeOf(Clothoid::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition += m_clothoidData_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Clothoid::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition = m_clothoidData_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t Clothoid::initializeOffsets(Clothoid::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition = m_clothoidData_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Clothoid::operator==(const Clothoid& other) const
{
    if (this != &other)
    {
        return
                (m_numOfValues_ == other.m_numOfValues_) &&
                (m_clothoidData_ == other.m_clothoidData_);
    }

    return true;
}

uint32_t Clothoid::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numOfValues_);
    result = ::zserio::calcHashCode(result, m_clothoidData_);

    return result;
}

void Clothoid::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numOfValues_);

    // check array length
    if (m_clothoidData_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Clothoid.clothoidData: ") <<
                m_clothoidData_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_clothoidData_.write(*this, out);
}

void Clothoid::write(Clothoid::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumOfValues().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numOfValues_);

    // check array length
    if (m_clothoidData_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Clothoid.clothoidData: ") <<
                m_clothoidData_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_clothoidData_.writePacked(*this, out);
}

void Clothoid::ZserioElementFactory_clothoidData::create(Clothoid&        ,
        ::zserio::vector<::nds::adas::types::ClothoidData>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Clothoid::ZserioElementFactory_clothoidData::create(Clothoid&        ,
        ::zserio::vector<::nds::adas::types::ClothoidData>& array,
        ::nds::adas::types::ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint16_t Clothoid::readNumOfValues(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t Clothoid::readNumOfValues(Clothoid::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumOfValues().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
Clothoid::ZserioArrayType_clothoidData Clothoid::readClothoidData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_clothoidData readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

Clothoid::ZserioArrayType_clothoidData Clothoid::readClothoidData(Clothoid::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_clothoidData readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/ClothoidData.h>

namespace nds
{
namespace adas
{
namespace types
{

ClothoidData::ClothoidData(const allocator_type& allocator) noexcept :
        m_clothoidDataDescription_(allocator),
        m_clothoidPosition_(::zserio::NullOpt),
        m_tangentArcStart_(::zserio::NullOpt),
        m_tangentArcEnd_(::zserio::NullOpt),
        m_curvatureStart_(::zserio::NullOpt),
        m_curvatureEnd_(::zserio::NullOpt),
        m_deltaChainage_(::zserio::NullOpt)
{
}

ClothoidData::ClothoidData(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_clothoidDataDescription_(readClothoidDataDescription(in, allocator)),
        m_clothoidPosition_(readClothoidPosition(in)),
        m_tangentArcStart_(readTangentArcStart(in)),
        m_tangentArcEnd_(readTangentArcEnd(in)),
        m_curvatureStart_(readCurvatureStart(in)),
        m_curvatureEnd_(readCurvatureEnd(in)),
        m_deltaChainage_(readDeltaChainage(in))
{
}

ClothoidData::ClothoidData(ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_clothoidDataDescription_(readClothoidDataDescription(context, in, allocator)),
        m_clothoidPosition_(readClothoidPosition(context, in)),
        m_tangentArcStart_(readTangentArcStart(context, in)),
        m_tangentArcEnd_(readTangentArcEnd(context, in)),
        m_curvatureStart_(readCurvatureStart(context, in)),
        m_curvatureEnd_(readCurvatureEnd(context, in)),
        m_deltaChainage_(readDeltaChainage(context, in))
{
}

ClothoidData::ClothoidData(::zserio::PropagateAllocatorT,
        const ClothoidData& other, const allocator_type& allocator) :
        m_clothoidDataDescription_(::zserio::allocatorPropagatingCopy(other.m_clothoidDataDescription_, allocator)),
        m_clothoidPosition_(::zserio::allocatorPropagatingCopy(other.m_clothoidPosition_, allocator)),
        m_tangentArcStart_(::zserio::allocatorPropagatingCopy(other.m_tangentArcStart_, allocator)),
        m_tangentArcEnd_(::zserio::allocatorPropagatingCopy(other.m_tangentArcEnd_, allocator)),
        m_curvatureStart_(::zserio::allocatorPropagatingCopy(other.m_curvatureStart_, allocator)),
        m_curvatureEnd_(::zserio::allocatorPropagatingCopy(other.m_curvatureEnd_, allocator)),
        m_deltaChainage_(::zserio::allocatorPropagatingCopy(other.m_deltaChainage_, allocator))
{
}

::nds::adas::types::ClothoidDataDescription& ClothoidData::getClothoidDataDescription()
{
    return m_clothoidDataDescription_;
}

const ::nds::adas::types::ClothoidDataDescription& ClothoidData::getClothoidDataDescription() const
{
    return m_clothoidDataDescription_;
}

void ClothoidData::setClothoidDataDescription(const ::nds::adas::types::ClothoidDataDescription& clothoidDataDescription_)
{
    m_clothoidDataDescription_ = clothoidDataDescription_;
}

void ClothoidData::setClothoidDataDescription(::nds::adas::types::ClothoidDataDescription&& clothoidDataDescription_)
{
    m_clothoidDataDescription_ = ::std::move(clothoidDataDescription_);
}

::nds::adas::types::AdasGeometryPosition ClothoidData::getClothoidPosition() const
{
    return m_clothoidPosition_.value();
}

void ClothoidData::setClothoidPosition(::nds::adas::types::AdasGeometryPosition clothoidPosition_)
{
    m_clothoidPosition_ = clothoidPosition_;
}

bool ClothoidData::isClothoidPositionUsed() const
{
    return (getClothoidDataDescription().getHasCoordDiff() == true);
}

bool ClothoidData::isClothoidPositionSet() const
{
    return m_clothoidPosition_.hasValue();
}

void ClothoidData::resetClothoidPosition()
{
    m_clothoidPosition_.reset();
}

::nds::adas::types::TangentArc ClothoidData::getTangentArcStart() const
{
    return m_tangentArcStart_.value();
}

void ClothoidData::setTangentArcStart(::nds::adas::types::TangentArc tangentArcStart_)
{
    m_tangentArcStart_ = tangentArcStart_;
}

bool ClothoidData::isTangentArcStartUsed() const
{
    return (getClothoidDataDescription().getHasTStart() == true);
}

bool ClothoidData::isTangentArcStartSet() const
{
    return m_tangentArcStart_.hasValue();
}

void ClothoidData::resetTangentArcStart()
{
    m_tangentArcStart_.reset();
}

::nds::adas::types::TangentArc ClothoidData::getTangentArcEnd() const
{
    return m_tangentArcEnd_.value();
}

void ClothoidData::setTangentArcEnd(::nds::adas::types::TangentArc tangentArcEnd_)
{
    m_tangentArcEnd_ = tangentArcEnd_;
}

bool ClothoidData::isTangentArcEndUsed() const
{
    return (getClothoidDataDescription().getHasTEnd() == true);
}

bool ClothoidData::isTangentArcEndSet() const
{
    return m_tangentArcEnd_.hasValue();
}

void ClothoidData::resetTangentArcEnd()
{
    m_tangentArcEnd_.reset();
}

::nds::adas::types::ClothoidCurvature ClothoidData::getCurvatureStart() const
{
    return m_curvatureStart_.value();
}

void ClothoidData::setCurvatureStart(::nds::adas::types::ClothoidCurvature curvatureStart_)
{
    m_curvatureStart_ = curvatureStart_;
}

bool ClothoidData::isCurvatureStartUsed() const
{
    return (getClothoidDataDescription().getHasCStart() == true);
}

bool ClothoidData::isCurvatureStartSet() const
{
    return m_curvatureStart_.hasValue();
}

void ClothoidData::resetCurvatureStart()
{
    m_curvatureStart_.reset();
}

::nds::adas::types::ClothoidCurvature ClothoidData::getCurvatureEnd() const
{
    return m_curvatureEnd_.value();
}

void ClothoidData::setCurvatureEnd(::nds::adas::types::ClothoidCurvature curvatureEnd_)
{
    m_curvatureEnd_ = curvatureEnd_;
}

bool ClothoidData::isCurvatureEndUsed() const
{
    return (getClothoidDataDescription().getHasCEnd() == true);
}

bool ClothoidData::isCurvatureEndSet() const
{
    return m_curvatureEnd_.hasValue();
}

void ClothoidData::resetCurvatureEnd()
{
    m_curvatureEnd_.reset();
}

uint32_t ClothoidData::getDeltaChainage() const
{
    return m_deltaChainage_.value();
}

void ClothoidData::setDeltaChainage(uint32_t deltaChainage_)
{
    m_deltaChainage_ = deltaChainage_;
}

bool ClothoidData::isDeltaChainageUsed() const
{
    return (getClothoidDataDescription().getHasChainageDiff() == true);
}

bool ClothoidData::isDeltaChainageSet() const
{
    return m_deltaChainage_.hasValue();
}

void ClothoidData::resetDeltaChainage()
{
    m_deltaChainage_.reset();
}

void ClothoidData::initPackingContext(ClothoidData::ZserioPackingContext& context) const
{
    m_clothoidDataDescription_.initPackingContext(context.getClothoidDataDescription());
    if (getClothoidDataDescription().getHasCoordDiff() == true)
    {
        context.getClothoidPosition().init<::zserio::VarSizeArrayTraits>(m_clothoidPosition_.value());
    }
    if (getClothoidDataDescription().getHasTStart() == true)
    {
        context.getTangentArcStart().init<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(m_tangentArcStart_.value());
    }
    if (getClothoidDataDescription().getHasTEnd() == true)
    {
        context.getTangentArcEnd().init<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(m_tangentArcEnd_.value());
    }
    if (getClothoidDataDescription().getHasCStart() == true)
    {
        context.getCurvatureStart().init<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(m_curvatureStart_.value());
    }
    if (getClothoidDataDescription().getHasCEnd() == true)
    {
        context.getCurvatureEnd().init<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(m_curvatureEnd_.value());
    }
    if (getClothoidDataDescription().getHasChainageDiff() == true)
    {
        context.getDeltaChainage().init<::zserio::VarSizeArrayTraits>(m_deltaChainage_.value());
    }
}

size_t ClothoidData::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_clothoidDataDescription_.bitSizeOf(endBitPosition);
    if (getClothoidDataDescription().getHasCoordDiff() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_clothoidPosition_.value());
    }
    if (getClothoidDataDescription().getHasTStart() == true)
    {
        endBitPosition += UINT8_C(16);
    }
    if (getClothoidDataDescription().getHasTEnd() == true)
    {
        endBitPosition += UINT8_C(16);
    }
    if (getClothoidDataDescription().getHasCStart() == true)
    {
        endBitPosition += UINT8_C(10);
    }
    if (getClothoidDataDescription().getHasCEnd() == true)
    {
        endBitPosition += UINT8_C(10);
    }
    if (getClothoidDataDescription().getHasChainageDiff() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_deltaChainage_.value());
    }

    return endBitPosition - bitPosition;
}

size_t ClothoidData::bitSizeOf(ClothoidData::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_clothoidDataDescription_.bitSizeOf(context.getClothoidDataDescription(), endBitPosition);
    if (getClothoidDataDescription().getHasCoordDiff() == true)
    {
        endBitPosition += context.getClothoidPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_clothoidPosition_.value());
    }
    if (getClothoidDataDescription().getHasTStart() == true)
    {
        endBitPosition += context.getTangentArcStart().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(m_tangentArcStart_.value());
    }
    if (getClothoidDataDescription().getHasTEnd() == true)
    {
        endBitPosition += context.getTangentArcEnd().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(m_tangentArcEnd_.value());
    }
    if (getClothoidDataDescription().getHasCStart() == true)
    {
        endBitPosition += context.getCurvatureStart().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(m_curvatureStart_.value());
    }
    if (getClothoidDataDescription().getHasCEnd() == true)
    {
        endBitPosition += context.getCurvatureEnd().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(m_curvatureEnd_.value());
    }
    if (getClothoidDataDescription().getHasChainageDiff() == true)
    {
        endBitPosition += context.getDeltaChainage().bitSizeOf<::zserio::VarSizeArrayTraits>(m_deltaChainage_.value());
    }

    return endBitPosition - bitPosition;
}

size_t ClothoidData::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_clothoidDataDescription_.initializeOffsets(endBitPosition);
    if (getClothoidDataDescription().getHasCoordDiff() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_clothoidPosition_.value());
    }
    if (getClothoidDataDescription().getHasTStart() == true)
    {
        endBitPosition += UINT8_C(16);
    }
    if (getClothoidDataDescription().getHasTEnd() == true)
    {
        endBitPosition += UINT8_C(16);
    }
    if (getClothoidDataDescription().getHasCStart() == true)
    {
        endBitPosition += UINT8_C(10);
    }
    if (getClothoidDataDescription().getHasCEnd() == true)
    {
        endBitPosition += UINT8_C(10);
    }
    if (getClothoidDataDescription().getHasChainageDiff() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_deltaChainage_.value());
    }

    return endBitPosition;
}

size_t ClothoidData::initializeOffsets(ClothoidData::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_clothoidDataDescription_.initializeOffsets(context.getClothoidDataDescription(), endBitPosition);
    if (getClothoidDataDescription().getHasCoordDiff() == true)
    {
        endBitPosition += context.getClothoidPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_clothoidPosition_.value());
    }
    if (getClothoidDataDescription().getHasTStart() == true)
    {
        endBitPosition += context.getTangentArcStart().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(m_tangentArcStart_.value());
    }
    if (getClothoidDataDescription().getHasTEnd() == true)
    {
        endBitPosition += context.getTangentArcEnd().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(m_tangentArcEnd_.value());
    }
    if (getClothoidDataDescription().getHasCStart() == true)
    {
        endBitPosition += context.getCurvatureStart().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(m_curvatureStart_.value());
    }
    if (getClothoidDataDescription().getHasCEnd() == true)
    {
        endBitPosition += context.getCurvatureEnd().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(m_curvatureEnd_.value());
    }
    if (getClothoidDataDescription().getHasChainageDiff() == true)
    {
        endBitPosition += context.getDeltaChainage().bitSizeOf<::zserio::VarSizeArrayTraits>(m_deltaChainage_.value());
    }

    return endBitPosition;
}

bool ClothoidData::operator==(const ClothoidData& other) const
{
    if (this != &other)
    {
        return
                (m_clothoidDataDescription_ == other.m_clothoidDataDescription_) &&
                (!isClothoidPositionUsed() ? !other.isClothoidPositionUsed() : (m_clothoidPosition_ == other.m_clothoidPosition_)) &&
                (!isTangentArcStartUsed() ? !other.isTangentArcStartUsed() : (m_tangentArcStart_ == other.m_tangentArcStart_)) &&
                (!isTangentArcEndUsed() ? !other.isTangentArcEndUsed() : (m_tangentArcEnd_ == other.m_tangentArcEnd_)) &&
                (!isCurvatureStartUsed() ? !other.isCurvatureStartUsed() : (m_curvatureStart_ == other.m_curvatureStart_)) &&
                (!isCurvatureEndUsed() ? !other.isCurvatureEndUsed() : (m_curvatureEnd_ == other.m_curvatureEnd_)) &&
                (!isDeltaChainageUsed() ? !other.isDeltaChainageUsed() : (m_deltaChainage_ == other.m_deltaChainage_));
    }

    return true;
}

uint32_t ClothoidData::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_clothoidDataDescription_);
    if (isClothoidPositionUsed())
        result = ::zserio::calcHashCode(result, m_clothoidPosition_);
    if (isTangentArcStartUsed())
        result = ::zserio::calcHashCode(result, m_tangentArcStart_);
    if (isTangentArcEndUsed())
        result = ::zserio::calcHashCode(result, m_tangentArcEnd_);
    if (isCurvatureStartUsed())
        result = ::zserio::calcHashCode(result, m_curvatureStart_);
    if (isCurvatureEndUsed())
        result = ::zserio::calcHashCode(result, m_curvatureEnd_);
    if (isDeltaChainageUsed())
        result = ::zserio::calcHashCode(result, m_deltaChainage_);

    return result;
}

void ClothoidData::write(::zserio::BitStreamWriter& out) const
{
    m_clothoidDataDescription_.write(out);
    if (getClothoidDataDescription().getHasCoordDiff() == true)
    {
        out.writeVarSize(m_clothoidPosition_.value());
    }
    if (getClothoidDataDescription().getHasTStart() == true)
    {
        out.writeBits(m_tangentArcStart_.value(), UINT8_C(16));
    }
    if (getClothoidDataDescription().getHasTEnd() == true)
    {
        out.writeBits(m_tangentArcEnd_.value(), UINT8_C(16));
    }
    if (getClothoidDataDescription().getHasCStart() == true)
    {
        out.writeBits(m_curvatureStart_.value(), UINT8_C(10));
    }
    if (getClothoidDataDescription().getHasCEnd() == true)
    {
        out.writeBits(m_curvatureEnd_.value(), UINT8_C(10));
    }
    if (getClothoidDataDescription().getHasChainageDiff() == true)
    {
        out.writeVarSize(m_deltaChainage_.value());
    }
}

void ClothoidData::write(ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_clothoidDataDescription_.write(context.getClothoidDataDescription(), out);
    if (getClothoidDataDescription().getHasCoordDiff() == true)
    {
        context.getClothoidPosition().write<::zserio::VarSizeArrayTraits>(out, m_clothoidPosition_.value());
    }
    if (getClothoidDataDescription().getHasTStart() == true)
    {
        context.getTangentArcStart().write<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(out, m_tangentArcStart_.value());
    }
    if (getClothoidDataDescription().getHasTEnd() == true)
    {
        context.getTangentArcEnd().write<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(out, m_tangentArcEnd_.value());
    }
    if (getClothoidDataDescription().getHasCStart() == true)
    {
        context.getCurvatureStart().write<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(out, m_curvatureStart_.value());
    }
    if (getClothoidDataDescription().getHasCEnd() == true)
    {
        context.getCurvatureEnd().write<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(out, m_curvatureEnd_.value());
    }
    if (getClothoidDataDescription().getHasChainageDiff() == true)
    {
        context.getDeltaChainage().write<::zserio::VarSizeArrayTraits>(out, m_deltaChainage_.value());
    }
}

::nds::adas::types::ClothoidDataDescription ClothoidData::readClothoidDataDescription(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::adas::types::ClothoidDataDescription(in, allocator);
}

::nds::adas::types::ClothoidDataDescription ClothoidData::readClothoidDataDescription(ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::adas::types::ClothoidDataDescription(context.getClothoidDataDescription(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::adas::types::AdasGeometryPosition> ClothoidData::readClothoidPosition(::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasCoordDiff() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::AdasGeometryPosition>(static_cast<::nds::adas::types::AdasGeometryPosition>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::AdasGeometryPosition>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::adas::types::AdasGeometryPosition> ClothoidData::readClothoidPosition(ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasCoordDiff() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::AdasGeometryPosition>(context.getClothoidPosition().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::AdasGeometryPosition>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc> ClothoidData::readTangentArcStart(::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasTStart() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc>(static_cast<::nds::adas::types::TangentArc>(in.readBits(UINT8_C(16))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc> ClothoidData::readTangentArcStart(ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasTStart() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc>(context.getTangentArcStart().read<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc> ClothoidData::readTangentArcEnd(::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasTEnd() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc>(static_cast<::nds::adas::types::TangentArc>(in.readBits(UINT8_C(16))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc> ClothoidData::readTangentArcEnd(ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasTEnd() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc>(context.getTangentArcEnd().read<::zserio::StdIntArrayTraits<::nds::adas::types::TangentArc>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::TangentArc>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature> ClothoidData::readCurvatureStart(::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasCStart() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature>(static_cast<::nds::adas::types::ClothoidCurvature>(in.readBits(UINT8_C(10))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature> ClothoidData::readCurvatureStart(ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasCStart() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature>(context.getCurvatureStart().read<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature> ClothoidData::readCurvatureEnd(::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasCEnd() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature>(static_cast<::nds::adas::types::ClothoidCurvature>(in.readBits(UINT8_C(10))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature> ClothoidData::readCurvatureEnd(ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasCEnd() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature>(context.getCurvatureEnd().read<::zserio::BitFieldArrayTraits<::nds::adas::types::ClothoidCurvature, UINT8_C(10)>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::adas::types::ClothoidCurvature>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint32_t> ClothoidData::readDeltaChainage(::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasChainageDiff() == true)
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> ClothoidData::readDeltaChainage(ClothoidData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getClothoidDataDescription().getHasChainageDiff() == true)
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(context.getDeltaChainage().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/ClothoidDataDescription.h>

namespace nds
{
namespace adas
{
namespace types
{

ClothoidDataDescription::ClothoidDataDescription(const allocator_type&) noexcept :
        m_numberOfSteps_(uint16_t()),
        m_numBits_(uint8_t()),
        m_hasCoordDiff_(bool()),
        m_hasTStart_(bool()),
        m_hasTEnd_(bool()),
        m_hasCStart_(bool()),
        m_hasCEnd_(bool()),
        m_hasChainageDiff_(bool())
{
}

ClothoidDataDescription::ClothoidDataDescription(::zserio::BitStreamReader& in, const allocator_type&) :
        m_numberOfSteps_(readNumberOfSteps(in)),
        m_numBits_(readNumBits(in)),
        m_hasCoordDiff_(readHasCoordDiff(in)),
        m_hasTStart_(readHasTStart(in)),
        m_hasTEnd_(readHasTEnd(in)),
        m_hasCStart_(readHasCStart(in)),
        m_hasCEnd_(readHasCEnd(in)),
        m_hasChainageDiff_(readHasChainageDiff(in))
{
}

ClothoidDataDescription::ClothoidDataDescription(ClothoidDataDescription::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_numberOfSteps_(readNumberOfSteps(context, in)),
        m_numBits_(readNumBits(context, in)),
        m_hasCoordDiff_(readHasCoordDiff(in)),
        m_hasTStart_(readHasTStart(in)),
        m_hasTEnd_(readHasTEnd(in)),
        m_hasCStart_(readHasCStart(in)),
        m_hasCEnd_(readHasCEnd(in)),
        m_hasChainageDiff_(readHasChainageDiff(in))
{
}

ClothoidDataDescription::ClothoidDataDescription(::zserio::PropagateAllocatorT,
        const ClothoidDataDescription& other, const allocator_type& allocator) :
        m_numberOfSteps_(::zserio::allocatorPropagatingCopy(other.m_numberOfSteps_, allocator)),
        m_numBits_(::zserio::allocatorPropagatingCopy(other.m_numBits_, allocator)),
        m_hasCoordDiff_(::zserio::allocatorPropagatingCopy(other.m_hasCoordDiff_, allocator)),
        m_hasTStart_(::zserio::allocatorPropagatingCopy(other.m_hasTStart_, allocator)),
        m_hasTEnd_(::zserio::allocatorPropagatingCopy(other.m_hasTEnd_, allocator)),
        m_hasCStart_(::zserio::allocatorPropagatingCopy(other.m_hasCStart_, allocator)),
        m_hasCEnd_(::zserio::allocatorPropagatingCopy(other.m_hasCEnd_, allocator)),
        m_hasChainageDiff_(::zserio::allocatorPropagatingCopy(other.m_hasChainageDiff_, allocator))
{
}

uint16_t ClothoidDataDescription::getNumberOfSteps() const
{
    return m_numberOfSteps_;
}

void ClothoidDataDescription::setNumberOfSteps(uint16_t numberOfSteps_)
{
    m_numberOfSteps_ = numberOfSteps_;
}

uint8_t ClothoidDataDescription::getNumBits() const
{
    return m_numBits_;
}

void ClothoidDataDescription::setNumBits(uint8_t numBits_)
{
    m_numBits_ = numBits_;
}

bool ClothoidDataDescription::getHasCoordDiff() const
{
    return m_hasCoordDiff_;
}

void ClothoidDataDescription::setHasCoordDiff(bool hasCoordDiff_)
{
    m_hasCoordDiff_ = hasCoordDiff_;
}

bool ClothoidDataDescription::getHasTStart() const
{
    return m_hasTStart_;
}

void ClothoidDataDescription::setHasTStart(bool hasTStart_)
{
    m_hasTStart_ = hasTStart_;
}

bool ClothoidDataDescription::getHasTEnd() const
{
    return m_hasTEnd_;
}

void ClothoidDataDescription::setHasTEnd(bool hasTEnd_)
{
    m_hasTEnd_ = hasTEnd_;
}

bool ClothoidDataDescription::getHasCStart() const
{
    return m_hasCStart_;
}

void ClothoidDataDescription::setHasCStart(bool hasCStart_)
{
    m_hasCStart_ = hasCStart_;
}

bool ClothoidDataDescription::getHasCEnd() const
{
    return m_hasCEnd_;
}

void ClothoidDataDescription::setHasCEnd(bool hasCEnd_)
{
    m_hasCEnd_ = hasCEnd_;
}

bool ClothoidDataDescription::getHasChainageDiff() const
{
    return m_hasChainageDiff_;
}

void ClothoidDataDescription::setHasChainageDiff(bool hasChainageDiff_)
{
    m_hasChainageDiff_ = hasChainageDiff_;
}

void ClothoidDataDescription::initPackingContext(ClothoidDataDescription::ZserioPackingContext& context) const
{
    context.getNumberOfSteps().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numberOfSteps_);
    context.getNumBits().init<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_numBits_);
}

size_t ClothoidDataDescription::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numberOfSteps_);
    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t ClothoidDataDescription::bitSizeOf(ClothoidDataDescription::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumberOfSteps().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numberOfSteps_);
    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_numBits_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t ClothoidDataDescription::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numberOfSteps_);
    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t ClothoidDataDescription::initializeOffsets(ClothoidDataDescription::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumberOfSteps().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numberOfSteps_);
    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_numBits_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool ClothoidDataDescription::operator==(const ClothoidDataDescription& other) const
{
    if (this != &other)
    {
        return
                (m_numberOfSteps_ == other.m_numberOfSteps_) &&
                (m_numBits_ == other.m_numBits_) &&
                (m_hasCoordDiff_ == other.m_hasCoordDiff_) &&
                (m_hasTStart_ == other.m_hasTStart_) &&
                (m_hasTEnd_ == other.m_hasTEnd_) &&
                (m_hasCStart_ == other.m_hasCStart_) &&
                (m_hasCEnd_ == other.m_hasCEnd_) &&
                (m_hasChainageDiff_ == other.m_hasChainageDiff_);
    }

    return true;
}

uint32_t ClothoidDataDescription::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numberOfSteps_);
    result = ::zserio::calcHashCode(result, m_numBits_);
    result = ::zserio::calcHashCode(result, m_hasCoordDiff_);
    result = ::zserio::calcHashCode(result, m_hasTStart_);
    result = ::zserio::calcHashCode(result, m_hasTEnd_);
    result = ::zserio::calcHashCode(result, m_hasCStart_);
    result = ::zserio::calcHashCode(result, m_hasCEnd_);
    result = ::zserio::calcHashCode(result, m_hasChainageDiff_);

    return result;
}

void ClothoidDataDescription::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numberOfSteps_);
    out.writeBits(m_numBits_, UINT8_C(5));
    out.writeBool(m_hasCoordDiff_);
    out.writeBool(m_hasTStart_);
    out.writeBool(m_hasTEnd_);
    out.writeBool(m_hasCStart_);
    out.writeBool(m_hasCEnd_);
    out.writeBool(m_hasChainageDiff_);
}

void ClothoidDataDescription::write(ClothoidDataDescription::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumberOfSteps().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numberOfSteps_);
    context.getNumBits().write<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(out, m_numBits_);
    out.writeBool(m_hasCoordDiff_);
    out.writeBool(m_hasTStart_);
    out.writeBool(m_hasTEnd_);
    out.writeBool(m_hasCStart_);
    out.writeBool(m_hasCEnd_);
    out.writeBool(m_hasChainageDiff_);
}

uint16_t ClothoidDataDescription::readNumberOfSteps(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t ClothoidDataDescription::readNumberOfSteps(ClothoidDataDescription::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumberOfSteps().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
uint8_t ClothoidDataDescription::readNumBits(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(5)));
}

uint8_t ClothoidDataDescription::readNumBits(ClothoidDataDescription::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumBits().read<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(in);
}
bool ClothoidDataDescription::readHasCoordDiff(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool ClothoidDataDescription::readHasTStart(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool ClothoidDataDescription::readHasTEnd(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool ClothoidDataDescription::readHasCStart(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool ClothoidDataDescription::readHasCEnd(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool ClothoidDataDescription::readHasChainageDiff(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/ClothoidMetaData.h>

namespace nds
{
namespace adas
{
namespace types
{

ClothoidMetaData::ClothoidMetaData(const allocator_type&) noexcept :
        m_adasAccuracy_(::nds::adas::types::AdasAccuracy()),
        m_relativeCurvatureDeviation_(::nds::adas::types::RelativeCurvatureDeviation()),
        m_degreeOfFreedom_(::nds::adas::types::DegreeOfFreedom()),
        m_hasGradient_(bool())
{
}

ClothoidMetaData::ClothoidMetaData(::zserio::BitStreamReader& in, const allocator_type&) :
        m_adasAccuracy_(readAdasAccuracy(in)),
        m_relativeCurvatureDeviation_(readRelativeCurvatureDeviation(in)),
        m_degreeOfFreedom_(readDegreeOfFreedom(in)),
        m_hasGradient_(readHasGradient(in))
{
}

ClothoidMetaData::ClothoidMetaData(ClothoidMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_adasAccuracy_(readAdasAccuracy(context, in)),
        m_relativeCurvatureDeviation_(readRelativeCurvatureDeviation(context, in)),
        m_degreeOfFreedom_(readDegreeOfFreedom(context, in)),
        m_hasGradient_(readHasGradient(in))
{
}

ClothoidMetaData::ClothoidMetaData(::zserio::PropagateAllocatorT,
        const ClothoidMetaData& other, const allocator_type& allocator) :
        m_adasAccuracy_(::zserio::allocatorPropagatingCopy(other.m_adasAccuracy_, allocator)),
        m_relativeCurvatureDeviation_(::zserio::allocatorPropagatingCopy(other.m_relativeCurvatureDeviation_, allocator)),
        m_degreeOfFreedom_(::zserio::allocatorPropagatingCopy(other.m_degreeOfFreedom_, allocator)),
        m_hasGradient_(::zserio::allocatorPropagatingCopy(other.m_hasGradient_, allocator))
{
}

::nds::adas::types::AdasAccuracy ClothoidMetaData::getAdasAccuracy() const
{
    return m_adasAccuracy_;
}

void ClothoidMetaData::setAdasAccuracy(::nds::adas::types::AdasAccuracy adasAccuracy_)
{
    m_adasAccuracy_ = adasAccuracy_;
}

::nds::adas::types::RelativeCurvatureDeviation ClothoidMetaData::getRelativeCurvatureDeviation() const
{
    return m_relativeCurvatureDeviation_;
}

void ClothoidMetaData::setRelativeCurvatureDeviation(::nds::adas::types::RelativeCurvatureDeviation relativeCurvatureDeviation_)
{
    m_relativeCurvatureDeviation_ = relativeCurvatureDeviation_;
}

::nds::adas::types::DegreeOfFreedom ClothoidMetaData::getDegreeOfFreedom() const
{
    return m_degreeOfFreedom_;
}

void ClothoidMetaData::setDegreeOfFreedom(::nds::adas::types::DegreeOfFreedom degreeOfFreedom_)
{
    m_degreeOfFreedom_ = degreeOfFreedom_;
}

bool ClothoidMetaData::getHasGradient() const
{
    return m_hasGradient_;
}

void ClothoidMetaData::setHasGradient(bool hasGradient_)
{
    m_hasGradient_ = hasGradient_;
}

void ClothoidMetaData::initPackingContext(ClothoidMetaData::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAdasAccuracy(), m_adasAccuracy_);
    context.getRelativeCurvatureDeviation().init<::zserio::StdIntArrayTraits<::nds::adas::types::RelativeCurvatureDeviation>>(m_relativeCurvatureDeviation_);
    context.getDegreeOfFreedom().init<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(m_degreeOfFreedom_);
}

size_t ClothoidMetaData::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_adasAccuracy_);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t ClothoidMetaData::bitSizeOf(ClothoidMetaData::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAdasAccuracy(), m_adasAccuracy_);
    endBitPosition += context.getRelativeCurvatureDeviation().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::RelativeCurvatureDeviation>>(m_relativeCurvatureDeviation_);
    endBitPosition += context.getDegreeOfFreedom().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(m_degreeOfFreedom_);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t ClothoidMetaData::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_adasAccuracy_);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t ClothoidMetaData::initializeOffsets(ClothoidMetaData::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAdasAccuracy(), endBitPosition,
        m_adasAccuracy_);
    endBitPosition += context.getRelativeCurvatureDeviation().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::RelativeCurvatureDeviation>>(m_relativeCurvatureDeviation_);
    endBitPosition += context.getDegreeOfFreedom().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(m_degreeOfFreedom_);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool ClothoidMetaData::operator==(const ClothoidMetaData& other) const
{
    if (this != &other)
    {
        return
                (m_adasAccuracy_ == other.m_adasAccuracy_) &&
                (m_relativeCurvatureDeviation_ == other.m_relativeCurvatureDeviation_) &&
                (m_degreeOfFreedom_ == other.m_degreeOfFreedom_) &&
                (m_hasGradient_ == other.m_hasGradient_);
    }

    return true;
}

uint32_t ClothoidMetaData::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_adasAccuracy_);
    result = ::zserio::calcHashCode(result, m_relativeCurvatureDeviation_);
    result = ::zserio::calcHashCode(result, m_degreeOfFreedom_);
    result = ::zserio::calcHashCode(result, m_hasGradient_);

    return result;
}

void ClothoidMetaData::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_adasAccuracy_);
    out.writeBits(m_relativeCurvatureDeviation_, UINT8_C(8));
    out.writeBits(m_degreeOfFreedom_, UINT8_C(16));
    out.writeBool(m_hasGradient_);
}

void ClothoidMetaData::write(ClothoidMetaData::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAdasAccuracy(), out, m_adasAccuracy_);
    context.getRelativeCurvatureDeviation().write<::zserio::StdIntArrayTraits<::nds::adas::types::RelativeCurvatureDeviation>>(out, m_relativeCurvatureDeviation_);
    context.getDegreeOfFreedom().write<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(out, m_degreeOfFreedom_);
    out.writeBool(m_hasGradient_);
}

::nds::adas::types::AdasAccuracy ClothoidMetaData::readAdasAccuracy(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::adas::types::AdasAccuracy>(in);
}

::nds::adas::types::AdasAccuracy ClothoidMetaData::readAdasAccuracy(ClothoidMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::adas::types::AdasAccuracy>(context.getAdasAccuracy(), in);
}
::nds::adas::types::RelativeCurvatureDeviation ClothoidMetaData::readRelativeCurvatureDeviation(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::RelativeCurvatureDeviation>(in.readBits(UINT8_C(8)));
}

::nds::adas::types::RelativeCurvatureDeviation ClothoidMetaData::readRelativeCurvatureDeviation(ClothoidMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getRelativeCurvatureDeviation().read<::zserio::StdIntArrayTraits<::nds::adas::types::RelativeCurvatureDeviation>>(in);
}
::nds::adas::types::DegreeOfFreedom ClothoidMetaData::readDegreeOfFreedom(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::DegreeOfFreedom>(in.readBits(UINT8_C(16)));
}

::nds::adas::types::DegreeOfFreedom ClothoidMetaData::readDegreeOfFreedom(ClothoidMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDegreeOfFreedom().read<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(in);
}
bool ClothoidMetaData::readHasGradient(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/Gradient.h>

namespace nds
{
namespace adas
{
namespace types
{

Gradient::Gradient(const allocator_type& allocator) noexcept :
        m_numOfValues_(uint16_t()),
        m_gradientData_(allocator)
{
}

Gradient::Gradient(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(in)),
        m_gradientData_(readGradientData(in, allocator))
{
}

Gradient::Gradient(Gradient::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numOfValues_(readNumOfValues(context, in)),
        m_gradientData_(readGradientData(context, in, allocator))
{
}

Gradient::Gradient(::zserio::PropagateAllocatorT,
        const Gradient& other, const allocator_type& allocator) :
        m_numOfValues_(::zserio::allocatorPropagatingCopy(other.m_numOfValues_, allocator)),
        m_gradientData_(::zserio::allocatorPropagatingCopy(other.m_gradientData_, allocator))
{
}

uint16_t Gradient::getNumOfValues() const
{
    return m_numOfValues_;
}

void Gradient::setNumOfValues(uint16_t numOfValues_)
{
    m_numOfValues_ = numOfValues_;
}

::zserio::vector<::nds::adas::types::GradientData>& Gradient::getGradientData()
{
    return m_gradientData_.getRawArray();
}

const ::zserio::vector<::nds::adas::types::GradientData>& Gradient::getGradientData() const
{
    return m_gradientData_.getRawArray();
}

void Gradient::setGradientData(const ::zserio::vector<::nds::adas::types::GradientData>& gradientData_)
{
    m_gradientData_ = ZserioArrayType_gradientData(gradientData_);
}

void Gradient::setGradientData(::zserio::vector<::nds::adas::types::GradientData>&& gradientData_)
{
    m_gradientData_ = ZserioArrayType_gradientData(std::move(gradientData_));
}

void Gradient::initPackingContext(Gradient::ZserioPackingContext& context) const
{
    context.getNumOfValues().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
}

size_t Gradient::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition += m_gradientData_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Gradient::bitSizeOf(Gradient::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition += m_gradientData_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Gradient::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numOfValues_);
    endBitPosition = m_gradientData_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t Gradient::initializeOffsets(Gradient::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumOfValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numOfValues_);
    endBitPosition = m_gradientData_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Gradient::operator==(const Gradient& other) const
{
    if (this != &other)
    {
        return
                (m_numOfValues_ == other.m_numOfValues_) &&
                (m_gradientData_ == other.m_gradientData_);
    }

    return true;
}

uint32_t Gradient::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numOfValues_);
    result = ::zserio::calcHashCode(result, m_gradientData_);

    return result;
}

void Gradient::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numOfValues_);

    // check array length
    if (m_gradientData_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Gradient.gradientData: ") <<
                m_gradientData_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_gradientData_.write(*this, out);
}

void Gradient::write(Gradient::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumOfValues().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numOfValues_);

    // check array length
    if (m_gradientData_.getRawArray().size() != static_cast<size_t>(getNumOfValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Gradient.gradientData: ") <<
                m_gradientData_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfValues()) << "!";
    }
    m_gradientData_.writePacked(*this, out);
}

void Gradient::ZserioElementFactory_gradientData::create(Gradient&        ,
        ::zserio::vector<::nds::adas::types::GradientData>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Gradient::ZserioElementFactory_gradientData::create(Gradient&        ,
        ::zserio::vector<::nds::adas::types::GradientData>& array,
        ::nds::adas::types::GradientData::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint16_t Gradient::readNumOfValues(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t Gradient::readNumOfValues(Gradient::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumOfValues().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
Gradient::ZserioArrayType_gradientData Gradient::readGradientData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_gradientData readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

Gradient::ZserioArrayType_gradientData Gradient::readGradientData(Gradient::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_gradientData readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumOfValues()));

    return readField;
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/GradientMetaData.h>

namespace nds
{
namespace adas
{
namespace types
{

GradientMetaData::GradientMetaData(const allocator_type&) noexcept :
        m_adasAccuracy_(::nds::adas::types::AdasAccuracy()),
        m_standardDeviation_(::nds::adas::types::StandardDeviation()),
        m_degreeOfFreedom_(::nds::adas::types::DegreeOfFreedom()),
        m_absoluteGradeLineElevation_(uint16_t()),
        m_deltaChainageStart_(int16_t())
{
}

GradientMetaData::GradientMetaData(::zserio::BitStreamReader& in, const allocator_type&) :
        m_adasAccuracy_(readAdasAccuracy(in)),
        m_standardDeviation_(readStandardDeviation(in)),
        m_degreeOfFreedom_(readDegreeOfFreedom(in)),
        m_absoluteGradeLineElevation_(readAbsoluteGradeLineElevation(in)),
        m_deltaChainageStart_(readDeltaChainageStart(in))
{
}

GradientMetaData::GradientMetaData(GradientMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_adasAccuracy_(readAdasAccuracy(context, in)),
        m_standardDeviation_(readStandardDeviation(context, in)),
        m_degreeOfFreedom_(readDegreeOfFreedom(context, in)),
        m_absoluteGradeLineElevation_(readAbsoluteGradeLineElevation(context, in)),
        m_deltaChainageStart_(readDeltaChainageStart(context, in))
{
}

GradientMetaData::GradientMetaData(::zserio::PropagateAllocatorT,
        const GradientMetaData& other, const allocator_type& allocator) :
        m_adasAccuracy_(::zserio::allocatorPropagatingCopy(other.m_adasAccuracy_, allocator)),
        m_standardDeviation_(::zserio::allocatorPropagatingCopy(other.m_standardDeviation_, allocator)),
        m_degreeOfFreedom_(::zserio::allocatorPropagatingCopy(other.m_degreeOfFreedom_, allocator)),
        m_absoluteGradeLineElevation_(::zserio::allocatorPropagatingCopy(other.m_absoluteGradeLineElevation_, allocator)),
        m_deltaChainageStart_(::zserio::allocatorPropagatingCopy(other.m_deltaChainageStart_, allocator))
{
}

::nds::adas::types::AdasAccuracy GradientMetaData::getAdasAccuracy() const
{
    return m_adasAccuracy_;
}

void GradientMetaData::setAdasAccuracy(::nds::adas::types::AdasAccuracy adasAccuracy_)
{
    m_adasAccuracy_ = adasAccuracy_;
}

::nds::adas::types::StandardDeviation GradientMetaData::getStandardDeviation() const
{
    return m_standardDeviation_;
}

void GradientMetaData::setStandardDeviation(::nds::adas::types::StandardDeviation standardDeviation_)
{
    m_standardDeviation_ = standardDeviation_;
}

::nds::adas::types::DegreeOfFreedom GradientMetaData::getDegreeOfFreedom() const
{
    return m_degreeOfFreedom_;
}

void GradientMetaData::setDegreeOfFreedom(::nds::adas::types::DegreeOfFreedom degreeOfFreedom_)
{
    m_degreeOfFreedom_ = degreeOfFreedom_;
}

uint16_t GradientMetaData::getAbsoluteGradeLineElevation() const
{
    return m_absoluteGradeLineElevation_;
}

void GradientMetaData::setAbsoluteGradeLineElevation(uint16_t absoluteGradeLineElevation_)
{
    m_absoluteGradeLineElevation_ = absoluteGradeLineElevation_;
}

int16_t GradientMetaData::getDeltaChainageStart() const
{
    return m_deltaChainageStart_;
}

void GradientMetaData::setDeltaChainageStart(int16_t deltaChainageStart_)
{
    m_deltaChainageStart_ = deltaChainageStart_;
}

void GradientMetaData::initPackingContext(GradientMetaData::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAdasAccuracy(), m_adasAccuracy_);
    context.getStandardDeviation().init<::zserio::StdIntArrayTraits<::nds::adas::types::StandardDeviation>>(m_standardDeviation_);
    context.getDegreeOfFreedom().init<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(m_degreeOfFreedom_);
    context.getAbsoluteGradeLineElevation().init<::zserio::BitFieldArrayTraits<uint16_t, UINT8_C(12)>>(m_absoluteGradeLineElevation_);
    context.getDeltaChainageStart().init<::zserio::StdIntArrayTraits<int16_t>>(m_deltaChainageStart_);
}

size_t GradientMetaData::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_adasAccuracy_);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(12);
    endBitPosition += UINT8_C(16);

    return endBitPosition - bitPosition;
}

size_t GradientMetaData::bitSizeOf(GradientMetaData::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAdasAccuracy(), m_adasAccuracy_);
    endBitPosition += context.getStandardDeviation().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::StandardDeviation>>(m_standardDeviation_);
    endBitPosition += context.getDegreeOfFreedom().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(m_degreeOfFreedom_);
    endBitPosition += context.getAbsoluteGradeLineElevation().bitSizeOf<::zserio::BitFieldArrayTraits<uint16_t, UINT8_C(12)>>(m_absoluteGradeLineElevation_);
    endBitPosition += context.getDeltaChainageStart().bitSizeOf<::zserio::StdIntArrayTraits<int16_t>>(m_deltaChainageStart_);

    return endBitPosition - bitPosition;
}

size_t GradientMetaData::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_adasAccuracy_);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(12);
    endBitPosition += UINT8_C(16);

    return endBitPosition;
}

size_t GradientMetaData::initializeOffsets(GradientMetaData::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAdasAccuracy(), endBitPosition,
        m_adasAccuracy_);
    endBitPosition += context.getStandardDeviation().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::StandardDeviation>>(m_standardDeviation_);
    endBitPosition += context.getDegreeOfFreedom().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(m_degreeOfFreedom_);
    endBitPosition += context.getAbsoluteGradeLineElevation().bitSizeOf<::zserio::BitFieldArrayTraits<uint16_t, UINT8_C(12)>>(m_absoluteGradeLineElevation_);
    endBitPosition += context.getDeltaChainageStart().bitSizeOf<::zserio::StdIntArrayTraits<int16_t>>(m_deltaChainageStart_);

    return endBitPosition;
}

bool GradientMetaData::operator==(const GradientMetaData& other) const
{
    if (this != &other)
    {
        return
                (m_adasAccuracy_ == other.m_adasAccuracy_) &&
                (m_standardDeviation_ == other.m_standardDeviation_) &&
                (m_degreeOfFreedom_ == other.m_degreeOfFreedom_) &&
                (m_absoluteGradeLineElevation_ == other.m_absoluteGradeLineElevation_) &&
                (m_deltaChainageStart_ == other.m_deltaChainageStart_);
    }

    return true;
}

uint32_t GradientMetaData::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_adasAccuracy_);
    result = ::zserio::calcHashCode(result, m_standardDeviation_);
    result = ::zserio::calcHashCode(result, m_degreeOfFreedom_);
    result = ::zserio::calcHashCode(result, m_absoluteGradeLineElevation_);
    result = ::zserio::calcHashCode(result, m_deltaChainageStart_);

    return result;
}

void GradientMetaData::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_adasAccuracy_);
    out.writeBits(m_standardDeviation_, UINT8_C(8));
    out.writeBits(m_degreeOfFreedom_, UINT8_C(16));
    out.writeBits(m_absoluteGradeLineElevation_, UINT8_C(12));
    out.writeSignedBits(m_deltaChainageStart_, UINT8_C(16));
}

void GradientMetaData::write(GradientMetaData::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAdasAccuracy(), out, m_adasAccuracy_);
    context.getStandardDeviation().write<::zserio::StdIntArrayTraits<::nds::adas::types::StandardDeviation>>(out, m_standardDeviation_);
    context.getDegreeOfFreedom().write<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(out, m_degreeOfFreedom_);
    context.getAbsoluteGradeLineElevation().write<::zserio::BitFieldArrayTraits<uint16_t, UINT8_C(12)>>(out, m_absoluteGradeLineElevation_);
    context.getDeltaChainageStart().write<::zserio::StdIntArrayTraits<int16_t>>(out, m_deltaChainageStart_);
}

::nds::adas::types::AdasAccuracy GradientMetaData::readAdasAccuracy(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::adas::types::AdasAccuracy>(in);
}

::nds::adas::types::AdasAccuracy GradientMetaData::readAdasAccuracy(GradientMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::adas::types::AdasAccuracy>(context.getAdasAccuracy(), in);
}
::nds::adas::types::StandardDeviation GradientMetaData::readStandardDeviation(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::StandardDeviation>(in.readBits(UINT8_C(8)));
}

::nds::adas::types::StandardDeviation GradientMetaData::readStandardDeviation(GradientMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStandardDeviation().read<::zserio::StdIntArrayTraits<::nds::adas::types::StandardDeviation>>(in);
}
::nds::adas::types::DegreeOfFreedom GradientMetaData::readDegreeOfFreedom(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::adas::types::DegreeOfFreedom>(in.readBits(UINT8_C(16)));
}

::nds::adas::types::DegreeOfFreedom GradientMetaData::readDegreeOfFreedom(GradientMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDegreeOfFreedom().read<::zserio::StdIntArrayTraits<::nds::adas::types::DegreeOfFreedom>>(in);
}
uint16_t GradientMetaData::readAbsoluteGradeLineElevation(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readBits(UINT8_C(12)));
}

uint16_t GradientMetaData::readAbsoluteGradeLineElevation(GradientMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAbsoluteGradeLineElevation().read<::zserio::BitFieldArrayTraits<uint16_t, UINT8_C(12)>>(in);
}
int16_t GradientMetaData::readDeltaChainageStart(::zserio::BitStreamReader& in)
{
    return static_cast<int16_t>(in.readSignedBits(UINT8_C(16)));
}

int16_t GradientMetaData::readDeltaChainageStart(GradientMetaData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDeltaChainageStart().read<::zserio::StdIntArrayTraits<int16_t>>(in);
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/GradientData.h>

namespace nds
{
namespace adas
{
namespace types
{

GradientData::GradientData(const allocator_type&) noexcept :
        m_hasRadiusValue_(bool()),
        m_chainageOffset_(uint32_t()),
        m_relativeGradeLineElevation_(int8_t()),
        m_radiusValue_(::zserio::NullOpt)
{
}

GradientData::GradientData(::zserio::BitStreamReader& in, const allocator_type&) :
        m_hasRadiusValue_(readHasRadiusValue(in)),
        m_chainageOffset_(readChainageOffset(in)),
        m_relativeGradeLineElevation_(readRelativeGradeLineElevation(in)),
        m_radiusValue_(readRadiusValue(in))
{
}

GradientData::GradientData(GradientData::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_hasRadiusValue_(readHasRadiusValue(in)),
        m_chainageOffset_(readChainageOffset(context, in)),
        m_relativeGradeLineElevation_(readRelativeGradeLineElevation(context, in)),
        m_radiusValue_(readRadiusValue(context, in))
{
}

GradientData::GradientData(::zserio::PropagateAllocatorT,
        const GradientData& other, const allocator_type& allocator) :
        m_hasRadiusValue_(::zserio::allocatorPropagatingCopy(other.m_hasRadiusValue_, allocator)),
        m_chainageOffset_(::zserio::allocatorPropagatingCopy(other.m_chainageOffset_, allocator)),
        m_relativeGradeLineElevation_(::zserio::allocatorPropagatingCopy(other.m_relativeGradeLineElevation_, allocator)),
        m_radiusValue_(::zserio::allocatorPropagatingCopy(other.m_radiusValue_, allocator))
{
}

bool GradientData::getHasRadiusValue() const
{
    return m_hasRadiusValue_;
}

void GradientData::setHasRadiusValue(bool hasRadiusValue_)
{
    m_hasRadiusValue_ = hasRadiusValue_;
}

uint32_t GradientData::getChainageOffset() const
{
    return m_chainageOffset_;
}

void GradientData::setChainageOffset(uint32_t chainageOffset_)
{
    m_chainageOffset_ = chainageOffset_;
}

int8_t GradientData::getRelativeGradeLineElevation() const
{
    return m_relativeGradeLineElevation_;
}

void GradientData::setRelativeGradeLineElevation(int8_t relativeGradeLineElevation_)
{
    m_relativeGradeLineElevation_ = relativeGradeLineElevation_;
}

uint8_t GradientData::getRadiusValue() const
{
    return m_radiusValue_.value();
}

void GradientData::setRadiusValue(uint8_t radiusValue_)
{
    m_radiusValue_ = radiusValue_;
}

bool GradientData::isRadiusValueUsed() const
{
    return (getHasRadiusValue() == true);
}

bool GradientData::isRadiusValueSet() const
{
    return m_radiusValue_.hasValue();
}

void GradientData::resetRadiusValue()
{
    m_radiusValue_.reset();
}

void GradientData::initPackingContext(GradientData::ZserioPackingContext& context) const
{
    context.getChainageOffset().init<::zserio::VarSizeArrayTraits>(m_chainageOffset_);
    context.getRelativeGradeLineElevation().init<::zserio::StdIntArrayTraits<int8_t>>(m_relativeGradeLineElevation_);
    if (getHasRadiusValue() == true)
    {
        context.getRadiusValue().init<::zserio::StdIntArrayTraits<uint8_t>>(m_radiusValue_.value());
    }
}

size_t GradientData::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_chainageOffset_);
    endBitPosition += UINT8_C(8);
    if (getHasRadiusValue() == true)
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition - bitPosition;
}

size_t GradientData::bitSizeOf(GradientData::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += context.getChainageOffset().bitSizeOf<::zserio::VarSizeArrayTraits>(m_chainageOffset_);
    endBitPosition += context.getRelativeGradeLineElevation().bitSizeOf<::zserio::StdIntArrayTraits<int8_t>>(m_relativeGradeLineElevation_);
    if (getHasRadiusValue() == true)
    {
        endBitPosition += context.getRadiusValue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_radiusValue_.value());
    }

    return endBitPosition - bitPosition;
}

size_t GradientData::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_chainageOffset_);
    endBitPosition += UINT8_C(8);
    if (getHasRadiusValue() == true)
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition;
}

size_t GradientData::initializeOffsets(GradientData::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += context.getChainageOffset().bitSizeOf<::zserio::VarSizeArrayTraits>(m_chainageOffset_);
    endBitPosition += context.getRelativeGradeLineElevation().bitSizeOf<::zserio::StdIntArrayTraits<int8_t>>(m_relativeGradeLineElevation_);
    if (getHasRadiusValue() == true)
    {
        endBitPosition += context.getRadiusValue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_radiusValue_.value());
    }

    return endBitPosition;
}

bool GradientData::operator==(const GradientData& other) const
{
    if (this != &other)
    {
        return
                (m_hasRadiusValue_ == other.m_hasRadiusValue_) &&
                (m_chainageOffset_ == other.m_chainageOffset_) &&
                (m_relativeGradeLineElevation_ == other.m_relativeGradeLineElevation_) &&
                (!isRadiusValueUsed() ? !other.isRadiusValueUsed() : (m_radiusValue_ == other.m_radiusValue_));
    }

    return true;
}

uint32_t GradientData::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_hasRadiusValue_);
    result = ::zserio::calcHashCode(result, m_chainageOffset_);
    result = ::zserio::calcHashCode(result, m_relativeGradeLineElevation_);
    if (isRadiusValueUsed())
        result = ::zserio::calcHashCode(result, m_radiusValue_);

    return result;
}

void GradientData::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasRadiusValue_);
    out.writeVarSize(m_chainageOffset_);
    out.writeSignedBits(m_relativeGradeLineElevation_, UINT8_C(8));
    if (getHasRadiusValue() == true)
    {
        out.writeBits(m_radiusValue_.value(), UINT8_C(8));
    }
}

void GradientData::write(GradientData::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasRadiusValue_);
    context.getChainageOffset().write<::zserio::VarSizeArrayTraits>(out, m_chainageOffset_);
    context.getRelativeGradeLineElevation().write<::zserio::StdIntArrayTraits<int8_t>>(out, m_relativeGradeLineElevation_);
    if (getHasRadiusValue() == true)
    {
        context.getRadiusValue().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_radiusValue_.value());
    }
}

bool GradientData::readHasRadiusValue(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
uint32_t GradientData::readChainageOffset(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t GradientData::readChainageOffset(GradientData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getChainageOffset().read<::zserio::VarSizeArrayTraits>(in);
}
int8_t GradientData::readRelativeGradeLineElevation(::zserio::BitStreamReader& in)
{
    return static_cast<int8_t>(in.readSignedBits(UINT8_C(8)));
}

int8_t GradientData::readRelativeGradeLineElevation(GradientData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getRelativeGradeLineElevation().read<::zserio::StdIntArrayTraits<int8_t>>(in);
}
::zserio::InplaceOptionalHolder<uint8_t> GradientData::readRadiusValue(::zserio::BitStreamReader& in)
{
    if (getHasRadiusValue() == true)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(static_cast<uint8_t>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint8_t> GradientData::readRadiusValue(GradientData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getHasRadiusValue() == true)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(context.getRadiusValue().read<::zserio::StdIntArrayTraits<uint8_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

} // namespace types
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/types/ElevationArray.h>

namespace nds
{
namespace adas
{
namespace types
{

ElevationArray::ElevationArray(const allocator_type& allocator) noexcept :
        m_numValues_(uint16_t()),
        m_point_(allocator),
        m_elevation_(allocator)
{
}

ElevationArray::ElevationArray(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numValues_(readNumValues(in)),
        m_point_(readPoint(in, allocator)),
        m_elevation_(readElevation(in, allocator))
{
}

ElevationArray::ElevationArray(ElevationArray::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numValues_(readNumValues(context, in)),
        m_point_(readPoint(context, in, allocator)),
        m_elevation_(readElevation(context, in, allocator))
{
}

ElevationArray::ElevationArray(::zserio::PropagateAllocatorT,
        const ElevationArray& other, const allocator_type& allocator) :
        m_numValues_(::zserio::allocatorPropagatingCopy(other.m_numValues_, allocator)),
        m_point_(::zserio::allocatorPropagatingCopy(other.m_point_, allocator)),
        m_elevation_(::zserio::allocatorPropagatingCopy(other.m_elevation_, allocator))
{
}

uint16_t ElevationArray::getNumValues() const
{
    return m_numValues_;
}

void ElevationArray::setNumValues(uint16_t numValues_)
{
    m_numValues_ = numValues_;
}

::zserio::vector<::nds::adas::types::AdasGeometryPosition>& ElevationArray::getPoint()
{
    return m_point_.getRawArray();
}

const ::zserio::vector<::nds::adas::types::AdasGeometryPosition>& ElevationArray::getPoint() const
{
    return m_point_.getRawArray();
}

void ElevationArray::setPoint(const ::zserio::vector<::nds::adas::types::AdasGeometryPosition>& point_)
{
    m_point_ = ZserioArrayType_point(point_);
}

void ElevationArray::setPoint(::zserio::vector<::nds::adas::types::AdasGeometryPosition>&& point_)
{
    m_point_ = ZserioArrayType_point(std::move(point_));
}

::zserio::vector<::nds::adas::types::Elevation>& ElevationArray::getElevation()
{
    return m_elevation_.getRawArray();
}

const ::zserio::vector<::nds::adas::types::Elevation>& ElevationArray::getElevation() const
{
    return m_elevation_.getRawArray();
}

void ElevationArray::setElevation(const ::zserio::vector<::nds::adas::types::Elevation>& elevation_)
{
    m_elevation_ = ZserioArrayType_elevation(elevation_);
}

void ElevationArray::setElevation(::zserio::vector<::nds::adas::types::Elevation>&& elevation_)
{
    m_elevation_ = ZserioArrayType_elevation(std::move(elevation_));
}

void ElevationArray::initPackingContext(ElevationArray::ZserioPackingContext& context) const
{
    context.getNumValues().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numValues_);
}

size_t ElevationArray::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numValues_);
    endBitPosition += m_point_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_elevation_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ElevationArray::bitSizeOf(ElevationArray::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numValues_);
    endBitPosition += m_point_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_elevation_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ElevationArray::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numValues_);
    endBitPosition = m_point_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_elevation_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

size_t ElevationArray::initializeOffsets(ElevationArray::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumValues().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numValues_);
    endBitPosition = m_point_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_elevation_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool ElevationArray::operator==(const ElevationArray& other) const
{
    if (this != &other)
    {
        return
                (m_numValues_ == other.m_numValues_) &&
                (m_point_ == other.m_point_) &&
                (m_elevation_ == other.m_elevation_);
    }

    return true;
}

uint32_t ElevationArray::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numValues_);
    result = ::zserio::calcHashCode(result, m_point_);
    result = ::zserio::calcHashCode(result, m_elevation_);

    return result;
}

void ElevationArray::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numValues_);

    // check array length
    if (m_point_.getRawArray().size() != static_cast<size_t>(getNumValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ElevationArray.point: ") <<
                m_point_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumValues()) << "!";
    }
    m_point_.writePacked(out);

    // check array length
    if (m_elevation_.getRawArray().size() != static_cast<size_t>(getNumValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ElevationArray.elevation: ") <<
                m_elevation_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumValues()) << "!";
    }
    m_elevation_.writePacked(out);
}

void ElevationArray::write(ElevationArray::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumValues().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numValues_);

    // check array length
    if (m_point_.getRawArray().size() != static_cast<size_t>(getNumValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ElevationArray.point: ") <<
                m_point_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumValues()) << "!";
    }
    m_point_.writePacked(out);

    // check array length
    if (m_elevation_.getRawArray().size() != static_cast<size_t>(getNumValues()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ElevationArray.elevation: ") <<
                m_elevation_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumValues()) << "!";
    }
    m_elevation_.writePacked(out);
}

uint16_t ElevationArray::readNumValues(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t ElevationArray::readNumValues(ElevationArray::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumValues().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
ElevationArray::ZserioArrayType_point ElevationArray::readPoint(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_point readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumValues()));

    return readField;
}

ElevationArray::ZserioArrayType_point ElevationArray::readPoint(ElevationArray::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_point readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumValues()));

    return readField;
}
ElevationArray::ZserioArrayType_elevation ElevationArray::readElevation(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_elevation readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumValues()));

    return readField;
}

ElevationArray::ZserioArrayType_elevation ElevationArray::readElevation(ElevationArray::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_elevation readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumValues()));

    return readField;
}

} // namespace types
} // namespace adas
} // namespace nds
