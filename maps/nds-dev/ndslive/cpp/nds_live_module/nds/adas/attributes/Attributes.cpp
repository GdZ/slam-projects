/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/adas/attributes/AdasTransitionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AdasTransitionAttributeType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::adas::attributes::AdasTransitionAttributeType>::names;
constexpr ::std::array<::nds::adas::attributes::AdasTransitionAttributeType, 2> EnumTraits<::nds::adas::attributes::AdasTransitionAttributeType>::values;
constexpr const char* EnumTraits<::nds::adas::attributes::AdasTransitionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::adas::attributes::AdasTransitionAttributeType value)
{
    switch (value)
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        return 0;
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdasTransitionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::adas::attributes::AdasTransitionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::adas::attributes::AdasTransitionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::adas::attributes::AdasTransitionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
        return static_cast<::nds::adas::attributes::AdasTransitionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdasTransitionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::adas::attributes::AdasTransitionAttributeType>(::nds::adas::attributes::AdasTransitionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::adas::attributes::AdasTransitionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::adas::attributes::AdasTransitionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::adas::attributes::AdasTransitionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::adas::attributes::AdasTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::adas::attributes::AdasTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::adas::attributes::AdasTransitionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::adas::attributes::AdasTransitionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::adas::attributes::AdasTransitionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::adas::attributes::AdasTransitionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::adas::attributes::AdasTransitionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasTransitionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::adas::attributes::AdasTransitionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::adas::attributes::AdasTransitionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasTransitionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/adas/attributes/AdasRoadAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AdasRoadAttributeType enumeration.
constexpr ::std::array<const char*, 9> EnumTraits<::nds::adas::attributes::AdasRoadAttributeType>::names;
constexpr ::std::array<::nds::adas::attributes::AdasRoadAttributeType, 9> EnumTraits<::nds::adas::attributes::AdasRoadAttributeType>::values;
constexpr const char* EnumTraits<::nds::adas::attributes::AdasRoadAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::adas::attributes::AdasRoadAttributeType value)
{
    switch (value)
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        return 0;
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        return 1;
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        return 2;
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        return 3;
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        return 4;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        return 5;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        return 6;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        return 7;
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        return 8;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdasRoadAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::adas::attributes::AdasRoadAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::adas::attributes::AdasRoadAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::adas::attributes::AdasRoadAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
        return static_cast<::nds::adas::attributes::AdasRoadAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdasRoadAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::adas::attributes::AdasRoadAttributeType>(::nds::adas::attributes::AdasRoadAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::adas::attributes::AdasRoadAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasRoadAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::adas::attributes::AdasRoadAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::adas::attributes::AdasRoadAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasRoadAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::adas::attributes::AdasRoadAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::adas::attributes::AdasRoadAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::adas::attributes::AdasRoadAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::adas::attributes::AdasRoadAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::adas::attributes::AdasRoadAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::adas::attributes::AdasRoadAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::adas::attributes::AdasRoadAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasRoadAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::adas::attributes::AdasRoadAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::adas::attributes::AdasRoadAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasRoadAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/adas/attributes/AdasLaneAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AdasLaneAttributeType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::adas::attributes::AdasLaneAttributeType>::names;
constexpr ::std::array<::nds::adas::attributes::AdasLaneAttributeType, 3> EnumTraits<::nds::adas::attributes::AdasLaneAttributeType>::values;
constexpr const char* EnumTraits<::nds::adas::attributes::AdasLaneAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::adas::attributes::AdasLaneAttributeType value)
{
    switch (value)
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        return 0;
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        return 1;
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdasLaneAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::adas::attributes::AdasLaneAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::adas::attributes::AdasLaneAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::adas::attributes::AdasLaneAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
        return static_cast<::nds::adas::attributes::AdasLaneAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdasLaneAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::adas::attributes::AdasLaneAttributeType>(::nds::adas::attributes::AdasLaneAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::adas::attributes::AdasLaneAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasLaneAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::adas::attributes::AdasLaneAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::adas::attributes::AdasLaneAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasLaneAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::adas::attributes::AdasLaneAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::adas::attributes::AdasLaneAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::adas::attributes::AdasLaneAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::adas::attributes::AdasLaneAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::adas::attributes::AdasLaneAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::adas::attributes::AdasLaneAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::adas::attributes::AdasLaneAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasLaneAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::adas::attributes::AdasLaneAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::adas::attributes::AdasLaneAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::adas::attributes::AdasLaneAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/attributes/AdasRoadAttributeValue.h>

namespace nds
{
namespace adas
{
namespace attributes
{

AdasRoadAttributeValue::AdasRoadAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

AdasRoadAttributeValue::AdasRoadAttributeValue(::zserio::BitStreamReader& in,
        ::nds::adas::attributes::AdasRoadAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

AdasRoadAttributeValue::AdasRoadAttributeValue(AdasRoadAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::adas::attributes::AdasRoadAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

AdasRoadAttributeValue::AdasRoadAttributeValue(const AdasRoadAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

AdasRoadAttributeValue& AdasRoadAttributeValue::operator=(const AdasRoadAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

AdasRoadAttributeValue::AdasRoadAttributeValue(AdasRoadAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

AdasRoadAttributeValue& AdasRoadAttributeValue::operator=(AdasRoadAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

AdasRoadAttributeValue::AdasRoadAttributeValue(::zserio::PropagateAllocatorT,
        const AdasRoadAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void AdasRoadAttributeValue::initialize(
        ::nds::adas::attributes::AdasRoadAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool AdasRoadAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::adas::attributes::AdasRoadAttributeType AdasRoadAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'AdasRoadAttributeValue' is not initialized!");

    return m_type_;
}

::nds::adas::types::SlopeArray& AdasRoadAttributeValue::getSlopeArray()
{
    return m_objectChoice.get<::nds::adas::types::SlopeArray>();
}

const ::nds::adas::types::SlopeArray& AdasRoadAttributeValue::getSlopeArray() const
{
    return m_objectChoice.get<::nds::adas::types::SlopeArray>();
}

void AdasRoadAttributeValue::setSlopeArray(const ::nds::adas::types::SlopeArray& slopeArray_)
{
    m_objectChoice = slopeArray_;
}

void AdasRoadAttributeValue::setSlopeArray(::nds::adas::types::SlopeArray&& slopeArray_)
{
    m_objectChoice = ::std::move(slopeArray_);
}

::nds::adas::types::Clothoid& AdasRoadAttributeValue::getClothoid()
{
    return m_objectChoice.get<::nds::adas::types::Clothoid>();
}

const ::nds::adas::types::Clothoid& AdasRoadAttributeValue::getClothoid() const
{
    return m_objectChoice.get<::nds::adas::types::Clothoid>();
}

void AdasRoadAttributeValue::setClothoid(const ::nds::adas::types::Clothoid& clothoid_)
{
    m_objectChoice = clothoid_;
}

void AdasRoadAttributeValue::setClothoid(::nds::adas::types::Clothoid&& clothoid_)
{
    m_objectChoice = ::std::move(clothoid_);
}

::nds::adas::types::Gradient& AdasRoadAttributeValue::getGradient()
{
    return m_objectChoice.get<::nds::adas::types::Gradient>();
}

const ::nds::adas::types::Gradient& AdasRoadAttributeValue::getGradient() const
{
    return m_objectChoice.get<::nds::adas::types::Gradient>();
}

void AdasRoadAttributeValue::setGradient(const ::nds::adas::types::Gradient& gradient_)
{
    m_objectChoice = gradient_;
}

void AdasRoadAttributeValue::setGradient(::nds::adas::types::Gradient&& gradient_)
{
    m_objectChoice = ::std::move(gradient_);
}

::nds::adas::types::EnhancedGeometry& AdasRoadAttributeValue::getEnhancedGeometry()
{
    return m_objectChoice.get<::nds::adas::types::EnhancedGeometry>();
}

const ::nds::adas::types::EnhancedGeometry& AdasRoadAttributeValue::getEnhancedGeometry() const
{
    return m_objectChoice.get<::nds::adas::types::EnhancedGeometry>();
}

void AdasRoadAttributeValue::setEnhancedGeometry(const ::nds::adas::types::EnhancedGeometry& enhancedGeometry_)
{
    m_objectChoice = enhancedGeometry_;
}

void AdasRoadAttributeValue::setEnhancedGeometry(::nds::adas::types::EnhancedGeometry&& enhancedGeometry_)
{
    m_objectChoice = ::std::move(enhancedGeometry_);
}

::nds::adas::types::CurvaturePointList& AdasRoadAttributeValue::getCurvaturePointList()
{
    return m_objectChoice.get<::nds::adas::types::CurvaturePointList>();
}

const ::nds::adas::types::CurvaturePointList& AdasRoadAttributeValue::getCurvaturePointList() const
{
    return m_objectChoice.get<::nds::adas::types::CurvaturePointList>();
}

void AdasRoadAttributeValue::setCurvaturePointList(const ::nds::adas::types::CurvaturePointList& curvaturePointList_)
{
    m_objectChoice = curvaturePointList_;
}

void AdasRoadAttributeValue::setCurvaturePointList(::nds::adas::types::CurvaturePointList&& curvaturePointList_)
{
    m_objectChoice = ::std::move(curvaturePointList_);
}

::nds::adas::types::CurvaturePath& AdasRoadAttributeValue::getCurvaturePath()
{
    return m_objectChoice.get<::nds::adas::types::CurvaturePath>();
}

const ::nds::adas::types::CurvaturePath& AdasRoadAttributeValue::getCurvaturePath() const
{
    return m_objectChoice.get<::nds::adas::types::CurvaturePath>();
}

void AdasRoadAttributeValue::setCurvaturePath(const ::nds::adas::types::CurvaturePath& curvaturePath_)
{
    m_objectChoice = curvaturePath_;
}

void AdasRoadAttributeValue::setCurvaturePath(::nds::adas::types::CurvaturePath&& curvaturePath_)
{
    m_objectChoice = ::std::move(curvaturePath_);
}

::nds::adas::types::ComfortableSpeedPointList& AdasRoadAttributeValue::getComfortableSpeedCurve()
{
    return m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>();
}

const ::nds::adas::types::ComfortableSpeedPointList& AdasRoadAttributeValue::getComfortableSpeedCurve() const
{
    return m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>();
}

void AdasRoadAttributeValue::setComfortableSpeedCurve(const ::nds::adas::types::ComfortableSpeedPointList& comfortableSpeedCurve_)
{
    m_objectChoice = comfortableSpeedCurve_;
}

void AdasRoadAttributeValue::setComfortableSpeedCurve(::nds::adas::types::ComfortableSpeedPointList&& comfortableSpeedCurve_)
{
    m_objectChoice = ::std::move(comfortableSpeedCurve_);
}

::nds::adas::types::ComfortableSpeedPath& AdasRoadAttributeValue::getComfortableSpeedPath()
{
    return m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>();
}

const ::nds::adas::types::ComfortableSpeedPath& AdasRoadAttributeValue::getComfortableSpeedPath() const
{
    return m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>();
}

void AdasRoadAttributeValue::setComfortableSpeedPath(const ::nds::adas::types::ComfortableSpeedPath& comfortableSpeedPath_)
{
    m_objectChoice = comfortableSpeedPath_;
}

void AdasRoadAttributeValue::setComfortableSpeedPath(::nds::adas::types::ComfortableSpeedPath&& comfortableSpeedPath_)
{
    m_objectChoice = ::std::move(comfortableSpeedPath_);
}

::nds::adas::types::ElevationArray& AdasRoadAttributeValue::getElevationArray()
{
    return m_objectChoice.get<::nds::adas::types::ElevationArray>();
}

const ::nds::adas::types::ElevationArray& AdasRoadAttributeValue::getElevationArray() const
{
    return m_objectChoice.get<::nds::adas::types::ElevationArray>();
}

void AdasRoadAttributeValue::setElevationArray(const ::nds::adas::types::ElevationArray& elevationArray_)
{
    m_objectChoice = elevationArray_;
}

void AdasRoadAttributeValue::setElevationArray(::nds::adas::types::ElevationArray&& elevationArray_)
{
    m_objectChoice = ::std::move(elevationArray_);
}

AdasRoadAttributeValue::ChoiceTag AdasRoadAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        return CHOICE_slopeArray;
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        return CHOICE_clothoid;
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        return CHOICE_gradient;
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        return CHOICE_enhancedGeometry;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        return CHOICE_curvaturePointList;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        return CHOICE_curvaturePath;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        return CHOICE_comfortableSpeedCurve;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        return CHOICE_comfortableSpeedPath;
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        return CHOICE_elevationArray;
    default:
        return UNDEFINED_CHOICE;
    }
}

void AdasRoadAttributeValue::initPackingContext(AdasRoadAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        m_objectChoice.get<::nds::adas::types::SlopeArray>().initPackingContext(context.getSlopeArray());
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        m_objectChoice.get<::nds::adas::types::Clothoid>().initPackingContext(context.getClothoid());
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        m_objectChoice.get<::nds::adas::types::Gradient>().initPackingContext(context.getGradient());
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        m_objectChoice.get<::nds::adas::types::CurvaturePointList>().initPackingContext(context.getCurvaturePointList());
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        m_objectChoice.get<::nds::adas::types::CurvaturePath>().initPackingContext(context.getCurvaturePath());
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().initPackingContext(context.getComfortableSpeedCurve());
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>().initPackingContext(context.getComfortableSpeedPath());
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        m_objectChoice.get<::nds::adas::types::ElevationArray>().initPackingContext(context.getElevationArray());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }
}

size_t AdasRoadAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        endBitPosition += m_objectChoice.get<::nds::adas::types::SlopeArray>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        endBitPosition += m_objectChoice.get<::nds::adas::types::Clothoid>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        endBitPosition += m_objectChoice.get<::nds::adas::types::Gradient>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        endBitPosition += m_objectChoice.get<::nds::adas::types::EnhancedGeometry>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        endBitPosition += m_objectChoice.get<::nds::adas::types::CurvaturePointList>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        endBitPosition += m_objectChoice.get<::nds::adas::types::CurvaturePath>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        endBitPosition += m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        endBitPosition += m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        endBitPosition += m_objectChoice.get<::nds::adas::types::ElevationArray>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t AdasRoadAttributeValue::bitSizeOf(AdasRoadAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        endBitPosition += m_objectChoice.get<::nds::adas::types::SlopeArray>().bitSizeOf(context.getSlopeArray(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        endBitPosition += m_objectChoice.get<::nds::adas::types::Clothoid>().bitSizeOf(context.getClothoid(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        endBitPosition += m_objectChoice.get<::nds::adas::types::Gradient>().bitSizeOf(context.getGradient(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        endBitPosition += m_objectChoice.get<::nds::adas::types::EnhancedGeometry>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        endBitPosition += m_objectChoice.get<::nds::adas::types::CurvaturePointList>().bitSizeOf(context.getCurvaturePointList(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        endBitPosition += m_objectChoice.get<::nds::adas::types::CurvaturePath>().bitSizeOf(context.getCurvaturePath(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        endBitPosition += m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().bitSizeOf(context.getComfortableSpeedCurve(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        endBitPosition += m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>().bitSizeOf(context.getComfortableSpeedPath(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        endBitPosition += m_objectChoice.get<::nds::adas::types::ElevationArray>().bitSizeOf(context.getElevationArray(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t AdasRoadAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        endBitPosition = m_objectChoice.get<::nds::adas::types::SlopeArray>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        endBitPosition = m_objectChoice.get<::nds::adas::types::Clothoid>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        endBitPosition = m_objectChoice.get<::nds::adas::types::Gradient>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        endBitPosition = m_objectChoice.get<::nds::adas::types::EnhancedGeometry>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        endBitPosition = m_objectChoice.get<::nds::adas::types::CurvaturePointList>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        endBitPosition = m_objectChoice.get<::nds::adas::types::CurvaturePath>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        endBitPosition = m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        endBitPosition = m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        endBitPosition = m_objectChoice.get<::nds::adas::types::ElevationArray>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }

    return endBitPosition;
}

size_t AdasRoadAttributeValue::initializeOffsets(AdasRoadAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        endBitPosition = m_objectChoice.get<::nds::adas::types::SlopeArray>().initializeOffsets(context.getSlopeArray(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        endBitPosition = m_objectChoice.get<::nds::adas::types::Clothoid>().initializeOffsets(context.getClothoid(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        endBitPosition = m_objectChoice.get<::nds::adas::types::Gradient>().initializeOffsets(context.getGradient(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        endBitPosition = m_objectChoice.get<::nds::adas::types::EnhancedGeometry>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        endBitPosition = m_objectChoice.get<::nds::adas::types::CurvaturePointList>().initializeOffsets(context.getCurvaturePointList(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        endBitPosition = m_objectChoice.get<::nds::adas::types::CurvaturePath>().initializeOffsets(context.getCurvaturePath(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        endBitPosition = m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().initializeOffsets(context.getComfortableSpeedCurve(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        endBitPosition = m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>().initializeOffsets(context.getComfortableSpeedPath(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        endBitPosition = m_objectChoice.get<::nds::adas::types::ElevationArray>().initializeOffsets(context.getElevationArray(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }

    return endBitPosition;
}

bool AdasRoadAttributeValue::operator==(const AdasRoadAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::SlopeArray>() == other.m_objectChoice.get<::nds::adas::types::SlopeArray>());
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::Clothoid>() == other.m_objectChoice.get<::nds::adas::types::Clothoid>());
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::Gradient>() == other.m_objectChoice.get<::nds::adas::types::Gradient>());
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::EnhancedGeometry>() == other.m_objectChoice.get<::nds::adas::types::EnhancedGeometry>());
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::CurvaturePointList>() == other.m_objectChoice.get<::nds::adas::types::CurvaturePointList>());
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::CurvaturePath>() == other.m_objectChoice.get<::nds::adas::types::CurvaturePath>());
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>() == other.m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>());
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>() == other.m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>());
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::ElevationArray>() == other.m_objectChoice.get<::nds::adas::types::ElevationArray>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }
}

uint32_t AdasRoadAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::SlopeArray>());
            break;
        case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::Clothoid>());
            break;
        case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::Gradient>());
            break;
        case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::EnhancedGeometry>());
            break;
        case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::CurvaturePointList>());
            break;
        case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::CurvaturePath>());
            break;
        case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>());
            break;
        case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>());
            break;
        case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::ElevationArray>());
            break;
        default:
            break;
        }
    }

    return result;
}

void AdasRoadAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        m_objectChoice.get<::nds::adas::types::SlopeArray>().write(out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        m_objectChoice.get<::nds::adas::types::Clothoid>().write(out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        m_objectChoice.get<::nds::adas::types::Gradient>().write(out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        m_objectChoice.get<::nds::adas::types::EnhancedGeometry>().write(out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        m_objectChoice.get<::nds::adas::types::CurvaturePointList>().write(out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        m_objectChoice.get<::nds::adas::types::CurvaturePath>().write(out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().write(out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>().write(out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        m_objectChoice.get<::nds::adas::types::ElevationArray>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }
}

void AdasRoadAttributeValue::write(AdasRoadAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        m_objectChoice.get<::nds::adas::types::SlopeArray>().write(context.getSlopeArray(), out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        m_objectChoice.get<::nds::adas::types::Clothoid>().write(context.getClothoid(), out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        m_objectChoice.get<::nds::adas::types::Gradient>().write(context.getGradient(), out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        m_objectChoice.get<::nds::adas::types::EnhancedGeometry>().write(out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        m_objectChoice.get<::nds::adas::types::CurvaturePointList>().write(context.getCurvaturePointList(), out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        m_objectChoice.get<::nds::adas::types::CurvaturePath>().write(context.getCurvaturePath(), out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().write(context.getComfortableSpeedCurve(), out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        m_objectChoice.get<::nds::adas::types::ComfortableSpeedPath>().write(context.getComfortableSpeedPath(), out);
        break;
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        m_objectChoice.get<::nds::adas::types::ElevationArray>().write(context.getElevationArray(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }
}

::zserio::AnyHolder<> AdasRoadAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        return ::zserio::AnyHolder<>(::nds::adas::types::SlopeArray(in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        return ::zserio::AnyHolder<>(::nds::adas::types::Clothoid(in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        return ::zserio::AnyHolder<>(::nds::adas::types::Gradient(in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        return ::zserio::AnyHolder<>(::nds::adas::types::EnhancedGeometry(in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        return ::zserio::AnyHolder<>(::nds::adas::types::CurvaturePointList(in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        return ::zserio::AnyHolder<>(::nds::adas::types::CurvaturePath(in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        return ::zserio::AnyHolder<>(::nds::adas::types::ComfortableSpeedPointList(in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        return ::zserio::AnyHolder<>(::nds::adas::types::ComfortableSpeedPath(in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        return ::zserio::AnyHolder<>(::nds::adas::types::ElevationArray(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }
}

::zserio::AnyHolder<> AdasRoadAttributeValue::readObject(AdasRoadAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        return ::zserio::AnyHolder<>(::nds::adas::types::SlopeArray(context.getSlopeArray(), in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        return ::zserio::AnyHolder<>(::nds::adas::types::Clothoid(context.getClothoid(), in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        return ::zserio::AnyHolder<>(::nds::adas::types::Gradient(context.getGradient(), in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        return ::zserio::AnyHolder<>(::nds::adas::types::EnhancedGeometry(in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        return ::zserio::AnyHolder<>(::nds::adas::types::CurvaturePointList(context.getCurvaturePointList(), in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        return ::zserio::AnyHolder<>(::nds::adas::types::CurvaturePath(context.getCurvaturePath(), in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        return ::zserio::AnyHolder<>(::nds::adas::types::ComfortableSpeedPointList(context.getComfortableSpeedCurve(), in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        return ::zserio::AnyHolder<>(::nds::adas::types::ComfortableSpeedPath(context.getComfortableSpeedPath(), in, allocator), allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        return ::zserio::AnyHolder<>(::nds::adas::types::ElevationArray(context.getElevationArray(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }
}

::zserio::AnyHolder<> AdasRoadAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasRoadAttributeType::SLOPE_ARRAY:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::SlopeArray>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::CLOTHOID:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::Clothoid>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::GRADIENT:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::Gradient>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::ENHANCED_GEOMETRY:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::EnhancedGeometry>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::CurvaturePointList>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::CURVATURE_PATH:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::CurvaturePath>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_CURVE:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::ComfortableSpeedPointList>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::COMFORTABLE_SPEED_PATH:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::ComfortableSpeedPath>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasRoadAttributeType::ELEVATION_ARRAY:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::ElevationArray>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasRoadAttributeValue!");
    }
}

} // namespace attributes
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/attributes/AdasTransitionAttributeValue.h>

namespace nds
{
namespace adas
{
namespace attributes
{

AdasTransitionAttributeValue::AdasTransitionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

AdasTransitionAttributeValue::AdasTransitionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::adas::attributes::AdasTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

AdasTransitionAttributeValue::AdasTransitionAttributeValue(AdasTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::adas::attributes::AdasTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

AdasTransitionAttributeValue::AdasTransitionAttributeValue(const AdasTransitionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

AdasTransitionAttributeValue& AdasTransitionAttributeValue::operator=(const AdasTransitionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

AdasTransitionAttributeValue::AdasTransitionAttributeValue(AdasTransitionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

AdasTransitionAttributeValue& AdasTransitionAttributeValue::operator=(AdasTransitionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

AdasTransitionAttributeValue::AdasTransitionAttributeValue(::zserio::PropagateAllocatorT,
        const AdasTransitionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void AdasTransitionAttributeValue::initialize(
        ::nds::adas::attributes::AdasTransitionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool AdasTransitionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::adas::attributes::AdasTransitionAttributeType AdasTransitionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'AdasTransitionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::adas::types::Curvature AdasTransitionAttributeValue::getTurnGeometryCurvature() const
{
    return m_objectChoice.get<::nds::adas::types::Curvature>();
}

void AdasTransitionAttributeValue::setTurnGeometryCurvature(::nds::adas::types::Curvature turnGeometryCurvature_)
{
    m_objectChoice = turnGeometryCurvature_;
}

::nds::adas::types::ComfortableSpeed AdasTransitionAttributeValue::getComfortableSpeed() const
{
    return m_objectChoice.get<::nds::adas::types::ComfortableSpeed>();
}

void AdasTransitionAttributeValue::setComfortableSpeed(::nds::adas::types::ComfortableSpeed comfortableSpeed_)
{
    m_objectChoice = comfortableSpeed_;
}

AdasTransitionAttributeValue::ChoiceTag AdasTransitionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        return CHOICE_turnGeometryCurvature;
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        return CHOICE_comfortableSpeed;
    default:
        return UNDEFINED_CHOICE;
    }
}

void AdasTransitionAttributeValue::initPackingContext(AdasTransitionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        context.getTurnGeometryCurvature().init<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(m_objectChoice.get<::nds::adas::types::Curvature>());
        break;
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        context.getComfortableSpeed().init<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(m_objectChoice.get<::nds::adas::types::ComfortableSpeed>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }
}

size_t AdasTransitionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        endBitPosition += UINT8_C(10);
        break;
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        endBitPosition += UINT8_C(8);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t AdasTransitionAttributeValue::bitSizeOf(AdasTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        endBitPosition += context.getTurnGeometryCurvature().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(m_objectChoice.get<::nds::adas::types::Curvature>());
        break;
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        endBitPosition += context.getComfortableSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(m_objectChoice.get<::nds::adas::types::ComfortableSpeed>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t AdasTransitionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        endBitPosition += UINT8_C(10);
        break;
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        endBitPosition += UINT8_C(8);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }

    return endBitPosition;
}

size_t AdasTransitionAttributeValue::initializeOffsets(AdasTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        endBitPosition += context.getTurnGeometryCurvature().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(m_objectChoice.get<::nds::adas::types::Curvature>());
        break;
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        endBitPosition += context.getComfortableSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(m_objectChoice.get<::nds::adas::types::ComfortableSpeed>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }

    return endBitPosition;
}

bool AdasTransitionAttributeValue::operator==(const AdasTransitionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::Curvature>() == other.m_objectChoice.get<::nds::adas::types::Curvature>());
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::ComfortableSpeed>() == other.m_objectChoice.get<::nds::adas::types::ComfortableSpeed>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }
}

uint32_t AdasTransitionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::Curvature>());
            break;
        case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::ComfortableSpeed>());
            break;
        default:
            break;
        }
    }

    return result;
}

void AdasTransitionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        out.writeBits(m_objectChoice.get<::nds::adas::types::Curvature>(), UINT8_C(10));
        break;
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        out.writeBits(m_objectChoice.get<::nds::adas::types::ComfortableSpeed>(), UINT8_C(8));
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }
}

void AdasTransitionAttributeValue::write(AdasTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        context.getTurnGeometryCurvature().write<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(out, m_objectChoice.get<::nds::adas::types::Curvature>());
        break;
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        context.getComfortableSpeed().write<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(out, m_objectChoice.get<::nds::adas::types::ComfortableSpeed>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> AdasTransitionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        return ::zserio::AnyHolder<>(static_cast<::nds::adas::types::Curvature>(in.readBits(UINT8_C(10))), allocator);
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        return ::zserio::AnyHolder<>(static_cast<::nds::adas::types::ComfortableSpeed>(in.readBits(UINT8_C(8))), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> AdasTransitionAttributeValue::readObject(AdasTransitionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        return ::zserio::AnyHolder<>(context.getTurnGeometryCurvature().read<::zserio::BitFieldArrayTraits<::nds::adas::types::Curvature, UINT8_C(10)>>(in), allocator);
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        return ::zserio::AnyHolder<>(context.getComfortableSpeed().read<::zserio::StdIntArrayTraits<::nds::adas::types::ComfortableSpeed>>(in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> AdasTransitionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasTransitionAttributeType::TURN_GEOMETRY_CURVATURE:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::Curvature>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasTransitionAttributeType::COMFORTABLE_SPEED:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::ComfortableSpeed>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasTransitionAttributeValue!");
    }
}

} // namespace attributes
} // namespace adas
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/adas/attributes/AdasLaneAttributeValue.h>

namespace nds
{
namespace adas
{
namespace attributes
{

AdasLaneAttributeValue::AdasLaneAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

AdasLaneAttributeValue::AdasLaneAttributeValue(::zserio::BitStreamReader& in,
        ::nds::adas::attributes::AdasLaneAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

AdasLaneAttributeValue::AdasLaneAttributeValue(AdasLaneAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::adas::attributes::AdasLaneAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

AdasLaneAttributeValue::AdasLaneAttributeValue(const AdasLaneAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

AdasLaneAttributeValue& AdasLaneAttributeValue::operator=(const AdasLaneAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

AdasLaneAttributeValue::AdasLaneAttributeValue(AdasLaneAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

AdasLaneAttributeValue& AdasLaneAttributeValue::operator=(AdasLaneAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

AdasLaneAttributeValue::AdasLaneAttributeValue(::zserio::PropagateAllocatorT,
        const AdasLaneAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void AdasLaneAttributeValue::initialize(
        ::nds::adas::attributes::AdasLaneAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool AdasLaneAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::adas::attributes::AdasLaneAttributeType AdasLaneAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'AdasLaneAttributeValue' is not initialized!");

    return m_type_;
}

::nds::adas::types::SlopeArray& AdasLaneAttributeValue::getSlopeArray()
{
    return m_objectChoice.get<::nds::adas::types::SlopeArray>();
}

const ::nds::adas::types::SlopeArray& AdasLaneAttributeValue::getSlopeArray() const
{
    return m_objectChoice.get<::nds::adas::types::SlopeArray>();
}

void AdasLaneAttributeValue::setSlopeArray(const ::nds::adas::types::SlopeArray& slopeArray_)
{
    m_objectChoice = slopeArray_;
}

void AdasLaneAttributeValue::setSlopeArray(::nds::adas::types::SlopeArray&& slopeArray_)
{
    m_objectChoice = ::std::move(slopeArray_);
}

::nds::adas::types::CurvaturePointList& AdasLaneAttributeValue::getCurvaturePointList()
{
    return m_objectChoice.get<::nds::adas::types::CurvaturePointList>();
}

const ::nds::adas::types::CurvaturePointList& AdasLaneAttributeValue::getCurvaturePointList() const
{
    return m_objectChoice.get<::nds::adas::types::CurvaturePointList>();
}

void AdasLaneAttributeValue::setCurvaturePointList(const ::nds::adas::types::CurvaturePointList& curvaturePointList_)
{
    m_objectChoice = curvaturePointList_;
}

void AdasLaneAttributeValue::setCurvaturePointList(::nds::adas::types::CurvaturePointList&& curvaturePointList_)
{
    m_objectChoice = ::std::move(curvaturePointList_);
}

::nds::adas::types::ComfortableSpeedPointList& AdasLaneAttributeValue::getComfortableSpeedCurve()
{
    return m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>();
}

const ::nds::adas::types::ComfortableSpeedPointList& AdasLaneAttributeValue::getComfortableSpeedCurve() const
{
    return m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>();
}

void AdasLaneAttributeValue::setComfortableSpeedCurve(const ::nds::adas::types::ComfortableSpeedPointList& comfortableSpeedCurve_)
{
    m_objectChoice = comfortableSpeedCurve_;
}

void AdasLaneAttributeValue::setComfortableSpeedCurve(::nds::adas::types::ComfortableSpeedPointList&& comfortableSpeedCurve_)
{
    m_objectChoice = ::std::move(comfortableSpeedCurve_);
}

AdasLaneAttributeValue::ChoiceTag AdasLaneAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        return CHOICE_slopeArray;
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        return CHOICE_curvaturePointList;
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        return CHOICE_comfortableSpeedCurve;
    default:
        return UNDEFINED_CHOICE;
    }
}

void AdasLaneAttributeValue::initPackingContext(AdasLaneAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        m_objectChoice.get<::nds::adas::types::SlopeArray>().initPackingContext(context.getSlopeArray());
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        m_objectChoice.get<::nds::adas::types::CurvaturePointList>().initPackingContext(context.getCurvaturePointList());
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().initPackingContext(context.getComfortableSpeedCurve());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }
}

size_t AdasLaneAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        endBitPosition += m_objectChoice.get<::nds::adas::types::SlopeArray>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        endBitPosition += m_objectChoice.get<::nds::adas::types::CurvaturePointList>().bitSizeOf(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        endBitPosition += m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t AdasLaneAttributeValue::bitSizeOf(AdasLaneAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        endBitPosition += m_objectChoice.get<::nds::adas::types::SlopeArray>().bitSizeOf(context.getSlopeArray(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        endBitPosition += m_objectChoice.get<::nds::adas::types::CurvaturePointList>().bitSizeOf(context.getCurvaturePointList(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        endBitPosition += m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().bitSizeOf(context.getComfortableSpeedCurve(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t AdasLaneAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        endBitPosition = m_objectChoice.get<::nds::adas::types::SlopeArray>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        endBitPosition = m_objectChoice.get<::nds::adas::types::CurvaturePointList>().initializeOffsets(endBitPosition);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        endBitPosition = m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }

    return endBitPosition;
}

size_t AdasLaneAttributeValue::initializeOffsets(AdasLaneAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        endBitPosition = m_objectChoice.get<::nds::adas::types::SlopeArray>().initializeOffsets(context.getSlopeArray(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        endBitPosition = m_objectChoice.get<::nds::adas::types::CurvaturePointList>().initializeOffsets(context.getCurvaturePointList(), endBitPosition);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        endBitPosition = m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().initializeOffsets(context.getComfortableSpeedCurve(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }

    return endBitPosition;
}

bool AdasLaneAttributeValue::operator==(const AdasLaneAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::SlopeArray>() == other.m_objectChoice.get<::nds::adas::types::SlopeArray>());
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::CurvaturePointList>() == other.m_objectChoice.get<::nds::adas::types::CurvaturePointList>());
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>() == other.m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }
}

uint32_t AdasLaneAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::SlopeArray>());
            break;
        case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::CurvaturePointList>());
            break;
        case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>());
            break;
        default:
            break;
        }
    }

    return result;
}

void AdasLaneAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        m_objectChoice.get<::nds::adas::types::SlopeArray>().write(out);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        m_objectChoice.get<::nds::adas::types::CurvaturePointList>().write(out);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }
}

void AdasLaneAttributeValue::write(AdasLaneAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        m_objectChoice.get<::nds::adas::types::SlopeArray>().write(context.getSlopeArray(), out);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        m_objectChoice.get<::nds::adas::types::CurvaturePointList>().write(context.getCurvaturePointList(), out);
        break;
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        m_objectChoice.get<::nds::adas::types::ComfortableSpeedPointList>().write(context.getComfortableSpeedCurve(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }
}

::zserio::AnyHolder<> AdasLaneAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        return ::zserio::AnyHolder<>(::nds::adas::types::SlopeArray(in, allocator), allocator);
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        return ::zserio::AnyHolder<>(::nds::adas::types::CurvaturePointList(in, allocator), allocator);
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        return ::zserio::AnyHolder<>(::nds::adas::types::ComfortableSpeedPointList(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }
}

::zserio::AnyHolder<> AdasLaneAttributeValue::readObject(AdasLaneAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        return ::zserio::AnyHolder<>(::nds::adas::types::SlopeArray(context.getSlopeArray(), in, allocator), allocator);
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        return ::zserio::AnyHolder<>(::nds::adas::types::CurvaturePointList(context.getCurvaturePointList(), in, allocator), allocator);
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        return ::zserio::AnyHolder<>(::nds::adas::types::ComfortableSpeedPointList(context.getComfortableSpeedCurve(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }
}

::zserio::AnyHolder<> AdasLaneAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::adas::attributes::AdasLaneAttributeType::SLOPE_ARRAY:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::SlopeArray>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasLaneAttributeType::CURVATURE:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::CurvaturePointList>(m_objectChoice, allocator);
    case ::nds::adas::attributes::AdasLaneAttributeType::COMFORTABLE_SPEED_CURVE:
        return ::zserio::allocatorPropagatingCopy<::nds::adas::types::ComfortableSpeedPointList>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice AdasLaneAttributeValue!");
    }
}

} // namespace attributes
} // namespace adas
} // namespace nds
