/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/system/types/LayerType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LayerType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::system::types::LayerType>::names;
constexpr ::std::array<::nds::system::types::LayerType, 4> EnumTraits<::nds::system::types::LayerType>::values;
constexpr const char* EnumTraits<::nds::system::types::LayerType>::enumName;

template <>
size_t enumToOrdinal(::nds::system::types::LayerType value)
{
    switch (value)
    {
    case ::nds::system::types::LayerType::FEATURE:
        return 0;
    case ::nds::system::types::LayerType::GEOMETRY:
        return 1;
    case ::nds::system::types::LayerType::ATTRIBUTE:
        return 2;
    case ::nds::system::types::LayerType::RELATION:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LayerType: ") <<
                static_cast<typename ::std::underlying_type<::nds::system::types::LayerType>::type>(value) << "!";
    }
}

template <>
::nds::system::types::LayerType valueToEnum(
        typename ::std::underlying_type<::nds::system::types::LayerType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::system::types::LayerType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LayerType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::system::types::LayerType>(::nds::system::types::LayerType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::system::types::LayerType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::system::types::LayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::system::types::LayerType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::system::types::LayerType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::system::types::LayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::system::types::LayerType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::system::types::LayerType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::system::types::LayerType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::system::types::LayerType>(
            static_cast<typename ::std::underlying_type<::nds::system::types::LayerType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::system::types::LayerType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::system::types::LayerType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::system::types::LayerType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::system::types::LayerType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::system::types::LayerType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::system::types::LayerType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/system/types/NdsSystemToken.h>

namespace nds
{
namespace system
{
namespace types
{

NdsSystemToken::NdsSystemToken(const allocator_type& allocator) noexcept :
        m_mapId_(allocator)
{
}

NdsSystemToken::NdsSystemToken(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_mapId_(readMapId(in, allocator))
{
}

NdsSystemToken::NdsSystemToken(NdsSystemToken::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_mapId_(readMapId(context, in, allocator))
{
}

NdsSystemToken::NdsSystemToken(::zserio::PropagateAllocatorT,
        const NdsSystemToken& other, const allocator_type& allocator) :
        m_mapId_(::zserio::allocatorPropagatingCopy(other.m_mapId_, allocator))
{
}

::nds::system::types::UUID& NdsSystemToken::getMapId()
{
    return m_mapId_;
}

const ::nds::system::types::UUID& NdsSystemToken::getMapId() const
{
    return m_mapId_;
}

void NdsSystemToken::setMapId(const ::nds::system::types::UUID& mapId_)
{
    m_mapId_ = mapId_;
}

void NdsSystemToken::setMapId(::nds::system::types::UUID&& mapId_)
{
    m_mapId_ = ::std::move(mapId_);
}

void NdsSystemToken::initPackingContext(NdsSystemToken::ZserioPackingContext& context) const
{
    m_mapId_.initPackingContext(context.getMapId());
}

size_t NdsSystemToken::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_mapId_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t NdsSystemToken::bitSizeOf(NdsSystemToken::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_mapId_.bitSizeOf(context.getMapId(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t NdsSystemToken::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_mapId_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t NdsSystemToken::initializeOffsets(NdsSystemToken::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_mapId_.initializeOffsets(context.getMapId(), endBitPosition);

    return endBitPosition;
}

bool NdsSystemToken::operator==(const NdsSystemToken& other) const
{
    if (this != &other)
    {
        return
                (m_mapId_ == other.m_mapId_);
    }

    return true;
}

uint32_t NdsSystemToken::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_mapId_);

    return result;
}

void NdsSystemToken::write(::zserio::BitStreamWriter& out) const
{
    m_mapId_.write(out);
}

void NdsSystemToken::write(NdsSystemToken::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_mapId_.write(context.getMapId(), out);
}

::nds::system::types::UUID NdsSystemToken::readMapId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::UUID(in, allocator);
}

::nds::system::types::UUID NdsSystemToken::readMapId(NdsSystemToken::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::system::types::UUID(context.getMapId(), in, allocator);
}

} // namespace types
} // namespace system
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/system/types/NdsNodeToken.h>

namespace nds
{
namespace system
{
namespace types
{

NdsNodeToken::NdsNodeToken(const allocator_type& allocator) noexcept :
        m_nodeId_(allocator)
{
}

NdsNodeToken::NdsNodeToken(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_nodeId_(readNodeId(in, allocator))
{
}

NdsNodeToken::NdsNodeToken(NdsNodeToken::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_nodeId_(readNodeId(context, in, allocator))
{
}

NdsNodeToken::NdsNodeToken(::zserio::PropagateAllocatorT,
        const NdsNodeToken& other, const allocator_type& allocator) :
        m_nodeId_(::zserio::allocatorPropagatingCopy(other.m_nodeId_, allocator))
{
}

::nds::system::types::UUID& NdsNodeToken::getNodeId()
{
    return m_nodeId_;
}

const ::nds::system::types::UUID& NdsNodeToken::getNodeId() const
{
    return m_nodeId_;
}

void NdsNodeToken::setNodeId(const ::nds::system::types::UUID& nodeId_)
{
    m_nodeId_ = nodeId_;
}

void NdsNodeToken::setNodeId(::nds::system::types::UUID&& nodeId_)
{
    m_nodeId_ = ::std::move(nodeId_);
}

void NdsNodeToken::initPackingContext(NdsNodeToken::ZserioPackingContext& context) const
{
    m_nodeId_.initPackingContext(context.getNodeId());
}

size_t NdsNodeToken::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_nodeId_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t NdsNodeToken::bitSizeOf(NdsNodeToken::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_nodeId_.bitSizeOf(context.getNodeId(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t NdsNodeToken::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_nodeId_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t NdsNodeToken::initializeOffsets(NdsNodeToken::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_nodeId_.initializeOffsets(context.getNodeId(), endBitPosition);

    return endBitPosition;
}

bool NdsNodeToken::operator==(const NdsNodeToken& other) const
{
    if (this != &other)
    {
        return
                (m_nodeId_ == other.m_nodeId_);
    }

    return true;
}

uint32_t NdsNodeToken::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_nodeId_);

    return result;
}

void NdsNodeToken::write(::zserio::BitStreamWriter& out) const
{
    m_nodeId_.write(out);
}

void NdsNodeToken::write(NdsNodeToken::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_nodeId_.write(context.getNodeId(), out);
}

::nds::system::types::UUID NdsNodeToken::readNodeId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::UUID(in, allocator);
}

::nds::system::types::UUID NdsNodeToken::readNodeId(NdsNodeToken::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::system::types::UUID(context.getNodeId(), in, allocator);
}

} // namespace types
} // namespace system
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/system/types/UUID.h>

namespace nds
{
namespace system
{
namespace types
{

UUID::UUID(const allocator_type& allocator) noexcept :
        m_uuid_(allocator)
{
}

UUID::UUID(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_uuid_(readUuid(in, allocator))
{
}

UUID::UUID(UUID::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_uuid_(readUuid(context, in, allocator))
{
}

UUID::UUID(::zserio::PropagateAllocatorT,
        const UUID& other, const allocator_type& allocator) :
        m_uuid_(::zserio::allocatorPropagatingCopy(other.m_uuid_, allocator))
{
}

::zserio::vector<uint8_t>& UUID::getUuid()
{
    return m_uuid_.getRawArray();
}

const ::zserio::vector<uint8_t>& UUID::getUuid() const
{
    return m_uuid_.getRawArray();
}

void UUID::setUuid(const ::zserio::vector<uint8_t>& uuid_)
{
    m_uuid_ = ZserioArrayType_uuid(uuid_);
}

void UUID::setUuid(::zserio::vector<uint8_t>&& uuid_)
{
    m_uuid_ = ZserioArrayType_uuid(std::move(uuid_));
}

void UUID::initPackingContext(UUID::ZserioPackingContext&) const
{
}

size_t UUID::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_uuid_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t UUID::bitSizeOf(UUID::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_uuid_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t UUID::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_uuid_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t UUID::initializeOffsets(UUID::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_uuid_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool UUID::operator==(const UUID& other) const
{
    if (this != &other)
    {
        return
                (m_uuid_ == other.m_uuid_);
    }

    return true;
}

uint32_t UUID::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_uuid_);

    return result;
}

void UUID::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_uuid_.getRawArray().size() != static_cast<size_t>(16))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field UUID.uuid: ") <<
                m_uuid_.getRawArray().size() << " != " <<
                static_cast<size_t>(16) << "!";
    }
    m_uuid_.write(out);
}

void UUID::write(UUID::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_uuid_.getRawArray().size() != static_cast<size_t>(16))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field UUID.uuid: ") <<
                m_uuid_.getRawArray().size() << " != " <<
                static_cast<size_t>(16) << "!";
    }
    m_uuid_.writePacked(out);
}

UUID::ZserioArrayType_uuid UUID::readUuid(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_uuid readField(allocator);
    readField.read(in, static_cast<size_t>(16));

    return readField;
}

UUID::ZserioArrayType_uuid UUID::readUuid(UUID::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_uuid readField(allocator);
    readField.readPacked(in, static_cast<size_t>(16));

    return readField;
}

} // namespace types
} // namespace system
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/system/types/NdsNodeLegalInfo.h>

namespace nds
{
namespace system
{
namespace types
{

NdsNodeLegalInfo::NdsNodeLegalInfo(const allocator_type& allocator) noexcept :
        m_nodeId_(allocator),
        m_providerName_(allocator),
        m_contentName_(allocator),
        m_contentVersion_(allocator),
        m_contentTimestamp_(allocator),
        m_copyright_(allocator),
        m_licenses_(allocator)
{
}

NdsNodeLegalInfo::NdsNodeLegalInfo(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_nodeId_(readNodeId(in, allocator)),
        m_providerName_(readProviderName(in, allocator)),
        m_contentName_(readContentName(in, allocator)),
        m_contentVersion_(readContentVersion(in, allocator)),
        m_contentTimestamp_(readContentTimestamp(in, allocator)),
        m_copyright_(readCopyright(in, allocator)),
        m_licenses_(readLicenses(in, allocator))
{
}

NdsNodeLegalInfo::NdsNodeLegalInfo(NdsNodeLegalInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_nodeId_(readNodeId(context, in, allocator)),
        m_providerName_(readProviderName(in, allocator)),
        m_contentName_(readContentName(in, allocator)),
        m_contentVersion_(readContentVersion(in, allocator)),
        m_contentTimestamp_(readContentTimestamp(in, allocator)),
        m_copyright_(readCopyright(in, allocator)),
        m_licenses_(readLicenses(in, allocator))
{
}

NdsNodeLegalInfo::NdsNodeLegalInfo(::zserio::PropagateAllocatorT,
        const NdsNodeLegalInfo& other, const allocator_type& allocator) :
        m_nodeId_(::zserio::allocatorPropagatingCopy(other.m_nodeId_, allocator)),
        m_providerName_(::zserio::allocatorPropagatingCopy(other.m_providerName_, allocator)),
        m_contentName_(::zserio::allocatorPropagatingCopy(other.m_contentName_, allocator)),
        m_contentVersion_(::zserio::allocatorPropagatingCopy(other.m_contentVersion_, allocator)),
        m_contentTimestamp_(::zserio::allocatorPropagatingCopy(other.m_contentTimestamp_, allocator)),
        m_copyright_(::zserio::allocatorPropagatingCopy(other.m_copyright_, allocator)),
        m_licenses_(::zserio::allocatorPropagatingCopy(other.m_licenses_, allocator))
{
}

::nds::system::types::NdsNodeToken& NdsNodeLegalInfo::getNodeId()
{
    return m_nodeId_;
}

const ::nds::system::types::NdsNodeToken& NdsNodeLegalInfo::getNodeId() const
{
    return m_nodeId_;
}

void NdsNodeLegalInfo::setNodeId(const ::nds::system::types::NdsNodeToken& nodeId_)
{
    m_nodeId_ = nodeId_;
}

void NdsNodeLegalInfo::setNodeId(::nds::system::types::NdsNodeToken&& nodeId_)
{
    m_nodeId_ = ::std::move(nodeId_);
}

::zserio::string<>& NdsNodeLegalInfo::getProviderName()
{
    return m_providerName_;
}

const ::zserio::string<>& NdsNodeLegalInfo::getProviderName() const
{
    return m_providerName_;
}

void NdsNodeLegalInfo::setProviderName(const ::zserio::string<>& providerName_)
{
    m_providerName_ = providerName_;
}

void NdsNodeLegalInfo::setProviderName(::zserio::string<>&& providerName_)
{
    m_providerName_ = ::std::move(providerName_);
}

::zserio::string<>& NdsNodeLegalInfo::getContentName()
{
    return m_contentName_;
}

const ::zserio::string<>& NdsNodeLegalInfo::getContentName() const
{
    return m_contentName_;
}

void NdsNodeLegalInfo::setContentName(const ::zserio::string<>& contentName_)
{
    m_contentName_ = contentName_;
}

void NdsNodeLegalInfo::setContentName(::zserio::string<>&& contentName_)
{
    m_contentName_ = ::std::move(contentName_);
}

::zserio::string<>& NdsNodeLegalInfo::getContentVersion()
{
    return m_contentVersion_;
}

const ::zserio::string<>& NdsNodeLegalInfo::getContentVersion() const
{
    return m_contentVersion_;
}

void NdsNodeLegalInfo::setContentVersion(const ::zserio::string<>& contentVersion_)
{
    m_contentVersion_ = contentVersion_;
}

void NdsNodeLegalInfo::setContentVersion(::zserio::string<>&& contentVersion_)
{
    m_contentVersion_ = ::std::move(contentVersion_);
}

::zserio::string<>& NdsNodeLegalInfo::getContentTimestamp()
{
    return m_contentTimestamp_;
}

const ::zserio::string<>& NdsNodeLegalInfo::getContentTimestamp() const
{
    return m_contentTimestamp_;
}

void NdsNodeLegalInfo::setContentTimestamp(const ::zserio::string<>& contentTimestamp_)
{
    m_contentTimestamp_ = contentTimestamp_;
}

void NdsNodeLegalInfo::setContentTimestamp(::zserio::string<>&& contentTimestamp_)
{
    m_contentTimestamp_ = ::std::move(contentTimestamp_);
}

::zserio::string<>& NdsNodeLegalInfo::getCopyright()
{
    return m_copyright_;
}

const ::zserio::string<>& NdsNodeLegalInfo::getCopyright() const
{
    return m_copyright_;
}

void NdsNodeLegalInfo::setCopyright(const ::zserio::string<>& copyright_)
{
    m_copyright_ = copyright_;
}

void NdsNodeLegalInfo::setCopyright(::zserio::string<>&& copyright_)
{
    m_copyright_ = ::std::move(copyright_);
}

::zserio::string<>& NdsNodeLegalInfo::getLicenses()
{
    return m_licenses_;
}

const ::zserio::string<>& NdsNodeLegalInfo::getLicenses() const
{
    return m_licenses_;
}

void NdsNodeLegalInfo::setLicenses(const ::zserio::string<>& licenses_)
{
    m_licenses_ = licenses_;
}

void NdsNodeLegalInfo::setLicenses(::zserio::string<>&& licenses_)
{
    m_licenses_ = ::std::move(licenses_);
}

void NdsNodeLegalInfo::initPackingContext(NdsNodeLegalInfo::ZserioPackingContext& context) const
{
    m_nodeId_.initPackingContext(context.getNodeId());
}

size_t NdsNodeLegalInfo::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_nodeId_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_providerName_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentName_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentVersion_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentTimestamp_);
    endBitPosition += ::zserio::bitSizeOfString(m_copyright_);
    endBitPosition += ::zserio::bitSizeOfString(m_licenses_);

    return endBitPosition - bitPosition;
}

size_t NdsNodeLegalInfo::bitSizeOf(NdsNodeLegalInfo::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_nodeId_.bitSizeOf(context.getNodeId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_providerName_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentName_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentVersion_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentTimestamp_);
    endBitPosition += ::zserio::bitSizeOfString(m_copyright_);
    endBitPosition += ::zserio::bitSizeOfString(m_licenses_);

    return endBitPosition - bitPosition;
}

size_t NdsNodeLegalInfo::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_nodeId_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_providerName_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentName_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentVersion_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentTimestamp_);
    endBitPosition += ::zserio::bitSizeOfString(m_copyright_);
    endBitPosition += ::zserio::bitSizeOfString(m_licenses_);

    return endBitPosition;
}

size_t NdsNodeLegalInfo::initializeOffsets(NdsNodeLegalInfo::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_nodeId_.initializeOffsets(context.getNodeId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_providerName_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentName_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentVersion_);
    endBitPosition += ::zserio::bitSizeOfString(m_contentTimestamp_);
    endBitPosition += ::zserio::bitSizeOfString(m_copyright_);
    endBitPosition += ::zserio::bitSizeOfString(m_licenses_);

    return endBitPosition;
}

bool NdsNodeLegalInfo::operator==(const NdsNodeLegalInfo& other) const
{
    if (this != &other)
    {
        return
                (m_nodeId_ == other.m_nodeId_) &&
                (m_providerName_ == other.m_providerName_) &&
                (m_contentName_ == other.m_contentName_) &&
                (m_contentVersion_ == other.m_contentVersion_) &&
                (m_contentTimestamp_ == other.m_contentTimestamp_) &&
                (m_copyright_ == other.m_copyright_) &&
                (m_licenses_ == other.m_licenses_);
    }

    return true;
}

uint32_t NdsNodeLegalInfo::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_nodeId_);
    result = ::zserio::calcHashCode(result, m_providerName_);
    result = ::zserio::calcHashCode(result, m_contentName_);
    result = ::zserio::calcHashCode(result, m_contentVersion_);
    result = ::zserio::calcHashCode(result, m_contentTimestamp_);
    result = ::zserio::calcHashCode(result, m_copyright_);
    result = ::zserio::calcHashCode(result, m_licenses_);

    return result;
}

void NdsNodeLegalInfo::write(::zserio::BitStreamWriter& out) const
{
    m_nodeId_.write(out);
    out.writeString(m_providerName_);
    out.writeString(m_contentName_);
    out.writeString(m_contentVersion_);
    out.writeString(m_contentTimestamp_);
    out.writeString(m_copyright_);
    out.writeString(m_licenses_);
}

void NdsNodeLegalInfo::write(NdsNodeLegalInfo::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_nodeId_.write(context.getNodeId(), out);
    out.writeString(m_providerName_);
    out.writeString(m_contentName_);
    out.writeString(m_contentVersion_);
    out.writeString(m_contentTimestamp_);
    out.writeString(m_copyright_);
    out.writeString(m_licenses_);
}

::nds::system::types::NdsNodeToken NdsNodeLegalInfo::readNodeId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::NdsNodeToken(in, allocator);
}

::nds::system::types::NdsNodeToken NdsNodeLegalInfo::readNodeId(NdsNodeLegalInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::system::types::NdsNodeToken(context.getNodeId(), in, allocator);
}
::zserio::string<> NdsNodeLegalInfo::readProviderName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> NdsNodeLegalInfo::readContentName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> NdsNodeLegalInfo::readContentVersion(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> NdsNodeLegalInfo::readContentTimestamp(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> NdsNodeLegalInfo::readCopyright(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> NdsNodeLegalInfo::readLicenses(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

} // namespace types
} // namespace system
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/system/types/ModuleDefinition.h>

namespace nds
{
namespace system
{
namespace types
{

ModuleDefinition::ModuleDefinition(const allocator_type& allocator) noexcept :
        m_name_(allocator),
        m_version_(allocator)
{
}

ModuleDefinition::ModuleDefinition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_name_(readName(in, allocator)),
        m_version_(readVersion(in, allocator))
{
}

ModuleDefinition::ModuleDefinition(::zserio::PropagateAllocatorT,
        const ModuleDefinition& other, const allocator_type& allocator) :
        m_name_(::zserio::allocatorPropagatingCopy(other.m_name_, allocator)),
        m_version_(::zserio::allocatorPropagatingCopy(other.m_version_, allocator))
{
}

::nds::system::types::ModuleName& ModuleDefinition::getName()
{
    return m_name_;
}

const ::nds::system::types::ModuleName& ModuleDefinition::getName() const
{
    return m_name_;
}

void ModuleDefinition::setName(const ::nds::system::types::ModuleName& name_)
{
    m_name_ = name_;
}

void ModuleDefinition::setName(::nds::system::types::ModuleName&& name_)
{
    m_name_ = ::std::move(name_);
}

::nds::system::types::ModuleVersion& ModuleDefinition::getVersion()
{
    return m_version_;
}

const ::nds::system::types::ModuleVersion& ModuleDefinition::getVersion() const
{
    return m_version_;
}

void ModuleDefinition::setVersion(const ::nds::system::types::ModuleVersion& version_)
{
    m_version_ = version_;
}

void ModuleDefinition::setVersion(::nds::system::types::ModuleVersion&& version_)
{
    m_version_ = ::std::move(version_);
}

size_t ModuleDefinition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOfString(m_version_);

    return endBitPosition - bitPosition;
}

size_t ModuleDefinition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOfString(m_version_);

    return endBitPosition;
}

bool ModuleDefinition::operator==(const ModuleDefinition& other) const
{
    if (this != &other)
    {
        return
                (m_name_ == other.m_name_) &&
                (m_version_ == other.m_version_);
    }

    return true;
}

uint32_t ModuleDefinition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_name_);
    result = ::zserio::calcHashCode(result, m_version_);

    return result;
}

void ModuleDefinition::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_name_);
    out.writeString(m_version_);
}

::nds::system::types::ModuleName ModuleDefinition::readName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleName>(in.readString(allocator));
}
::nds::system::types::ModuleVersion ModuleDefinition::readVersion(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleVersion>(in.readString(allocator));
}

} // namespace types
} // namespace system
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/system/types/ExternData.h>

namespace nds
{
namespace system
{
namespace types
{

ExternData::ExternData(const allocator_type& allocator) noexcept :
        m_externDescriptor_(allocator),
        m_data_(allocator)
{
}

ExternData::ExternData(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_externDescriptor_(readExternDescriptor(in, allocator)),
        m_data_(readData(in, allocator))
{
}

ExternData::ExternData(::zserio::PropagateAllocatorT,
        const ExternData& other, const allocator_type& allocator) :
        m_externDescriptor_(::zserio::allocatorPropagatingCopy(other.m_externDescriptor_, allocator)),
        m_data_(::zserio::allocatorPropagatingCopy(other.m_data_, allocator))
{
}

::nds::system::types::ExternDescriptor& ExternData::getExternDescriptor()
{
    return m_externDescriptor_;
}

const ::nds::system::types::ExternDescriptor& ExternData::getExternDescriptor() const
{
    return m_externDescriptor_;
}

void ExternData::setExternDescriptor(const ::nds::system::types::ExternDescriptor& externDescriptor_)
{
    m_externDescriptor_ = externDescriptor_;
}

void ExternData::setExternDescriptor(::nds::system::types::ExternDescriptor&& externDescriptor_)
{
    m_externDescriptor_ = ::std::move(externDescriptor_);
}

::zserio::BitBuffer& ExternData::getData()
{
    return m_data_;
}

const ::zserio::BitBuffer& ExternData::getData() const
{
    return m_data_;
}

void ExternData::setData(const ::zserio::BitBuffer& data_)
{
    m_data_ = data_;
}

void ExternData::setData(::zserio::BitBuffer&& data_)
{
    m_data_ = ::std::move(data_);
}

size_t ExternData::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_externDescriptor_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_data_);

    return endBitPosition - bitPosition;
}

size_t ExternData::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_externDescriptor_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_data_);

    return endBitPosition;
}

bool ExternData::operator==(const ExternData& other) const
{
    if (this != &other)
    {
        return
                (m_externDescriptor_ == other.m_externDescriptor_) &&
                (m_data_ == other.m_data_);
    }

    return true;
}

uint32_t ExternData::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_externDescriptor_);
    result = ::zserio::calcHashCode(result, m_data_);

    return result;
}

void ExternData::write(::zserio::BitStreamWriter& out) const
{
    out.alignTo(8);
    m_externDescriptor_.write(out);
    out.writeBitBuffer(m_data_);
}

::nds::system::types::ExternDescriptor ExternData::readExternDescriptor(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    return ::nds::system::types::ExternDescriptor(in, allocator);
}
::zserio::BitBuffer ExternData::readData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::BitBuffer>(in.readBitBuffer(allocator));
}

} // namespace types
} // namespace system
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/system/types/ExternDescriptor.h>

namespace nds
{
namespace system
{
namespace types
{

ExternDescriptor::ExternDescriptor(const allocator_type& allocator) noexcept :
        m_name_(allocator),
        m_version_(allocator),
        m_target_(allocator)
{
}

ExternDescriptor::ExternDescriptor(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_name_(readName(in, allocator)),
        m_version_(readVersion(in, allocator)),
        m_target_(readTarget(in, allocator))
{
}

ExternDescriptor::ExternDescriptor(::zserio::PropagateAllocatorT,
        const ExternDescriptor& other, const allocator_type& allocator) :
        m_name_(::zserio::allocatorPropagatingCopy(other.m_name_, allocator)),
        m_version_(::zserio::allocatorPropagatingCopy(other.m_version_, allocator)),
        m_target_(::zserio::allocatorPropagatingCopy(other.m_target_, allocator))
{
}

::nds::system::types::ModuleName& ExternDescriptor::getName()
{
    return m_name_;
}

const ::nds::system::types::ModuleName& ExternDescriptor::getName() const
{
    return m_name_;
}

void ExternDescriptor::setName(const ::nds::system::types::ModuleName& name_)
{
    m_name_ = name_;
}

void ExternDescriptor::setName(::nds::system::types::ModuleName&& name_)
{
    m_name_ = ::std::move(name_);
}

::nds::system::types::ModuleVersion& ExternDescriptor::getVersion()
{
    return m_version_;
}

const ::nds::system::types::ModuleVersion& ExternDescriptor::getVersion() const
{
    return m_version_;
}

void ExternDescriptor::setVersion(const ::nds::system::types::ModuleVersion& version_)
{
    m_version_ = version_;
}

void ExternDescriptor::setVersion(::nds::system::types::ModuleVersion&& version_)
{
    m_version_ = ::std::move(version_);
}

::nds::system::types::ModuleExtern& ExternDescriptor::getTarget()
{
    return m_target_;
}

const ::nds::system::types::ModuleExtern& ExternDescriptor::getTarget() const
{
    return m_target_;
}

void ExternDescriptor::setTarget(const ::nds::system::types::ModuleExtern& target_)
{
    m_target_ = target_;
}

void ExternDescriptor::setTarget(::nds::system::types::ModuleExtern&& target_)
{
    m_target_ = ::std::move(target_);
}

size_t ExternDescriptor::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOfString(m_version_);
    endBitPosition += ::zserio::bitSizeOfString(m_target_);

    return endBitPosition - bitPosition;
}

size_t ExternDescriptor::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOfString(m_version_);
    endBitPosition += ::zserio::bitSizeOfString(m_target_);

    return endBitPosition;
}

bool ExternDescriptor::operator==(const ExternDescriptor& other) const
{
    if (this != &other)
    {
        return
                (m_name_ == other.m_name_) &&
                (m_version_ == other.m_version_) &&
                (m_target_ == other.m_target_);
    }

    return true;
}

uint32_t ExternDescriptor::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_name_);
    result = ::zserio::calcHashCode(result, m_version_);
    result = ::zserio::calcHashCode(result, m_target_);

    return result;
}

void ExternDescriptor::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_name_);
    out.writeString(m_version_);
    out.writeString(m_target_);
}

::nds::system::types::ModuleName ExternDescriptor::readName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleName>(in.readString(allocator));
}
::nds::system::types::ModuleVersion ExternDescriptor::readVersion(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleVersion>(in.readString(allocator));
}
::nds::system::types::ModuleExtern ExternDescriptor::readTarget(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleExtern>(in.readString(allocator));
}

} // namespace types
} // namespace system
} // namespace nds
