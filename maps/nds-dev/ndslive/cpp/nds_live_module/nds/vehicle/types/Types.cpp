/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/vehicle/types/Horizon.h>

namespace nds
{
namespace vehicle
{
namespace types
{

Horizon::Horizon(const allocator_type& allocator) noexcept :
        m_numPaths_(uint32_t()),
        m_horizon_(allocator),
        m_mostProbablePath_(allocator)
{
}

Horizon::Horizon(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numPaths_(readNumPaths(in)),
        m_horizon_(readHorizon(in, allocator)),
        m_mostProbablePath_(readMostProbablePath(in, allocator))
{
}

Horizon::Horizon(Horizon::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numPaths_(readNumPaths(context, in)),
        m_horizon_(readHorizon(context, in, allocator)),
        m_mostProbablePath_(readMostProbablePath(context, in, allocator))
{
}

Horizon::Horizon(::zserio::PropagateAllocatorT,
        const Horizon& other, const allocator_type& allocator) :
        m_numPaths_(::zserio::allocatorPropagatingCopy(other.m_numPaths_, allocator)),
        m_horizon_(::zserio::allocatorPropagatingCopy(other.m_horizon_, allocator)),
        m_mostProbablePath_(::zserio::allocatorPropagatingCopy(other.m_mostProbablePath_, allocator))
{
}

void Horizon::initializeChildren()
{
    m_horizon_.initializeElements(*this);
}

uint32_t Horizon::getNumPaths() const
{
    return m_numPaths_;
}

void Horizon::setNumPaths(uint32_t numPaths_)
{
    m_numPaths_ = numPaths_;
}

::zserio::vector<::nds::vehicle::types::HorizonPath>& Horizon::getHorizon()
{
    return m_horizon_.getRawArray();
}

const ::zserio::vector<::nds::vehicle::types::HorizonPath>& Horizon::getHorizon() const
{
    return m_horizon_.getRawArray();
}

void Horizon::setHorizon(const ::zserio::vector<::nds::vehicle::types::HorizonPath>& horizon_)
{
    m_horizon_ = ZserioArrayType_horizon(horizon_);
}

void Horizon::setHorizon(::zserio::vector<::nds::vehicle::types::HorizonPath>&& horizon_)
{
    m_horizon_ = ZserioArrayType_horizon(std::move(horizon_));
}

::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>& Horizon::getMostProbablePath()
{
    return m_mostProbablePath_.getRawArray();
}

const ::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>& Horizon::getMostProbablePath() const
{
    return m_mostProbablePath_.getRawArray();
}

void Horizon::setMostProbablePath(const ::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>& mostProbablePath_)
{
    m_mostProbablePath_ = ZserioArrayType_mostProbablePath(mostProbablePath_);
}

void Horizon::setMostProbablePath(::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>&& mostProbablePath_)
{
    m_mostProbablePath_ = ZserioArrayType_mostProbablePath(std::move(mostProbablePath_));
}

void Horizon::initPackingContext(Horizon::ZserioPackingContext& context) const
{
    context.getNumPaths().init<::zserio::VarSizeArrayTraits>(m_numPaths_);
}

size_t Horizon::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPaths_);
    endBitPosition += m_horizon_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_mostProbablePath_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Horizon::bitSizeOf(Horizon::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPaths().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPaths_);
    endBitPosition += m_horizon_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_mostProbablePath_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Horizon::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPaths_);
    endBitPosition = m_horizon_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_mostProbablePath_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t Horizon::initializeOffsets(Horizon::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPaths().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPaths_);
    endBitPosition = m_horizon_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_mostProbablePath_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool Horizon::operator==(const Horizon& other) const
{
    if (this != &other)
    {
        return
                (m_numPaths_ == other.m_numPaths_) &&
                (m_horizon_ == other.m_horizon_) &&
                (m_mostProbablePath_ == other.m_mostProbablePath_);
    }

    return true;
}

uint32_t Horizon::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numPaths_);
    result = ::zserio::calcHashCode(result, m_horizon_);
    result = ::zserio::calcHashCode(result, m_mostProbablePath_);

    return result;
}

void Horizon::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numPaths_);

    // check array length
    if (m_horizon_.getRawArray().size() != static_cast<size_t>(getNumPaths()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Horizon.horizon: ") <<
                m_horizon_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPaths()) << "!";
    }
    m_horizon_.write(*this, out);

    m_mostProbablePath_.write(out);
}

void Horizon::write(Horizon::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumPaths().write<::zserio::VarSizeArrayTraits>(out, m_numPaths_);

    // check array length
    if (m_horizon_.getRawArray().size() != static_cast<size_t>(getNumPaths()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Horizon.horizon: ") <<
                m_horizon_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPaths()) << "!";
    }
    m_horizon_.writePacked(*this, out);

    m_mostProbablePath_.writePacked(out);
}

void Horizon::ZserioArrayExpressions_horizon::initializeElement(Horizon&,
        ::nds::vehicle::types::HorizonPath& element, size_t)
{
    element.initializeChildren();
}

void Horizon::ZserioElementFactory_horizon::create(Horizon&        ,
        ::zserio::vector<::nds::vehicle::types::HorizonPath>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Horizon::ZserioElementFactory_horizon::create(Horizon&        ,
        ::zserio::vector<::nds::vehicle::types::HorizonPath>& array,
        ::nds::vehicle::types::HorizonPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t Horizon::readNumPaths(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t Horizon::readNumPaths(Horizon::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumPaths().read<::zserio::VarSizeArrayTraits>(in);
}
Horizon::ZserioArrayType_horizon Horizon::readHorizon(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_horizon readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumPaths()));

    return readField;
}

Horizon::ZserioArrayType_horizon Horizon::readHorizon(Horizon::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_horizon readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPaths()));

    return readField;
}
Horizon::ZserioArrayType_mostProbablePath Horizon::readMostProbablePath(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_mostProbablePath readField(allocator);
    readField.read(in);

    return readField;
}

Horizon::ZserioArrayType_mostProbablePath Horizon::readMostProbablePath(Horizon::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_mostProbablePath readField(allocator);
    readField.readPacked(in);

    return readField;
}

} // namespace types
} // namespace vehicle
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/vehicle/types/HorizonPath.h>

namespace nds
{
namespace vehicle
{
namespace types
{

HorizonPath::HorizonPath(const allocator_type& allocator) noexcept :
        m_pathId_(::nds::vehicle::reference::types::HorizonPathId()),
        m_parentPathId_(::nds::vehicle::reference::types::HorizonPathId()),
        m_parentSegmentIndex_(uint32_t()),
        m_path_(allocator)
{
}

HorizonPath::HorizonPath(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_pathId_(readPathId(in)),
        m_parentPathId_(readParentPathId(in)),
        m_parentSegmentIndex_(readParentSegmentIndex(in)),
        m_path_(readPath(in, allocator))
{
}

HorizonPath::HorizonPath(HorizonPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_pathId_(readPathId(context, in)),
        m_parentPathId_(readParentPathId(context, in)),
        m_parentSegmentIndex_(readParentSegmentIndex(context, in)),
        m_path_(readPath(context, in, allocator))
{
}

HorizonPath::HorizonPath(::zserio::PropagateAllocatorT,
        const HorizonPath& other, const allocator_type& allocator) :
        m_pathId_(::zserio::allocatorPropagatingCopy(other.m_pathId_, allocator)),
        m_parentPathId_(::zserio::allocatorPropagatingCopy(other.m_parentPathId_, allocator)),
        m_parentSegmentIndex_(::zserio::allocatorPropagatingCopy(other.m_parentSegmentIndex_, allocator)),
        m_path_(::zserio::allocatorPropagatingCopy(other.m_path_, allocator))
{
}

void HorizonPath::initializeChildren()
{
    m_path_.initializeChildren();
}

::nds::vehicle::reference::types::HorizonPathId HorizonPath::getPathId() const
{
    return m_pathId_;
}

void HorizonPath::setPathId(::nds::vehicle::reference::types::HorizonPathId pathId_)
{
    m_pathId_ = pathId_;
}

::nds::vehicle::reference::types::HorizonPathId HorizonPath::getParentPathId() const
{
    return m_parentPathId_;
}

void HorizonPath::setParentPathId(::nds::vehicle::reference::types::HorizonPathId parentPathId_)
{
    m_parentPathId_ = parentPathId_;
}

uint32_t HorizonPath::getParentSegmentIndex() const
{
    return m_parentSegmentIndex_;
}

void HorizonPath::setParentSegmentIndex(uint32_t parentSegmentIndex_)
{
    m_parentSegmentIndex_ = parentSegmentIndex_;
}

::nds::core::location::RoadLocationPath& HorizonPath::getPath()
{
    return m_path_;
}

const ::nds::core::location::RoadLocationPath& HorizonPath::getPath() const
{
    return m_path_;
}

void HorizonPath::setPath(const ::nds::core::location::RoadLocationPath& path_)
{
    m_path_ = path_;
}

void HorizonPath::setPath(::nds::core::location::RoadLocationPath&& path_)
{
    m_path_ = ::std::move(path_);
}

void HorizonPath::initPackingContext(HorizonPath::ZserioPackingContext& context) const
{
    context.getPathId().init<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(m_pathId_);
    context.getParentPathId().init<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(m_parentPathId_);
    context.getParentSegmentIndex().init<::zserio::VarSizeArrayTraits>(m_parentSegmentIndex_);
    m_path_.initPackingContext(context.getPath());
}

size_t HorizonPath::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_pathId_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_parentPathId_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_parentSegmentIndex_);
    endBitPosition += m_path_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t HorizonPath::bitSizeOf(HorizonPath::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPathId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(m_pathId_);
    endBitPosition += context.getParentPathId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(m_parentPathId_);
    endBitPosition += context.getParentSegmentIndex().bitSizeOf<::zserio::VarSizeArrayTraits>(m_parentSegmentIndex_);
    endBitPosition += m_path_.bitSizeOf(context.getPath(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t HorizonPath::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_pathId_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_parentPathId_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_parentSegmentIndex_);
    endBitPosition = m_path_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t HorizonPath::initializeOffsets(HorizonPath::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPathId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(m_pathId_);
    endBitPosition += context.getParentPathId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(m_parentPathId_);
    endBitPosition += context.getParentSegmentIndex().bitSizeOf<::zserio::VarSizeArrayTraits>(m_parentSegmentIndex_);
    endBitPosition = m_path_.initializeOffsets(context.getPath(), endBitPosition);

    return endBitPosition;
}

bool HorizonPath::operator==(const HorizonPath& other) const
{
    if (this != &other)
    {
        return
                (m_pathId_ == other.m_pathId_) &&
                (m_parentPathId_ == other.m_parentPathId_) &&
                (m_parentSegmentIndex_ == other.m_parentSegmentIndex_) &&
                (m_path_ == other.m_path_);
    }

    return true;
}

uint32_t HorizonPath::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_pathId_);
    result = ::zserio::calcHashCode(result, m_parentPathId_);
    result = ::zserio::calcHashCode(result, m_parentSegmentIndex_);
    result = ::zserio::calcHashCode(result, m_path_);

    return result;
}

void HorizonPath::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_pathId_);
    out.writeVarUInt32(m_parentPathId_);
    out.writeVarSize(m_parentSegmentIndex_);
    m_path_.write(out);
}

void HorizonPath::write(HorizonPath::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getPathId().write<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(out, m_pathId_);
    context.getParentPathId().write<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(out, m_parentPathId_);
    context.getParentSegmentIndex().write<::zserio::VarSizeArrayTraits>(out, m_parentSegmentIndex_);
    m_path_.write(context.getPath(), out);
}

::nds::vehicle::reference::types::HorizonPathId HorizonPath::readPathId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::vehicle::reference::types::HorizonPathId>(in.readVarUInt32());
}

::nds::vehicle::reference::types::HorizonPathId HorizonPath::readPathId(HorizonPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getPathId().read<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(in);
}
::nds::vehicle::reference::types::HorizonPathId HorizonPath::readParentPathId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::vehicle::reference::types::HorizonPathId>(in.readVarUInt32());
}

::nds::vehicle::reference::types::HorizonPathId HorizonPath::readParentPathId(HorizonPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getParentPathId().read<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(in);
}
uint32_t HorizonPath::readParentSegmentIndex(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t HorizonPath::readParentSegmentIndex(HorizonPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getParentSegmentIndex().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::location::RoadLocationPath HorizonPath::readPath(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationPath(in, allocator);
}

::nds::core::location::RoadLocationPath HorizonPath::readPath(HorizonPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationPath(context.getPath(), in, allocator);
}

} // namespace types
} // namespace vehicle
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/vehicle/types/PoseRoadPathMatched.h>

namespace nds
{
namespace vehicle
{
namespace types
{

PoseRoadPathMatched::PoseRoadPathMatched(const allocator_type&) noexcept :
        m_id_(::nds::vehicle::reference::types::HorizonPathId()),
        m_offset_(::nds::vehicle::reference::types::HorizonPathOffset()),
        m_altitude_(::zserio::NullOpt),
        m_heading_(::zserio::NullOpt),
        m_speed_(::zserio::NullOpt),
        m_probability_(::zserio::NullOpt)
{
}

PoseRoadPathMatched::PoseRoadPathMatched(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in)),
        m_offset_(readOffset(in)),
        m_altitude_(readAltitude(in)),
        m_heading_(readHeading(in)),
        m_speed_(readSpeed(in)),
        m_probability_(readProbability(in, allocator))
{
}

PoseRoadPathMatched::PoseRoadPathMatched(PoseRoadPathMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in)),
        m_offset_(readOffset(context, in)),
        m_altitude_(readAltitude(context, in)),
        m_heading_(readHeading(context, in)),
        m_speed_(readSpeed(context, in)),
        m_probability_(readProbability(context, in, allocator))
{
}

PoseRoadPathMatched::PoseRoadPathMatched(::zserio::PropagateAllocatorT,
        const PoseRoadPathMatched& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_offset_(::zserio::allocatorPropagatingCopy(other.m_offset_, allocator)),
        m_altitude_(::zserio::allocatorPropagatingCopy(other.m_altitude_, allocator)),
        m_heading_(::zserio::allocatorPropagatingCopy(other.m_heading_, allocator)),
        m_speed_(::zserio::allocatorPropagatingCopy(other.m_speed_, allocator)),
        m_probability_(::zserio::allocatorPropagatingCopy(other.m_probability_, allocator))
{
}

::nds::vehicle::reference::types::HorizonPathId PoseRoadPathMatched::getId() const
{
    return m_id_;
}

void PoseRoadPathMatched::setId(::nds::vehicle::reference::types::HorizonPathId id_)
{
    m_id_ = id_;
}

::nds::vehicle::reference::types::HorizonPathOffset PoseRoadPathMatched::getOffset() const
{
    return m_offset_;
}

void PoseRoadPathMatched::setOffset(::nds::vehicle::reference::types::HorizonPathOffset offset_)
{
    m_offset_ = offset_;
}

int32_t PoseRoadPathMatched::getAltitude() const
{
    return m_altitude_.value();
}

void PoseRoadPathMatched::setAltitude(int32_t altitude_)
{
    m_altitude_ = altitude_;
}

bool PoseRoadPathMatched::isAltitudeUsed() const
{
    return (isAltitudeSet());
}

bool PoseRoadPathMatched::isAltitudeSet() const
{
    return m_altitude_.hasValue();
}

void PoseRoadPathMatched::resetAltitude()
{
    m_altitude_.reset();
}

::nds::core::vehicle::Heading PoseRoadPathMatched::getHeading() const
{
    return m_heading_.value();
}

void PoseRoadPathMatched::setHeading(::nds::core::vehicle::Heading heading_)
{
    m_heading_ = heading_;
}

bool PoseRoadPathMatched::isHeadingUsed() const
{
    return (isHeadingSet());
}

bool PoseRoadPathMatched::isHeadingSet() const
{
    return m_heading_.hasValue();
}

void PoseRoadPathMatched::resetHeading()
{
    m_heading_.reset();
}

::nds::core::types::SpeedKmh PoseRoadPathMatched::getSpeed() const
{
    return m_speed_.value();
}

void PoseRoadPathMatched::setSpeed(::nds::core::types::SpeedKmh speed_)
{
    m_speed_ = speed_;
}

bool PoseRoadPathMatched::isSpeedUsed() const
{
    return (isSpeedSet());
}

bool PoseRoadPathMatched::isSpeedSet() const
{
    return m_speed_.hasValue();
}

void PoseRoadPathMatched::resetSpeed()
{
    m_speed_.reset();
}

::nds::core::vehicle::MatchProbability& PoseRoadPathMatched::getProbability()
{
    return m_probability_.value();
}

const ::nds::core::vehicle::MatchProbability& PoseRoadPathMatched::getProbability() const
{
    return m_probability_.value();
}

void PoseRoadPathMatched::setProbability(const ::nds::core::vehicle::MatchProbability& probability_)
{
    m_probability_ = probability_;
}

void PoseRoadPathMatched::setProbability(::nds::core::vehicle::MatchProbability&& probability_)
{
    m_probability_ = ::std::move(probability_);
}

bool PoseRoadPathMatched::isProbabilityUsed() const
{
    return (isProbabilitySet());
}

bool PoseRoadPathMatched::isProbabilitySet() const
{
    return m_probability_.hasValue();
}

void PoseRoadPathMatched::resetProbability()
{
    m_probability_.reset();
}

void PoseRoadPathMatched::initPackingContext(PoseRoadPathMatched::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(m_id_);
    context.getOffset().init<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathOffset>>(m_offset_);
    if (isAltitudeSet())
    {
        context.getAltitude().init<::zserio::VarIntNNArrayTraits<int32_t>>(m_altitude_.value());
    }
    if (isHeadingSet())
    {
        context.getHeading().init<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(m_heading_.value());
    }
    if (isSpeedSet())
    {
        context.getSpeed().init<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_speed_.value());
    }
    if (isProbabilitySet())
    {
        m_probability_.value().initPackingContext(context.getProbability());
    }
}

size_t PoseRoadPathMatched::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_id_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_offset_);
    endBitPosition += 1;
    if (isAltitudeSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_altitude_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isProbabilitySet())
    {
        endBitPosition += m_probability_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t PoseRoadPathMatched::bitSizeOf(PoseRoadPathMatched::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(m_id_);
    endBitPosition += context.getOffset().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathOffset>>(m_offset_);
    endBitPosition += 1;
    if (isAltitudeSet())
    {
        endBitPosition += context.getAltitude().bitSizeOf<::zserio::VarIntNNArrayTraits<int32_t>>(m_altitude_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += context.getHeading().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(m_heading_.value());
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += context.getSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_speed_.value());
    }
    endBitPosition += 1;
    if (isProbabilitySet())
    {
        endBitPosition += m_probability_.value().bitSizeOf(context.getProbability(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t PoseRoadPathMatched::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_id_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_offset_);
    endBitPosition += 1;
    if (isAltitudeSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_altitude_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isProbabilitySet())
    {
        endBitPosition = m_probability_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t PoseRoadPathMatched::initializeOffsets(PoseRoadPathMatched::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(m_id_);
    endBitPosition += context.getOffset().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathOffset>>(m_offset_);
    endBitPosition += 1;
    if (isAltitudeSet())
    {
        endBitPosition += context.getAltitude().bitSizeOf<::zserio::VarIntNNArrayTraits<int32_t>>(m_altitude_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += context.getHeading().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(m_heading_.value());
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += context.getSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_speed_.value());
    }
    endBitPosition += 1;
    if (isProbabilitySet())
    {
        endBitPosition = m_probability_.value().initializeOffsets(context.getProbability(), endBitPosition);
    }

    return endBitPosition;
}

bool PoseRoadPathMatched::operator==(const PoseRoadPathMatched& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_offset_ == other.m_offset_) &&
                (!isAltitudeUsed() ? !other.isAltitudeUsed() : (m_altitude_ == other.m_altitude_)) &&
                (!isHeadingUsed() ? !other.isHeadingUsed() : (m_heading_ == other.m_heading_)) &&
                (!isSpeedUsed() ? !other.isSpeedUsed() : (m_speed_ == other.m_speed_)) &&
                (!isProbabilityUsed() ? !other.isProbabilityUsed() : (m_probability_ == other.m_probability_));
    }

    return true;
}

uint32_t PoseRoadPathMatched::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_offset_);
    if (isAltitudeUsed())
        result = ::zserio::calcHashCode(result, m_altitude_);
    if (isHeadingUsed())
        result = ::zserio::calcHashCode(result, m_heading_);
    if (isSpeedUsed())
        result = ::zserio::calcHashCode(result, m_speed_);
    if (isProbabilityUsed())
        result = ::zserio::calcHashCode(result, m_probability_);

    return result;
}

void PoseRoadPathMatched::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_id_);
    out.writeVarUInt32(m_offset_);
    if (isAltitudeSet())
    {
        out.writeBool(true);
        out.writeVarInt32(m_altitude_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isHeadingSet())
    {
        out.writeBool(true);
        out.writeBits(m_heading_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }
    if (isSpeedSet())
    {
        out.writeBool(true);
        out.writeBits(m_speed_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }
    if (isProbabilitySet())
    {
        out.writeBool(true);
        m_probability_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void PoseRoadPathMatched::write(PoseRoadPathMatched::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(out, m_id_);
    context.getOffset().write<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathOffset>>(out, m_offset_);
    if (isAltitudeSet())
    {
        out.writeBool(true);
        context.getAltitude().write<::zserio::VarIntNNArrayTraits<int32_t>>(out, m_altitude_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isHeadingSet())
    {
        out.writeBool(true);
        context.getHeading().write<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(out, m_heading_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isSpeedSet())
    {
        out.writeBool(true);
        context.getSpeed().write<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(out, m_speed_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isProbabilitySet())
    {
        out.writeBool(true);
        m_probability_.value().write(context.getProbability(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::vehicle::reference::types::HorizonPathId PoseRoadPathMatched::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::vehicle::reference::types::HorizonPathId>(in.readVarUInt32());
}

::nds::vehicle::reference::types::HorizonPathId PoseRoadPathMatched::readId(PoseRoadPathMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathId>>(in);
}
::nds::vehicle::reference::types::HorizonPathOffset PoseRoadPathMatched::readOffset(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::vehicle::reference::types::HorizonPathOffset>(in.readVarUInt32());
}

::nds::vehicle::reference::types::HorizonPathOffset PoseRoadPathMatched::readOffset(PoseRoadPathMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getOffset().read<::zserio::VarIntNNArrayTraits<::nds::vehicle::reference::types::HorizonPathOffset>>(in);
}
::zserio::InplaceOptionalHolder<int32_t> PoseRoadPathMatched::readAltitude(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(static_cast<int32_t>(in.readVarInt32()));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int32_t> PoseRoadPathMatched::readAltitude(PoseRoadPathMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(context.getAltitude().read<::zserio::VarIntNNArrayTraits<int32_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading> PoseRoadPathMatched::readHeading(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(static_cast<::nds::core::vehicle::Heading>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading> PoseRoadPathMatched::readHeading(PoseRoadPathMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(context.getHeading().read<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh> PoseRoadPathMatched::readSpeed(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(static_cast<::nds::core::types::SpeedKmh>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh> PoseRoadPathMatched::readSpeed(PoseRoadPathMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(context.getSpeed().read<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability> PoseRoadPathMatched::readProbability(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability>(::nds::core::vehicle::MatchProbability(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability> PoseRoadPathMatched::readProbability(PoseRoadPathMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability>(::nds::core::vehicle::MatchProbability(context.getProbability(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability>(::zserio::NullOpt);
}

} // namespace types
} // namespace vehicle
} // namespace nds
