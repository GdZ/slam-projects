/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/vehicle/services/HorizonRequest.h>

namespace nds
{
namespace vehicle
{
namespace services
{

HorizonRequest::HorizonRequest(const allocator_type& allocator) noexcept :
        m_pose_(allocator),
        m_horizonLength_(::nds::core::types::LengthMeters())
{
}

HorizonRequest::HorizonRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_pose_(readPose(in, allocator)),
        m_horizonLength_(readHorizonLength(in))
{
}

HorizonRequest::HorizonRequest(HorizonRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_pose_(readPose(context, in, allocator)),
        m_horizonLength_(readHorizonLength(context, in))
{
}

HorizonRequest::HorizonRequest(::zserio::PropagateAllocatorT,
        const HorizonRequest& other, const allocator_type& allocator) :
        m_pose_(::zserio::allocatorPropagatingCopy(other.m_pose_, allocator)),
        m_horizonLength_(::zserio::allocatorPropagatingCopy(other.m_horizonLength_, allocator))
{
}

void HorizonRequest::initializeChildren()
{
    m_pose_.initializeElements(*this);
}

::zserio::vector<::nds::core::vehicle::VehiclePose>& HorizonRequest::getPose()
{
    return m_pose_.getRawArray();
}

const ::zserio::vector<::nds::core::vehicle::VehiclePose>& HorizonRequest::getPose() const
{
    return m_pose_.getRawArray();
}

void HorizonRequest::setPose(const ::zserio::vector<::nds::core::vehicle::VehiclePose>& pose_)
{
    m_pose_ = ZserioArrayType_pose(pose_);
}

void HorizonRequest::setPose(::zserio::vector<::nds::core::vehicle::VehiclePose>&& pose_)
{
    m_pose_ = ZserioArrayType_pose(std::move(pose_));
}

::nds::core::types::LengthMeters HorizonRequest::getHorizonLength() const
{
    return m_horizonLength_;
}

void HorizonRequest::setHorizonLength(::nds::core::types::LengthMeters horizonLength_)
{
    m_horizonLength_ = horizonLength_;
}

void HorizonRequest::initPackingContext(HorizonRequest::ZserioPackingContext& context) const
{
    context.getHorizonLength().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(m_horizonLength_);
}

size_t HorizonRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_pose_.bitSizeOf(*this, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_horizonLength_);

    return endBitPosition - bitPosition;
}

size_t HorizonRequest::bitSizeOf(HorizonRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_pose_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += context.getHorizonLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(m_horizonLength_);

    return endBitPosition - bitPosition;
}

size_t HorizonRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_pose_.initializeOffsets(*this, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_horizonLength_);

    return endBitPosition;
}

size_t HorizonRequest::initializeOffsets(HorizonRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_pose_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += context.getHorizonLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(m_horizonLength_);

    return endBitPosition;
}

bool HorizonRequest::operator==(const HorizonRequest& other) const
{
    if (this != &other)
    {
        return
                (m_pose_ == other.m_pose_) &&
                (m_horizonLength_ == other.m_horizonLength_);
    }

    return true;
}

uint32_t HorizonRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_pose_);
    result = ::zserio::calcHashCode(result, m_horizonLength_);

    return result;
}

void HorizonRequest::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getPose().size() >= 1))
        throw ::zserio::ConstraintException("Write: Constraint violated at HorizonRequest.pose!");
    m_pose_.write(*this, out);

    out.writeVarUInt32(m_horizonLength_);
}

void HorizonRequest::write(HorizonRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getPose().size() >= 1))
        throw ::zserio::ConstraintException("Write: Constraint violated at HorizonRequest.pose!");
    m_pose_.writePacked(*this, out);

    context.getHorizonLength().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(out, m_horizonLength_);
}

void HorizonRequest::ZserioArrayExpressions_pose::initializeElement(HorizonRequest&,
        ::nds::core::vehicle::VehiclePose& element, size_t)
{
    element.initializeChildren();
}

void HorizonRequest::ZserioElementFactory_pose::create(HorizonRequest&        ,
        ::zserio::vector<::nds::core::vehicle::VehiclePose>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void HorizonRequest::ZserioElementFactory_pose::create(HorizonRequest&        ,
        ::zserio::vector<::nds::core::vehicle::VehiclePose>& array,
        ::nds::core::vehicle::VehiclePose::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

HorizonRequest::ZserioArrayType_pose HorizonRequest::readPose(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_pose readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() >= 1))
        throw ::zserio::ConstraintException("Read: Constraint violated at HorizonRequest.pose!");

    return readField;
}

HorizonRequest::ZserioArrayType_pose HorizonRequest::readPose(HorizonRequest::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_pose readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() >= 1))
        throw ::zserio::ConstraintException("Read: Constraint violated at HorizonRequest.pose!");

    return readField;
}
::nds::core::types::LengthMeters HorizonRequest::readHorizonLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LengthMeters>(in.readVarUInt32());
}

::nds::core::types::LengthMeters HorizonRequest::readHorizonLength(HorizonRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getHorizonLength().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(in);
}

} // namespace services
} // namespace vehicle
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/vehicle/services/VehicleHorizonService.h>

namespace nds
{
namespace vehicle
{
namespace services
{

namespace VehicleHorizonService
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getServiceModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getServiceNodeSystemReferenceMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getServiceNodeLegalInfoMethod(requestData, context);
    if (methodName == methodNames()[3])
        return getHorizonServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[4])
        return calculateHorizonMethod(requestData, context);
    throw ::zserio::ServiceException("nds.vehicle.services.VehicleHorizonService: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.vehicle.services.VehicleHorizonService");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 5>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 5> names =
    {
        ::zserio::makeStringView("getServiceModuleDefinition"),
        ::zserio::makeStringView("getServiceNodeSystemReference"),
        ::zserio::makeStringView("getServiceNodeLegalInfo"),
        ::zserio::makeStringView("getHorizonServiceCapabilities"),
        ::zserio::makeStringView("calculateHorizon")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getServiceModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeSystemReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsSystemToken&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeSystemReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeLegalInfoMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsNodeLegalInfo&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeLegalInfoImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHorizonServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::vehicle::metadata::HorizonServiceCapabilitiesResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHorizonServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::calculateHorizonMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::vehicle::services::HorizonRequest request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::vehicle::types::Horizon&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            calculateHorizonImpl(request, context), get_allocator_ref());
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getServiceModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::system::types::NdsSystemToken Client::getServiceNodeSystemReferenceMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeSystemReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsSystemToken(reader, get_allocator_ref());
}

::nds::system::types::NdsNodeLegalInfo Client::getServiceNodeLegalInfoMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeLegalInfo"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsNodeLegalInfo(reader, get_allocator_ref());
}

::nds::vehicle::metadata::HorizonServiceCapabilitiesResponse Client::getHorizonServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHorizonServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::vehicle::metadata::HorizonServiceCapabilitiesResponse(reader, get_allocator_ref());
}

::nds::vehicle::types::Horizon Client::calculateHorizonMethod(const ::nds::vehicle::services::HorizonRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("calculateHorizon"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::vehicle::types::Horizon(reader, get_allocator_ref());
}

} // namespace VehicleHorizonService

} // namespace services
} // namespace vehicle
} // namespace nds
