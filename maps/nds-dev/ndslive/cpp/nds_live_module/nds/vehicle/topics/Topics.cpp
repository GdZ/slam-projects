/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/vehicle/topics/PoseRawTopic.h>

namespace nds
{
namespace vehicle
{
namespace topics
{

PoseRawTopic::PoseRawTopic(const allocator_type& allocator) noexcept :
        m_stamp_(allocator),
        m_pose_(allocator)
{
}

PoseRawTopic::PoseRawTopic(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stamp_(readStamp(in, allocator)),
        m_pose_(readPose(in, allocator))
{
}

PoseRawTopic::PoseRawTopic(PoseRawTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stamp_(readStamp(context, in, allocator)),
        m_pose_(readPose(context, in, allocator))
{
}

PoseRawTopic::PoseRawTopic(::zserio::PropagateAllocatorT,
        const PoseRawTopic& other, const allocator_type& allocator) :
        m_stamp_(::zserio::allocatorPropagatingCopy(other.m_stamp_, allocator)),
        m_pose_(::zserio::allocatorPropagatingCopy(other.m_pose_, allocator))
{
}

::nds::core::types::TimeStamp& PoseRawTopic::getStamp()
{
    return m_stamp_;
}

const ::nds::core::types::TimeStamp& PoseRawTopic::getStamp() const
{
    return m_stamp_;
}

void PoseRawTopic::setStamp(const ::nds::core::types::TimeStamp& stamp_)
{
    m_stamp_ = stamp_;
}

void PoseRawTopic::setStamp(::nds::core::types::TimeStamp&& stamp_)
{
    m_stamp_ = ::std::move(stamp_);
}

::nds::core::vehicle::PoseRaw& PoseRawTopic::getPose()
{
    return m_pose_;
}

const ::nds::core::vehicle::PoseRaw& PoseRawTopic::getPose() const
{
    return m_pose_;
}

void PoseRawTopic::setPose(const ::nds::core::vehicle::PoseRaw& pose_)
{
    m_pose_ = pose_;
}

void PoseRawTopic::setPose(::nds::core::vehicle::PoseRaw&& pose_)
{
    m_pose_ = ::std::move(pose_);
}

void PoseRawTopic::initPackingContext(PoseRawTopic::ZserioPackingContext& context) const
{
    m_stamp_.initPackingContext(context.getStamp());
    m_pose_.initPackingContext(context.getPose());
}

size_t PoseRawTopic::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_stamp_.bitSizeOf(endBitPosition);
    endBitPosition += m_pose_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PoseRawTopic::bitSizeOf(PoseRawTopic::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_stamp_.bitSizeOf(context.getStamp(), endBitPosition);
    endBitPosition += m_pose_.bitSizeOf(context.getPose(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PoseRawTopic::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_stamp_.initializeOffsets(endBitPosition);
    endBitPosition = m_pose_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t PoseRawTopic::initializeOffsets(PoseRawTopic::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_stamp_.initializeOffsets(context.getStamp(), endBitPosition);
    endBitPosition = m_pose_.initializeOffsets(context.getPose(), endBitPosition);

    return endBitPosition;
}

bool PoseRawTopic::operator==(const PoseRawTopic& other) const
{
    if (this != &other)
    {
        return
                (m_stamp_ == other.m_stamp_) &&
                (m_pose_ == other.m_pose_);
    }

    return true;
}

uint32_t PoseRawTopic::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_stamp_);
    result = ::zserio::calcHashCode(result, m_pose_);

    return result;
}

void PoseRawTopic::write(::zserio::BitStreamWriter& out) const
{
    m_stamp_.write(out);
    m_pose_.write(out);
}

void PoseRawTopic::write(PoseRawTopic::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_stamp_.write(context.getStamp(), out);
    m_pose_.write(context.getPose(), out);
}

::nds::core::types::TimeStamp PoseRawTopic::readStamp(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(in, allocator);
}

::nds::core::types::TimeStamp PoseRawTopic::readStamp(PoseRawTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(context.getStamp(), in, allocator);
}
::nds::core::vehicle::PoseRaw PoseRawTopic::readPose(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::PoseRaw(in, allocator);
}

::nds::core::vehicle::PoseRaw PoseRawTopic::readPose(PoseRawTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::PoseRaw(context.getPose(), in, allocator);
}

} // namespace topics
} // namespace vehicle
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/vehicle/topics/PoseGeoMatchedTopic.h>

namespace nds
{
namespace vehicle
{
namespace topics
{

PoseGeoMatchedTopic::PoseGeoMatchedTopic(const allocator_type& allocator) noexcept :
        m_stamp_(allocator),
        m_poseMatchedCandidates_(allocator)
{
}

PoseGeoMatchedTopic::PoseGeoMatchedTopic(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stamp_(readStamp(in, allocator)),
        m_poseMatchedCandidates_(readPoseMatchedCandidates(in, allocator))
{
}

PoseGeoMatchedTopic::PoseGeoMatchedTopic(PoseGeoMatchedTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stamp_(readStamp(context, in, allocator)),
        m_poseMatchedCandidates_(readPoseMatchedCandidates(context, in, allocator))
{
}

PoseGeoMatchedTopic::PoseGeoMatchedTopic(::zserio::PropagateAllocatorT,
        const PoseGeoMatchedTopic& other, const allocator_type& allocator) :
        m_stamp_(::zserio::allocatorPropagatingCopy(other.m_stamp_, allocator)),
        m_poseMatchedCandidates_(::zserio::allocatorPropagatingCopy(other.m_poseMatchedCandidates_, allocator))
{
}

void PoseGeoMatchedTopic::initializeChildren()
{
    m_poseMatchedCandidates_.initializeElements(*this);
}

::nds::core::types::TimeStamp& PoseGeoMatchedTopic::getStamp()
{
    return m_stamp_;
}

const ::nds::core::types::TimeStamp& PoseGeoMatchedTopic::getStamp() const
{
    return m_stamp_;
}

void PoseGeoMatchedTopic::setStamp(const ::nds::core::types::TimeStamp& stamp_)
{
    m_stamp_ = stamp_;
}

void PoseGeoMatchedTopic::setStamp(::nds::core::types::TimeStamp&& stamp_)
{
    m_stamp_ = ::std::move(stamp_);
}

::zserio::vector<::nds::core::vehicle::PoseGeoMatched>& PoseGeoMatchedTopic::getPoseMatchedCandidates()
{
    return m_poseMatchedCandidates_.getRawArray();
}

const ::zserio::vector<::nds::core::vehicle::PoseGeoMatched>& PoseGeoMatchedTopic::getPoseMatchedCandidates() const
{
    return m_poseMatchedCandidates_.getRawArray();
}

void PoseGeoMatchedTopic::setPoseMatchedCandidates(const ::zserio::vector<::nds::core::vehicle::PoseGeoMatched>& poseMatchedCandidates_)
{
    m_poseMatchedCandidates_ = ZserioArrayType_poseMatchedCandidates(poseMatchedCandidates_);
}

void PoseGeoMatchedTopic::setPoseMatchedCandidates(::zserio::vector<::nds::core::vehicle::PoseGeoMatched>&& poseMatchedCandidates_)
{
    m_poseMatchedCandidates_ = ZserioArrayType_poseMatchedCandidates(std::move(poseMatchedCandidates_));
}

void PoseGeoMatchedTopic::initPackingContext(PoseGeoMatchedTopic::ZserioPackingContext& context) const
{
    m_stamp_.initPackingContext(context.getStamp());
}

size_t PoseGeoMatchedTopic::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_stamp_.bitSizeOf(endBitPosition);
    endBitPosition += m_poseMatchedCandidates_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PoseGeoMatchedTopic::bitSizeOf(PoseGeoMatchedTopic::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_stamp_.bitSizeOf(context.getStamp(), endBitPosition);
    endBitPosition += m_poseMatchedCandidates_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PoseGeoMatchedTopic::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_stamp_.initializeOffsets(endBitPosition);
    endBitPosition = m_poseMatchedCandidates_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t PoseGeoMatchedTopic::initializeOffsets(PoseGeoMatchedTopic::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_stamp_.initializeOffsets(context.getStamp(), endBitPosition);
    endBitPosition = m_poseMatchedCandidates_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool PoseGeoMatchedTopic::operator==(const PoseGeoMatchedTopic& other) const
{
    if (this != &other)
    {
        return
                (m_stamp_ == other.m_stamp_) &&
                (m_poseMatchedCandidates_ == other.m_poseMatchedCandidates_);
    }

    return true;
}

uint32_t PoseGeoMatchedTopic::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_stamp_);
    result = ::zserio::calcHashCode(result, m_poseMatchedCandidates_);

    return result;
}

void PoseGeoMatchedTopic::write(::zserio::BitStreamWriter& out) const
{
    m_stamp_.write(out);
    m_poseMatchedCandidates_.write(*this, out);
}

void PoseGeoMatchedTopic::write(PoseGeoMatchedTopic::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_stamp_.write(context.getStamp(), out);
    m_poseMatchedCandidates_.writePacked(*this, out);
}

void PoseGeoMatchedTopic::ZserioArrayExpressions_poseMatchedCandidates::initializeElement(PoseGeoMatchedTopic&,
        ::nds::core::vehicle::PoseGeoMatched& element, size_t)
{
    element.initializeChildren();
}

void PoseGeoMatchedTopic::ZserioElementFactory_poseMatchedCandidates::create(PoseGeoMatchedTopic&        ,
        ::zserio::vector<::nds::core::vehicle::PoseGeoMatched>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void PoseGeoMatchedTopic::ZserioElementFactory_poseMatchedCandidates::create(PoseGeoMatchedTopic&        ,
        ::zserio::vector<::nds::core::vehicle::PoseGeoMatched>& array,
        ::nds::core::vehicle::PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::types::TimeStamp PoseGeoMatchedTopic::readStamp(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(in, allocator);
}

::nds::core::types::TimeStamp PoseGeoMatchedTopic::readStamp(PoseGeoMatchedTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(context.getStamp(), in, allocator);
}
PoseGeoMatchedTopic::ZserioArrayType_poseMatchedCandidates PoseGeoMatchedTopic::readPoseMatchedCandidates(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_poseMatchedCandidates readField(allocator);
    readField.read(*this, in);

    return readField;
}

PoseGeoMatchedTopic::ZserioArrayType_poseMatchedCandidates PoseGeoMatchedTopic::readPoseMatchedCandidates(PoseGeoMatchedTopic::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_poseMatchedCandidates readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace topics
} // namespace vehicle
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/vehicle/topics/GeoRoadNetworkTopic.h>

namespace nds
{
namespace vehicle
{
namespace topics
{

GeoRoadNetworkTopic::GeoRoadNetworkTopic(const allocator_type& allocator) noexcept :
        m_stamp_(allocator),
        m_roadNetwork_(allocator)
{
}

GeoRoadNetworkTopic::GeoRoadNetworkTopic(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stamp_(readStamp(in, allocator)),
        m_roadNetwork_(readRoadNetwork(in, allocator))
{
}

GeoRoadNetworkTopic::GeoRoadNetworkTopic(GeoRoadNetworkTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stamp_(readStamp(context, in, allocator)),
        m_roadNetwork_(readRoadNetwork(context, in, allocator))
{
}

GeoRoadNetworkTopic::GeoRoadNetworkTopic(::zserio::PropagateAllocatorT,
        const GeoRoadNetworkTopic& other, const allocator_type& allocator) :
        m_stamp_(::zserio::allocatorPropagatingCopy(other.m_stamp_, allocator)),
        m_roadNetwork_(::zserio::allocatorPropagatingCopy(other.m_roadNetwork_, allocator))
{
}

void GeoRoadNetworkTopic::initializeChildren()
{
    m_roadNetwork_.initializeChildren();
}

::nds::core::types::TimeStamp& GeoRoadNetworkTopic::getStamp()
{
    return m_stamp_;
}

const ::nds::core::types::TimeStamp& GeoRoadNetworkTopic::getStamp() const
{
    return m_stamp_;
}

void GeoRoadNetworkTopic::setStamp(const ::nds::core::types::TimeStamp& stamp_)
{
    m_stamp_ = stamp_;
}

void GeoRoadNetworkTopic::setStamp(::nds::core::types::TimeStamp&& stamp_)
{
    m_stamp_ = ::std::move(stamp_);
}

::nds::vehicle::types::Horizon& GeoRoadNetworkTopic::getRoadNetwork()
{
    return m_roadNetwork_;
}

const ::nds::vehicle::types::Horizon& GeoRoadNetworkTopic::getRoadNetwork() const
{
    return m_roadNetwork_;
}

void GeoRoadNetworkTopic::setRoadNetwork(const ::nds::vehicle::types::Horizon& roadNetwork_)
{
    m_roadNetwork_ = roadNetwork_;
}

void GeoRoadNetworkTopic::setRoadNetwork(::nds::vehicle::types::Horizon&& roadNetwork_)
{
    m_roadNetwork_ = ::std::move(roadNetwork_);
}

void GeoRoadNetworkTopic::initPackingContext(GeoRoadNetworkTopic::ZserioPackingContext& context) const
{
    m_stamp_.initPackingContext(context.getStamp());
    m_roadNetwork_.initPackingContext(context.getRoadNetwork());
}

size_t GeoRoadNetworkTopic::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_stamp_.bitSizeOf(endBitPosition);
    endBitPosition += m_roadNetwork_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GeoRoadNetworkTopic::bitSizeOf(GeoRoadNetworkTopic::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_stamp_.bitSizeOf(context.getStamp(), endBitPosition);
    endBitPosition += m_roadNetwork_.bitSizeOf(context.getRoadNetwork(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GeoRoadNetworkTopic::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_stamp_.initializeOffsets(endBitPosition);
    endBitPosition = m_roadNetwork_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t GeoRoadNetworkTopic::initializeOffsets(GeoRoadNetworkTopic::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_stamp_.initializeOffsets(context.getStamp(), endBitPosition);
    endBitPosition = m_roadNetwork_.initializeOffsets(context.getRoadNetwork(), endBitPosition);

    return endBitPosition;
}

bool GeoRoadNetworkTopic::operator==(const GeoRoadNetworkTopic& other) const
{
    if (this != &other)
    {
        return
                (m_stamp_ == other.m_stamp_) &&
                (m_roadNetwork_ == other.m_roadNetwork_);
    }

    return true;
}

uint32_t GeoRoadNetworkTopic::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_stamp_);
    result = ::zserio::calcHashCode(result, m_roadNetwork_);

    return result;
}

void GeoRoadNetworkTopic::write(::zserio::BitStreamWriter& out) const
{
    m_stamp_.write(out);
    m_roadNetwork_.write(out);
}

void GeoRoadNetworkTopic::write(GeoRoadNetworkTopic::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_stamp_.write(context.getStamp(), out);
    m_roadNetwork_.write(context.getRoadNetwork(), out);
}

::nds::core::types::TimeStamp GeoRoadNetworkTopic::readStamp(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(in, allocator);
}

::nds::core::types::TimeStamp GeoRoadNetworkTopic::readStamp(GeoRoadNetworkTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(context.getStamp(), in, allocator);
}
::nds::vehicle::types::Horizon GeoRoadNetworkTopic::readRoadNetwork(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::vehicle::types::Horizon(in, allocator);
}

::nds::vehicle::types::Horizon GeoRoadNetworkTopic::readRoadNetwork(GeoRoadNetworkTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::vehicle::types::Horizon(context.getRoadNetwork(), in, allocator);
}

} // namespace topics
} // namespace vehicle
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/vehicle/topics/MatchedGeoRoadNetworkTopic.h>

namespace nds
{
namespace vehicle
{
namespace topics
{

MatchedGeoRoadNetworkTopic::MatchedGeoRoadNetworkTopic(const allocator_type& allocator) noexcept :
        m_stamp_(allocator),
        m_matchedRoadNetwork_(allocator),
        m_unmatchedPaths_(allocator)
{
}

MatchedGeoRoadNetworkTopic::MatchedGeoRoadNetworkTopic(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stamp_(readStamp(in, allocator)),
        m_matchedRoadNetwork_(readMatchedRoadNetwork(in, allocator)),
        m_unmatchedPaths_(readUnmatchedPaths(in, allocator))
{
}

MatchedGeoRoadNetworkTopic::MatchedGeoRoadNetworkTopic(MatchedGeoRoadNetworkTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stamp_(readStamp(context, in, allocator)),
        m_matchedRoadNetwork_(readMatchedRoadNetwork(context, in, allocator)),
        m_unmatchedPaths_(readUnmatchedPaths(context, in, allocator))
{
}

MatchedGeoRoadNetworkTopic::MatchedGeoRoadNetworkTopic(::zserio::PropagateAllocatorT,
        const MatchedGeoRoadNetworkTopic& other, const allocator_type& allocator) :
        m_stamp_(::zserio::allocatorPropagatingCopy(other.m_stamp_, allocator)),
        m_matchedRoadNetwork_(::zserio::allocatorPropagatingCopy(other.m_matchedRoadNetwork_, allocator)),
        m_unmatchedPaths_(::zserio::allocatorPropagatingCopy(other.m_unmatchedPaths_, allocator))
{
}

void MatchedGeoRoadNetworkTopic::initializeChildren()
{
    m_matchedRoadNetwork_.initializeChildren();
}

::nds::core::types::TimeStamp& MatchedGeoRoadNetworkTopic::getStamp()
{
    return m_stamp_;
}

const ::nds::core::types::TimeStamp& MatchedGeoRoadNetworkTopic::getStamp() const
{
    return m_stamp_;
}

void MatchedGeoRoadNetworkTopic::setStamp(const ::nds::core::types::TimeStamp& stamp_)
{
    m_stamp_ = stamp_;
}

void MatchedGeoRoadNetworkTopic::setStamp(::nds::core::types::TimeStamp&& stamp_)
{
    m_stamp_ = ::std::move(stamp_);
}

::nds::vehicle::types::Horizon& MatchedGeoRoadNetworkTopic::getMatchedRoadNetwork()
{
    return m_matchedRoadNetwork_;
}

const ::nds::vehicle::types::Horizon& MatchedGeoRoadNetworkTopic::getMatchedRoadNetwork() const
{
    return m_matchedRoadNetwork_;
}

void MatchedGeoRoadNetworkTopic::setMatchedRoadNetwork(const ::nds::vehicle::types::Horizon& matchedRoadNetwork_)
{
    m_matchedRoadNetwork_ = matchedRoadNetwork_;
}

void MatchedGeoRoadNetworkTopic::setMatchedRoadNetwork(::nds::vehicle::types::Horizon&& matchedRoadNetwork_)
{
    m_matchedRoadNetwork_ = ::std::move(matchedRoadNetwork_);
}

::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>& MatchedGeoRoadNetworkTopic::getUnmatchedPaths()
{
    return m_unmatchedPaths_.getRawArray();
}

const ::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>& MatchedGeoRoadNetworkTopic::getUnmatchedPaths() const
{
    return m_unmatchedPaths_.getRawArray();
}

void MatchedGeoRoadNetworkTopic::setUnmatchedPaths(const ::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>& unmatchedPaths_)
{
    m_unmatchedPaths_ = ZserioArrayType_unmatchedPaths(unmatchedPaths_);
}

void MatchedGeoRoadNetworkTopic::setUnmatchedPaths(::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>&& unmatchedPaths_)
{
    m_unmatchedPaths_ = ZserioArrayType_unmatchedPaths(std::move(unmatchedPaths_));
}

void MatchedGeoRoadNetworkTopic::initPackingContext(MatchedGeoRoadNetworkTopic::ZserioPackingContext& context) const
{
    m_stamp_.initPackingContext(context.getStamp());
    m_matchedRoadNetwork_.initPackingContext(context.getMatchedRoadNetwork());
}

size_t MatchedGeoRoadNetworkTopic::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_stamp_.bitSizeOf(endBitPosition);
    endBitPosition += m_matchedRoadNetwork_.bitSizeOf(endBitPosition);
    endBitPosition += m_unmatchedPaths_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MatchedGeoRoadNetworkTopic::bitSizeOf(MatchedGeoRoadNetworkTopic::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_stamp_.bitSizeOf(context.getStamp(), endBitPosition);
    endBitPosition += m_matchedRoadNetwork_.bitSizeOf(context.getMatchedRoadNetwork(), endBitPosition);
    endBitPosition += m_unmatchedPaths_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MatchedGeoRoadNetworkTopic::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_stamp_.initializeOffsets(endBitPosition);
    endBitPosition = m_matchedRoadNetwork_.initializeOffsets(endBitPosition);
    endBitPosition = m_unmatchedPaths_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t MatchedGeoRoadNetworkTopic::initializeOffsets(MatchedGeoRoadNetworkTopic::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_stamp_.initializeOffsets(context.getStamp(), endBitPosition);
    endBitPosition = m_matchedRoadNetwork_.initializeOffsets(context.getMatchedRoadNetwork(), endBitPosition);
    endBitPosition = m_unmatchedPaths_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool MatchedGeoRoadNetworkTopic::operator==(const MatchedGeoRoadNetworkTopic& other) const
{
    if (this != &other)
    {
        return
                (m_stamp_ == other.m_stamp_) &&
                (m_matchedRoadNetwork_ == other.m_matchedRoadNetwork_) &&
                (m_unmatchedPaths_ == other.m_unmatchedPaths_);
    }

    return true;
}

uint32_t MatchedGeoRoadNetworkTopic::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_stamp_);
    result = ::zserio::calcHashCode(result, m_matchedRoadNetwork_);
    result = ::zserio::calcHashCode(result, m_unmatchedPaths_);

    return result;
}

void MatchedGeoRoadNetworkTopic::write(::zserio::BitStreamWriter& out) const
{
    m_stamp_.write(out);
    m_matchedRoadNetwork_.write(out);
    m_unmatchedPaths_.write(out);
}

void MatchedGeoRoadNetworkTopic::write(MatchedGeoRoadNetworkTopic::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_stamp_.write(context.getStamp(), out);
    m_matchedRoadNetwork_.write(context.getMatchedRoadNetwork(), out);
    m_unmatchedPaths_.writePacked(out);
}

::nds::core::types::TimeStamp MatchedGeoRoadNetworkTopic::readStamp(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(in, allocator);
}

::nds::core::types::TimeStamp MatchedGeoRoadNetworkTopic::readStamp(MatchedGeoRoadNetworkTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(context.getStamp(), in, allocator);
}
::nds::vehicle::types::Horizon MatchedGeoRoadNetworkTopic::readMatchedRoadNetwork(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::vehicle::types::Horizon(in, allocator);
}

::nds::vehicle::types::Horizon MatchedGeoRoadNetworkTopic::readMatchedRoadNetwork(MatchedGeoRoadNetworkTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::vehicle::types::Horizon(context.getMatchedRoadNetwork(), in, allocator);
}
MatchedGeoRoadNetworkTopic::ZserioArrayType_unmatchedPaths MatchedGeoRoadNetworkTopic::readUnmatchedPaths(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_unmatchedPaths readField(allocator);
    readField.read(in);

    return readField;
}

MatchedGeoRoadNetworkTopic::ZserioArrayType_unmatchedPaths MatchedGeoRoadNetworkTopic::readUnmatchedPaths(MatchedGeoRoadNetworkTopic::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_unmatchedPaths readField(allocator);
    readField.readPacked(in);

    return readField;
}

} // namespace topics
} // namespace vehicle
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/vehicle/topics/MppTopic.h>

namespace nds
{
namespace vehicle
{
namespace topics
{

MppTopic::MppTopic(const allocator_type& allocator) noexcept :
        m_time_(allocator),
        m_mpp_(allocator)
{
}

MppTopic::MppTopic(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_time_(readTime(in, allocator)),
        m_mpp_(readMpp(in, allocator))
{
}

MppTopic::MppTopic(MppTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_time_(readTime(context, in, allocator)),
        m_mpp_(readMpp(context, in, allocator))
{
}

MppTopic::MppTopic(::zserio::PropagateAllocatorT,
        const MppTopic& other, const allocator_type& allocator) :
        m_time_(::zserio::allocatorPropagatingCopy(other.m_time_, allocator)),
        m_mpp_(::zserio::allocatorPropagatingCopy(other.m_mpp_, allocator))
{
}

::nds::core::types::TimeStamp& MppTopic::getTime()
{
    return m_time_;
}

const ::nds::core::types::TimeStamp& MppTopic::getTime() const
{
    return m_time_;
}

void MppTopic::setTime(const ::nds::core::types::TimeStamp& time_)
{
    m_time_ = time_;
}

void MppTopic::setTime(::nds::core::types::TimeStamp&& time_)
{
    m_time_ = ::std::move(time_);
}

::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>& MppTopic::getMpp()
{
    return m_mpp_.getRawArray();
}

const ::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>& MppTopic::getMpp() const
{
    return m_mpp_.getRawArray();
}

void MppTopic::setMpp(const ::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>& mpp_)
{
    m_mpp_ = ZserioArrayType_mpp(mpp_);
}

void MppTopic::setMpp(::zserio::vector<::nds::vehicle::reference::types::HorizonPathId>&& mpp_)
{
    m_mpp_ = ZserioArrayType_mpp(std::move(mpp_));
}

void MppTopic::initPackingContext(MppTopic::ZserioPackingContext& context) const
{
    m_time_.initPackingContext(context.getTime());
}

size_t MppTopic::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_time_.bitSizeOf(endBitPosition);
    endBitPosition += m_mpp_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MppTopic::bitSizeOf(MppTopic::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_time_.bitSizeOf(context.getTime(), endBitPosition);
    endBitPosition += m_mpp_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MppTopic::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_time_.initializeOffsets(endBitPosition);
    endBitPosition = m_mpp_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t MppTopic::initializeOffsets(MppTopic::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_time_.initializeOffsets(context.getTime(), endBitPosition);
    endBitPosition = m_mpp_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool MppTopic::operator==(const MppTopic& other) const
{
    if (this != &other)
    {
        return
                (m_time_ == other.m_time_) &&
                (m_mpp_ == other.m_mpp_);
    }

    return true;
}

uint32_t MppTopic::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_time_);
    result = ::zserio::calcHashCode(result, m_mpp_);

    return result;
}

void MppTopic::write(::zserio::BitStreamWriter& out) const
{
    m_time_.write(out);
    m_mpp_.write(out);
}

void MppTopic::write(MppTopic::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_time_.write(context.getTime(), out);
    m_mpp_.writePacked(out);
}

::nds::core::types::TimeStamp MppTopic::readTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(in, allocator);
}

::nds::core::types::TimeStamp MppTopic::readTime(MppTopic::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(context.getTime(), in, allocator);
}
MppTopic::ZserioArrayType_mpp MppTopic::readMpp(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_mpp readField(allocator);
    readField.read(in);

    return readField;
}

MppTopic::ZserioArrayType_mpp MppTopic::readMpp(MppTopic::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_mpp readField(allocator);
    readField.readPacked(in);

    return readField;
}

} // namespace topics
} // namespace vehicle
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/StringView.h>

#include <nds/vehicle/topics/VehicleTopicCollection.h>

namespace nds
{
namespace vehicle
{
namespace topics
{

namespace
{

template <typename ZSERIO_MESSAGE>
class VehicleTopicCollectionOnRaw : public ::zserio::IPubsub::OnTopicCallback
{
public:
    explicit VehicleTopicCollectionOnRaw(const ::std::shared_ptr<VehicleTopicCollection::VehicleTopicCollectionCallback<ZSERIO_MESSAGE>>& callback,
            const ::std::allocator<uint8_t>& allocator) :
            m_callback(callback), m_allocator(allocator)
    {}

    void operator()(::zserio::StringView topic, ::zserio::Span<const uint8_t> data) override
    {
        ::zserio::BitStreamReader reader(data.data(), data.size());
        const ZSERIO_MESSAGE message(reader, m_allocator);

        m_callback->operator()(topic, message);
    }

private:
    ::std::shared_ptr<VehicleTopicCollection::VehicleTopicCollectionCallback<ZSERIO_MESSAGE>> m_callback;
    ::std::allocator<uint8_t> m_allocator;
};

} // namespace

VehicleTopicCollection::VehicleTopicCollection(::zserio::IPubsub& pubsub, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_pubsub(pubsub)
{
}

void VehicleTopicCollection::publishPoseRaw(const ::nds::vehicle::topics::PoseRawTopic& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/vehicle/+/pose/raw"), context);
}

::zserio::IPubsub::SubscriptionId VehicleTopicCollection::subscribePoseRaw(
        const ::std::shared_ptr<VehicleTopicCollectionCallback<::nds::vehicle::topics::PoseRawTopic>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<VehicleTopicCollectionOnRaw<::nds::vehicle::topics::PoseRawTopic>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/vehicle/+/pose/raw"), onRawCallback, context);
}

void VehicleTopicCollection::publishPoseGeoMatched(const ::nds::vehicle::topics::PoseGeoMatchedTopic& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/vehicle/+/pose/geomatched"), context);
}

::zserio::IPubsub::SubscriptionId VehicleTopicCollection::subscribePoseGeoMatched(
        const ::std::shared_ptr<VehicleTopicCollectionCallback<::nds::vehicle::topics::PoseGeoMatchedTopic>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<VehicleTopicCollectionOnRaw<::nds::vehicle::topics::PoseGeoMatchedTopic>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/vehicle/+/pose/geomatched"), onRawCallback, context);
}

void VehicleTopicCollection::publishGeoRoadNetwork(const ::nds::vehicle::topics::GeoRoadNetworkTopic& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/vehicle/+/path/network"), context);
}

::zserio::IPubsub::SubscriptionId VehicleTopicCollection::subscribeGeoRoadNetwork(
        const ::std::shared_ptr<VehicleTopicCollectionCallback<::nds::vehicle::topics::GeoRoadNetworkTopic>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<VehicleTopicCollectionOnRaw<::nds::vehicle::topics::GeoRoadNetworkTopic>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/vehicle/+/path/network"), onRawCallback, context);
}

void VehicleTopicCollection::publishMpp(const ::nds::vehicle::topics::MppTopic& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/vehicle/+/path/mpp"), context);
}

::zserio::IPubsub::SubscriptionId VehicleTopicCollection::subscribeMpp(
        const ::std::shared_ptr<VehicleTopicCollectionCallback<::nds::vehicle::topics::MppTopic>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<VehicleTopicCollectionOnRaw<::nds::vehicle::topics::MppTopic>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/vehicle/+/path/mpp"), onRawCallback, context);
}

void VehicleTopicCollection::publishMatchedGeoRoadNetwork(const ::nds::vehicle::topics::MatchedGeoRoadNetworkTopic& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/vehicle/+/path/network/matched"), context);
}

::zserio::IPubsub::SubscriptionId VehicleTopicCollection::subscribeMatchedGeoRoadNetwork(
        const ::std::shared_ptr<VehicleTopicCollectionCallback<::nds::vehicle::topics::MatchedGeoRoadNetworkTopic>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<VehicleTopicCollectionOnRaw<::nds::vehicle::topics::MatchedGeoRoadNetworkTopic>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/vehicle/+/path/network/matched"), onRawCallback, context);
}

void VehicleTopicCollection::unsubscribe(::zserio::IPubsub::SubscriptionId id)
{
    m_pubsub.unsubscribe(id);
}

template <typename ZSERIO_MESSAGE>
void VehicleTopicCollection::publish(ZSERIO_MESSAGE& message, ::zserio::StringView topic, void* context)
{
    ::zserio::BitBuffer bitBuffer(message.bitSizeOf(), get_allocator_ref());
    ::zserio::BitStreamWriter writer(bitBuffer);
    message.write(writer);
    m_pubsub.publish(topic, bitBuffer.getBytes(), context);
}

} // namespace topics
} // namespace vehicle
} // namespace nds
