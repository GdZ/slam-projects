/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/venue/parking/ParkingRangeRelationType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ParkingRangeRelationType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::venue::parking::ParkingRangeRelationType>::names;
constexpr ::std::array<::nds::venue::parking::ParkingRangeRelationType, 2> EnumTraits<::nds::venue::parking::ParkingRangeRelationType>::values;
constexpr const char* EnumTraits<::nds::venue::parking::ParkingRangeRelationType>::enumName;

template <>
size_t enumToOrdinal(::nds::venue::parking::ParkingRangeRelationType value)
{
    switch (value)
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        return 0;
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingRangeRelationType: ") <<
                static_cast<typename ::std::underlying_type<::nds::venue::parking::ParkingRangeRelationType>::type>(value) << "!";
    }
}

template <>
::nds::venue::parking::ParkingRangeRelationType valueToEnum(
        typename ::std::underlying_type<::nds::venue::parking::ParkingRangeRelationType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::venue::parking::ParkingRangeRelationType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingRangeRelationType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::venue::parking::ParkingRangeRelationType>(::nds::venue::parking::ParkingRangeRelationType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::venue::parking::ParkingRangeRelationType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingRangeRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::venue::parking::ParkingRangeRelationType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::venue::parking::ParkingRangeRelationType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingRangeRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::venue::parking::ParkingRangeRelationType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::venue::parking::ParkingRangeRelationType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::venue::parking::ParkingRangeRelationType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::parking::ParkingRangeRelationType>(
            static_cast<typename ::std::underlying_type<::nds::venue::parking::ParkingRangeRelationType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::venue::parking::ParkingRangeRelationType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::parking::ParkingRangeRelationType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingRangeRelationType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::venue::parking::ParkingRangeRelationType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::venue::parking::ParkingRangeRelationType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingRangeRelationType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/venue/parking/ParkingPositionRelationType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ParkingPositionRelationType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::venue::parking::ParkingPositionRelationType>::names;
constexpr ::std::array<::nds::venue::parking::ParkingPositionRelationType, 5> EnumTraits<::nds::venue::parking::ParkingPositionRelationType>::values;
constexpr const char* EnumTraits<::nds::venue::parking::ParkingPositionRelationType>::enumName;

template <>
size_t enumToOrdinal(::nds::venue::parking::ParkingPositionRelationType value)
{
    switch (value)
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        return 0;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        return 1;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        return 2;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        return 3;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingPositionRelationType: ") <<
                static_cast<typename ::std::underlying_type<::nds::venue::parking::ParkingPositionRelationType>::type>(value) << "!";
    }
}

template <>
::nds::venue::parking::ParkingPositionRelationType valueToEnum(
        typename ::std::underlying_type<::nds::venue::parking::ParkingPositionRelationType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::venue::parking::ParkingPositionRelationType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingPositionRelationType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::venue::parking::ParkingPositionRelationType>(::nds::venue::parking::ParkingPositionRelationType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::venue::parking::ParkingPositionRelationType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingPositionRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::venue::parking::ParkingPositionRelationType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::venue::parking::ParkingPositionRelationType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingPositionRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::venue::parking::ParkingPositionRelationType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::venue::parking::ParkingPositionRelationType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::venue::parking::ParkingPositionRelationType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::parking::ParkingPositionRelationType>(
            static_cast<typename ::std::underlying_type<::nds::venue::parking::ParkingPositionRelationType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::venue::parking::ParkingPositionRelationType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::parking::ParkingPositionRelationType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingPositionRelationType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::venue::parking::ParkingPositionRelationType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::venue::parking::ParkingPositionRelationType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingPositionRelationType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/venue/parking/ParkingRelationType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ParkingRelationType enumeration.
constexpr ::std::array<const char*, 6> EnumTraits<::nds::venue::parking::ParkingRelationType>::names;
constexpr ::std::array<::nds::venue::parking::ParkingRelationType, 6> EnumTraits<::nds::venue::parking::ParkingRelationType>::values;
constexpr const char* EnumTraits<::nds::venue::parking::ParkingRelationType>::enumName;

template <>
size_t enumToOrdinal(::nds::venue::parking::ParkingRelationType value)
{
    switch (value)
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        return 0;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        return 1;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        return 2;
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        return 3;
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        return 4;
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        return 5;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingRelationType: ") <<
                static_cast<typename ::std::underlying_type<::nds::venue::parking::ParkingRelationType>::type>(value) << "!";
    }
}

template <>
::nds::venue::parking::ParkingRelationType valueToEnum(
        typename ::std::underlying_type<::nds::venue::parking::ParkingRelationType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
        return static_cast<::nds::venue::parking::ParkingRelationType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingRelationType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::venue::parking::ParkingRelationType>(::nds::venue::parking::ParkingRelationType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::venue::parking::ParkingRelationType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::venue::parking::ParkingRelationType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::venue::parking::ParkingRelationType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::venue::parking::ParkingRelationType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::venue::parking::ParkingRelationType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::venue::parking::ParkingRelationType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::parking::ParkingRelationType>(
            static_cast<typename ::std::underlying_type<::nds::venue::parking::ParkingRelationType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::venue::parking::ParkingRelationType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::parking::ParkingRelationType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingRelationType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::venue::parking::ParkingRelationType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::venue::parking::ParkingRelationType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::venue::parking::ParkingRelationType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/venue/parking/RoadNetworkAccessType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadNetworkAccessType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::venue::parking::RoadNetworkAccessType>::names;
constexpr ::std::array<::nds::venue::parking::RoadNetworkAccessType, 3> EnumTraits<::nds::venue::parking::RoadNetworkAccessType>::values;
constexpr const char* EnumTraits<::nds::venue::parking::RoadNetworkAccessType>::enumName;

template <>
size_t enumToOrdinal(::nds::venue::parking::RoadNetworkAccessType value)
{
    switch (value)
    {
    case ::nds::venue::parking::RoadNetworkAccessType::ENTRY:
        return 0;
    case ::nds::venue::parking::RoadNetworkAccessType::EXIT:
        return 1;
    case ::nds::venue::parking::RoadNetworkAccessType::ENTRY_AND_EXIT:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadNetworkAccessType: ") <<
                static_cast<typename ::std::underlying_type<::nds::venue::parking::RoadNetworkAccessType>::type>(value) << "!";
    }
}

template <>
::nds::venue::parking::RoadNetworkAccessType valueToEnum(
        typename ::std::underlying_type<::nds::venue::parking::RoadNetworkAccessType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::venue::parking::RoadNetworkAccessType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadNetworkAccessType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::venue::parking::RoadNetworkAccessType>(::nds::venue::parking::RoadNetworkAccessType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::venue::parking::RoadNetworkAccessType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::venue::parking::RoadNetworkAccessType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::venue::parking::RoadNetworkAccessType)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::venue::parking::RoadNetworkAccessType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::venue::parking::RoadNetworkAccessType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::venue::parking::RoadNetworkAccessType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::venue::parking::RoadNetworkAccessType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::venue::parking::RoadNetworkAccessType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::parking::RoadNetworkAccessType>(
            static_cast<typename ::std::underlying_type<::nds::venue::parking::RoadNetworkAccessType>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::venue::parking::RoadNetworkAccessType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::parking::RoadNetworkAccessType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::venue::parking::RoadNetworkAccessType>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::venue::parking::RoadNetworkAccessType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::venue::parking::RoadNetworkAccessType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::venue::parking::RoadNetworkAccessType>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingFacility.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingFacility::ParkingFacility(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_levels_(allocator)
{
}

ParkingFacility::ParkingFacility(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_levels_(readLevels(in, allocator))
{
}

ParkingFacility::ParkingFacility(ParkingFacility::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_levels_(readLevels(context, in, allocator))
{
}

ParkingFacility::ParkingFacility(::zserio::PropagateAllocatorT,
        const ParkingFacility& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_levels_(::zserio::allocatorPropagatingCopy(other.m_levels_, allocator))
{
}

void ParkingFacility::initializeChildren()
{
    m_levels_.initializeElements(*this);
}

::nds::venue::reference::types::ParkingFacilityId& ParkingFacility::getId()
{
    return m_id_;
}

const ::nds::venue::reference::types::ParkingFacilityId& ParkingFacility::getId() const
{
    return m_id_;
}

void ParkingFacility::setId(const ::nds::venue::reference::types::ParkingFacilityId& id_)
{
    m_id_ = id_;
}

void ParkingFacility::setId(::nds::venue::reference::types::ParkingFacilityId&& id_)
{
    m_id_ = ::std::move(id_);
}

::zserio::vector<::nds::venue::parking::ParkingLevel>& ParkingFacility::getLevels()
{
    return m_levels_.getRawArray();
}

const ::zserio::vector<::nds::venue::parking::ParkingLevel>& ParkingFacility::getLevels() const
{
    return m_levels_.getRawArray();
}

void ParkingFacility::setLevels(const ::zserio::vector<::nds::venue::parking::ParkingLevel>& levels_)
{
    m_levels_ = ZserioArrayType_levels(levels_);
}

void ParkingFacility::setLevels(::zserio::vector<::nds::venue::parking::ParkingLevel>&& levels_)
{
    m_levels_ = ZserioArrayType_levels(std::move(levels_));
}

void ParkingFacility::initPackingContext(ParkingFacility::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
}

size_t ParkingFacility::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += m_levels_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacility::bitSizeOf(ParkingFacility::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += m_levels_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacility::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition = m_levels_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingFacility::initializeOffsets(ParkingFacility::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition = m_levels_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingFacility::operator==(const ParkingFacility& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_levels_ == other.m_levels_);
    }

    return true;
}

uint32_t ParkingFacility::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_levels_);

    return result;
}

void ParkingFacility::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);
    m_levels_.write(*this, out);
}

void ParkingFacility::write(ParkingFacility::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);
    m_levels_.writePacked(*this, out);
}

void ParkingFacility::ZserioArrayExpressions_levels::initializeElement(ParkingFacility&,
        ::nds::venue::parking::ParkingLevel& element, size_t)
{
    element.initializeChildren();
}

void ParkingFacility::ZserioElementFactory_levels::create(ParkingFacility&        ,
        ::zserio::vector<::nds::venue::parking::ParkingLevel>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingFacility::ZserioElementFactory_levels::create(ParkingFacility&        ,
        ::zserio::vector<::nds::venue::parking::ParkingLevel>& array,
        ::nds::venue::parking::ParkingLevel::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::venue::reference::types::ParkingFacilityId ParkingFacility::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingFacilityId(in, allocator);
}

::nds::venue::reference::types::ParkingFacilityId ParkingFacility::readId(ParkingFacility::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingFacilityId(context.getId(), in, allocator);
}
ParkingFacility::ZserioArrayType_levels ParkingFacility::readLevels(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_levels readField(allocator);
    readField.read(*this, in);

    return readField;
}

ParkingFacility::ZserioArrayType_levels ParkingFacility::readLevels(ParkingFacility::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_levels readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingLevel.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingLevel::ParkingLevel(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_sections_(allocator),
        m_connectedLevels_(::zserio::NullOpt)
{
}

ParkingLevel::ParkingLevel(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_sections_(readSections(in, allocator)),
        m_connectedLevels_(readConnectedLevels(in, allocator))
{
}

ParkingLevel::ParkingLevel(ParkingLevel::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_sections_(readSections(context, in, allocator)),
        m_connectedLevels_(readConnectedLevels(context, in, allocator))
{
}

ParkingLevel::ParkingLevel(::zserio::PropagateAllocatorT,
        const ParkingLevel& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_sections_(::zserio::allocatorPropagatingCopy(other.m_sections_, allocator)),
        m_connectedLevels_(::zserio::allocatorPropagatingCopy(other.m_connectedLevels_, allocator))
{
}

void ParkingLevel::initializeChildren()
{
    m_sections_.initializeElements(*this);
    if (isConnectedLevelsSet())
        m_connectedLevels_.value().initializeElements(*this);
}

::nds::venue::reference::types::ParkingLevelId& ParkingLevel::getId()
{
    return m_id_;
}

const ::nds::venue::reference::types::ParkingLevelId& ParkingLevel::getId() const
{
    return m_id_;
}

void ParkingLevel::setId(const ::nds::venue::reference::types::ParkingLevelId& id_)
{
    m_id_ = id_;
}

void ParkingLevel::setId(::nds::venue::reference::types::ParkingLevelId&& id_)
{
    m_id_ = ::std::move(id_);
}

::zserio::vector<::nds::venue::parking::ParkingSection>& ParkingLevel::getSections()
{
    return m_sections_.getRawArray();
}

const ::zserio::vector<::nds::venue::parking::ParkingSection>& ParkingLevel::getSections() const
{
    return m_sections_.getRawArray();
}

void ParkingLevel::setSections(const ::zserio::vector<::nds::venue::parking::ParkingSection>& sections_)
{
    m_sections_ = ZserioArrayType_sections(sections_);
}

void ParkingLevel::setSections(::zserio::vector<::nds::venue::parking::ParkingSection>&& sections_)
{
    m_sections_ = ZserioArrayType_sections(std::move(sections_));
}

::zserio::vector<::nds::venue::parking::ParkingLevelConnector>& ParkingLevel::getConnectedLevels()
{
    return m_connectedLevels_.value().getRawArray();
}

const ::zserio::vector<::nds::venue::parking::ParkingLevelConnector>& ParkingLevel::getConnectedLevels() const
{
    return m_connectedLevels_.value().getRawArray();
}

void ParkingLevel::setConnectedLevels(const ::zserio::vector<::nds::venue::parking::ParkingLevelConnector>& connectedLevels_)
{
    m_connectedLevels_ = ZserioArrayType_connectedLevels(connectedLevels_);
}

void ParkingLevel::setConnectedLevels(::zserio::vector<::nds::venue::parking::ParkingLevelConnector>&& connectedLevels_)
{
    m_connectedLevels_ = ZserioArrayType_connectedLevels(std::move(connectedLevels_));
}

bool ParkingLevel::isConnectedLevelsUsed() const
{
    return (isConnectedLevelsSet());
}

bool ParkingLevel::isConnectedLevelsSet() const
{
    return m_connectedLevels_.hasValue();
}

void ParkingLevel::resetConnectedLevels()
{
    m_connectedLevels_.reset();
}

void ParkingLevel::initPackingContext(ParkingLevel::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
}

size_t ParkingLevel::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += m_sections_.bitSizeOf(*this, endBitPosition);
    endBitPosition += 1;
    if (isConnectedLevelsSet())
    {
        endBitPosition += m_connectedLevels_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingLevel::bitSizeOf(ParkingLevel::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += m_sections_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isConnectedLevelsSet())
    {
        endBitPosition += m_connectedLevels_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingLevel::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition = m_sections_.initializeOffsets(*this, endBitPosition);
    endBitPosition += 1;
    if (isConnectedLevelsSet())
    {
        endBitPosition = m_connectedLevels_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t ParkingLevel::initializeOffsets(ParkingLevel::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition = m_sections_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isConnectedLevelsSet())
    {
        endBitPosition = m_connectedLevels_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool ParkingLevel::operator==(const ParkingLevel& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_sections_ == other.m_sections_) &&
                (!isConnectedLevelsUsed() ? !other.isConnectedLevelsUsed() : (m_connectedLevels_ == other.m_connectedLevels_));
    }

    return true;
}

uint32_t ParkingLevel::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_sections_);
    if (isConnectedLevelsUsed())
        result = ::zserio::calcHashCode(result, m_connectedLevels_);

    return result;
}

void ParkingLevel::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);
    m_sections_.write(*this, out);
    if (isConnectedLevelsSet())
    {
        out.writeBool(true);
        m_connectedLevels_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingLevel::write(ParkingLevel::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);
    m_sections_.writePacked(*this, out);
    if (isConnectedLevelsSet())
    {
        out.writeBool(true);
        m_connectedLevels_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingLevel::ZserioArrayExpressions_sections::initializeElement(ParkingLevel&,
        ::nds::venue::parking::ParkingSection& element, size_t)
{
    element.initializeChildren();
}

void ParkingLevel::ZserioElementFactory_sections::create(ParkingLevel&        ,
        ::zserio::vector<::nds::venue::parking::ParkingSection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingLevel::ZserioElementFactory_sections::create(ParkingLevel&        ,
        ::zserio::vector<::nds::venue::parking::ParkingSection>& array,
        ::nds::venue::parking::ParkingSection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingLevel::ZserioArrayExpressions_connectedLevels::initializeElement(ParkingLevel&,
        ::nds::venue::parking::ParkingLevelConnector& element, size_t)
{
    element.initializeChildren();
}

void ParkingLevel::ZserioElementFactory_connectedLevels::create(ParkingLevel&        ,
        ::zserio::vector<::nds::venue::parking::ParkingLevelConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingLevel::ZserioElementFactory_connectedLevels::create(ParkingLevel&        ,
        ::zserio::vector<::nds::venue::parking::ParkingLevelConnector>& array,
        ::nds::venue::parking::ParkingLevelConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::venue::reference::types::ParkingLevelId ParkingLevel::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingLevelId(in, allocator);
}

::nds::venue::reference::types::ParkingLevelId ParkingLevel::readId(ParkingLevel::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingLevelId(context.getId(), in, allocator);
}
ParkingLevel::ZserioArrayType_sections ParkingLevel::readSections(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sections readField(allocator);
    readField.read(*this, in);

    return readField;
}

ParkingLevel::ZserioArrayType_sections ParkingLevel::readSections(ParkingLevel::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sections readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::zserio::InplaceOptionalHolder<ParkingLevel::ZserioArrayType_connectedLevels> ParkingLevel::readConnectedLevels(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_connectedLevels readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_connectedLevels>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_connectedLevels>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<ParkingLevel::ZserioArrayType_connectedLevels> ParkingLevel::readConnectedLevels(ParkingLevel::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_connectedLevels readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_connectedLevels>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_connectedLevels>(::zserio::NullOpt);
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingLevelConnector.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingLevelConnector::ParkingLevelConnector(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_levelId_(allocator),
        m_transitionPolygon_(::zserio::NullOpt)
{
}

ParkingLevelConnector::ParkingLevelConnector(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_levelId_(readLevelId(in, allocator)),
        m_transitionPolygon_(readTransitionPolygon(in, allocator))
{
}

ParkingLevelConnector::ParkingLevelConnector(ParkingLevelConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_levelId_(readLevelId(context, in, allocator)),
        m_transitionPolygon_(readTransitionPolygon(context, in, allocator))
{
}

ParkingLevelConnector::ParkingLevelConnector(const ParkingLevelConnector& other) :
        m_levelId_(other.m_levelId_),
        m_transitionPolygon_(other.m_transitionPolygon_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingLevelConnector& ParkingLevelConnector::operator=(const ParkingLevelConnector& other)
{
    m_levelId_ = other.m_levelId_;
    m_transitionPolygon_ = other.m_transitionPolygon_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingLevelConnector::ParkingLevelConnector(ParkingLevelConnector&& other) :
        m_levelId_(::std::move(other.m_levelId_)),
        m_transitionPolygon_(::std::move(other.m_transitionPolygon_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingLevelConnector& ParkingLevelConnector::operator=(ParkingLevelConnector&& other)
{
    m_levelId_ = ::std::move(other.m_levelId_);
    m_transitionPolygon_ = ::std::move(other.m_transitionPolygon_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingLevelConnector::ParkingLevelConnector(::zserio::PropagateAllocatorT,
        const ParkingLevelConnector& other, const allocator_type& allocator) :
        m_levelId_(::zserio::allocatorPropagatingCopy(other.m_levelId_, allocator)),
        m_transitionPolygon_(::zserio::allocatorPropagatingCopy(other.m_transitionPolygon_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ParkingLevelConnector::initializeChildren()
{
    if (isTransitionPolygonSet())
        m_transitionPolygon_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::venue::reference::types::ParkingLevelId& ParkingLevelConnector::getLevelId()
{
    return m_levelId_;
}

const ::nds::venue::reference::types::ParkingLevelId& ParkingLevelConnector::getLevelId() const
{
    return m_levelId_;
}

void ParkingLevelConnector::setLevelId(const ::nds::venue::reference::types::ParkingLevelId& levelId_)
{
    m_levelId_ = levelId_;
}

void ParkingLevelConnector::setLevelId(::nds::venue::reference::types::ParkingLevelId&& levelId_)
{
    m_levelId_ = ::std::move(levelId_);
}

::nds::core::geometry::BoundingPolygon3D& ParkingLevelConnector::getTransitionPolygon()
{
    return m_transitionPolygon_.value();
}

const ::nds::core::geometry::BoundingPolygon3D& ParkingLevelConnector::getTransitionPolygon() const
{
    return m_transitionPolygon_.value();
}

void ParkingLevelConnector::setTransitionPolygon(const ::nds::core::geometry::BoundingPolygon3D& transitionPolygon_)
{
    m_transitionPolygon_ = transitionPolygon_;
}

void ParkingLevelConnector::setTransitionPolygon(::nds::core::geometry::BoundingPolygon3D&& transitionPolygon_)
{
    m_transitionPolygon_ = ::std::move(transitionPolygon_);
}

bool ParkingLevelConnector::isTransitionPolygonUsed() const
{
    return (isTransitionPolygonSet());
}

bool ParkingLevelConnector::isTransitionPolygonSet() const
{
    return m_transitionPolygon_.hasValue();
}

void ParkingLevelConnector::resetTransitionPolygon()
{
    m_transitionPolygon_.reset();
}

void ParkingLevelConnector::initPackingContext(ParkingLevelConnector::ZserioPackingContext& context) const
{
    m_levelId_.initPackingContext(context.getLevelId());
    if (isTransitionPolygonSet())
    {
        m_transitionPolygon_.value().initPackingContext(context.getTransitionPolygon());
    }
}

size_t ParkingLevelConnector::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_levelId_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isTransitionPolygonSet())
    {
        endBitPosition += m_transitionPolygon_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingLevelConnector::bitSizeOf(ParkingLevelConnector::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_levelId_.bitSizeOf(context.getLevelId(), endBitPosition);
    endBitPosition += 1;
    if (isTransitionPolygonSet())
    {
        endBitPosition += m_transitionPolygon_.value().bitSizeOf(context.getTransitionPolygon(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingLevelConnector::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_levelId_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isTransitionPolygonSet())
    {
        endBitPosition = m_transitionPolygon_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t ParkingLevelConnector::initializeOffsets(ParkingLevelConnector::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_levelId_.initializeOffsets(context.getLevelId(), endBitPosition);
    endBitPosition += 1;
    if (isTransitionPolygonSet())
    {
        endBitPosition = m_transitionPolygon_.value().initializeOffsets(context.getTransitionPolygon(), endBitPosition);
    }

    return endBitPosition;
}

bool ParkingLevelConnector::operator==(const ParkingLevelConnector& other) const
{
    if (this != &other)
    {
        return
                (m_levelId_ == other.m_levelId_) &&
                (!isTransitionPolygonUsed() ? !other.isTransitionPolygonUsed() : (m_transitionPolygon_ == other.m_transitionPolygon_));
    }

    return true;
}

uint32_t ParkingLevelConnector::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_levelId_);
    if (isTransitionPolygonUsed())
        result = ::zserio::calcHashCode(result, m_transitionPolygon_);

    return result;
}

void ParkingLevelConnector::write(::zserio::BitStreamWriter& out) const
{
    m_levelId_.write(out);

    if (isTransitionPolygonSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_transitionPolygon_.value().getXyShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter xyShift for field ParkingLevelConnector.transitionPolygon: ") <<
                    m_transitionPolygon_.value().getXyShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        if (m_transitionPolygon_.value().getZShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter zShift for field ParkingLevelConnector.transitionPolygon: ") <<
                    m_transitionPolygon_.value().getZShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_transitionPolygon_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingLevelConnector::write(ParkingLevelConnector::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_levelId_.write(context.getLevelId(), out);

    if (isTransitionPolygonSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_transitionPolygon_.value().getXyShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter xyShift for field ParkingLevelConnector.transitionPolygon: ") <<
                    m_transitionPolygon_.value().getXyShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        if (m_transitionPolygon_.value().getZShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter zShift for field ParkingLevelConnector.transitionPolygon: ") <<
                    m_transitionPolygon_.value().getZShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_transitionPolygon_.value().write(context.getTransitionPolygon(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::venue::reference::types::ParkingLevelId ParkingLevelConnector::readLevelId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingLevelId(in, allocator);
}

::nds::venue::reference::types::ParkingLevelId ParkingLevelConnector::readLevelId(ParkingLevelConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingLevelId(context.getLevelId(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon3D> ParkingLevelConnector::readTransitionPolygon(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon3D>(::nds::core::geometry::BoundingPolygon3D(in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon3D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon3D> ParkingLevelConnector::readTransitionPolygon(ParkingLevelConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon3D>(::nds::core::geometry::BoundingPolygon3D(context.getTransitionPolygon(), in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon3D>(::zserio::NullOpt);
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingSection.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingSection::ParkingSection(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_rows_(allocator),
        m_connectedSections_(::zserio::NullOpt)
{
}

ParkingSection::ParkingSection(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_rows_(readRows(in, allocator)),
        m_connectedSections_(readConnectedSections(in, allocator))
{
}

ParkingSection::ParkingSection(ParkingSection::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_rows_(readRows(context, in, allocator)),
        m_connectedSections_(readConnectedSections(context, in, allocator))
{
}

ParkingSection::ParkingSection(::zserio::PropagateAllocatorT,
        const ParkingSection& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_rows_(::zserio::allocatorPropagatingCopy(other.m_rows_, allocator)),
        m_connectedSections_(::zserio::allocatorPropagatingCopy(other.m_connectedSections_, allocator))
{
}

void ParkingSection::initializeChildren()
{
    if (isConnectedSectionsSet())
        m_connectedSections_.value().initializeElements(*this);
}

::nds::venue::reference::types::ParkingSectionId& ParkingSection::getId()
{
    return m_id_;
}

const ::nds::venue::reference::types::ParkingSectionId& ParkingSection::getId() const
{
    return m_id_;
}

void ParkingSection::setId(const ::nds::venue::reference::types::ParkingSectionId& id_)
{
    m_id_ = id_;
}

void ParkingSection::setId(::nds::venue::reference::types::ParkingSectionId&& id_)
{
    m_id_ = ::std::move(id_);
}

::zserio::vector<::nds::venue::parking::ParkingRow>& ParkingSection::getRows()
{
    return m_rows_.getRawArray();
}

const ::zserio::vector<::nds::venue::parking::ParkingRow>& ParkingSection::getRows() const
{
    return m_rows_.getRawArray();
}

void ParkingSection::setRows(const ::zserio::vector<::nds::venue::parking::ParkingRow>& rows_)
{
    m_rows_ = ZserioArrayType_rows(rows_);
}

void ParkingSection::setRows(::zserio::vector<::nds::venue::parking::ParkingRow>&& rows_)
{
    m_rows_ = ZserioArrayType_rows(std::move(rows_));
}

::zserio::vector<::nds::venue::parking::ParkingSectionConnector>& ParkingSection::getConnectedSections()
{
    return m_connectedSections_.value().getRawArray();
}

const ::zserio::vector<::nds::venue::parking::ParkingSectionConnector>& ParkingSection::getConnectedSections() const
{
    return m_connectedSections_.value().getRawArray();
}

void ParkingSection::setConnectedSections(const ::zserio::vector<::nds::venue::parking::ParkingSectionConnector>& connectedSections_)
{
    m_connectedSections_ = ZserioArrayType_connectedSections(connectedSections_);
}

void ParkingSection::setConnectedSections(::zserio::vector<::nds::venue::parking::ParkingSectionConnector>&& connectedSections_)
{
    m_connectedSections_ = ZserioArrayType_connectedSections(std::move(connectedSections_));
}

bool ParkingSection::isConnectedSectionsUsed() const
{
    return (isConnectedSectionsSet());
}

bool ParkingSection::isConnectedSectionsSet() const
{
    return m_connectedSections_.hasValue();
}

void ParkingSection::resetConnectedSections()
{
    m_connectedSections_.reset();
}

void ParkingSection::initPackingContext(ParkingSection::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
}

size_t ParkingSection::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += m_rows_.bitSizeOf(*this, endBitPosition);
    endBitPosition += 1;
    if (isConnectedSectionsSet())
    {
        endBitPosition += m_connectedSections_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSection::bitSizeOf(ParkingSection::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += m_rows_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isConnectedSectionsSet())
    {
        endBitPosition += m_connectedSections_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSection::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition = m_rows_.initializeOffsets(*this, endBitPosition);
    endBitPosition += 1;
    if (isConnectedSectionsSet())
    {
        endBitPosition = m_connectedSections_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t ParkingSection::initializeOffsets(ParkingSection::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition = m_rows_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isConnectedSectionsSet())
    {
        endBitPosition = m_connectedSections_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool ParkingSection::operator==(const ParkingSection& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_rows_ == other.m_rows_) &&
                (!isConnectedSectionsUsed() ? !other.isConnectedSectionsUsed() : (m_connectedSections_ == other.m_connectedSections_));
    }

    return true;
}

uint32_t ParkingSection::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_rows_);
    if (isConnectedSectionsUsed())
        result = ::zserio::calcHashCode(result, m_connectedSections_);

    return result;
}

void ParkingSection::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);
    m_rows_.write(*this, out);
    if (isConnectedSectionsSet())
    {
        out.writeBool(true);
        m_connectedSections_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingSection::write(ParkingSection::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);
    m_rows_.writePacked(*this, out);
    if (isConnectedSectionsSet())
    {
        out.writeBool(true);
        m_connectedSections_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingSection::ZserioElementFactory_rows::create(ParkingSection&        ,
        ::zserio::vector<::nds::venue::parking::ParkingRow>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSection::ZserioElementFactory_rows::create(ParkingSection&        ,
        ::zserio::vector<::nds::venue::parking::ParkingRow>& array,
        ::nds::venue::parking::ParkingRow::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingSection::ZserioArrayExpressions_connectedSections::initializeElement(ParkingSection&,
        ::nds::venue::parking::ParkingSectionConnector& element, size_t)
{
    element.initializeChildren();
}

void ParkingSection::ZserioElementFactory_connectedSections::create(ParkingSection&        ,
        ::zserio::vector<::nds::venue::parking::ParkingSectionConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSection::ZserioElementFactory_connectedSections::create(ParkingSection&        ,
        ::zserio::vector<::nds::venue::parking::ParkingSectionConnector>& array,
        ::nds::venue::parking::ParkingSectionConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::venue::reference::types::ParkingSectionId ParkingSection::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingSectionId(in, allocator);
}

::nds::venue::reference::types::ParkingSectionId ParkingSection::readId(ParkingSection::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingSectionId(context.getId(), in, allocator);
}
ParkingSection::ZserioArrayType_rows ParkingSection::readRows(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_rows readField(allocator);
    readField.read(*this, in);

    return readField;
}

ParkingSection::ZserioArrayType_rows ParkingSection::readRows(ParkingSection::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_rows readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::zserio::InplaceOptionalHolder<ParkingSection::ZserioArrayType_connectedSections> ParkingSection::readConnectedSections(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_connectedSections readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_connectedSections>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_connectedSections>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<ParkingSection::ZserioArrayType_connectedSections> ParkingSection::readConnectedSections(ParkingSection::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_connectedSections readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_connectedSections>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_connectedSections>(::zserio::NullOpt);
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingSectionConnector.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingSectionConnector::ParkingSectionConnector(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_sectionId_(allocator),
        m_transitionPolygon_(::zserio::NullOpt)
{
}

ParkingSectionConnector::ParkingSectionConnector(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_sectionId_(readSectionId(in, allocator)),
        m_transitionPolygon_(readTransitionPolygon(in, allocator))
{
}

ParkingSectionConnector::ParkingSectionConnector(ParkingSectionConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_sectionId_(readSectionId(context, in, allocator)),
        m_transitionPolygon_(readTransitionPolygon(context, in, allocator))
{
}

ParkingSectionConnector::ParkingSectionConnector(const ParkingSectionConnector& other) :
        m_sectionId_(other.m_sectionId_),
        m_transitionPolygon_(other.m_transitionPolygon_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingSectionConnector& ParkingSectionConnector::operator=(const ParkingSectionConnector& other)
{
    m_sectionId_ = other.m_sectionId_;
    m_transitionPolygon_ = other.m_transitionPolygon_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingSectionConnector::ParkingSectionConnector(ParkingSectionConnector&& other) :
        m_sectionId_(::std::move(other.m_sectionId_)),
        m_transitionPolygon_(::std::move(other.m_transitionPolygon_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingSectionConnector& ParkingSectionConnector::operator=(ParkingSectionConnector&& other)
{
    m_sectionId_ = ::std::move(other.m_sectionId_);
    m_transitionPolygon_ = ::std::move(other.m_transitionPolygon_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingSectionConnector::ParkingSectionConnector(::zserio::PropagateAllocatorT,
        const ParkingSectionConnector& other, const allocator_type& allocator) :
        m_sectionId_(::zserio::allocatorPropagatingCopy(other.m_sectionId_, allocator)),
        m_transitionPolygon_(::zserio::allocatorPropagatingCopy(other.m_transitionPolygon_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ParkingSectionConnector::initializeChildren()
{
    if (isTransitionPolygonSet())
        m_transitionPolygon_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::venue::reference::types::ParkingSectionId& ParkingSectionConnector::getSectionId()
{
    return m_sectionId_;
}

const ::nds::venue::reference::types::ParkingSectionId& ParkingSectionConnector::getSectionId() const
{
    return m_sectionId_;
}

void ParkingSectionConnector::setSectionId(const ::nds::venue::reference::types::ParkingSectionId& sectionId_)
{
    m_sectionId_ = sectionId_;
}

void ParkingSectionConnector::setSectionId(::nds::venue::reference::types::ParkingSectionId&& sectionId_)
{
    m_sectionId_ = ::std::move(sectionId_);
}

::nds::core::geometry::BoundingPolygon2D& ParkingSectionConnector::getTransitionPolygon()
{
    return m_transitionPolygon_.value();
}

const ::nds::core::geometry::BoundingPolygon2D& ParkingSectionConnector::getTransitionPolygon() const
{
    return m_transitionPolygon_.value();
}

void ParkingSectionConnector::setTransitionPolygon(const ::nds::core::geometry::BoundingPolygon2D& transitionPolygon_)
{
    m_transitionPolygon_ = transitionPolygon_;
}

void ParkingSectionConnector::setTransitionPolygon(::nds::core::geometry::BoundingPolygon2D&& transitionPolygon_)
{
    m_transitionPolygon_ = ::std::move(transitionPolygon_);
}

bool ParkingSectionConnector::isTransitionPolygonUsed() const
{
    return (isTransitionPolygonSet());
}

bool ParkingSectionConnector::isTransitionPolygonSet() const
{
    return m_transitionPolygon_.hasValue();
}

void ParkingSectionConnector::resetTransitionPolygon()
{
    m_transitionPolygon_.reset();
}

void ParkingSectionConnector::initPackingContext(ParkingSectionConnector::ZserioPackingContext& context) const
{
    m_sectionId_.initPackingContext(context.getSectionId());
    if (isTransitionPolygonSet())
    {
        m_transitionPolygon_.value().initPackingContext(context.getTransitionPolygon());
    }
}

size_t ParkingSectionConnector::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_sectionId_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isTransitionPolygonSet())
    {
        endBitPosition += m_transitionPolygon_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSectionConnector::bitSizeOf(ParkingSectionConnector::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_sectionId_.bitSizeOf(context.getSectionId(), endBitPosition);
    endBitPosition += 1;
    if (isTransitionPolygonSet())
    {
        endBitPosition += m_transitionPolygon_.value().bitSizeOf(context.getTransitionPolygon(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSectionConnector::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_sectionId_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isTransitionPolygonSet())
    {
        endBitPosition = m_transitionPolygon_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t ParkingSectionConnector::initializeOffsets(ParkingSectionConnector::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_sectionId_.initializeOffsets(context.getSectionId(), endBitPosition);
    endBitPosition += 1;
    if (isTransitionPolygonSet())
    {
        endBitPosition = m_transitionPolygon_.value().initializeOffsets(context.getTransitionPolygon(), endBitPosition);
    }

    return endBitPosition;
}

bool ParkingSectionConnector::operator==(const ParkingSectionConnector& other) const
{
    if (this != &other)
    {
        return
                (m_sectionId_ == other.m_sectionId_) &&
                (!isTransitionPolygonUsed() ? !other.isTransitionPolygonUsed() : (m_transitionPolygon_ == other.m_transitionPolygon_));
    }

    return true;
}

uint32_t ParkingSectionConnector::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_sectionId_);
    if (isTransitionPolygonUsed())
        result = ::zserio::calcHashCode(result, m_transitionPolygon_);

    return result;
}

void ParkingSectionConnector::write(::zserio::BitStreamWriter& out) const
{
    m_sectionId_.write(out);

    if (isTransitionPolygonSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_transitionPolygon_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field ParkingSectionConnector.transitionPolygon: ") <<
                    m_transitionPolygon_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_transitionPolygon_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingSectionConnector::write(ParkingSectionConnector::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_sectionId_.write(context.getSectionId(), out);

    if (isTransitionPolygonSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_transitionPolygon_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field ParkingSectionConnector.transitionPolygon: ") <<
                    m_transitionPolygon_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_transitionPolygon_.value().write(context.getTransitionPolygon(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::venue::reference::types::ParkingSectionId ParkingSectionConnector::readSectionId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingSectionId(in, allocator);
}

::nds::venue::reference::types::ParkingSectionId ParkingSectionConnector::readSectionId(ParkingSectionConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingSectionId(context.getSectionId(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D> ParkingSectionConnector::readTransitionPolygon(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D>(::nds::core::geometry::BoundingPolygon2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D> ParkingSectionConnector::readTransitionPolygon(ParkingSectionConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D>(::nds::core::geometry::BoundingPolygon2D(context.getTransitionPolygon(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D>(::zserio::NullOpt);
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingRow.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingRow::ParkingRow(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_spots_(allocator)
{
}

ParkingRow::ParkingRow(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_spots_(readSpots(in, allocator))
{
}

ParkingRow::ParkingRow(ParkingRow::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_spots_(readSpots(context, in, allocator))
{
}

ParkingRow::ParkingRow(::zserio::PropagateAllocatorT,
        const ParkingRow& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_spots_(::zserio::allocatorPropagatingCopy(other.m_spots_, allocator))
{
}

::nds::venue::reference::types::ParkingRowId& ParkingRow::getId()
{
    return m_id_;
}

const ::nds::venue::reference::types::ParkingRowId& ParkingRow::getId() const
{
    return m_id_;
}

void ParkingRow::setId(const ::nds::venue::reference::types::ParkingRowId& id_)
{
    m_id_ = id_;
}

void ParkingRow::setId(::nds::venue::reference::types::ParkingRowId&& id_)
{
    m_id_ = ::std::move(id_);
}

::zserio::vector<::nds::venue::parking::ParkingSpot>& ParkingRow::getSpots()
{
    return m_spots_.getRawArray();
}

const ::zserio::vector<::nds::venue::parking::ParkingSpot>& ParkingRow::getSpots() const
{
    return m_spots_.getRawArray();
}

void ParkingRow::setSpots(const ::zserio::vector<::nds::venue::parking::ParkingSpot>& spots_)
{
    m_spots_ = ZserioArrayType_spots(spots_);
}

void ParkingRow::setSpots(::zserio::vector<::nds::venue::parking::ParkingSpot>&& spots_)
{
    m_spots_ = ZserioArrayType_spots(std::move(spots_));
}

void ParkingRow::initPackingContext(ParkingRow::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
}

size_t ParkingRow::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += m_spots_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRow::bitSizeOf(ParkingRow::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += m_spots_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRow::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition = m_spots_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingRow::initializeOffsets(ParkingRow::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition = m_spots_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingRow::operator==(const ParkingRow& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_spots_ == other.m_spots_);
    }

    return true;
}

uint32_t ParkingRow::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_spots_);

    return result;
}

void ParkingRow::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);
    m_spots_.write(*this, out);
}

void ParkingRow::write(ParkingRow::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);
    m_spots_.writePacked(*this, out);
}

void ParkingRow::ZserioElementFactory_spots::create(ParkingRow&        ,
        ::zserio::vector<::nds::venue::parking::ParkingSpot>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingRow::ZserioElementFactory_spots::create(ParkingRow&        ,
        ::zserio::vector<::nds::venue::parking::ParkingSpot>& array,
        ::nds::venue::parking::ParkingSpot::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::venue::reference::types::ParkingRowId ParkingRow::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingRowId(in, allocator);
}

::nds::venue::reference::types::ParkingRowId ParkingRow::readId(ParkingRow::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingRowId(context.getId(), in, allocator);
}
ParkingRow::ZserioArrayType_spots ParkingRow::readSpots(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_spots readField(allocator);
    readField.read(*this, in);

    return readField;
}

ParkingRow::ZserioArrayType_spots ParkingRow::readSpots(ParkingRow::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_spots readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingSpot.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingSpot::ParkingSpot(const allocator_type& allocator) noexcept :
        m_id_(allocator)
{
}

ParkingSpot::ParkingSpot(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator))
{
}

ParkingSpot::ParkingSpot(ParkingSpot::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator))
{
}

ParkingSpot::ParkingSpot(::zserio::PropagateAllocatorT,
        const ParkingSpot& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator))
{
}

::nds::venue::reference::types::ParkingSpotId& ParkingSpot::getId()
{
    return m_id_;
}

const ::nds::venue::reference::types::ParkingSpotId& ParkingSpot::getId() const
{
    return m_id_;
}

void ParkingSpot::setId(const ::nds::venue::reference::types::ParkingSpotId& id_)
{
    m_id_ = id_;
}

void ParkingSpot::setId(::nds::venue::reference::types::ParkingSpotId&& id_)
{
    m_id_ = ::std::move(id_);
}

void ParkingSpot::initPackingContext(ParkingSpot::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
}

size_t ParkingSpot::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpot::bitSizeOf(ParkingSpot::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpot::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingSpot::initializeOffsets(ParkingSpot::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);

    return endBitPosition;
}

bool ParkingSpot::operator==(const ParkingSpot& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_);
    }

    return true;
}

uint32_t ParkingSpot::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);

    return result;
}

void ParkingSpot::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);
}

void ParkingSpot::write(ParkingSpot::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);
}

::nds::venue::reference::types::ParkingSpotId ParkingSpot::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingSpotId(in, allocator);
}

::nds::venue::reference::types::ParkingSpotId ParkingSpot::readId(ParkingSpot::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingSpotId(context.getId(), in, allocator);
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/RoadNetworkAccessRoadReference.h>

namespace nds
{
namespace venue
{
namespace parking
{

RoadNetworkAccessRoadReference::RoadNetworkAccessRoadReference(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_facilityId_(allocator),
        m_type_(::nds::venue::parking::RoadNetworkAccessType()),
        m_hasIndirectReference_(bool()),
        m_indirectReference_(::zserio::NullOpt),
        m_reference_(::zserio::NullOpt),
        m_validity_(allocator)
{
}

RoadNetworkAccessRoadReference::RoadNetworkAccessRoadReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_facilityId_(readFacilityId(in, allocator)),
        m_type_(readType(in)),
        m_hasIndirectReference_(readHasIndirectReference(in)),
        m_indirectReference_(readIndirectReference(in, allocator)),
        m_reference_(readReference(in, allocator)),
        m_validity_(readValidity(in, allocator))
{
}

RoadNetworkAccessRoadReference::RoadNetworkAccessRoadReference(RoadNetworkAccessRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_facilityId_(readFacilityId(context, in, allocator)),
        m_type_(readType(context, in)),
        m_hasIndirectReference_(readHasIndirectReference(in)),
        m_indirectReference_(readIndirectReference(context, in, allocator)),
        m_reference_(readReference(context, in, allocator)),
        m_validity_(readValidity(context, in, allocator))
{
}

RoadNetworkAccessRoadReference::RoadNetworkAccessRoadReference(const RoadNetworkAccessRoadReference& other) :
        m_facilityId_(other.m_facilityId_),
        m_type_(other.m_type_),
        m_hasIndirectReference_(other.m_hasIndirectReference_),
        m_indirectReference_(other.m_indirectReference_),
        m_reference_(other.m_reference_),
        m_validity_(other.m_validity_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadNetworkAccessRoadReference& RoadNetworkAccessRoadReference::operator=(const RoadNetworkAccessRoadReference& other)
{
    m_facilityId_ = other.m_facilityId_;
    m_type_ = other.m_type_;
    m_hasIndirectReference_ = other.m_hasIndirectReference_;
    m_indirectReference_ = other.m_indirectReference_;
    m_reference_ = other.m_reference_;
    m_validity_ = other.m_validity_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadNetworkAccessRoadReference::RoadNetworkAccessRoadReference(RoadNetworkAccessRoadReference&& other) :
        m_facilityId_(::std::move(other.m_facilityId_)),
        m_type_(::std::move(other.m_type_)),
        m_hasIndirectReference_(::std::move(other.m_hasIndirectReference_)),
        m_indirectReference_(::std::move(other.m_indirectReference_)),
        m_reference_(::std::move(other.m_reference_)),
        m_validity_(::std::move(other.m_validity_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadNetworkAccessRoadReference& RoadNetworkAccessRoadReference::operator=(RoadNetworkAccessRoadReference&& other)
{
    m_facilityId_ = ::std::move(other.m_facilityId_);
    m_type_ = ::std::move(other.m_type_);
    m_hasIndirectReference_ = ::std::move(other.m_hasIndirectReference_);
    m_indirectReference_ = ::std::move(other.m_indirectReference_);
    m_reference_ = ::std::move(other.m_reference_);
    m_validity_ = ::std::move(other.m_validity_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadNetworkAccessRoadReference::RoadNetworkAccessRoadReference(::zserio::PropagateAllocatorT,
        const RoadNetworkAccessRoadReference& other, const allocator_type& allocator) :
        m_facilityId_(::zserio::allocatorPropagatingCopy(other.m_facilityId_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_hasIndirectReference_(::zserio::allocatorPropagatingCopy(other.m_hasIndirectReference_, allocator)),
        m_indirectReference_(::zserio::allocatorPropagatingCopy(other.m_indirectReference_, allocator)),
        m_reference_(::zserio::allocatorPropagatingCopy(other.m_reference_, allocator)),
        m_validity_(::zserio::allocatorPropagatingCopy(other.m_validity_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadNetworkAccessRoadReference::initializeChildren()
{
    if (getHasIndirectReference())
        m_indirectReference_.value().initializeChildren();
    m_validity_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::venue::reference::types::ParkingFacilityId& RoadNetworkAccessRoadReference::getFacilityId()
{
    return m_facilityId_;
}

const ::nds::venue::reference::types::ParkingFacilityId& RoadNetworkAccessRoadReference::getFacilityId() const
{
    return m_facilityId_;
}

void RoadNetworkAccessRoadReference::setFacilityId(const ::nds::venue::reference::types::ParkingFacilityId& facilityId_)
{
    m_facilityId_ = facilityId_;
}

void RoadNetworkAccessRoadReference::setFacilityId(::nds::venue::reference::types::ParkingFacilityId&& facilityId_)
{
    m_facilityId_ = ::std::move(facilityId_);
}

::nds::venue::parking::RoadNetworkAccessType RoadNetworkAccessRoadReference::getType() const
{
    return m_type_;
}

void RoadNetworkAccessRoadReference::setType(::nds::venue::parking::RoadNetworkAccessType type_)
{
    m_type_ = type_;
}

bool RoadNetworkAccessRoadReference::getHasIndirectReference() const
{
    return m_hasIndirectReference_;
}

void RoadNetworkAccessRoadReference::setHasIndirectReference(bool hasIndirectReference_)
{
    m_hasIndirectReference_ = hasIndirectReference_;
}

::nds::road::reference::types::RoadReferenceIndirect& RoadNetworkAccessRoadReference::getIndirectReference()
{
    return m_indirectReference_.value();
}

const ::nds::road::reference::types::RoadReferenceIndirect& RoadNetworkAccessRoadReference::getIndirectReference() const
{
    return m_indirectReference_.value();
}

void RoadNetworkAccessRoadReference::setIndirectReference(const ::nds::road::reference::types::RoadReferenceIndirect& indirectReference_)
{
    m_indirectReference_ = indirectReference_;
}

void RoadNetworkAccessRoadReference::setIndirectReference(::nds::road::reference::types::RoadReferenceIndirect&& indirectReference_)
{
    m_indirectReference_ = ::std::move(indirectReference_);
}

bool RoadNetworkAccessRoadReference::isIndirectReferenceUsed() const
{
    return (getHasIndirectReference());
}

bool RoadNetworkAccessRoadReference::isIndirectReferenceSet() const
{
    return m_indirectReference_.hasValue();
}

void RoadNetworkAccessRoadReference::resetIndirectReference()
{
    m_indirectReference_.reset();
}

::nds::road::reference::types::RoadReference& RoadNetworkAccessRoadReference::getReference()
{
    return m_reference_.value();
}

const ::nds::road::reference::types::RoadReference& RoadNetworkAccessRoadReference::getReference() const
{
    return m_reference_.value();
}

void RoadNetworkAccessRoadReference::setReference(const ::nds::road::reference::types::RoadReference& reference_)
{
    m_reference_ = reference_;
}

void RoadNetworkAccessRoadReference::setReference(::nds::road::reference::types::RoadReference&& reference_)
{
    m_reference_ = ::std::move(reference_);
}

bool RoadNetworkAccessRoadReference::isReferenceUsed() const
{
    return (!getHasIndirectReference());
}

bool RoadNetworkAccessRoadReference::isReferenceSet() const
{
    return m_reference_.hasValue();
}

void RoadNetworkAccessRoadReference::resetReference()
{
    m_reference_.reset();
}

::nds::road::reference::types::RoadPositionValidity& RoadNetworkAccessRoadReference::getValidity()
{
    return m_validity_;
}

const ::nds::road::reference::types::RoadPositionValidity& RoadNetworkAccessRoadReference::getValidity() const
{
    return m_validity_;
}

void RoadNetworkAccessRoadReference::setValidity(const ::nds::road::reference::types::RoadPositionValidity& validity_)
{
    m_validity_ = validity_;
}

void RoadNetworkAccessRoadReference::setValidity(::nds::road::reference::types::RoadPositionValidity&& validity_)
{
    m_validity_ = ::std::move(validity_);
}

void RoadNetworkAccessRoadReference::initPackingContext(RoadNetworkAccessRoadReference::ZserioPackingContext& context) const
{
    m_facilityId_.initPackingContext(context.getFacilityId());
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getHasIndirectReference())
    {
        m_indirectReference_.value().initPackingContext(context.getIndirectReference());
    }
    if (!getHasIndirectReference())
    {
        m_reference_.value().initPackingContext(context.getReference());
    }
    m_validity_.initPackingContext(context.getValidity());
}

size_t RoadNetworkAccessRoadReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_facilityId_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += UINT8_C(1);
    if (getHasIndirectReference())
    {
        endBitPosition += m_indirectReference_.value().bitSizeOf(endBitPosition);
    }
    if (!getHasIndirectReference())
    {
        endBitPosition += m_reference_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += m_validity_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadNetworkAccessRoadReference::bitSizeOf(RoadNetworkAccessRoadReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_facilityId_.bitSizeOf(context.getFacilityId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += UINT8_C(1);
    if (getHasIndirectReference())
    {
        endBitPosition += m_indirectReference_.value().bitSizeOf(context.getIndirectReference(), endBitPosition);
    }
    if (!getHasIndirectReference())
    {
        endBitPosition += m_reference_.value().bitSizeOf(context.getReference(), endBitPosition);
    }
    endBitPosition += m_validity_.bitSizeOf(context.getValidity(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadNetworkAccessRoadReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_facilityId_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += UINT8_C(1);
    if (getHasIndirectReference())
    {
        endBitPosition = m_indirectReference_.value().initializeOffsets(endBitPosition);
    }
    if (!getHasIndirectReference())
    {
        endBitPosition = m_reference_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = m_validity_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadNetworkAccessRoadReference::initializeOffsets(RoadNetworkAccessRoadReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_facilityId_.initializeOffsets(context.getFacilityId(), endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += UINT8_C(1);
    if (getHasIndirectReference())
    {
        endBitPosition = m_indirectReference_.value().initializeOffsets(context.getIndirectReference(), endBitPosition);
    }
    if (!getHasIndirectReference())
    {
        endBitPosition = m_reference_.value().initializeOffsets(context.getReference(), endBitPosition);
    }
    endBitPosition = m_validity_.initializeOffsets(context.getValidity(), endBitPosition);

    return endBitPosition;
}

bool RoadNetworkAccessRoadReference::operator==(const RoadNetworkAccessRoadReference& other) const
{
    if (this != &other)
    {
        return
                (m_facilityId_ == other.m_facilityId_) &&
                (m_type_ == other.m_type_) &&
                (m_hasIndirectReference_ == other.m_hasIndirectReference_) &&
                (!isIndirectReferenceUsed() ? !other.isIndirectReferenceUsed() : (m_indirectReference_ == other.m_indirectReference_)) &&
                (!isReferenceUsed() ? !other.isReferenceUsed() : (m_reference_ == other.m_reference_)) &&
                (m_validity_ == other.m_validity_);
    }

    return true;
}

uint32_t RoadNetworkAccessRoadReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_facilityId_);
    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_hasIndirectReference_);
    if (isIndirectReferenceUsed())
        result = ::zserio::calcHashCode(result, m_indirectReference_);
    if (isReferenceUsed())
        result = ::zserio::calcHashCode(result, m_reference_);
    result = ::zserio::calcHashCode(result, m_validity_);

    return result;
}

void RoadNetworkAccessRoadReference::write(::zserio::BitStreamWriter& out) const
{
    m_facilityId_.write(out);

    ::zserio::write(out, m_type_);

    out.writeBool(m_hasIndirectReference_);

    if (getHasIndirectReference())
    {
        m_indirectReference_.value().write(out);
    }

    if (!getHasIndirectReference())
    {
        m_reference_.value().write(out);
    }

    // check parameters
    if (m_validity_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadNetworkAccessRoadReference.validity: ") <<
                m_validity_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_validity_.write(out);
}

void RoadNetworkAccessRoadReference::write(RoadNetworkAccessRoadReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_facilityId_.write(context.getFacilityId(), out);

    ::zserio::write(context.getType(), out, m_type_);

    out.writeBool(m_hasIndirectReference_);

    if (getHasIndirectReference())
    {
        m_indirectReference_.value().write(context.getIndirectReference(), out);
    }

    if (!getHasIndirectReference())
    {
        m_reference_.value().write(context.getReference(), out);
    }

    // check parameters
    if (m_validity_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RoadNetworkAccessRoadReference.validity: ") <<
                m_validity_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_validity_.write(context.getValidity(), out);
}

::nds::venue::reference::types::ParkingFacilityId RoadNetworkAccessRoadReference::readFacilityId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingFacilityId(in, allocator);
}

::nds::venue::reference::types::ParkingFacilityId RoadNetworkAccessRoadReference::readFacilityId(RoadNetworkAccessRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingFacilityId(context.getFacilityId(), in, allocator);
}
::nds::venue::parking::RoadNetworkAccessType RoadNetworkAccessRoadReference::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::parking::RoadNetworkAccessType>(in);
}

::nds::venue::parking::RoadNetworkAccessType RoadNetworkAccessRoadReference::readType(RoadNetworkAccessRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::parking::RoadNetworkAccessType>(context.getType(), in);
}
bool RoadNetworkAccessRoadReference::readHasIndirectReference(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect> RoadNetworkAccessRoadReference::readIndirectReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasIndirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect>(::nds::road::reference::types::RoadReferenceIndirect(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect> RoadNetworkAccessRoadReference::readIndirectReference(RoadNetworkAccessRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasIndirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect>(::nds::road::reference::types::RoadReferenceIndirect(context.getIndirectReference(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReferenceIndirect>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference> RoadNetworkAccessRoadReference::readReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getHasIndirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference>(::nds::road::reference::types::RoadReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference> RoadNetworkAccessRoadReference::readReference(RoadNetworkAccessRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getHasIndirectReference())
    {
        return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference>(::nds::road::reference::types::RoadReference(context.getReference(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::road::reference::types::RoadReference>(::zserio::NullOpt);
}
::nds::road::reference::types::RoadPositionValidity RoadNetworkAccessRoadReference::readValidity(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadPositionValidity(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::road::reference::types::RoadPositionValidity RoadNetworkAccessRoadReference::readValidity(RoadNetworkAccessRoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::road::reference::types::RoadPositionValidity(context.getValidity(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/RoadNetworkAccessLaneReference.h>

namespace nds
{
namespace venue
{
namespace parking
{

RoadNetworkAccessLaneReference::RoadNetworkAccessLaneReference(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_facilityId_(allocator),
        m_type_(::nds::venue::parking::RoadNetworkAccessType()),
        m_indirectReference_(allocator),
        m_validity_(allocator)
{
}

RoadNetworkAccessLaneReference::RoadNetworkAccessLaneReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_facilityId_(readFacilityId(in, allocator)),
        m_type_(readType(in)),
        m_indirectReference_(readIndirectReference(in, allocator)),
        m_validity_(readValidity(in, allocator))
{
}

RoadNetworkAccessLaneReference::RoadNetworkAccessLaneReference(RoadNetworkAccessLaneReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_facilityId_(readFacilityId(context, in, allocator)),
        m_type_(readType(context, in)),
        m_indirectReference_(readIndirectReference(context, in, allocator)),
        m_validity_(readValidity(context, in, allocator))
{
}

RoadNetworkAccessLaneReference::RoadNetworkAccessLaneReference(const RoadNetworkAccessLaneReference& other) :
        m_facilityId_(other.m_facilityId_),
        m_type_(other.m_type_),
        m_indirectReference_(other.m_indirectReference_),
        m_validity_(other.m_validity_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadNetworkAccessLaneReference& RoadNetworkAccessLaneReference::operator=(const RoadNetworkAccessLaneReference& other)
{
    m_facilityId_ = other.m_facilityId_;
    m_type_ = other.m_type_;
    m_indirectReference_ = other.m_indirectReference_;
    m_validity_ = other.m_validity_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadNetworkAccessLaneReference::RoadNetworkAccessLaneReference(RoadNetworkAccessLaneReference&& other) :
        m_facilityId_(::std::move(other.m_facilityId_)),
        m_type_(::std::move(other.m_type_)),
        m_indirectReference_(::std::move(other.m_indirectReference_)),
        m_validity_(::std::move(other.m_validity_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadNetworkAccessLaneReference& RoadNetworkAccessLaneReference::operator=(RoadNetworkAccessLaneReference&& other)
{
    m_facilityId_ = ::std::move(other.m_facilityId_);
    m_type_ = ::std::move(other.m_type_);
    m_indirectReference_ = ::std::move(other.m_indirectReference_);
    m_validity_ = ::std::move(other.m_validity_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadNetworkAccessLaneReference::RoadNetworkAccessLaneReference(::zserio::PropagateAllocatorT,
        const RoadNetworkAccessLaneReference& other, const allocator_type& allocator) :
        m_facilityId_(::zserio::allocatorPropagatingCopy(other.m_facilityId_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_indirectReference_(::zserio::allocatorPropagatingCopy(other.m_indirectReference_, allocator)),
        m_validity_(::zserio::allocatorPropagatingCopy(other.m_validity_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadNetworkAccessLaneReference::initializeChildren()
{
    m_indirectReference_.initializeChildren();
    m_validity_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::venue::reference::types::ParkingFacilityId& RoadNetworkAccessLaneReference::getFacilityId()
{
    return m_facilityId_;
}

const ::nds::venue::reference::types::ParkingFacilityId& RoadNetworkAccessLaneReference::getFacilityId() const
{
    return m_facilityId_;
}

void RoadNetworkAccessLaneReference::setFacilityId(const ::nds::venue::reference::types::ParkingFacilityId& facilityId_)
{
    m_facilityId_ = facilityId_;
}

void RoadNetworkAccessLaneReference::setFacilityId(::nds::venue::reference::types::ParkingFacilityId&& facilityId_)
{
    m_facilityId_ = ::std::move(facilityId_);
}

::nds::venue::parking::RoadNetworkAccessType RoadNetworkAccessLaneReference::getType() const
{
    return m_type_;
}

void RoadNetworkAccessLaneReference::setType(::nds::venue::parking::RoadNetworkAccessType type_)
{
    m_type_ = type_;
}

::nds::lane::reference::types::LaneGroupReferenceIndirect& RoadNetworkAccessLaneReference::getIndirectReference()
{
    return m_indirectReference_;
}

const ::nds::lane::reference::types::LaneGroupReferenceIndirect& RoadNetworkAccessLaneReference::getIndirectReference() const
{
    return m_indirectReference_;
}

void RoadNetworkAccessLaneReference::setIndirectReference(const ::nds::lane::reference::types::LaneGroupReferenceIndirect& indirectReference_)
{
    m_indirectReference_ = indirectReference_;
}

void RoadNetworkAccessLaneReference::setIndirectReference(::nds::lane::reference::types::LaneGroupReferenceIndirect&& indirectReference_)
{
    m_indirectReference_ = ::std::move(indirectReference_);
}

::nds::lane::reference::types::LaneGroupPositionValidity& RoadNetworkAccessLaneReference::getValidity()
{
    return m_validity_;
}

const ::nds::lane::reference::types::LaneGroupPositionValidity& RoadNetworkAccessLaneReference::getValidity() const
{
    return m_validity_;
}

void RoadNetworkAccessLaneReference::setValidity(const ::nds::lane::reference::types::LaneGroupPositionValidity& validity_)
{
    m_validity_ = validity_;
}

void RoadNetworkAccessLaneReference::setValidity(::nds::lane::reference::types::LaneGroupPositionValidity&& validity_)
{
    m_validity_ = ::std::move(validity_);
}

void RoadNetworkAccessLaneReference::initPackingContext(RoadNetworkAccessLaneReference::ZserioPackingContext& context) const
{
    m_facilityId_.initPackingContext(context.getFacilityId());
    ::zserio::initPackingContext(context.getType(), m_type_);
    m_indirectReference_.initPackingContext(context.getIndirectReference());
    m_validity_.initPackingContext(context.getValidity());
}

size_t RoadNetworkAccessLaneReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_facilityId_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += m_indirectReference_.bitSizeOf(endBitPosition);
    endBitPosition += m_validity_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadNetworkAccessLaneReference::bitSizeOf(RoadNetworkAccessLaneReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_facilityId_.bitSizeOf(context.getFacilityId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += m_indirectReference_.bitSizeOf(context.getIndirectReference(), endBitPosition);
    endBitPosition += m_validity_.bitSizeOf(context.getValidity(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadNetworkAccessLaneReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_facilityId_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = m_indirectReference_.initializeOffsets(endBitPosition);
    endBitPosition = m_validity_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadNetworkAccessLaneReference::initializeOffsets(RoadNetworkAccessLaneReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_facilityId_.initializeOffsets(context.getFacilityId(), endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = m_indirectReference_.initializeOffsets(context.getIndirectReference(), endBitPosition);
    endBitPosition = m_validity_.initializeOffsets(context.getValidity(), endBitPosition);

    return endBitPosition;
}

bool RoadNetworkAccessLaneReference::operator==(const RoadNetworkAccessLaneReference& other) const
{
    if (this != &other)
    {
        return
                (m_facilityId_ == other.m_facilityId_) &&
                (m_type_ == other.m_type_) &&
                (m_indirectReference_ == other.m_indirectReference_) &&
                (m_validity_ == other.m_validity_);
    }

    return true;
}

uint32_t RoadNetworkAccessLaneReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_facilityId_);
    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_indirectReference_);
    result = ::zserio::calcHashCode(result, m_validity_);

    return result;
}

void RoadNetworkAccessLaneReference::write(::zserio::BitStreamWriter& out) const
{
    m_facilityId_.write(out);

    ::zserio::write(out, m_type_);

    m_indirectReference_.write(out);

    // check parameters
    if (m_validity_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field RoadNetworkAccessLaneReference.validity: ") <<
                m_validity_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_validity_.write(out);
}

void RoadNetworkAccessLaneReference::write(RoadNetworkAccessLaneReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_facilityId_.write(context.getFacilityId(), out);

    ::zserio::write(context.getType(), out, m_type_);

    m_indirectReference_.write(context.getIndirectReference(), out);

    // check parameters
    if (m_validity_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field RoadNetworkAccessLaneReference.validity: ") <<
                m_validity_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_validity_.write(context.getValidity(), out);
}

::nds::venue::reference::types::ParkingFacilityId RoadNetworkAccessLaneReference::readFacilityId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingFacilityId(in, allocator);
}

::nds::venue::reference::types::ParkingFacilityId RoadNetworkAccessLaneReference::readFacilityId(RoadNetworkAccessLaneReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingFacilityId(context.getFacilityId(), in, allocator);
}
::nds::venue::parking::RoadNetworkAccessType RoadNetworkAccessLaneReference::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::parking::RoadNetworkAccessType>(in);
}

::nds::venue::parking::RoadNetworkAccessType RoadNetworkAccessLaneReference::readType(RoadNetworkAccessLaneReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::parking::RoadNetworkAccessType>(context.getType(), in);
}
::nds::lane::reference::types::LaneGroupReferenceIndirect RoadNetworkAccessLaneReference::readIndirectReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupReferenceIndirect(in, allocator);
}

::nds::lane::reference::types::LaneGroupReferenceIndirect RoadNetworkAccessLaneReference::readIndirectReference(RoadNetworkAccessLaneReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupReferenceIndirect(context.getIndirectReference(), in, allocator);
}
::nds::lane::reference::types::LaneGroupPositionValidity RoadNetworkAccessLaneReference::readValidity(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupPositionValidity(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::lane::reference::types::LaneGroupPositionValidity RoadNetworkAccessLaneReference::readValidity(RoadNetworkAccessLaneReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupPositionValidity(context.getValidity(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/RoadNetworkAccess.h>

namespace nds
{
namespace venue
{
namespace parking
{

RoadNetworkAccess::RoadNetworkAccess(const allocator_type& allocator) noexcept :
        m_facilityId_(allocator),
        m_type_(::nds::venue::parking::RoadNetworkAccessType())
{
}

RoadNetworkAccess::RoadNetworkAccess(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_facilityId_(readFacilityId(in, allocator)),
        m_type_(readType(in))
{
}

RoadNetworkAccess::RoadNetworkAccess(RoadNetworkAccess::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_facilityId_(readFacilityId(context, in, allocator)),
        m_type_(readType(context, in))
{
}

RoadNetworkAccess::RoadNetworkAccess(::zserio::PropagateAllocatorT,
        const RoadNetworkAccess& other, const allocator_type& allocator) :
        m_facilityId_(::zserio::allocatorPropagatingCopy(other.m_facilityId_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator))
{
}

::nds::venue::reference::types::ParkingFacilityId& RoadNetworkAccess::getFacilityId()
{
    return m_facilityId_;
}

const ::nds::venue::reference::types::ParkingFacilityId& RoadNetworkAccess::getFacilityId() const
{
    return m_facilityId_;
}

void RoadNetworkAccess::setFacilityId(const ::nds::venue::reference::types::ParkingFacilityId& facilityId_)
{
    m_facilityId_ = facilityId_;
}

void RoadNetworkAccess::setFacilityId(::nds::venue::reference::types::ParkingFacilityId&& facilityId_)
{
    m_facilityId_ = ::std::move(facilityId_);
}

::nds::venue::parking::RoadNetworkAccessType RoadNetworkAccess::getType() const
{
    return m_type_;
}

void RoadNetworkAccess::setType(::nds::venue::parking::RoadNetworkAccessType type_)
{
    m_type_ = type_;
}

void RoadNetworkAccess::initPackingContext(RoadNetworkAccess::ZserioPackingContext& context) const
{
    m_facilityId_.initPackingContext(context.getFacilityId());
    ::zserio::initPackingContext(context.getType(), m_type_);
}

size_t RoadNetworkAccess::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_facilityId_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_type_);

    return endBitPosition - bitPosition;
}

size_t RoadNetworkAccess::bitSizeOf(RoadNetworkAccess::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_facilityId_.bitSizeOf(context.getFacilityId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);

    return endBitPosition - bitPosition;
}

size_t RoadNetworkAccess::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_facilityId_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);

    return endBitPosition;
}

size_t RoadNetworkAccess::initializeOffsets(RoadNetworkAccess::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_facilityId_.initializeOffsets(context.getFacilityId(), endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);

    return endBitPosition;
}

bool RoadNetworkAccess::operator==(const RoadNetworkAccess& other) const
{
    if (this != &other)
    {
        return
                (m_facilityId_ == other.m_facilityId_) &&
                (m_type_ == other.m_type_);
    }

    return true;
}

uint32_t RoadNetworkAccess::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_facilityId_);
    result = ::zserio::calcHashCode(result, m_type_);

    return result;
}

void RoadNetworkAccess::write(::zserio::BitStreamWriter& out) const
{
    m_facilityId_.write(out);
    ::zserio::write(out, m_type_);
}

void RoadNetworkAccess::write(RoadNetworkAccess::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_facilityId_.write(context.getFacilityId(), out);
    ::zserio::write(context.getType(), out, m_type_);
}

::nds::venue::reference::types::ParkingFacilityId RoadNetworkAccess::readFacilityId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingFacilityId(in, allocator);
}

::nds::venue::reference::types::ParkingFacilityId RoadNetworkAccess::readFacilityId(RoadNetworkAccess::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::reference::types::ParkingFacilityId(context.getFacilityId(), in, allocator);
}
::nds::venue::parking::RoadNetworkAccessType RoadNetworkAccess::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::parking::RoadNetworkAccessType>(in);
}

::nds::venue::parking::RoadNetworkAccessType RoadNetworkAccess::readType(RoadNetworkAccess::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::parking::RoadNetworkAccessType>(context.getType(), in);
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingRangeRelationValue.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingRangeRelationValue::ParkingRangeRelationValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

ParkingRangeRelationValue::ParkingRangeRelationValue(::zserio::BitStreamReader& in,
        ::nds::venue::parking::ParkingRangeRelationType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

ParkingRangeRelationValue::ParkingRangeRelationValue(ParkingRangeRelationValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::parking::ParkingRangeRelationType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

ParkingRangeRelationValue::ParkingRangeRelationValue(const ParkingRangeRelationValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingRangeRelationValue& ParkingRangeRelationValue::operator=(const ParkingRangeRelationValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRangeRelationValue::ParkingRangeRelationValue(ParkingRangeRelationValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingRangeRelationValue& ParkingRangeRelationValue::operator=(ParkingRangeRelationValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRangeRelationValue::ParkingRangeRelationValue(::zserio::PropagateAllocatorT,
        const ParkingRangeRelationValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void ParkingRangeRelationValue::initialize(
        ::nds::venue::parking::ParkingRangeRelationType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool ParkingRangeRelationValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::venue::parking::ParkingRangeRelationType ParkingRangeRelationValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'ParkingRangeRelationValue' is not initialized!");

    return m_type_;
}

::nds::venue::reference::types::ParkingSectionId& ParkingRangeRelationValue::getSectionId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>();
}

const ::nds::venue::reference::types::ParkingSectionId& ParkingRangeRelationValue::getSectionId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>();
}

void ParkingRangeRelationValue::setSectionId(const ::nds::venue::reference::types::ParkingSectionId& sectionId_)
{
    m_objectChoice = sectionId_;
}

void ParkingRangeRelationValue::setSectionId(::nds::venue::reference::types::ParkingSectionId&& sectionId_)
{
    m_objectChoice = ::std::move(sectionId_);
}

::nds::venue::reference::types::ParkingRowId& ParkingRangeRelationValue::getParkingRowId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>();
}

const ::nds::venue::reference::types::ParkingRowId& ParkingRangeRelationValue::getParkingRowId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>();
}

void ParkingRangeRelationValue::setParkingRowId(const ::nds::venue::reference::types::ParkingRowId& parkingRowId_)
{
    m_objectChoice = parkingRowId_;
}

void ParkingRangeRelationValue::setParkingRowId(::nds::venue::reference::types::ParkingRowId&& parkingRowId_)
{
    m_objectChoice = ::std::move(parkingRowId_);
}

ParkingRangeRelationValue::ChoiceTag ParkingRangeRelationValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        return CHOICE_sectionId;
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        return CHOICE_parkingRowId;
    default:
        return UNDEFINED_CHOICE;
    }
}

void ParkingRangeRelationValue::initPackingContext(ParkingRangeRelationValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initPackingContext(context.getSectionId());
        break;
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().initPackingContext(context.getParkingRowId());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }
}

size_t ParkingRangeRelationValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingRangeRelationValue::bitSizeOf(ParkingRangeRelationValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().bitSizeOf(context.getSectionId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().bitSizeOf(context.getParkingRowId(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingRangeRelationValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }

    return endBitPosition;
}

size_t ParkingRangeRelationValue::initializeOffsets(ParkingRangeRelationValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initializeOffsets(context.getSectionId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().initializeOffsets(context.getParkingRowId(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }

    return endBitPosition;
}

bool ParkingRangeRelationValue::operator==(const ParkingRangeRelationValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>());
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }
}

uint32_t ParkingRangeRelationValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>());
            break;
        case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>());
            break;
        default:
            break;
        }
    }

    return result;
}

void ParkingRangeRelationValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().write(out);
        break;
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }
}

void ParkingRangeRelationValue::write(ParkingRangeRelationValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().write(context.getSectionId(), out);
        break;
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().write(context.getParkingRowId(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }
}

::zserio::AnyHolder<> ParkingRangeRelationValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSectionId(in, allocator), allocator);
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingRowId(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }
}

::zserio::AnyHolder<> ParkingRangeRelationValue::readObject(ParkingRangeRelationValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSectionId(context.getSectionId(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingRowId(context.getParkingRowId(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }
}

::zserio::AnyHolder<> ParkingRangeRelationValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRangeRelationType::PART_OF_SECTION:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingSectionId>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingRangeRelationType::ACCESS_PARKING_ROW:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingRowId>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRangeRelationValue!");
    }
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingPositionRelationValue.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingPositionRelationValue::ParkingPositionRelationValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

ParkingPositionRelationValue::ParkingPositionRelationValue(::zserio::BitStreamReader& in,
        ::nds::venue::parking::ParkingPositionRelationType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

ParkingPositionRelationValue::ParkingPositionRelationValue(ParkingPositionRelationValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::parking::ParkingPositionRelationType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

ParkingPositionRelationValue::ParkingPositionRelationValue(const ParkingPositionRelationValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingPositionRelationValue& ParkingPositionRelationValue::operator=(const ParkingPositionRelationValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingPositionRelationValue::ParkingPositionRelationValue(ParkingPositionRelationValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingPositionRelationValue& ParkingPositionRelationValue::operator=(ParkingPositionRelationValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingPositionRelationValue::ParkingPositionRelationValue(::zserio::PropagateAllocatorT,
        const ParkingPositionRelationValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void ParkingPositionRelationValue::initialize(
        ::nds::venue::parking::ParkingPositionRelationType type_)
{
    m_type_ = type_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingPositionRelationValue::isInitialized() const
{
    return m_isInitialized;
}

void ParkingPositionRelationValue::initializeChildren()
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>().initializeChildren();
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>().initializeChildren();
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }
}

::nds::venue::parking::ParkingPositionRelationType ParkingPositionRelationValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'ParkingPositionRelationValue' is not initialized!");

    return m_type_;
}

::nds::venue::reference::types::ParkingSectionId& ParkingPositionRelationValue::getSectionId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>();
}

const ::nds::venue::reference::types::ParkingSectionId& ParkingPositionRelationValue::getSectionId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>();
}

void ParkingPositionRelationValue::setSectionId(const ::nds::venue::reference::types::ParkingSectionId& sectionId_)
{
    m_objectChoice = sectionId_;
}

void ParkingPositionRelationValue::setSectionId(::nds::venue::reference::types::ParkingSectionId&& sectionId_)
{
    m_objectChoice = ::std::move(sectionId_);
}

::nds::venue::reference::types::ParkingSpotId& ParkingPositionRelationValue::getParkingSpotId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>();
}

const ::nds::venue::reference::types::ParkingSpotId& ParkingPositionRelationValue::getParkingSpotId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>();
}

void ParkingPositionRelationValue::setParkingSpotId(const ::nds::venue::reference::types::ParkingSpotId& parkingSpotId_)
{
    m_objectChoice = parkingSpotId_;
}

void ParkingPositionRelationValue::setParkingSpotId(::nds::venue::reference::types::ParkingSpotId&& parkingSpotId_)
{
    m_objectChoice = ::std::move(parkingSpotId_);
}

::nds::venue::parking::RoadNetworkAccessRoadReference& ParkingPositionRelationValue::getOutsideRoadReference()
{
    return m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>();
}

const ::nds::venue::parking::RoadNetworkAccessRoadReference& ParkingPositionRelationValue::getOutsideRoadReference() const
{
    return m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>();
}

void ParkingPositionRelationValue::setOutsideRoadReference(const ::nds::venue::parking::RoadNetworkAccessRoadReference& outsideRoadReference_)
{
    m_objectChoice = outsideRoadReference_;
}

void ParkingPositionRelationValue::setOutsideRoadReference(::nds::venue::parking::RoadNetworkAccessRoadReference&& outsideRoadReference_)
{
    m_objectChoice = ::std::move(outsideRoadReference_);
}

::nds::venue::parking::RoadNetworkAccessLaneReference& ParkingPositionRelationValue::getOutsideLaneReference()
{
    return m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>();
}

const ::nds::venue::parking::RoadNetworkAccessLaneReference& ParkingPositionRelationValue::getOutsideLaneReference() const
{
    return m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>();
}

void ParkingPositionRelationValue::setOutsideLaneReference(const ::nds::venue::parking::RoadNetworkAccessLaneReference& outsideLaneReference_)
{
    m_objectChoice = outsideLaneReference_;
}

void ParkingPositionRelationValue::setOutsideLaneReference(::nds::venue::parking::RoadNetworkAccessLaneReference&& outsideLaneReference_)
{
    m_objectChoice = ::std::move(outsideLaneReference_);
}

::nds::venue::parking::RoadNetworkAccess& ParkingPositionRelationValue::getRoadNetworkAccess()
{
    return m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>();
}

const ::nds::venue::parking::RoadNetworkAccess& ParkingPositionRelationValue::getRoadNetworkAccess() const
{
    return m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>();
}

void ParkingPositionRelationValue::setRoadNetworkAccess(const ::nds::venue::parking::RoadNetworkAccess& roadNetworkAccess_)
{
    m_objectChoice = roadNetworkAccess_;
}

void ParkingPositionRelationValue::setRoadNetworkAccess(::nds::venue::parking::RoadNetworkAccess&& roadNetworkAccess_)
{
    m_objectChoice = ::std::move(roadNetworkAccess_);
}

ParkingPositionRelationValue::ChoiceTag ParkingPositionRelationValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        return CHOICE_sectionId;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        return CHOICE_parkingSpotId;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        return CHOICE_outsideRoadReference;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        return CHOICE_outsideLaneReference;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        return CHOICE_roadNetworkAccess;
    default:
        return UNDEFINED_CHOICE;
    }
}

void ParkingPositionRelationValue::initPackingContext(ParkingPositionRelationValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initPackingContext(context.getSectionId());
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().initPackingContext(context.getParkingSpotId());
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>().initPackingContext(context.getOutsideRoadReference());
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>().initPackingContext(context.getOutsideLaneReference());
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>().initPackingContext(context.getRoadNetworkAccess());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }
}

size_t ParkingPositionRelationValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        endBitPosition += m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        endBitPosition += m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        endBitPosition += m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingPositionRelationValue::bitSizeOf(ParkingPositionRelationValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().bitSizeOf(context.getSectionId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().bitSizeOf(context.getParkingSpotId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        endBitPosition += m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>().bitSizeOf(context.getOutsideRoadReference(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        endBitPosition += m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>().bitSizeOf(context.getOutsideLaneReference(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        endBitPosition += m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>().bitSizeOf(context.getRoadNetworkAccess(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingPositionRelationValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        endBitPosition = m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        endBitPosition = m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        endBitPosition = m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }

    return endBitPosition;
}

size_t ParkingPositionRelationValue::initializeOffsets(ParkingPositionRelationValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initializeOffsets(context.getSectionId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().initializeOffsets(context.getParkingSpotId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        endBitPosition = m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>().initializeOffsets(context.getOutsideRoadReference(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        endBitPosition = m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>().initializeOffsets(context.getOutsideLaneReference(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        endBitPosition = m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>().initializeOffsets(context.getRoadNetworkAccess(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }

    return endBitPosition;
}

bool ParkingPositionRelationValue::operator==(const ParkingPositionRelationValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>());
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>());
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>() == other.m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>());
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>() == other.m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>());
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>() == other.m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }
}

uint32_t ParkingPositionRelationValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>());
            break;
        case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>());
            break;
        case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>());
            break;
        case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>());
            break;
        case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>());
            break;
        default:
            break;
        }
    }

    return result;
}

void ParkingPositionRelationValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().write(out);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().write(out);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>().write(out);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>().write(out);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }
}

void ParkingPositionRelationValue::write(ParkingPositionRelationValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().write(context.getSectionId(), out);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().write(context.getParkingSpotId(), out);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessRoadReference>().write(context.getOutsideRoadReference(), out);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccessLaneReference>().write(context.getOutsideLaneReference(), out);
        break;
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        m_objectChoice.get<::nds::venue::parking::RoadNetworkAccess>().write(context.getRoadNetworkAccess(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }
}

::zserio::AnyHolder<> ParkingPositionRelationValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSectionId(in, allocator), allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSpotId(in, allocator), allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        return ::zserio::AnyHolder<>(::nds::venue::parking::RoadNetworkAccessRoadReference(in, allocator), allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        return ::zserio::AnyHolder<>(::nds::venue::parking::RoadNetworkAccessLaneReference(in, allocator), allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        return ::zserio::AnyHolder<>(::nds::venue::parking::RoadNetworkAccess(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }
}

::zserio::AnyHolder<> ParkingPositionRelationValue::readObject(ParkingPositionRelationValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSectionId(context.getSectionId(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSpotId(context.getParkingSpotId(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        return ::zserio::AnyHolder<>(::nds::venue::parking::RoadNetworkAccessRoadReference(context.getOutsideRoadReference(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        return ::zserio::AnyHolder<>(::nds::venue::parking::RoadNetworkAccessLaneReference(context.getOutsideLaneReference(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        return ::zserio::AnyHolder<>(::nds::venue::parking::RoadNetworkAccess(context.getRoadNetworkAccess(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }
}

::zserio::AnyHolder<> ParkingPositionRelationValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingPositionRelationType::PART_OF_SECTION:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingSectionId>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ACCESS_PARKING_SPOT:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingSpotId>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_ROAD_REFERENCE:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::parking::RoadNetworkAccessRoadReference>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS_LANE_REFERENCE:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::parking::RoadNetworkAccessLaneReference>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingPositionRelationType::ROAD_NETWORK_ACCESS:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::parking::RoadNetworkAccess>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingPositionRelationValue!");
    }
}

} // namespace parking
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/parking/ParkingRelationValue.h>

namespace nds
{
namespace venue
{
namespace parking
{

ParkingRelationValue::ParkingRelationValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

ParkingRelationValue::ParkingRelationValue(::zserio::BitStreamReader& in,
        ::nds::venue::parking::ParkingRelationType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

ParkingRelationValue::ParkingRelationValue(ParkingRelationValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::parking::ParkingRelationType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

ParkingRelationValue::ParkingRelationValue(const ParkingRelationValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingRelationValue& ParkingRelationValue::operator=(const ParkingRelationValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRelationValue::ParkingRelationValue(ParkingRelationValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingRelationValue& ParkingRelationValue::operator=(ParkingRelationValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRelationValue::ParkingRelationValue(::zserio::PropagateAllocatorT,
        const ParkingRelationValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void ParkingRelationValue::initialize(
        ::nds::venue::parking::ParkingRelationType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool ParkingRelationValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::venue::parking::ParkingRelationType ParkingRelationValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'ParkingRelationValue' is not initialized!");

    return m_type_;
}

::nds::venue::reference::types::ParkingSectionId& ParkingRelationValue::getPartOfSectionId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>();
}

const ::nds::venue::reference::types::ParkingSectionId& ParkingRelationValue::getPartOfSectionId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>();
}

void ParkingRelationValue::setPartOfSectionId(const ::nds::venue::reference::types::ParkingSectionId& partOfSectionId_)
{
    m_objectChoice = partOfSectionId_;
}

void ParkingRelationValue::setPartOfSectionId(::nds::venue::reference::types::ParkingSectionId&& partOfSectionId_)
{
    m_objectChoice = ::std::move(partOfSectionId_);
}

::nds::venue::reference::types::ParkingRowId& ParkingRelationValue::getPartOfRowId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>();
}

const ::nds::venue::reference::types::ParkingRowId& ParkingRelationValue::getPartOfRowId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>();
}

void ParkingRelationValue::setPartOfRowId(const ::nds::venue::reference::types::ParkingRowId& partOfRowId_)
{
    m_objectChoice = partOfRowId_;
}

void ParkingRelationValue::setPartOfRowId(::nds::venue::reference::types::ParkingRowId&& partOfRowId_)
{
    m_objectChoice = ::std::move(partOfRowId_);
}

::nds::venue::reference::types::ParkingSpotId& ParkingRelationValue::getPartOfSpotId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>();
}

const ::nds::venue::reference::types::ParkingSpotId& ParkingRelationValue::getPartOfSpotId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>();
}

void ParkingRelationValue::setPartOfSpotId(const ::nds::venue::reference::types::ParkingSpotId& partOfSpotId_)
{
    m_objectChoice = partOfSpotId_;
}

void ParkingRelationValue::setPartOfSpotId(::nds::venue::reference::types::ParkingSpotId&& partOfSpotId_)
{
    m_objectChoice = ::std::move(partOfSpotId_);
}

::nds::venue::reference::types::ParkingSectionId& ParkingRelationValue::getSectionId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>();
}

const ::nds::venue::reference::types::ParkingSectionId& ParkingRelationValue::getSectionId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>();
}

void ParkingRelationValue::setSectionId(const ::nds::venue::reference::types::ParkingSectionId& sectionId_)
{
    m_objectChoice = sectionId_;
}

void ParkingRelationValue::setSectionId(::nds::venue::reference::types::ParkingSectionId&& sectionId_)
{
    m_objectChoice = ::std::move(sectionId_);
}

::nds::venue::reference::types::ParkingRowId& ParkingRelationValue::getRowId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>();
}

const ::nds::venue::reference::types::ParkingRowId& ParkingRelationValue::getRowId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>();
}

void ParkingRelationValue::setRowId(const ::nds::venue::reference::types::ParkingRowId& rowId_)
{
    m_objectChoice = rowId_;
}

void ParkingRelationValue::setRowId(::nds::venue::reference::types::ParkingRowId&& rowId_)
{
    m_objectChoice = ::std::move(rowId_);
}

::nds::venue::reference::types::ParkingSpotId& ParkingRelationValue::getSpotId()
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>();
}

const ::nds::venue::reference::types::ParkingSpotId& ParkingRelationValue::getSpotId() const
{
    return m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>();
}

void ParkingRelationValue::setSpotId(const ::nds::venue::reference::types::ParkingSpotId& spotId_)
{
    m_objectChoice = spotId_;
}

void ParkingRelationValue::setSpotId(::nds::venue::reference::types::ParkingSpotId&& spotId_)
{
    m_objectChoice = ::std::move(spotId_);
}

ParkingRelationValue::ChoiceTag ParkingRelationValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        return CHOICE_partOfSectionId;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        return CHOICE_partOfRowId;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        return CHOICE_partOfSpotId;
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        return CHOICE_sectionId;
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        return CHOICE_rowId;
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        return CHOICE_spotId;
    default:
        return UNDEFINED_CHOICE;
    }
}

void ParkingRelationValue::initPackingContext(ParkingRelationValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initPackingContext(context.getPartOfSectionId());
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().initPackingContext(context.getPartOfRowId());
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().initPackingContext(context.getPartOfSpotId());
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initPackingContext(context.getSectionId());
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().initPackingContext(context.getRowId());
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().initPackingContext(context.getSpotId());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }
}

size_t ParkingRelationValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingRelationValue::bitSizeOf(ParkingRelationValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().bitSizeOf(context.getPartOfSectionId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().bitSizeOf(context.getPartOfRowId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().bitSizeOf(context.getPartOfSpotId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().bitSizeOf(context.getSectionId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().bitSizeOf(context.getRowId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        endBitPosition += m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().bitSizeOf(context.getSpotId(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingRelationValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }

    return endBitPosition;
}

size_t ParkingRelationValue::initializeOffsets(ParkingRelationValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initializeOffsets(context.getPartOfSectionId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().initializeOffsets(context.getPartOfRowId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().initializeOffsets(context.getPartOfSpotId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().initializeOffsets(context.getSectionId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().initializeOffsets(context.getRowId(), endBitPosition);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        endBitPosition = m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().initializeOffsets(context.getSpotId(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }

    return endBitPosition;
}

bool ParkingRelationValue::operator==(const ParkingRelationValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>());
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>());
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>());
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>());
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>());
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>() == other.m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }
}

uint32_t ParkingRelationValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>());
            break;
        case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>());
            break;
        case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>());
            break;
        case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>());
            break;
        case ::nds::venue::parking::ParkingRelationType::IS_ROW:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>());
            break;
        case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>());
            break;
        default:
            break;
        }
    }

    return result;
}

void ParkingRelationValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().write(out);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().write(out);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().write(out);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().write(out);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().write(out);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }
}

void ParkingRelationValue::write(ParkingRelationValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().write(context.getPartOfSectionId(), out);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().write(context.getPartOfRowId(), out);
        break;
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().write(context.getPartOfSpotId(), out);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSectionId>().write(context.getSectionId(), out);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        m_objectChoice.get<::nds::venue::reference::types::ParkingRowId>().write(context.getRowId(), out);
        break;
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        m_objectChoice.get<::nds::venue::reference::types::ParkingSpotId>().write(context.getSpotId(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }
}

::zserio::AnyHolder<> ParkingRelationValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSectionId(in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingRowId(in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSpotId(in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSectionId(in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingRowId(in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSpotId(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }
}

::zserio::AnyHolder<> ParkingRelationValue::readObject(ParkingRelationValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSectionId(context.getPartOfSectionId(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingRowId(context.getPartOfRowId(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSpotId(context.getPartOfSpotId(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSectionId(context.getSectionId(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingRowId(context.getRowId(), in, allocator), allocator);
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        return ::zserio::AnyHolder<>(::nds::venue::reference::types::ParkingSpotId(context.getSpotId(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }
}

::zserio::AnyHolder<> ParkingRelationValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SECTION:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingSectionId>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingRelationType::PART_OF_ROW:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingRowId>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingRelationType::PART_OF_SPOT:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingSpotId>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingRelationType::IS_SECTION:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingSectionId>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingRelationType::IS_ROW:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingRowId>(m_objectChoice, allocator);
    case ::nds::venue::parking::ParkingRelationType::IS_SPOT:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::reference::types::ParkingSpotId>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRelationValue!");
    }
}

} // namespace parking
} // namespace venue
} // namespace nds
