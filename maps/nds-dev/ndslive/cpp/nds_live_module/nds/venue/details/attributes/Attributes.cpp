/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/venue/details/attributes/ParkingFacilityAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ParkingFacilityAttributeType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::venue::details::attributes::ParkingFacilityAttributeType>::names;
constexpr ::std::array<::nds::venue::details::attributes::ParkingFacilityAttributeType, 2> EnumTraits<::nds::venue::details::attributes::ParkingFacilityAttributeType>::values;
constexpr const char* EnumTraits<::nds::venue::details::attributes::ParkingFacilityAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::venue::details::attributes::ParkingFacilityAttributeType value)
{
    switch (value)
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        return 0;
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingFacilityAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingFacilityAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::venue::details::attributes::ParkingFacilityAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::venue::details::attributes::ParkingFacilityAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
        return static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingFacilityAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::venue::details::attributes::ParkingFacilityAttributeType>(::nds::venue::details::attributes::ParkingFacilityAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingFacilityAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingFacilityAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::venue::details::attributes::ParkingFacilityAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingFacilityAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingFacilityAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::venue::details::attributes::ParkingFacilityAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::venue::details::attributes::ParkingFacilityAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::venue::details::attributes::ParkingFacilityAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingFacilityAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingFacilityAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::venue::details::attributes::ParkingFacilityAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingFacilityAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingFacilityAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingFacilityAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingFacilityAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingFacilityAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/venue/details/attributes/ParkingLevelAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ParkingLevelAttributeType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::venue::details::attributes::ParkingLevelAttributeType>::names;
constexpr ::std::array<::nds::venue::details::attributes::ParkingLevelAttributeType, 3> EnumTraits<::nds::venue::details::attributes::ParkingLevelAttributeType>::values;
constexpr const char* EnumTraits<::nds::venue::details::attributes::ParkingLevelAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::venue::details::attributes::ParkingLevelAttributeType value)
{
    switch (value)
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        return 0;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        return 1;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingLevelAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingLevelAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::venue::details::attributes::ParkingLevelAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::venue::details::attributes::ParkingLevelAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
        return static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingLevelAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::venue::details::attributes::ParkingLevelAttributeType>(::nds::venue::details::attributes::ParkingLevelAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingLevelAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingLevelAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::venue::details::attributes::ParkingLevelAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingLevelAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingLevelAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::venue::details::attributes::ParkingLevelAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::venue::details::attributes::ParkingLevelAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::venue::details::attributes::ParkingLevelAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingLevelAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingLevelAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::venue::details::attributes::ParkingLevelAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingLevelAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingLevelAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingLevelAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingLevelAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingLevelAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/venue/details/attributes/ParkingSectionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ParkingSectionAttributeType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::venue::details::attributes::ParkingSectionAttributeType>::names;
constexpr ::std::array<::nds::venue::details::attributes::ParkingSectionAttributeType, 2> EnumTraits<::nds::venue::details::attributes::ParkingSectionAttributeType>::values;
constexpr const char* EnumTraits<::nds::venue::details::attributes::ParkingSectionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::venue::details::attributes::ParkingSectionAttributeType value)
{
    switch (value)
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        return 0;
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingSectionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSectionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::venue::details::attributes::ParkingSectionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSectionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
        return static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingSectionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::venue::details::attributes::ParkingSectionAttributeType>(::nds::venue::details::attributes::ParkingSectionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingSectionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSectionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::venue::details::attributes::ParkingSectionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingSectionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSectionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::venue::details::attributes::ParkingSectionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::venue::details::attributes::ParkingSectionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::venue::details::attributes::ParkingSectionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingSectionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSectionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::venue::details::attributes::ParkingSectionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingSectionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSectionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingSectionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingSectionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSectionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/venue/details/attributes/ParkingRowAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ParkingRowAttributeType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::venue::details::attributes::ParkingRowAttributeType>::names;
constexpr ::std::array<::nds::venue::details::attributes::ParkingRowAttributeType, 3> EnumTraits<::nds::venue::details::attributes::ParkingRowAttributeType>::values;
constexpr const char* EnumTraits<::nds::venue::details::attributes::ParkingRowAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::venue::details::attributes::ParkingRowAttributeType value)
{
    switch (value)
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        return 0;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        return 1;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingRowAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingRowAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::venue::details::attributes::ParkingRowAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::venue::details::attributes::ParkingRowAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
        return static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingRowAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::venue::details::attributes::ParkingRowAttributeType>(::nds::venue::details::attributes::ParkingRowAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingRowAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingRowAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::venue::details::attributes::ParkingRowAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingRowAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingRowAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::venue::details::attributes::ParkingRowAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::venue::details::attributes::ParkingRowAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::venue::details::attributes::ParkingRowAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingRowAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingRowAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::venue::details::attributes::ParkingRowAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingRowAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingRowAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingRowAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingRowAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingRowAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/venue/details/attributes/ParkingSpotAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ParkingSpotAttributeType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::venue::details::attributes::ParkingSpotAttributeType>::names;
constexpr ::std::array<::nds::venue::details::attributes::ParkingSpotAttributeType, 4> EnumTraits<::nds::venue::details::attributes::ParkingSpotAttributeType>::values;
constexpr const char* EnumTraits<::nds::venue::details::attributes::ParkingSpotAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::venue::details::attributes::ParkingSpotAttributeType value)
{
    switch (value)
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        return 0;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        return 1;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        return 2;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingSpotAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSpotAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::venue::details::attributes::ParkingSpotAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSpotAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
        return static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ParkingSpotAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::venue::details::attributes::ParkingSpotAttributeType>(::nds::venue::details::attributes::ParkingSpotAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingSpotAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSpotAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::venue::details::attributes::ParkingSpotAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::venue::details::attributes::ParkingSpotAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSpotAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::venue::details::attributes::ParkingSpotAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::venue::details::attributes::ParkingSpotAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::venue::details::attributes::ParkingSpotAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingSpotAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSpotAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::venue::details::attributes::ParkingSpotAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::venue::details::attributes::ParkingSpotAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSpotAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingSpotAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::venue::details::attributes::ParkingSpotAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::venue::details::attributes::ParkingSpotAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/attributes/ParkingFacilityAttributeValue.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace attributes
{

ParkingFacilityAttributeValue::ParkingFacilityAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

ParkingFacilityAttributeValue::ParkingFacilityAttributeValue(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingFacilityAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

ParkingFacilityAttributeValue::ParkingFacilityAttributeValue(ParkingFacilityAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingFacilityAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

ParkingFacilityAttributeValue::ParkingFacilityAttributeValue(const ParkingFacilityAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeValue& ParkingFacilityAttributeValue::operator=(const ParkingFacilityAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeValue::ParkingFacilityAttributeValue(ParkingFacilityAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeValue& ParkingFacilityAttributeValue::operator=(ParkingFacilityAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeValue::ParkingFacilityAttributeValue(::zserio::PropagateAllocatorT,
        const ParkingFacilityAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void ParkingFacilityAttributeValue::initialize(
        ::nds::venue::details::attributes::ParkingFacilityAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool ParkingFacilityAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::venue::details::attributes::ParkingFacilityAttributeType ParkingFacilityAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'ParkingFacilityAttributeValue' is not initialized!");

    return m_type_;
}

::nds::venue::details::types::ParkingFacilitySize ParkingFacilityAttributeValue::getSize() const
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>();
}

void ParkingFacilityAttributeValue::setSize(::nds::venue::details::types::ParkingFacilitySize size_)
{
    m_objectChoice = size_;
}

::nds::venue::details::types::ProhibitedAccess& ParkingFacilityAttributeValue::getProhibitedAccess()
{
    return m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>();
}

const ::nds::venue::details::types::ProhibitedAccess& ParkingFacilityAttributeValue::getProhibitedAccess() const
{
    return m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>();
}

void ParkingFacilityAttributeValue::setProhibitedAccess(const ::nds::venue::details::types::ProhibitedAccess& prohibitedAccess_)
{
    m_objectChoice = prohibitedAccess_;
}

void ParkingFacilityAttributeValue::setProhibitedAccess(::nds::venue::details::types::ProhibitedAccess&& prohibitedAccess_)
{
    m_objectChoice = ::std::move(prohibitedAccess_);
}

ParkingFacilityAttributeValue::ChoiceTag ParkingFacilityAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        return CHOICE_size;
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        return CHOICE_prohibitedAccess;
    default:
        return UNDEFINED_CHOICE;
    }
}

void ParkingFacilityAttributeValue::initPackingContext(ParkingFacilityAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        context.getSize().init<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingFacilitySize>>(m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>());
        break;
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }
}

size_t ParkingFacilityAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>());
        break;
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeValue::bitSizeOf(ParkingFacilityAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        endBitPosition += context.getSize().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingFacilitySize>>(m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>());
        break;
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>());
        break;
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }

    return endBitPosition;
}

size_t ParkingFacilityAttributeValue::initializeOffsets(ParkingFacilityAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        endBitPosition += context.getSize().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingFacilitySize>>(m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>());
        break;
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }

    return endBitPosition;
}

bool ParkingFacilityAttributeValue::operator==(const ParkingFacilityAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>() == other.m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>());
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>() == other.m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }
}

uint32_t ParkingFacilityAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>());
            break;
        case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>());
            break;
        default:
            break;
        }
    }

    return result;
}

void ParkingFacilityAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        out.writeVarUInt16(m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>());
        break;
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }
}

void ParkingFacilityAttributeValue::write(ParkingFacilityAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        context.getSize().write<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingFacilitySize>>(out, m_objectChoice.get<::nds::venue::details::types::ParkingFacilitySize>());
        break;
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingFacilityAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        return ::zserio::AnyHolder<>(static_cast<::nds::venue::details::types::ParkingFacilitySize>(in.readVarUInt16()), allocator);
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ProhibitedAccess(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingFacilityAttributeValue::readObject(ParkingFacilityAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        return ::zserio::AnyHolder<>(context.getSize().read<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingFacilitySize>>(in), allocator);
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ProhibitedAccess(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingFacilityAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PARKING_FACILITY_SIZE:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ParkingFacilitySize>(m_objectChoice, allocator);
    case ::nds::venue::details::attributes::ParkingFacilityAttributeType::PROHIBITED_ACCESS:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ProhibitedAccess>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingFacilityAttributeValue!");
    }
}

} // namespace attributes
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/attributes/ParkingLevelAttributeValue.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace attributes
{

ParkingLevelAttributeValue::ParkingLevelAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

ParkingLevelAttributeValue::ParkingLevelAttributeValue(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingLevelAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

ParkingLevelAttributeValue::ParkingLevelAttributeValue(ParkingLevelAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingLevelAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

ParkingLevelAttributeValue::ParkingLevelAttributeValue(const ParkingLevelAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeValue& ParkingLevelAttributeValue::operator=(const ParkingLevelAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeValue::ParkingLevelAttributeValue(ParkingLevelAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeValue& ParkingLevelAttributeValue::operator=(ParkingLevelAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeValue::ParkingLevelAttributeValue(::zserio::PropagateAllocatorT,
        const ParkingLevelAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void ParkingLevelAttributeValue::initialize(
        ::nds::venue::details::attributes::ParkingLevelAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool ParkingLevelAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::venue::details::attributes::ParkingLevelAttributeType ParkingLevelAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'ParkingLevelAttributeValue' is not initialized!");

    return m_type_;
}

::nds::venue::details::types::ParkingLevelName& ParkingLevelAttributeValue::getParkingLevelName()
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>();
}

const ::nds::venue::details::types::ParkingLevelName& ParkingLevelAttributeValue::getParkingLevelName() const
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>();
}

void ParkingLevelAttributeValue::setParkingLevelName(const ::nds::venue::details::types::ParkingLevelName& parkingLevelName_)
{
    m_objectChoice = parkingLevelName_;
}

void ParkingLevelAttributeValue::setParkingLevelName(::nds::venue::details::types::ParkingLevelName&& parkingLevelName_)
{
    m_objectChoice = ::std::move(parkingLevelName_);
}

::nds::venue::details::types::ProhibitedAccess& ParkingLevelAttributeValue::getProhibitedAccess()
{
    return m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>();
}

const ::nds::venue::details::types::ProhibitedAccess& ParkingLevelAttributeValue::getProhibitedAccess() const
{
    return m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>();
}

void ParkingLevelAttributeValue::setProhibitedAccess(const ::nds::venue::details::types::ProhibitedAccess& prohibitedAccess_)
{
    m_objectChoice = prohibitedAccess_;
}

void ParkingLevelAttributeValue::setProhibitedAccess(::nds::venue::details::types::ProhibitedAccess&& prohibitedAccess_)
{
    m_objectChoice = ::std::move(prohibitedAccess_);
}

::nds::venue::details::types::ParkingLevelSlope ParkingLevelAttributeValue::getSlope() const
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>();
}

void ParkingLevelAttributeValue::setSlope(::nds::venue::details::types::ParkingLevelSlope slope_)
{
    m_objectChoice = slope_;
}

ParkingLevelAttributeValue::ChoiceTag ParkingLevelAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        return CHOICE_parkingLevelName;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        return CHOICE_prohibitedAccess;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        return CHOICE_slope;
    default:
        return UNDEFINED_CHOICE;
    }
}

void ParkingLevelAttributeValue::initPackingContext(ParkingLevelAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        context.getSlope().init<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingLevelSlope>>(m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }
}

size_t ParkingLevelAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>());
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeValue::bitSizeOf(ParkingLevelAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>());
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        endBitPosition += context.getSlope().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingLevelSlope>>(m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>());
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }

    return endBitPosition;
}

size_t ParkingLevelAttributeValue::initializeOffsets(ParkingLevelAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>());
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        endBitPosition += context.getSlope().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingLevelSlope>>(m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }

    return endBitPosition;
}

bool ParkingLevelAttributeValue::operator==(const ParkingLevelAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>() == other.m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>());
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>() == other.m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>());
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>() == other.m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }
}

uint32_t ParkingLevelAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>());
            break;
        case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>());
            break;
        case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>());
            break;
        default:
            break;
        }
    }

    return result;
}

void ParkingLevelAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        out.writeString(m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>());
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().write(out);
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        out.writeVarUInt16(m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }
}

void ParkingLevelAttributeValue::write(ParkingLevelAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        out.writeString(m_objectChoice.get<::nds::venue::details::types::ParkingLevelName>());
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().write(out);
        break;
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        context.getSlope().write<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingLevelSlope>>(out, m_objectChoice.get<::nds::venue::details::types::ParkingLevelSlope>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingLevelAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::venue::details::types::ParkingLevelName>(in.readString(allocator)), allocator);
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ProhibitedAccess(in, allocator), allocator);
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        return ::zserio::AnyHolder<>(static_cast<::nds::venue::details::types::ParkingLevelSlope>(in.readVarUInt16()), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingLevelAttributeValue::readObject(ParkingLevelAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::venue::details::types::ParkingLevelName>(in.readString(allocator)), allocator);
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ProhibitedAccess(in, allocator), allocator);
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        return ::zserio::AnyHolder<>(context.getSlope().read<::zserio::VarIntNNArrayTraits<::nds::venue::details::types::ParkingLevelSlope>>(in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingLevelAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ParkingLevelName>(m_objectChoice, allocator);
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PROHIBITED_ACCESS:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ProhibitedAccess>(m_objectChoice, allocator);
    case ::nds::venue::details::attributes::ParkingLevelAttributeType::PARKING_LEVEL_SLOPE:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ParkingLevelSlope>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingLevelAttributeValue!");
    }
}

} // namespace attributes
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/attributes/ParkingSectionAttributeValue.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace attributes
{

ParkingSectionAttributeValue::ParkingSectionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

ParkingSectionAttributeValue::ParkingSectionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingSectionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

ParkingSectionAttributeValue::ParkingSectionAttributeValue(ParkingSectionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingSectionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

ParkingSectionAttributeValue::ParkingSectionAttributeValue(const ParkingSectionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeValue& ParkingSectionAttributeValue::operator=(const ParkingSectionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeValue::ParkingSectionAttributeValue(ParkingSectionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeValue& ParkingSectionAttributeValue::operator=(ParkingSectionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeValue::ParkingSectionAttributeValue(::zserio::PropagateAllocatorT,
        const ParkingSectionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void ParkingSectionAttributeValue::initialize(
        ::nds::venue::details::attributes::ParkingSectionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool ParkingSectionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::venue::details::attributes::ParkingSectionAttributeType ParkingSectionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'ParkingSectionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::venue::details::types::ParkingSectionType ParkingSectionAttributeValue::getParkingSectionType() const
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>();
}

void ParkingSectionAttributeValue::setParkingSectionType(::nds::venue::details::types::ParkingSectionType parkingSectionType_)
{
    m_objectChoice = parkingSectionType_;
}

::nds::venue::details::types::ProhibitedAccess& ParkingSectionAttributeValue::getProhibitedAccess()
{
    return m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>();
}

const ::nds::venue::details::types::ProhibitedAccess& ParkingSectionAttributeValue::getProhibitedAccess() const
{
    return m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>();
}

void ParkingSectionAttributeValue::setProhibitedAccess(const ::nds::venue::details::types::ProhibitedAccess& prohibitedAccess_)
{
    m_objectChoice = prohibitedAccess_;
}

void ParkingSectionAttributeValue::setProhibitedAccess(::nds::venue::details::types::ProhibitedAccess&& prohibitedAccess_)
{
    m_objectChoice = ::std::move(prohibitedAccess_);
}

ParkingSectionAttributeValue::ChoiceTag ParkingSectionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        return CHOICE_parkingSectionType;
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        return CHOICE_prohibitedAccess;
    default:
        return UNDEFINED_CHOICE;
    }
}

void ParkingSectionAttributeValue::initPackingContext(ParkingSectionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        ::zserio::initPackingContext(context.getParkingSectionType(), m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>());
        break;
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }
}

size_t ParkingSectionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>());
        break;
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeValue::bitSizeOf(ParkingSectionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        endBitPosition += ::zserio::bitSizeOf(context.getParkingSectionType(), m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>());
        break;
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>());
        break;
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }

    return endBitPosition;
}

size_t ParkingSectionAttributeValue::initializeOffsets(ParkingSectionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        endBitPosition = ::zserio::initializeOffsets(context.getParkingSectionType(), endBitPosition,
        m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>());
        break;
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }

    return endBitPosition;
}

bool ParkingSectionAttributeValue::operator==(const ParkingSectionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>() == other.m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>());
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>() == other.m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }
}

uint32_t ParkingSectionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>());
            break;
        case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>());
            break;
        default:
            break;
        }
    }

    return result;
}

void ParkingSectionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        ::zserio::write(out, m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>());
        break;
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }
}

void ParkingSectionAttributeValue::write(ParkingSectionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        ::zserio::write(context.getParkingSectionType(), out, m_objectChoice.get<::nds::venue::details::types::ParkingSectionType>());
        break;
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        m_objectChoice.get<::nds::venue::details::types::ProhibitedAccess>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingSectionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::venue::details::types::ParkingSectionType>(in), allocator);
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ProhibitedAccess(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingSectionAttributeValue::readObject(ParkingSectionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::venue::details::types::ParkingSectionType>(context.getParkingSectionType(), in), allocator);
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ProhibitedAccess(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingSectionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PARKING_SECTION_TYPE:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ParkingSectionType>(m_objectChoice, allocator);
    case ::nds::venue::details::attributes::ParkingSectionAttributeType::PROHIBITED_ACCESS:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ProhibitedAccess>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSectionAttributeValue!");
    }
}

} // namespace attributes
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/attributes/ParkingRowAttributeValue.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace attributes
{

ParkingRowAttributeValue::ParkingRowAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

ParkingRowAttributeValue::ParkingRowAttributeValue(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingRowAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

ParkingRowAttributeValue::ParkingRowAttributeValue(ParkingRowAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingRowAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

ParkingRowAttributeValue::ParkingRowAttributeValue(const ParkingRowAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeValue& ParkingRowAttributeValue::operator=(const ParkingRowAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeValue::ParkingRowAttributeValue(ParkingRowAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeValue& ParkingRowAttributeValue::operator=(ParkingRowAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeValue::ParkingRowAttributeValue(::zserio::PropagateAllocatorT,
        const ParkingRowAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void ParkingRowAttributeValue::initialize(
        ::nds::venue::details::attributes::ParkingRowAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool ParkingRowAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::venue::details::attributes::ParkingRowAttributeType ParkingRowAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'ParkingRowAttributeValue' is not initialized!");

    return m_type_;
}

::nds::venue::details::types::ParkingRowName& ParkingRowAttributeValue::getParkingRowName()
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingRowName>();
}

const ::nds::venue::details::types::ParkingRowName& ParkingRowAttributeValue::getParkingRowName() const
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingRowName>();
}

void ParkingRowAttributeValue::setParkingRowName(const ::nds::venue::details::types::ParkingRowName& parkingRowName_)
{
    m_objectChoice = parkingRowName_;
}

void ParkingRowAttributeValue::setParkingRowName(::nds::venue::details::types::ParkingRowName&& parkingRowName_)
{
    m_objectChoice = ::std::move(parkingRowName_);
}

::nds::venue::details::types::ParkingRowLayout& ParkingRowAttributeValue::getParkingRowLayout()
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>();
}

const ::nds::venue::details::types::ParkingRowLayout& ParkingRowAttributeValue::getParkingRowLayout() const
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>();
}

void ParkingRowAttributeValue::setParkingRowLayout(const ::nds::venue::details::types::ParkingRowLayout& parkingRowLayout_)
{
    m_objectChoice = parkingRowLayout_;
}

void ParkingRowAttributeValue::setParkingRowLayout(::nds::venue::details::types::ParkingRowLayout&& parkingRowLayout_)
{
    m_objectChoice = ::std::move(parkingRowLayout_);
}

::nds::venue::details::types::ParkingRestrictions ParkingRowAttributeValue::getParkingRowRestrictions() const
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>();
}

void ParkingRowAttributeValue::setParkingRowRestrictions(::nds::venue::details::types::ParkingRestrictions parkingRowRestrictions_)
{
    m_objectChoice = parkingRowRestrictions_;
}

ParkingRowAttributeValue::ChoiceTag ParkingRowAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        return CHOICE_parkingRowName;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        return CHOICE_parkingRowLayout;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        return CHOICE_parkingRowRestrictions;
    default:
        return UNDEFINED_CHOICE;
    }
}

void ParkingRowAttributeValue::initPackingContext(ParkingRowAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>().initPackingContext(context.getParkingRowLayout());
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().initPackingContext(context.getParkingRowRestrictions());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }
}

size_t ParkingRowAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingRowName>());
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeValue::bitSizeOf(ParkingRowAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingRowName>());
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>().bitSizeOf(context.getParkingRowLayout(), endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().bitSizeOf(context.getParkingRowRestrictions(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingRowName>());
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }

    return endBitPosition;
}

size_t ParkingRowAttributeValue::initializeOffsets(ParkingRowAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingRowName>());
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>().initializeOffsets(context.getParkingRowLayout(), endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().initializeOffsets(context.getParkingRowRestrictions(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }

    return endBitPosition;
}

bool ParkingRowAttributeValue::operator==(const ParkingRowAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ParkingRowName>() == other.m_objectChoice.get<::nds::venue::details::types::ParkingRowName>());
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>() == other.m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>());
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>() == other.m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }
}

uint32_t ParkingRowAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ParkingRowName>());
            break;
        case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>());
            break;
        case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>());
            break;
        default:
            break;
        }
    }

    return result;
}

void ParkingRowAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        out.writeString(m_objectChoice.get<::nds::venue::details::types::ParkingRowName>());
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>().write(out);
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }
}

void ParkingRowAttributeValue::write(ParkingRowAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        out.writeString(m_objectChoice.get<::nds::venue::details::types::ParkingRowName>());
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        m_objectChoice.get<::nds::venue::details::types::ParkingRowLayout>().write(context.getParkingRowLayout(), out);
        break;
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().write(context.getParkingRowRestrictions(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingRowAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::venue::details::types::ParkingRowName>(in.readString(allocator)), allocator);
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ParkingRowLayout(in, allocator), allocator);
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ParkingRestrictions(in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingRowAttributeValue::readObject(ParkingRowAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        return ::zserio::AnyHolder<>(static_cast<::nds::venue::details::types::ParkingRowName>(in.readString(allocator)), allocator);
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ParkingRowLayout(context.getParkingRowLayout(), in, allocator), allocator);
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ParkingRestrictions(context.getParkingRowRestrictions(), in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingRowAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_NAME:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ParkingRowName>(m_objectChoice, allocator);
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_ROW_LAYOUT:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ParkingRowLayout>(m_objectChoice, allocator);
    case ::nds::venue::details::attributes::ParkingRowAttributeType::PARKING_RESTRICTIONS:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ParkingRestrictions>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingRowAttributeValue!");
    }
}

} // namespace attributes
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/attributes/ParkingSpotAttributeValue.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace attributes
{

ParkingSpotAttributeValue::ParkingSpotAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

ParkingSpotAttributeValue::ParkingSpotAttributeValue(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingSpotAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

ParkingSpotAttributeValue::ParkingSpotAttributeValue(ParkingSpotAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingSpotAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

ParkingSpotAttributeValue::ParkingSpotAttributeValue(const ParkingSpotAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeValue& ParkingSpotAttributeValue::operator=(const ParkingSpotAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeValue::ParkingSpotAttributeValue(ParkingSpotAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeValue& ParkingSpotAttributeValue::operator=(ParkingSpotAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeValue::ParkingSpotAttributeValue(::zserio::PropagateAllocatorT,
        const ParkingSpotAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void ParkingSpotAttributeValue::initialize(
        ::nds::venue::details::attributes::ParkingSpotAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool ParkingSpotAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::venue::details::attributes::ParkingSpotAttributeType ParkingSpotAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'ParkingSpotAttributeValue' is not initialized!");

    return m_type_;
}

::nds::venue::details::types::ParkingSpotNumber& ParkingSpotAttributeValue::getParkingSpotNumber()
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>();
}

const ::nds::venue::details::types::ParkingSpotNumber& ParkingSpotAttributeValue::getParkingSpotNumber() const
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>();
}

void ParkingSpotAttributeValue::setParkingSpotNumber(const ::nds::venue::details::types::ParkingSpotNumber& parkingSpotNumber_)
{
    m_objectChoice = parkingSpotNumber_;
}

void ParkingSpotAttributeValue::setParkingSpotNumber(::nds::venue::details::types::ParkingSpotNumber&& parkingSpotNumber_)
{
    m_objectChoice = ::std::move(parkingSpotNumber_);
}

::nds::venue::details::types::Available& ParkingSpotAttributeValue::getAvailable()
{
    return m_objectChoice.get<::nds::venue::details::types::Available>();
}

const ::nds::venue::details::types::Available& ParkingSpotAttributeValue::getAvailable() const
{
    return m_objectChoice.get<::nds::venue::details::types::Available>();
}

void ParkingSpotAttributeValue::setAvailable(const ::nds::venue::details::types::Available& available_)
{
    m_objectChoice = available_;
}

void ParkingSpotAttributeValue::setAvailable(::nds::venue::details::types::Available&& available_)
{
    m_objectChoice = ::std::move(available_);
}

::nds::venue::details::types::ParkingRestrictions ParkingSpotAttributeValue::getParkingSpotRestrictions() const
{
    return m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>();
}

void ParkingSpotAttributeValue::setParkingSpotRestrictions(::nds::venue::details::types::ParkingRestrictions parkingSpotRestrictions_)
{
    m_objectChoice = parkingSpotRestrictions_;
}

::nds::venue::details::types::PrivateParkingDetails& ParkingSpotAttributeValue::getPrivateParkingDetails()
{
    return m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>();
}

const ::nds::venue::details::types::PrivateParkingDetails& ParkingSpotAttributeValue::getPrivateParkingDetails() const
{
    return m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>();
}

void ParkingSpotAttributeValue::setPrivateParkingDetails(const ::nds::venue::details::types::PrivateParkingDetails& privateParkingDetails_)
{
    m_objectChoice = privateParkingDetails_;
}

void ParkingSpotAttributeValue::setPrivateParkingDetails(::nds::venue::details::types::PrivateParkingDetails&& privateParkingDetails_)
{
    m_objectChoice = ::std::move(privateParkingDetails_);
}

ParkingSpotAttributeValue::ChoiceTag ParkingSpotAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        return CHOICE_parkingSpotNumber;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        return CHOICE_available;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        return CHOICE_parkingSpotRestrictions;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        return CHOICE_privateParkingDetails;
    default:
        return UNDEFINED_CHOICE;
    }
}

void ParkingSpotAttributeValue::initPackingContext(ParkingSpotAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().initPackingContext(context.getParkingSpotRestrictions());
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }
}

size_t ParkingSpotAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>());
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::Available>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeValue::bitSizeOf(ParkingSpotAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>());
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::Available>().bitSizeOf(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().bitSizeOf(context.getParkingSpotRestrictions(), endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        endBitPosition += m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>());
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::Available>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }

    return endBitPosition;
}

size_t ParkingSpotAttributeValue::initializeOffsets(ParkingSpotAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>());
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::Available>().initializeOffsets(endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().initializeOffsets(context.getParkingSpotRestrictions(), endBitPosition);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        endBitPosition = m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }

    return endBitPosition;
}

bool ParkingSpotAttributeValue::operator==(const ParkingSpotAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>() == other.m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>());
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::Available>() == other.m_objectChoice.get<::nds::venue::details::types::Available>());
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>() == other.m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>());
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>() == other.m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }
}

uint32_t ParkingSpotAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>());
            break;
        case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::Available>());
            break;
        case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>());
            break;
        case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>());
            break;
        default:
            break;
        }
    }

    return result;
}

void ParkingSpotAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        out.writeString(m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>());
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        m_objectChoice.get<::nds::venue::details::types::Available>().write(out);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().write(out);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }
}

void ParkingSpotAttributeValue::write(ParkingSpotAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        out.writeString(m_objectChoice.get<::nds::venue::details::types::ParkingSpotNumber>());
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        m_objectChoice.get<::nds::venue::details::types::Available>().write(out);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        m_objectChoice.get<::nds::venue::details::types::ParkingRestrictions>().write(context.getParkingSpotRestrictions(), out);
        break;
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        m_objectChoice.get<::nds::venue::details::types::PrivateParkingDetails>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingSpotAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::venue::details::types::ParkingSpotNumber>(in.readString(allocator)), allocator);
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::Available(in, allocator), allocator);
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ParkingRestrictions(in), allocator);
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::PrivateParkingDetails(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingSpotAttributeValue::readObject(ParkingSpotAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        return ::zserio::AnyHolder<>(static_cast<::nds::venue::details::types::ParkingSpotNumber>(in.readString(allocator)), allocator);
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::Available(in, allocator), allocator);
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::ParkingRestrictions(context.getParkingSpotRestrictions(), in), allocator);
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        return ::zserio::AnyHolder<>(::nds::venue::details::types::PrivateParkingDetails(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }
}

::zserio::AnyHolder<> ParkingSpotAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_NUMBER:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ParkingSpotNumber>(m_objectChoice, allocator);
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_AVAILABLE:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::Available>(m_objectChoice, allocator);
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_RESTRICTIONS:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::ParkingRestrictions>(m_objectChoice, allocator);
    case ::nds::venue::details::attributes::ParkingSpotAttributeType::PARKING_SPOT_PRIVATE_PARKING_DETAILS:
        return ::zserio::allocatorPropagatingCopy<::nds::venue::details::types::PrivateParkingDetails>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice ParkingSpotAttributeValue!");
    }
}

} // namespace attributes
} // namespace details
} // namespace venue
} // namespace nds
