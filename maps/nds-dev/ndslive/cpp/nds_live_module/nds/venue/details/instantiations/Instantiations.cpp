/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingFacilityAttributeMetadata.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingFacilityAttributeMetadata::ParkingFacilityAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

ParkingFacilityAttributeMetadata::ParkingFacilityAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

ParkingFacilityAttributeMetadata::ParkingFacilityAttributeMetadata(ParkingFacilityAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

ParkingFacilityAttributeMetadata::ParkingFacilityAttributeMetadata(::zserio::PropagateAllocatorT,
        const ParkingFacilityAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::venue::details::attributes::ParkingFacilityAttributeType>& ParkingFacilityAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingFacilityAttributeType>& ParkingFacilityAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void ParkingFacilityAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::venue::details::attributes::ParkingFacilityAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void ParkingFacilityAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::venue::details::attributes::ParkingFacilityAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingFacilityAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingFacilityAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void ParkingFacilityAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void ParkingFacilityAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::venue::details::properties::VenuePropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& ParkingFacilityAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& ParkingFacilityAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void ParkingFacilityAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void ParkingFacilityAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void ParkingFacilityAttributeMetadata::initPackingContext(ParkingFacilityAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t ParkingFacilityAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeMetadata::bitSizeOf(ParkingFacilityAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingFacilityAttributeMetadata::initializeOffsets(ParkingFacilityAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool ParkingFacilityAttributeMetadata::operator==(const ParkingFacilityAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t ParkingFacilityAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void ParkingFacilityAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void ParkingFacilityAttributeMetadata::write(ParkingFacilityAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void ParkingFacilityAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingFacilityAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingFacilityAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingFacilityAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::nds::venue::details::properties::VenuePropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingFacilityAttributeMetadata::ZserioArrayType_availableAttributes ParkingFacilityAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

ParkingFacilityAttributeMetadata::ZserioArrayType_availableAttributes ParkingFacilityAttributeMetadata::readAvailableAttributes(ParkingFacilityAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
ParkingFacilityAttributeMetadata::ZserioArrayType_availableProperties ParkingFacilityAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

ParkingFacilityAttributeMetadata::ZserioArrayType_availableProperties ParkingFacilityAttributeMetadata::readAvailableProperties(ParkingFacilityAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection ParkingFacilityAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection ParkingFacilityAttributeMetadata::readAvailableConditions(ParkingFacilityAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingLevelAttributeMetadata.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingLevelAttributeMetadata::ParkingLevelAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

ParkingLevelAttributeMetadata::ParkingLevelAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

ParkingLevelAttributeMetadata::ParkingLevelAttributeMetadata(ParkingLevelAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

ParkingLevelAttributeMetadata::ParkingLevelAttributeMetadata(::zserio::PropagateAllocatorT,
        const ParkingLevelAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::venue::details::attributes::ParkingLevelAttributeType>& ParkingLevelAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingLevelAttributeType>& ParkingLevelAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void ParkingLevelAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::venue::details::attributes::ParkingLevelAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void ParkingLevelAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::venue::details::attributes::ParkingLevelAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingLevelAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingLevelAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void ParkingLevelAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void ParkingLevelAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::venue::details::properties::VenuePropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& ParkingLevelAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& ParkingLevelAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void ParkingLevelAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void ParkingLevelAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void ParkingLevelAttributeMetadata::initPackingContext(ParkingLevelAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t ParkingLevelAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeMetadata::bitSizeOf(ParkingLevelAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingLevelAttributeMetadata::initializeOffsets(ParkingLevelAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool ParkingLevelAttributeMetadata::operator==(const ParkingLevelAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t ParkingLevelAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void ParkingLevelAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void ParkingLevelAttributeMetadata::write(ParkingLevelAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void ParkingLevelAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingLevelAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingLevelAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingLevelAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::nds::venue::details::properties::VenuePropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingLevelAttributeMetadata::ZserioArrayType_availableAttributes ParkingLevelAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

ParkingLevelAttributeMetadata::ZserioArrayType_availableAttributes ParkingLevelAttributeMetadata::readAvailableAttributes(ParkingLevelAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
ParkingLevelAttributeMetadata::ZserioArrayType_availableProperties ParkingLevelAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

ParkingLevelAttributeMetadata::ZserioArrayType_availableProperties ParkingLevelAttributeMetadata::readAvailableProperties(ParkingLevelAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection ParkingLevelAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection ParkingLevelAttributeMetadata::readAvailableConditions(ParkingLevelAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSectionAttributeMetadata.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSectionAttributeMetadata::ParkingSectionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

ParkingSectionAttributeMetadata::ParkingSectionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

ParkingSectionAttributeMetadata::ParkingSectionAttributeMetadata(ParkingSectionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

ParkingSectionAttributeMetadata::ParkingSectionAttributeMetadata(::zserio::PropagateAllocatorT,
        const ParkingSectionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::venue::details::attributes::ParkingSectionAttributeType>& ParkingSectionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingSectionAttributeType>& ParkingSectionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void ParkingSectionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::venue::details::attributes::ParkingSectionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void ParkingSectionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::venue::details::attributes::ParkingSectionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingSectionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingSectionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void ParkingSectionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void ParkingSectionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::venue::details::properties::VenuePropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& ParkingSectionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& ParkingSectionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void ParkingSectionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void ParkingSectionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void ParkingSectionAttributeMetadata::initPackingContext(ParkingSectionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t ParkingSectionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeMetadata::bitSizeOf(ParkingSectionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingSectionAttributeMetadata::initializeOffsets(ParkingSectionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool ParkingSectionAttributeMetadata::operator==(const ParkingSectionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t ParkingSectionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void ParkingSectionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void ParkingSectionAttributeMetadata::write(ParkingSectionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void ParkingSectionAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingSectionAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSectionAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingSectionAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::nds::venue::details::properties::VenuePropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingSectionAttributeMetadata::ZserioArrayType_availableAttributes ParkingSectionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

ParkingSectionAttributeMetadata::ZserioArrayType_availableAttributes ParkingSectionAttributeMetadata::readAvailableAttributes(ParkingSectionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
ParkingSectionAttributeMetadata::ZserioArrayType_availableProperties ParkingSectionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

ParkingSectionAttributeMetadata::ZserioArrayType_availableProperties ParkingSectionAttributeMetadata::readAvailableProperties(ParkingSectionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection ParkingSectionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection ParkingSectionAttributeMetadata::readAvailableConditions(ParkingSectionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingRowAttributeMetadata.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingRowAttributeMetadata::ParkingRowAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

ParkingRowAttributeMetadata::ParkingRowAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

ParkingRowAttributeMetadata::ParkingRowAttributeMetadata(ParkingRowAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

ParkingRowAttributeMetadata::ParkingRowAttributeMetadata(::zserio::PropagateAllocatorT,
        const ParkingRowAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::venue::details::attributes::ParkingRowAttributeType>& ParkingRowAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingRowAttributeType>& ParkingRowAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void ParkingRowAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::venue::details::attributes::ParkingRowAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void ParkingRowAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::venue::details::attributes::ParkingRowAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingRowAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingRowAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void ParkingRowAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void ParkingRowAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::venue::details::properties::VenuePropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& ParkingRowAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& ParkingRowAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void ParkingRowAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void ParkingRowAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void ParkingRowAttributeMetadata::initPackingContext(ParkingRowAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t ParkingRowAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeMetadata::bitSizeOf(ParkingRowAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingRowAttributeMetadata::initializeOffsets(ParkingRowAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool ParkingRowAttributeMetadata::operator==(const ParkingRowAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t ParkingRowAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void ParkingRowAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void ParkingRowAttributeMetadata::write(ParkingRowAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void ParkingRowAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingRowAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingRowAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingRowAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::nds::venue::details::properties::VenuePropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingRowAttributeMetadata::ZserioArrayType_availableAttributes ParkingRowAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

ParkingRowAttributeMetadata::ZserioArrayType_availableAttributes ParkingRowAttributeMetadata::readAvailableAttributes(ParkingRowAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
ParkingRowAttributeMetadata::ZserioArrayType_availableProperties ParkingRowAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

ParkingRowAttributeMetadata::ZserioArrayType_availableProperties ParkingRowAttributeMetadata::readAvailableProperties(ParkingRowAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection ParkingRowAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection ParkingRowAttributeMetadata::readAvailableConditions(ParkingRowAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSpotAttributeMetadata.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSpotAttributeMetadata::ParkingSpotAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

ParkingSpotAttributeMetadata::ParkingSpotAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

ParkingSpotAttributeMetadata::ParkingSpotAttributeMetadata(ParkingSpotAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

ParkingSpotAttributeMetadata::ParkingSpotAttributeMetadata(::zserio::PropagateAllocatorT,
        const ParkingSpotAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::venue::details::attributes::ParkingSpotAttributeType>& ParkingSpotAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingSpotAttributeType>& ParkingSpotAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void ParkingSpotAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::venue::details::attributes::ParkingSpotAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void ParkingSpotAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::venue::details::attributes::ParkingSpotAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingSpotAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& ParkingSpotAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void ParkingSpotAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void ParkingSpotAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::venue::details::properties::VenuePropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& ParkingSpotAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& ParkingSpotAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void ParkingSpotAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void ParkingSpotAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void ParkingSpotAttributeMetadata::initPackingContext(ParkingSpotAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t ParkingSpotAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeMetadata::bitSizeOf(ParkingSpotAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingSpotAttributeMetadata::initializeOffsets(ParkingSpotAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool ParkingSpotAttributeMetadata::operator==(const ParkingSpotAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t ParkingSpotAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void ParkingSpotAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void ParkingSpotAttributeMetadata::write(ParkingSpotAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void ParkingSpotAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingSpotAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSpotAttributeMetadata::ZserioElementFactory_availableProperties::create(ParkingSpotAttributeMetadata&        ,
        ::zserio::vector<::nds::venue::details::properties::VenuePropertyType>& array,
        ::nds::venue::details::properties::VenuePropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingSpotAttributeMetadata::ZserioArrayType_availableAttributes ParkingSpotAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

ParkingSpotAttributeMetadata::ZserioArrayType_availableAttributes ParkingSpotAttributeMetadata::readAvailableAttributes(ParkingSpotAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
ParkingSpotAttributeMetadata::ZserioArrayType_availableProperties ParkingSpotAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

ParkingSpotAttributeMetadata::ZserioArrayType_availableProperties ParkingSpotAttributeMetadata::readAvailableProperties(ParkingSpotAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection ParkingSpotAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection ParkingSpotAttributeMetadata::readAvailableConditions(ParkingSpotAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingFacilityAttributeMapList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingFacilityAttributeMapList::ParkingFacilityAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

ParkingFacilityAttributeMapList::ParkingFacilityAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

ParkingFacilityAttributeMapList::ParkingFacilityAttributeMapList(ParkingFacilityAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

ParkingFacilityAttributeMapList::ParkingFacilityAttributeMapList(const ParkingFacilityAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeMapList& ParkingFacilityAttributeMapList::operator=(const ParkingFacilityAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeMapList::ParkingFacilityAttributeMapList(ParkingFacilityAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeMapList& ParkingFacilityAttributeMapList::operator=(ParkingFacilityAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeMapList::ParkingFacilityAttributeMapList(::zserio::PropagateAllocatorT,
        const ParkingFacilityAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingFacilityAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingFacilityAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingFacilityAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingFacilityAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingFacilityAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingFacilityAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void ParkingFacilityAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::venue::details::instantiations::ParkingFacilityAttributeMapListHeader& ParkingFacilityAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::venue::details::instantiations::ParkingFacilityAttributeMapListHeader& ParkingFacilityAttributeMapList::getHeader() const
{
    return m_header_;
}

void ParkingFacilityAttributeMapList::setHeader(const ::nds::venue::details::instantiations::ParkingFacilityAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void ParkingFacilityAttributeMapList::setHeader(::nds::venue::details::instantiations::ParkingFacilityAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeMap>& ParkingFacilityAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeMap>& ParkingFacilityAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void ParkingFacilityAttributeMapList::setMaps(const ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void ParkingFacilityAttributeMapList::setMaps(::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void ParkingFacilityAttributeMapList::initPackingContext(ParkingFacilityAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t ParkingFacilityAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeMapList::bitSizeOf(ParkingFacilityAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingFacilityAttributeMapList::initializeOffsets(ParkingFacilityAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingFacilityAttributeMapList::operator==(const ParkingFacilityAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t ParkingFacilityAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void ParkingFacilityAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingFacilityAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingFacilityAttributeMapList::write(ParkingFacilityAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingFacilityAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingFacilityAttributeMapList::ZserioArrayExpressions_maps::initializeElement(ParkingFacilityAttributeMapList& owner,
        ::nds::venue::details::instantiations::ParkingFacilityAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingFacilityAttributeMapList::ZserioElementFactory_maps::create(ParkingFacilityAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingFacilityAttributeMapList::ZserioElementFactory_maps::create(ParkingFacilityAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeMap>& array,
        ::nds::venue::details::instantiations::ParkingFacilityAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingFacilityAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingFacilityAttributeMapList::readNumMaps(ParkingFacilityAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::venue::details::instantiations::ParkingFacilityAttributeMapListHeader ParkingFacilityAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingFacilityAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::venue::details::instantiations::ParkingFacilityAttributeMapListHeader ParkingFacilityAttributeMapList::readHeader(ParkingFacilityAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingFacilityAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
ParkingFacilityAttributeMapList::ZserioArrayType_maps ParkingFacilityAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingFacilityAttributeMapList::ZserioArrayType_maps ParkingFacilityAttributeMapList::readMaps(ParkingFacilityAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingLevelAttributeMapList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingLevelAttributeMapList::ParkingLevelAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

ParkingLevelAttributeMapList::ParkingLevelAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

ParkingLevelAttributeMapList::ParkingLevelAttributeMapList(ParkingLevelAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

ParkingLevelAttributeMapList::ParkingLevelAttributeMapList(const ParkingLevelAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeMapList& ParkingLevelAttributeMapList::operator=(const ParkingLevelAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeMapList::ParkingLevelAttributeMapList(ParkingLevelAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeMapList& ParkingLevelAttributeMapList::operator=(ParkingLevelAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeMapList::ParkingLevelAttributeMapList(::zserio::PropagateAllocatorT,
        const ParkingLevelAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingLevelAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingLevelAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingLevelAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingLevelAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingLevelAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingLevelAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void ParkingLevelAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::venue::details::instantiations::ParkingLevelAttributeMapListHeader& ParkingLevelAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::venue::details::instantiations::ParkingLevelAttributeMapListHeader& ParkingLevelAttributeMapList::getHeader() const
{
    return m_header_;
}

void ParkingLevelAttributeMapList::setHeader(const ::nds::venue::details::instantiations::ParkingLevelAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void ParkingLevelAttributeMapList::setHeader(::nds::venue::details::instantiations::ParkingLevelAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeMap>& ParkingLevelAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeMap>& ParkingLevelAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void ParkingLevelAttributeMapList::setMaps(const ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void ParkingLevelAttributeMapList::setMaps(::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void ParkingLevelAttributeMapList::initPackingContext(ParkingLevelAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t ParkingLevelAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeMapList::bitSizeOf(ParkingLevelAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingLevelAttributeMapList::initializeOffsets(ParkingLevelAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingLevelAttributeMapList::operator==(const ParkingLevelAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t ParkingLevelAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void ParkingLevelAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingLevelAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingLevelAttributeMapList::write(ParkingLevelAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingLevelAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingLevelAttributeMapList::ZserioArrayExpressions_maps::initializeElement(ParkingLevelAttributeMapList& owner,
        ::nds::venue::details::instantiations::ParkingLevelAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingLevelAttributeMapList::ZserioElementFactory_maps::create(ParkingLevelAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingLevelAttributeMapList::ZserioElementFactory_maps::create(ParkingLevelAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeMap>& array,
        ::nds::venue::details::instantiations::ParkingLevelAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingLevelAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingLevelAttributeMapList::readNumMaps(ParkingLevelAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::venue::details::instantiations::ParkingLevelAttributeMapListHeader ParkingLevelAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingLevelAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::venue::details::instantiations::ParkingLevelAttributeMapListHeader ParkingLevelAttributeMapList::readHeader(ParkingLevelAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingLevelAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
ParkingLevelAttributeMapList::ZserioArrayType_maps ParkingLevelAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingLevelAttributeMapList::ZserioArrayType_maps ParkingLevelAttributeMapList::readMaps(ParkingLevelAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSectionAttributeMapList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSectionAttributeMapList::ParkingSectionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

ParkingSectionAttributeMapList::ParkingSectionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

ParkingSectionAttributeMapList::ParkingSectionAttributeMapList(ParkingSectionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

ParkingSectionAttributeMapList::ParkingSectionAttributeMapList(const ParkingSectionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeMapList& ParkingSectionAttributeMapList::operator=(const ParkingSectionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeMapList::ParkingSectionAttributeMapList(ParkingSectionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeMapList& ParkingSectionAttributeMapList::operator=(ParkingSectionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeMapList::ParkingSectionAttributeMapList(::zserio::PropagateAllocatorT,
        const ParkingSectionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingSectionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSectionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSectionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingSectionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingSectionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingSectionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void ParkingSectionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::venue::details::instantiations::ParkingSectionAttributeMapListHeader& ParkingSectionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::venue::details::instantiations::ParkingSectionAttributeMapListHeader& ParkingSectionAttributeMapList::getHeader() const
{
    return m_header_;
}

void ParkingSectionAttributeMapList::setHeader(const ::nds::venue::details::instantiations::ParkingSectionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void ParkingSectionAttributeMapList::setHeader(::nds::venue::details::instantiations::ParkingSectionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeMap>& ParkingSectionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeMap>& ParkingSectionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void ParkingSectionAttributeMapList::setMaps(const ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void ParkingSectionAttributeMapList::setMaps(::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void ParkingSectionAttributeMapList::initPackingContext(ParkingSectionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t ParkingSectionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeMapList::bitSizeOf(ParkingSectionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSectionAttributeMapList::initializeOffsets(ParkingSectionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSectionAttributeMapList::operator==(const ParkingSectionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t ParkingSectionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void ParkingSectionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingSectionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingSectionAttributeMapList::write(ParkingSectionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingSectionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingSectionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(ParkingSectionAttributeMapList& owner,
        ::nds::venue::details::instantiations::ParkingSectionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingSectionAttributeMapList::ZserioElementFactory_maps::create(ParkingSectionAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingSectionAttributeMapList::ZserioElementFactory_maps::create(ParkingSectionAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeMap>& array,
        ::nds::venue::details::instantiations::ParkingSectionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingSectionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingSectionAttributeMapList::readNumMaps(ParkingSectionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::venue::details::instantiations::ParkingSectionAttributeMapListHeader ParkingSectionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingSectionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::venue::details::instantiations::ParkingSectionAttributeMapListHeader ParkingSectionAttributeMapList::readHeader(ParkingSectionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingSectionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
ParkingSectionAttributeMapList::ZserioArrayType_maps ParkingSectionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingSectionAttributeMapList::ZserioArrayType_maps ParkingSectionAttributeMapList::readMaps(ParkingSectionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingRowAttributeMapList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingRowAttributeMapList::ParkingRowAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

ParkingRowAttributeMapList::ParkingRowAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

ParkingRowAttributeMapList::ParkingRowAttributeMapList(ParkingRowAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

ParkingRowAttributeMapList::ParkingRowAttributeMapList(const ParkingRowAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeMapList& ParkingRowAttributeMapList::operator=(const ParkingRowAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeMapList::ParkingRowAttributeMapList(ParkingRowAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeMapList& ParkingRowAttributeMapList::operator=(ParkingRowAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeMapList::ParkingRowAttributeMapList(::zserio::PropagateAllocatorT,
        const ParkingRowAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingRowAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingRowAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingRowAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingRowAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingRowAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingRowAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void ParkingRowAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::venue::details::instantiations::ParkingRowAttributeMapListHeader& ParkingRowAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::venue::details::instantiations::ParkingRowAttributeMapListHeader& ParkingRowAttributeMapList::getHeader() const
{
    return m_header_;
}

void ParkingRowAttributeMapList::setHeader(const ::nds::venue::details::instantiations::ParkingRowAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void ParkingRowAttributeMapList::setHeader(::nds::venue::details::instantiations::ParkingRowAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeMap>& ParkingRowAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeMap>& ParkingRowAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void ParkingRowAttributeMapList::setMaps(const ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void ParkingRowAttributeMapList::setMaps(::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void ParkingRowAttributeMapList::initPackingContext(ParkingRowAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t ParkingRowAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeMapList::bitSizeOf(ParkingRowAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingRowAttributeMapList::initializeOffsets(ParkingRowAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingRowAttributeMapList::operator==(const ParkingRowAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t ParkingRowAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void ParkingRowAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingRowAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingRowAttributeMapList::write(ParkingRowAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingRowAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingRowAttributeMapList::ZserioArrayExpressions_maps::initializeElement(ParkingRowAttributeMapList& owner,
        ::nds::venue::details::instantiations::ParkingRowAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingRowAttributeMapList::ZserioElementFactory_maps::create(ParkingRowAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingRowAttributeMapList::ZserioElementFactory_maps::create(ParkingRowAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeMap>& array,
        ::nds::venue::details::instantiations::ParkingRowAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingRowAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingRowAttributeMapList::readNumMaps(ParkingRowAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::venue::details::instantiations::ParkingRowAttributeMapListHeader ParkingRowAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingRowAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::venue::details::instantiations::ParkingRowAttributeMapListHeader ParkingRowAttributeMapList::readHeader(ParkingRowAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingRowAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
ParkingRowAttributeMapList::ZserioArrayType_maps ParkingRowAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingRowAttributeMapList::ZserioArrayType_maps ParkingRowAttributeMapList::readMaps(ParkingRowAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSpotAttributeMapList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSpotAttributeMapList::ParkingSpotAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

ParkingSpotAttributeMapList::ParkingSpotAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

ParkingSpotAttributeMapList::ParkingSpotAttributeMapList(ParkingSpotAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

ParkingSpotAttributeMapList::ParkingSpotAttributeMapList(const ParkingSpotAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeMapList& ParkingSpotAttributeMapList::operator=(const ParkingSpotAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeMapList::ParkingSpotAttributeMapList(ParkingSpotAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeMapList& ParkingSpotAttributeMapList::operator=(ParkingSpotAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeMapList::ParkingSpotAttributeMapList(::zserio::PropagateAllocatorT,
        const ParkingSpotAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingSpotAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSpotAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSpotAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingSpotAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingSpotAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingSpotAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void ParkingSpotAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::venue::details::instantiations::ParkingSpotAttributeMapListHeader& ParkingSpotAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::venue::details::instantiations::ParkingSpotAttributeMapListHeader& ParkingSpotAttributeMapList::getHeader() const
{
    return m_header_;
}

void ParkingSpotAttributeMapList::setHeader(const ::nds::venue::details::instantiations::ParkingSpotAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void ParkingSpotAttributeMapList::setHeader(::nds::venue::details::instantiations::ParkingSpotAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeMap>& ParkingSpotAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeMap>& ParkingSpotAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void ParkingSpotAttributeMapList::setMaps(const ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void ParkingSpotAttributeMapList::setMaps(::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void ParkingSpotAttributeMapList::initPackingContext(ParkingSpotAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t ParkingSpotAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeMapList::bitSizeOf(ParkingSpotAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSpotAttributeMapList::initializeOffsets(ParkingSpotAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSpotAttributeMapList::operator==(const ParkingSpotAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t ParkingSpotAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void ParkingSpotAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingSpotAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingSpotAttributeMapList::write(ParkingSpotAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field ParkingSpotAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void ParkingSpotAttributeMapList::ZserioArrayExpressions_maps::initializeElement(ParkingSpotAttributeMapList& owner,
        ::nds::venue::details::instantiations::ParkingSpotAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingSpotAttributeMapList::ZserioElementFactory_maps::create(ParkingSpotAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingSpotAttributeMapList::ZserioElementFactory_maps::create(ParkingSpotAttributeMapList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeMap>& array,
        ::nds::venue::details::instantiations::ParkingSpotAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingSpotAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingSpotAttributeMapList::readNumMaps(ParkingSpotAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::venue::details::instantiations::ParkingSpotAttributeMapListHeader ParkingSpotAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingSpotAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::venue::details::instantiations::ParkingSpotAttributeMapListHeader ParkingSpotAttributeMapList::readHeader(ParkingSpotAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingSpotAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
ParkingSpotAttributeMapList::ZserioArrayType_maps ParkingSpotAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingSpotAttributeMapList::ZserioArrayType_maps ParkingSpotAttributeMapList::readMaps(ParkingSpotAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingFacilityAttributeMapListHeader.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingFacilityAttributeMapListHeader::ParkingFacilityAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

ParkingFacilityAttributeMapListHeader::ParkingFacilityAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

ParkingFacilityAttributeMapListHeader::ParkingFacilityAttributeMapListHeader(ParkingFacilityAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

ParkingFacilityAttributeMapListHeader::ParkingFacilityAttributeMapListHeader(const ParkingFacilityAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeMapListHeader& ParkingFacilityAttributeMapListHeader::operator=(const ParkingFacilityAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeMapListHeader::ParkingFacilityAttributeMapListHeader(ParkingFacilityAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeMapListHeader& ParkingFacilityAttributeMapListHeader::operator=(ParkingFacilityAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeMapListHeader::ParkingFacilityAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const ParkingFacilityAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void ParkingFacilityAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool ParkingFacilityAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t ParkingFacilityAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'ParkingFacilityAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::venue::details::attributes::ParkingFacilityAttributeType>& ParkingFacilityAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingFacilityAttributeType>& ParkingFacilityAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void ParkingFacilityAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::venue::details::attributes::ParkingFacilityAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void ParkingFacilityAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::venue::details::attributes::ParkingFacilityAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingFacilityAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingFacilityAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void ParkingFacilityAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void ParkingFacilityAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void ParkingFacilityAttributeMapListHeader::initPackingContext(ParkingFacilityAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t ParkingFacilityAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeMapListHeader::bitSizeOf(ParkingFacilityAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingFacilityAttributeMapListHeader::initializeOffsets(ParkingFacilityAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingFacilityAttributeMapListHeader::operator==(const ParkingFacilityAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t ParkingFacilityAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void ParkingFacilityAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingFacilityAttributeMapListHeader::write(ParkingFacilityAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingFacilityAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingFacilityAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingFacilityAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingFacilityAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingFacilityAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingFacilityAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingFacilityAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingFacilityAttributeMapListHeader::readAttributeTypeCode(ParkingFacilityAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
ParkingFacilityAttributeMapListHeader::ZserioArrayType_conditionType ParkingFacilityAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingFacilityAttributeMapListHeader::ZserioArrayType_conditionType ParkingFacilityAttributeMapListHeader::readConditionType(ParkingFacilityAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingLevelAttributeMapListHeader.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingLevelAttributeMapListHeader::ParkingLevelAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

ParkingLevelAttributeMapListHeader::ParkingLevelAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

ParkingLevelAttributeMapListHeader::ParkingLevelAttributeMapListHeader(ParkingLevelAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

ParkingLevelAttributeMapListHeader::ParkingLevelAttributeMapListHeader(const ParkingLevelAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeMapListHeader& ParkingLevelAttributeMapListHeader::operator=(const ParkingLevelAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeMapListHeader::ParkingLevelAttributeMapListHeader(ParkingLevelAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeMapListHeader& ParkingLevelAttributeMapListHeader::operator=(ParkingLevelAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeMapListHeader::ParkingLevelAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const ParkingLevelAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void ParkingLevelAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool ParkingLevelAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t ParkingLevelAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'ParkingLevelAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::venue::details::attributes::ParkingLevelAttributeType>& ParkingLevelAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingLevelAttributeType>& ParkingLevelAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void ParkingLevelAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::venue::details::attributes::ParkingLevelAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void ParkingLevelAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::venue::details::attributes::ParkingLevelAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingLevelAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingLevelAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void ParkingLevelAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void ParkingLevelAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void ParkingLevelAttributeMapListHeader::initPackingContext(ParkingLevelAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t ParkingLevelAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeMapListHeader::bitSizeOf(ParkingLevelAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingLevelAttributeMapListHeader::initializeOffsets(ParkingLevelAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingLevelAttributeMapListHeader::operator==(const ParkingLevelAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t ParkingLevelAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void ParkingLevelAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingLevelAttributeMapListHeader::write(ParkingLevelAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingLevelAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingLevelAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingLevelAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingLevelAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingLevelAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingLevelAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingLevelAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingLevelAttributeMapListHeader::readAttributeTypeCode(ParkingLevelAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
ParkingLevelAttributeMapListHeader::ZserioArrayType_conditionType ParkingLevelAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingLevelAttributeMapListHeader::ZserioArrayType_conditionType ParkingLevelAttributeMapListHeader::readConditionType(ParkingLevelAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSectionAttributeMapListHeader.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSectionAttributeMapListHeader::ParkingSectionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

ParkingSectionAttributeMapListHeader::ParkingSectionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

ParkingSectionAttributeMapListHeader::ParkingSectionAttributeMapListHeader(ParkingSectionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

ParkingSectionAttributeMapListHeader::ParkingSectionAttributeMapListHeader(const ParkingSectionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeMapListHeader& ParkingSectionAttributeMapListHeader::operator=(const ParkingSectionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeMapListHeader::ParkingSectionAttributeMapListHeader(ParkingSectionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeMapListHeader& ParkingSectionAttributeMapListHeader::operator=(ParkingSectionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeMapListHeader::ParkingSectionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const ParkingSectionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void ParkingSectionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool ParkingSectionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t ParkingSectionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'ParkingSectionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::venue::details::attributes::ParkingSectionAttributeType>& ParkingSectionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingSectionAttributeType>& ParkingSectionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void ParkingSectionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::venue::details::attributes::ParkingSectionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void ParkingSectionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::venue::details::attributes::ParkingSectionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingSectionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingSectionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void ParkingSectionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void ParkingSectionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void ParkingSectionAttributeMapListHeader::initPackingContext(ParkingSectionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t ParkingSectionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeMapListHeader::bitSizeOf(ParkingSectionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSectionAttributeMapListHeader::initializeOffsets(ParkingSectionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSectionAttributeMapListHeader::operator==(const ParkingSectionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t ParkingSectionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void ParkingSectionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingSectionAttributeMapListHeader::write(ParkingSectionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingSectionAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingSectionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSectionAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingSectionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingSectionAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingSectionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingSectionAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingSectionAttributeMapListHeader::readAttributeTypeCode(ParkingSectionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
ParkingSectionAttributeMapListHeader::ZserioArrayType_conditionType ParkingSectionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingSectionAttributeMapListHeader::ZserioArrayType_conditionType ParkingSectionAttributeMapListHeader::readConditionType(ParkingSectionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingRowAttributeMapListHeader.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingRowAttributeMapListHeader::ParkingRowAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

ParkingRowAttributeMapListHeader::ParkingRowAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

ParkingRowAttributeMapListHeader::ParkingRowAttributeMapListHeader(ParkingRowAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

ParkingRowAttributeMapListHeader::ParkingRowAttributeMapListHeader(const ParkingRowAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeMapListHeader& ParkingRowAttributeMapListHeader::operator=(const ParkingRowAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeMapListHeader::ParkingRowAttributeMapListHeader(ParkingRowAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeMapListHeader& ParkingRowAttributeMapListHeader::operator=(ParkingRowAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeMapListHeader::ParkingRowAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const ParkingRowAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void ParkingRowAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool ParkingRowAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t ParkingRowAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'ParkingRowAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::venue::details::attributes::ParkingRowAttributeType>& ParkingRowAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingRowAttributeType>& ParkingRowAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void ParkingRowAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::venue::details::attributes::ParkingRowAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void ParkingRowAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::venue::details::attributes::ParkingRowAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingRowAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingRowAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void ParkingRowAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void ParkingRowAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void ParkingRowAttributeMapListHeader::initPackingContext(ParkingRowAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t ParkingRowAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeMapListHeader::bitSizeOf(ParkingRowAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingRowAttributeMapListHeader::initializeOffsets(ParkingRowAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingRowAttributeMapListHeader::operator==(const ParkingRowAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t ParkingRowAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void ParkingRowAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingRowAttributeMapListHeader::write(ParkingRowAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingRowAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingRowAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingRowAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingRowAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingRowAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingRowAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingRowAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingRowAttributeMapListHeader::readAttributeTypeCode(ParkingRowAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
ParkingRowAttributeMapListHeader::ZserioArrayType_conditionType ParkingRowAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingRowAttributeMapListHeader::ZserioArrayType_conditionType ParkingRowAttributeMapListHeader::readConditionType(ParkingRowAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSpotAttributeMapListHeader.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSpotAttributeMapListHeader::ParkingSpotAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

ParkingSpotAttributeMapListHeader::ParkingSpotAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

ParkingSpotAttributeMapListHeader::ParkingSpotAttributeMapListHeader(ParkingSpotAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

ParkingSpotAttributeMapListHeader::ParkingSpotAttributeMapListHeader(const ParkingSpotAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeMapListHeader& ParkingSpotAttributeMapListHeader::operator=(const ParkingSpotAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeMapListHeader::ParkingSpotAttributeMapListHeader(ParkingSpotAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeMapListHeader& ParkingSpotAttributeMapListHeader::operator=(ParkingSpotAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeMapListHeader::ParkingSpotAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const ParkingSpotAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void ParkingSpotAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool ParkingSpotAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t ParkingSpotAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'ParkingSpotAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::venue::details::attributes::ParkingSpotAttributeType>& ParkingSpotAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::attributes::ParkingSpotAttributeType>& ParkingSpotAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void ParkingSpotAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::venue::details::attributes::ParkingSpotAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void ParkingSpotAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::venue::details::attributes::ParkingSpotAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingSpotAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& ParkingSpotAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void ParkingSpotAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void ParkingSpotAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void ParkingSpotAttributeMapListHeader::initPackingContext(ParkingSpotAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t ParkingSpotAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeMapListHeader::bitSizeOf(ParkingSpotAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSpotAttributeMapListHeader::initializeOffsets(ParkingSpotAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSpotAttributeMapListHeader::operator==(const ParkingSpotAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t ParkingSpotAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void ParkingSpotAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingSpotAttributeMapListHeader::write(ParkingSpotAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void ParkingSpotAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingSpotAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSpotAttributeMapListHeader::ZserioElementFactory_conditionType::create(ParkingSpotAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

ParkingSpotAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingSpotAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingSpotAttributeMapListHeader::ZserioArrayType_attributeTypeCode ParkingSpotAttributeMapListHeader::readAttributeTypeCode(ParkingSpotAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
ParkingSpotAttributeMapListHeader::ZserioArrayType_conditionType ParkingSpotAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

ParkingSpotAttributeMapListHeader::ZserioArrayType_conditionType ParkingSpotAttributeMapListHeader::readConditionType(ParkingSpotAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingFacilityAttributeMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingFacilityAttributeMap::ParkingFacilityAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingFacilityAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

ParkingFacilityAttributeMap::ParkingFacilityAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

ParkingFacilityAttributeMap::ParkingFacilityAttributeMap(ParkingFacilityAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

ParkingFacilityAttributeMap::ParkingFacilityAttributeMap(const ParkingFacilityAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeMap& ParkingFacilityAttributeMap::operator=(const ParkingFacilityAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeMap::ParkingFacilityAttributeMap(ParkingFacilityAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeMap& ParkingFacilityAttributeMap::operator=(ParkingFacilityAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeMap::ParkingFacilityAttributeMap(::zserio::PropagateAllocatorT,
        const ParkingFacilityAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingFacilityAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingFacilityAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingFacilityAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingFacilityAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingFacilityAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::attributes::ParkingFacilityAttributeType ParkingFacilityAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingFacilityAttributeMap::setAttributeTypeCode(::nds::venue::details::attributes::ParkingFacilityAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator ParkingFacilityAttributeMap::getFeature() const
{
    return m_feature_;
}

void ParkingFacilityAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& ParkingFacilityAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& ParkingFacilityAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void ParkingFacilityAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void ParkingFacilityAttributeMap::setFeatureReferences(::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingFacilityAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingFacilityAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void ParkingFacilityAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void ParkingFacilityAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingFacilityAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingFacilityAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void ParkingFacilityAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void ParkingFacilityAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator ParkingFacilityAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void ParkingFacilityAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttribute>& ParkingFacilityAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttribute>& ParkingFacilityAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void ParkingFacilityAttributeMap::setAttributeValues(const ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void ParkingFacilityAttributeMap::setAttributeValues(::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingFacilityAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingFacilityAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void ParkingFacilityAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void ParkingFacilityAttributeMap::setAttributeProperties(::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingFacilityAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingFacilityAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void ParkingFacilityAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void ParkingFacilityAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void ParkingFacilityAttributeMap::initPackingContext(ParkingFacilityAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t ParkingFacilityAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeMap::bitSizeOf(ParkingFacilityAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingFacilityAttributeMap::initializeOffsets(ParkingFacilityAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingFacilityAttributeMap::operator==(const ParkingFacilityAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t ParkingFacilityAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void ParkingFacilityAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingFacilityAttributeMap::write(ParkingFacilityAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingFacilityAttributeMap::ZserioElementFactory_featureReferences::create(ParkingFacilityAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingFacilityAttributeMap::ZserioElementFactory_featureReferences::create(ParkingFacilityAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& array,
        ::nds::venue::reference::types::ParkingFacilityId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingFacilityAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(ParkingFacilityAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingFacilityAttributeMap::ZserioElementFactory_featureValidities::create(ParkingFacilityAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingFacilityAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(ParkingFacilityAttributeMap& owner,
        ::nds::venue::details::instantiations::ParkingFacilityAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(owner.getAttributeTypeCode()));
}

void ParkingFacilityAttributeMap::ZserioElementFactory_attributeValues::create(ParkingFacilityAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingFacilityAttributeMap::ZserioElementFactory_attributeValues::create(ParkingFacilityAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttribute>& array,
        ::nds::venue::details::instantiations::ParkingFacilityAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingFacilityAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(ParkingFacilityAttributeMap&,
        ::nds::venue::details::instantiations::VenuePropertyList& element, size_t)
{
    element.initializeChildren();
}

void ParkingFacilityAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingFacilityAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingFacilityAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingFacilityAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::nds::venue::details::instantiations::VenuePropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingFacilityAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(ParkingFacilityAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void ParkingFacilityAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingFacilityAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingFacilityAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingFacilityAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::venue::details::attributes::ParkingFacilityAttributeType ParkingFacilityAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingFacilityAttributeType>(in);
}

::nds::venue::details::attributes::ParkingFacilityAttributeType ParkingFacilityAttributeMap::readAttributeTypeCode(ParkingFacilityAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingFacilityAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator ParkingFacilityAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingFacilityAttributeMap::readFeature(ParkingFacilityAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingFacilityAttributeMap::ZserioArrayType_featureReferences ParkingFacilityAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingFacilityAttributeMap::ZserioArrayType_featureReferences ParkingFacilityAttributeMap::readFeatureReferences(ParkingFacilityAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingFacilityAttributeMap::ZserioArrayType_featureValidities ParkingFacilityAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingFacilityAttributeMap::ZserioArrayType_featureValuePtr ParkingFacilityAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingFacilityAttributeMap::ZserioArrayType_featureValuePtr ParkingFacilityAttributeMap::readFeatureValuePtr(ParkingFacilityAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator ParkingFacilityAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator ParkingFacilityAttributeMap::readAttribute(ParkingFacilityAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingFacilityAttributeMap::ZserioArrayType_attributeValues ParkingFacilityAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingFacilityAttributeMap::ZserioArrayType_attributeValues ParkingFacilityAttributeMap::readAttributeValues(ParkingFacilityAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingFacilityAttributeMap::ZserioArrayType_attributeProperties ParkingFacilityAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingFacilityAttributeMap::ZserioArrayType_attributeProperties ParkingFacilityAttributeMap::readAttributeProperties(ParkingFacilityAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingFacilityAttributeMap::ZserioArrayType_attributeConditions ParkingFacilityAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingFacilityAttributeMap::ZserioArrayType_attributeConditions ParkingFacilityAttributeMap::readAttributeConditions(ParkingFacilityAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingLevelAttributeMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingLevelAttributeMap::ParkingLevelAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingLevelAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

ParkingLevelAttributeMap::ParkingLevelAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

ParkingLevelAttributeMap::ParkingLevelAttributeMap(ParkingLevelAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

ParkingLevelAttributeMap::ParkingLevelAttributeMap(const ParkingLevelAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeMap& ParkingLevelAttributeMap::operator=(const ParkingLevelAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeMap::ParkingLevelAttributeMap(ParkingLevelAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeMap& ParkingLevelAttributeMap::operator=(ParkingLevelAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeMap::ParkingLevelAttributeMap(::zserio::PropagateAllocatorT,
        const ParkingLevelAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingLevelAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingLevelAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingLevelAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingLevelAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingLevelAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::attributes::ParkingLevelAttributeType ParkingLevelAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingLevelAttributeMap::setAttributeTypeCode(::nds::venue::details::attributes::ParkingLevelAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator ParkingLevelAttributeMap::getFeature() const
{
    return m_feature_;
}

void ParkingLevelAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& ParkingLevelAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& ParkingLevelAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void ParkingLevelAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void ParkingLevelAttributeMap::setFeatureReferences(::zserio::vector<::nds::venue::reference::types::ParkingLevelId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingLevelAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingLevelAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void ParkingLevelAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void ParkingLevelAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingLevelAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingLevelAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void ParkingLevelAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void ParkingLevelAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator ParkingLevelAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void ParkingLevelAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttribute>& ParkingLevelAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttribute>& ParkingLevelAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void ParkingLevelAttributeMap::setAttributeValues(const ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void ParkingLevelAttributeMap::setAttributeValues(::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingLevelAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingLevelAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void ParkingLevelAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void ParkingLevelAttributeMap::setAttributeProperties(::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingLevelAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingLevelAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void ParkingLevelAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void ParkingLevelAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void ParkingLevelAttributeMap::initPackingContext(ParkingLevelAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t ParkingLevelAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeMap::bitSizeOf(ParkingLevelAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingLevelAttributeMap::initializeOffsets(ParkingLevelAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingLevelAttributeMap::operator==(const ParkingLevelAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t ParkingLevelAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void ParkingLevelAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingLevelAttributeMap::write(ParkingLevelAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingLevelAttributeMap::ZserioElementFactory_featureReferences::create(ParkingLevelAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingLevelAttributeMap::ZserioElementFactory_featureReferences::create(ParkingLevelAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& array,
        ::nds::venue::reference::types::ParkingLevelId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingLevelAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(ParkingLevelAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingLevelAttributeMap::ZserioElementFactory_featureValidities::create(ParkingLevelAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingLevelAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(ParkingLevelAttributeMap& owner,
        ::nds::venue::details::instantiations::ParkingLevelAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(owner.getAttributeTypeCode()));
}

void ParkingLevelAttributeMap::ZserioElementFactory_attributeValues::create(ParkingLevelAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingLevelAttributeMap::ZserioElementFactory_attributeValues::create(ParkingLevelAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttribute>& array,
        ::nds::venue::details::instantiations::ParkingLevelAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingLevelAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(ParkingLevelAttributeMap&,
        ::nds::venue::details::instantiations::VenuePropertyList& element, size_t)
{
    element.initializeChildren();
}

void ParkingLevelAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingLevelAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingLevelAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingLevelAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::nds::venue::details::instantiations::VenuePropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingLevelAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(ParkingLevelAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void ParkingLevelAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingLevelAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingLevelAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingLevelAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::venue::details::attributes::ParkingLevelAttributeType ParkingLevelAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingLevelAttributeType>(in);
}

::nds::venue::details::attributes::ParkingLevelAttributeType ParkingLevelAttributeMap::readAttributeTypeCode(ParkingLevelAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingLevelAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator ParkingLevelAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingLevelAttributeMap::readFeature(ParkingLevelAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingLevelAttributeMap::ZserioArrayType_featureReferences ParkingLevelAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingLevelAttributeMap::ZserioArrayType_featureReferences ParkingLevelAttributeMap::readFeatureReferences(ParkingLevelAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingLevelAttributeMap::ZserioArrayType_featureValidities ParkingLevelAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingLevelAttributeMap::ZserioArrayType_featureValuePtr ParkingLevelAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingLevelAttributeMap::ZserioArrayType_featureValuePtr ParkingLevelAttributeMap::readFeatureValuePtr(ParkingLevelAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator ParkingLevelAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator ParkingLevelAttributeMap::readAttribute(ParkingLevelAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingLevelAttributeMap::ZserioArrayType_attributeValues ParkingLevelAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingLevelAttributeMap::ZserioArrayType_attributeValues ParkingLevelAttributeMap::readAttributeValues(ParkingLevelAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingLevelAttributeMap::ZserioArrayType_attributeProperties ParkingLevelAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingLevelAttributeMap::ZserioArrayType_attributeProperties ParkingLevelAttributeMap::readAttributeProperties(ParkingLevelAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingLevelAttributeMap::ZserioArrayType_attributeConditions ParkingLevelAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingLevelAttributeMap::ZserioArrayType_attributeConditions ParkingLevelAttributeMap::readAttributeConditions(ParkingLevelAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSectionAttributeMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSectionAttributeMap::ParkingSectionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingSectionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

ParkingSectionAttributeMap::ParkingSectionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

ParkingSectionAttributeMap::ParkingSectionAttributeMap(ParkingSectionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

ParkingSectionAttributeMap::ParkingSectionAttributeMap(const ParkingSectionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeMap& ParkingSectionAttributeMap::operator=(const ParkingSectionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeMap::ParkingSectionAttributeMap(ParkingSectionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeMap& ParkingSectionAttributeMap::operator=(ParkingSectionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeMap::ParkingSectionAttributeMap(::zserio::PropagateAllocatorT,
        const ParkingSectionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingSectionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSectionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSectionAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingSectionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingSectionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::attributes::ParkingSectionAttributeType ParkingSectionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingSectionAttributeMap::setAttributeTypeCode(::nds::venue::details::attributes::ParkingSectionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator ParkingSectionAttributeMap::getFeature() const
{
    return m_feature_;
}

void ParkingSectionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& ParkingSectionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& ParkingSectionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void ParkingSectionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void ParkingSectionAttributeMap::setFeatureReferences(::zserio::vector<::nds::venue::reference::types::ParkingSectionId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingSectionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingSectionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void ParkingSectionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void ParkingSectionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingSectionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingSectionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void ParkingSectionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void ParkingSectionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator ParkingSectionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void ParkingSectionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttribute>& ParkingSectionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttribute>& ParkingSectionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void ParkingSectionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void ParkingSectionAttributeMap::setAttributeValues(::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingSectionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingSectionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void ParkingSectionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void ParkingSectionAttributeMap::setAttributeProperties(::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingSectionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingSectionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void ParkingSectionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void ParkingSectionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void ParkingSectionAttributeMap::initPackingContext(ParkingSectionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t ParkingSectionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeMap::bitSizeOf(ParkingSectionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSectionAttributeMap::initializeOffsets(ParkingSectionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSectionAttributeMap::operator==(const ParkingSectionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t ParkingSectionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void ParkingSectionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingSectionAttributeMap::write(ParkingSectionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingSectionAttributeMap::ZserioElementFactory_featureReferences::create(ParkingSectionAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSectionAttributeMap::ZserioElementFactory_featureReferences::create(ParkingSectionAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& array,
        ::nds::venue::reference::types::ParkingSectionId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingSectionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(ParkingSectionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingSectionAttributeMap::ZserioElementFactory_featureValidities::create(ParkingSectionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingSectionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(ParkingSectionAttributeMap& owner,
        ::nds::venue::details::instantiations::ParkingSectionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(owner.getAttributeTypeCode()));
}

void ParkingSectionAttributeMap::ZserioElementFactory_attributeValues::create(ParkingSectionAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingSectionAttributeMap::ZserioElementFactory_attributeValues::create(ParkingSectionAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttribute>& array,
        ::nds::venue::details::instantiations::ParkingSectionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingSectionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(ParkingSectionAttributeMap&,
        ::nds::venue::details::instantiations::VenuePropertyList& element, size_t)
{
    element.initializeChildren();
}

void ParkingSectionAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingSectionAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSectionAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingSectionAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::nds::venue::details::instantiations::VenuePropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingSectionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(ParkingSectionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void ParkingSectionAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingSectionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSectionAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingSectionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::venue::details::attributes::ParkingSectionAttributeType ParkingSectionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingSectionAttributeType>(in);
}

::nds::venue::details::attributes::ParkingSectionAttributeType ParkingSectionAttributeMap::readAttributeTypeCode(ParkingSectionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingSectionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator ParkingSectionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingSectionAttributeMap::readFeature(ParkingSectionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSectionAttributeMap::ZserioArrayType_featureReferences ParkingSectionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingSectionAttributeMap::ZserioArrayType_featureReferences ParkingSectionAttributeMap::readFeatureReferences(ParkingSectionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingSectionAttributeMap::ZserioArrayType_featureValidities ParkingSectionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingSectionAttributeMap::ZserioArrayType_featureValuePtr ParkingSectionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingSectionAttributeMap::ZserioArrayType_featureValuePtr ParkingSectionAttributeMap::readFeatureValuePtr(ParkingSectionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator ParkingSectionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator ParkingSectionAttributeMap::readAttribute(ParkingSectionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSectionAttributeMap::ZserioArrayType_attributeValues ParkingSectionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingSectionAttributeMap::ZserioArrayType_attributeValues ParkingSectionAttributeMap::readAttributeValues(ParkingSectionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingSectionAttributeMap::ZserioArrayType_attributeProperties ParkingSectionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingSectionAttributeMap::ZserioArrayType_attributeProperties ParkingSectionAttributeMap::readAttributeProperties(ParkingSectionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingSectionAttributeMap::ZserioArrayType_attributeConditions ParkingSectionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingSectionAttributeMap::ZserioArrayType_attributeConditions ParkingSectionAttributeMap::readAttributeConditions(ParkingSectionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingRowAttributeMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingRowAttributeMap::ParkingRowAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingRowAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

ParkingRowAttributeMap::ParkingRowAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

ParkingRowAttributeMap::ParkingRowAttributeMap(ParkingRowAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

ParkingRowAttributeMap::ParkingRowAttributeMap(const ParkingRowAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeMap& ParkingRowAttributeMap::operator=(const ParkingRowAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeMap::ParkingRowAttributeMap(ParkingRowAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeMap& ParkingRowAttributeMap::operator=(ParkingRowAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeMap::ParkingRowAttributeMap(::zserio::PropagateAllocatorT,
        const ParkingRowAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingRowAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingRowAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingRowAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingRowAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingRowAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::attributes::ParkingRowAttributeType ParkingRowAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingRowAttributeMap::setAttributeTypeCode(::nds::venue::details::attributes::ParkingRowAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator ParkingRowAttributeMap::getFeature() const
{
    return m_feature_;
}

void ParkingRowAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingRowId>& ParkingRowAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingRowId>& ParkingRowAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void ParkingRowAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingRowId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void ParkingRowAttributeMap::setFeatureReferences(::zserio::vector<::nds::venue::reference::types::ParkingRowId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingRowAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingRowAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void ParkingRowAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void ParkingRowAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingRowAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingRowAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void ParkingRowAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void ParkingRowAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator ParkingRowAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void ParkingRowAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttribute>& ParkingRowAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttribute>& ParkingRowAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void ParkingRowAttributeMap::setAttributeValues(const ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void ParkingRowAttributeMap::setAttributeValues(::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingRowAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingRowAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void ParkingRowAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void ParkingRowAttributeMap::setAttributeProperties(::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingRowAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingRowAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void ParkingRowAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void ParkingRowAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void ParkingRowAttributeMap::initPackingContext(ParkingRowAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t ParkingRowAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeMap::bitSizeOf(ParkingRowAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingRowAttributeMap::initializeOffsets(ParkingRowAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingRowAttributeMap::operator==(const ParkingRowAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t ParkingRowAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void ParkingRowAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingRowAttributeMap::write(ParkingRowAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingRowAttributeMap::ZserioElementFactory_featureReferences::create(ParkingRowAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingRowId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingRowAttributeMap::ZserioElementFactory_featureReferences::create(ParkingRowAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingRowId>& array,
        ::nds::venue::reference::types::ParkingRowId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingRowAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(ParkingRowAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingRowAttributeMap::ZserioElementFactory_featureValidities::create(ParkingRowAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingRowAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(ParkingRowAttributeMap& owner,
        ::nds::venue::details::instantiations::ParkingRowAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(owner.getAttributeTypeCode()));
}

void ParkingRowAttributeMap::ZserioElementFactory_attributeValues::create(ParkingRowAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingRowAttributeMap::ZserioElementFactory_attributeValues::create(ParkingRowAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttribute>& array,
        ::nds::venue::details::instantiations::ParkingRowAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingRowAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(ParkingRowAttributeMap&,
        ::nds::venue::details::instantiations::VenuePropertyList& element, size_t)
{
    element.initializeChildren();
}

void ParkingRowAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingRowAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingRowAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingRowAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::nds::venue::details::instantiations::VenuePropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingRowAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(ParkingRowAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void ParkingRowAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingRowAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingRowAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingRowAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::venue::details::attributes::ParkingRowAttributeType ParkingRowAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingRowAttributeType>(in);
}

::nds::venue::details::attributes::ParkingRowAttributeType ParkingRowAttributeMap::readAttributeTypeCode(ParkingRowAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingRowAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator ParkingRowAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingRowAttributeMap::readFeature(ParkingRowAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingRowAttributeMap::ZserioArrayType_featureReferences ParkingRowAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingRowAttributeMap::ZserioArrayType_featureReferences ParkingRowAttributeMap::readFeatureReferences(ParkingRowAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingRowAttributeMap::ZserioArrayType_featureValidities ParkingRowAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingRowAttributeMap::ZserioArrayType_featureValuePtr ParkingRowAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingRowAttributeMap::ZserioArrayType_featureValuePtr ParkingRowAttributeMap::readFeatureValuePtr(ParkingRowAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator ParkingRowAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator ParkingRowAttributeMap::readAttribute(ParkingRowAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingRowAttributeMap::ZserioArrayType_attributeValues ParkingRowAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingRowAttributeMap::ZserioArrayType_attributeValues ParkingRowAttributeMap::readAttributeValues(ParkingRowAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingRowAttributeMap::ZserioArrayType_attributeProperties ParkingRowAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingRowAttributeMap::ZserioArrayType_attributeProperties ParkingRowAttributeMap::readAttributeProperties(ParkingRowAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingRowAttributeMap::ZserioArrayType_attributeConditions ParkingRowAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingRowAttributeMap::ZserioArrayType_attributeConditions ParkingRowAttributeMap::readAttributeConditions(ParkingRowAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSpotAttributeMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSpotAttributeMap::ParkingSpotAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingSpotAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

ParkingSpotAttributeMap::ParkingSpotAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

ParkingSpotAttributeMap::ParkingSpotAttributeMap(ParkingSpotAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

ParkingSpotAttributeMap::ParkingSpotAttributeMap(const ParkingSpotAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeMap& ParkingSpotAttributeMap::operator=(const ParkingSpotAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeMap::ParkingSpotAttributeMap(ParkingSpotAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeMap& ParkingSpotAttributeMap::operator=(ParkingSpotAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeMap::ParkingSpotAttributeMap(::zserio::PropagateAllocatorT,
        const ParkingSpotAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingSpotAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSpotAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSpotAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingSpotAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingSpotAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::attributes::ParkingSpotAttributeType ParkingSpotAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingSpotAttributeMap::setAttributeTypeCode(::nds::venue::details::attributes::ParkingSpotAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator ParkingSpotAttributeMap::getFeature() const
{
    return m_feature_;
}

void ParkingSpotAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& ParkingSpotAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& ParkingSpotAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void ParkingSpotAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void ParkingSpotAttributeMap::setFeatureReferences(::zserio::vector<::nds::venue::reference::types::ParkingSpotId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingSpotAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingSpotAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void ParkingSpotAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void ParkingSpotAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingSpotAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& ParkingSpotAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void ParkingSpotAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void ParkingSpotAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator ParkingSpotAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void ParkingSpotAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttribute>& ParkingSpotAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttribute>& ParkingSpotAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void ParkingSpotAttributeMap::setAttributeValues(const ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void ParkingSpotAttributeMap::setAttributeValues(::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingSpotAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& ParkingSpotAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void ParkingSpotAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void ParkingSpotAttributeMap::setAttributeProperties(::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingSpotAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& ParkingSpotAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void ParkingSpotAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void ParkingSpotAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void ParkingSpotAttributeMap::initPackingContext(ParkingSpotAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t ParkingSpotAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeMap::bitSizeOf(ParkingSpotAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSpotAttributeMap::initializeOffsets(ParkingSpotAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSpotAttributeMap::operator==(const ParkingSpotAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t ParkingSpotAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void ParkingSpotAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingSpotAttributeMap::write(ParkingSpotAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void ParkingSpotAttributeMap::ZserioElementFactory_featureReferences::create(ParkingSpotAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSpotAttributeMap::ZserioElementFactory_featureReferences::create(ParkingSpotAttributeMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& array,
        ::nds::venue::reference::types::ParkingSpotId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingSpotAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(ParkingSpotAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingSpotAttributeMap::ZserioElementFactory_featureValidities::create(ParkingSpotAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingSpotAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(ParkingSpotAttributeMap& owner,
        ::nds::venue::details::instantiations::ParkingSpotAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(owner.getAttributeTypeCode()));
}

void ParkingSpotAttributeMap::ZserioElementFactory_attributeValues::create(ParkingSpotAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingSpotAttributeMap::ZserioElementFactory_attributeValues::create(ParkingSpotAttributeMap&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttribute>& array,
        ::nds::venue::details::instantiations::ParkingSpotAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void ParkingSpotAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(ParkingSpotAttributeMap&,
        ::nds::venue::details::instantiations::VenuePropertyList& element, size_t)
{
    element.initializeChildren();
}

void ParkingSpotAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingSpotAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSpotAttributeMap::ZserioElementFactory_attributeProperties::create(ParkingSpotAttributeMap&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenuePropertyList>& array,
        ::nds::venue::details::instantiations::VenuePropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingSpotAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(ParkingSpotAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void ParkingSpotAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingSpotAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSpotAttributeMap::ZserioElementFactory_attributeConditions::create(ParkingSpotAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::venue::details::attributes::ParkingSpotAttributeType ParkingSpotAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingSpotAttributeType>(in);
}

::nds::venue::details::attributes::ParkingSpotAttributeType ParkingSpotAttributeMap::readAttributeTypeCode(ParkingSpotAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingSpotAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator ParkingSpotAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingSpotAttributeMap::readFeature(ParkingSpotAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSpotAttributeMap::ZserioArrayType_featureReferences ParkingSpotAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingSpotAttributeMap::ZserioArrayType_featureReferences ParkingSpotAttributeMap::readFeatureReferences(ParkingSpotAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingSpotAttributeMap::ZserioArrayType_featureValidities ParkingSpotAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingSpotAttributeMap::ZserioArrayType_featureValuePtr ParkingSpotAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingSpotAttributeMap::ZserioArrayType_featureValuePtr ParkingSpotAttributeMap::readFeatureValuePtr(ParkingSpotAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator ParkingSpotAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator ParkingSpotAttributeMap::readAttribute(ParkingSpotAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSpotAttributeMap::ZserioArrayType_attributeValues ParkingSpotAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingSpotAttributeMap::ZserioArrayType_attributeValues ParkingSpotAttributeMap::readAttributeValues(ParkingSpotAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingSpotAttributeMap::ZserioArrayType_attributeProperties ParkingSpotAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingSpotAttributeMap::ZserioArrayType_attributeProperties ParkingSpotAttributeMap::readAttributeProperties(ParkingSpotAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
ParkingSpotAttributeMap::ZserioArrayType_attributeConditions ParkingSpotAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

ParkingSpotAttributeMap::ZserioArrayType_attributeConditions ParkingSpotAttributeMap::readAttributeConditions(ParkingSpotAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingFacilityAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingFacilityAttribute::ParkingFacilityAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

ParkingFacilityAttribute::ParkingFacilityAttribute(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingFacilityAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

ParkingFacilityAttribute::ParkingFacilityAttribute(ParkingFacilityAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingFacilityAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

ParkingFacilityAttribute::ParkingFacilityAttribute(const ParkingFacilityAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttribute& ParkingFacilityAttribute::operator=(const ParkingFacilityAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttribute::ParkingFacilityAttribute(ParkingFacilityAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttribute& ParkingFacilityAttribute::operator=(ParkingFacilityAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttribute::ParkingFacilityAttribute(::zserio::PropagateAllocatorT,
        const ParkingFacilityAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void ParkingFacilityAttribute::initialize(
        ::nds::venue::details::attributes::ParkingFacilityAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingFacilityAttribute::isInitialized() const
{
    return m_isInitialized;
}

void ParkingFacilityAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()));
}

::nds::venue::details::attributes::ParkingFacilityAttributeType ParkingFacilityAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'ParkingFacilityAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingFacilityAttributeValue& ParkingFacilityAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingFacilityAttributeValue& ParkingFacilityAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingFacilityAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingFacilityAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingFacilityAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingFacilityAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void ParkingFacilityAttribute::initPackingContext(ParkingFacilityAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t ParkingFacilityAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttribute::bitSizeOf(ParkingFacilityAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingFacilityAttribute::initializeOffsets(ParkingFacilityAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool ParkingFacilityAttribute::operator==(const ParkingFacilityAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t ParkingFacilityAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void ParkingFacilityAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingFacilityAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void ParkingFacilityAttribute::write(ParkingFacilityAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingFacilityAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::venue::details::attributes::ParkingFacilityAttributeValue ParkingFacilityAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingFacilityAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingFacilityAttributeValue ParkingFacilityAttribute::readAttributeValue(ParkingFacilityAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingFacilityAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingLevelAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingLevelAttribute::ParkingLevelAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

ParkingLevelAttribute::ParkingLevelAttribute(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingLevelAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

ParkingLevelAttribute::ParkingLevelAttribute(ParkingLevelAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingLevelAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

ParkingLevelAttribute::ParkingLevelAttribute(const ParkingLevelAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingLevelAttribute& ParkingLevelAttribute::operator=(const ParkingLevelAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttribute::ParkingLevelAttribute(ParkingLevelAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingLevelAttribute& ParkingLevelAttribute::operator=(ParkingLevelAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttribute::ParkingLevelAttribute(::zserio::PropagateAllocatorT,
        const ParkingLevelAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void ParkingLevelAttribute::initialize(
        ::nds::venue::details::attributes::ParkingLevelAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingLevelAttribute::isInitialized() const
{
    return m_isInitialized;
}

void ParkingLevelAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()));
}

::nds::venue::details::attributes::ParkingLevelAttributeType ParkingLevelAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'ParkingLevelAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingLevelAttributeValue& ParkingLevelAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingLevelAttributeValue& ParkingLevelAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingLevelAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingLevelAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingLevelAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingLevelAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void ParkingLevelAttribute::initPackingContext(ParkingLevelAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t ParkingLevelAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttribute::bitSizeOf(ParkingLevelAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingLevelAttribute::initializeOffsets(ParkingLevelAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool ParkingLevelAttribute::operator==(const ParkingLevelAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t ParkingLevelAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void ParkingLevelAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingLevelAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void ParkingLevelAttribute::write(ParkingLevelAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingLevelAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::venue::details::attributes::ParkingLevelAttributeValue ParkingLevelAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingLevelAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingLevelAttributeValue ParkingLevelAttribute::readAttributeValue(ParkingLevelAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingLevelAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSectionAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSectionAttribute::ParkingSectionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

ParkingSectionAttribute::ParkingSectionAttribute(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingSectionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

ParkingSectionAttribute::ParkingSectionAttribute(ParkingSectionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingSectionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

ParkingSectionAttribute::ParkingSectionAttribute(const ParkingSectionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingSectionAttribute& ParkingSectionAttribute::operator=(const ParkingSectionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttribute::ParkingSectionAttribute(ParkingSectionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingSectionAttribute& ParkingSectionAttribute::operator=(ParkingSectionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttribute::ParkingSectionAttribute(::zserio::PropagateAllocatorT,
        const ParkingSectionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void ParkingSectionAttribute::initialize(
        ::nds::venue::details::attributes::ParkingSectionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSectionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSectionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()));
}

::nds::venue::details::attributes::ParkingSectionAttributeType ParkingSectionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'ParkingSectionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingSectionAttributeValue& ParkingSectionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingSectionAttributeValue& ParkingSectionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingSectionAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingSectionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingSectionAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingSectionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void ParkingSectionAttribute::initPackingContext(ParkingSectionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t ParkingSectionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttribute::bitSizeOf(ParkingSectionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingSectionAttribute::initializeOffsets(ParkingSectionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool ParkingSectionAttribute::operator==(const ParkingSectionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t ParkingSectionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void ParkingSectionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingSectionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void ParkingSectionAttribute::write(ParkingSectionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingSectionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::venue::details::attributes::ParkingSectionAttributeValue ParkingSectionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingSectionAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingSectionAttributeValue ParkingSectionAttribute::readAttributeValue(ParkingSectionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingSectionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingRowAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingRowAttribute::ParkingRowAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

ParkingRowAttribute::ParkingRowAttribute(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingRowAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

ParkingRowAttribute::ParkingRowAttribute(ParkingRowAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingRowAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

ParkingRowAttribute::ParkingRowAttribute(const ParkingRowAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingRowAttribute& ParkingRowAttribute::operator=(const ParkingRowAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttribute::ParkingRowAttribute(ParkingRowAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingRowAttribute& ParkingRowAttribute::operator=(ParkingRowAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttribute::ParkingRowAttribute(::zserio::PropagateAllocatorT,
        const ParkingRowAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void ParkingRowAttribute::initialize(
        ::nds::venue::details::attributes::ParkingRowAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingRowAttribute::isInitialized() const
{
    return m_isInitialized;
}

void ParkingRowAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()));
}

::nds::venue::details::attributes::ParkingRowAttributeType ParkingRowAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'ParkingRowAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingRowAttributeValue& ParkingRowAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingRowAttributeValue& ParkingRowAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingRowAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingRowAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingRowAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingRowAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void ParkingRowAttribute::initPackingContext(ParkingRowAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t ParkingRowAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttribute::bitSizeOf(ParkingRowAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingRowAttribute::initializeOffsets(ParkingRowAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool ParkingRowAttribute::operator==(const ParkingRowAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t ParkingRowAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void ParkingRowAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingRowAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void ParkingRowAttribute::write(ParkingRowAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingRowAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::venue::details::attributes::ParkingRowAttributeValue ParkingRowAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingRowAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingRowAttributeValue ParkingRowAttribute::readAttributeValue(ParkingRowAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingRowAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSpotAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSpotAttribute::ParkingSpotAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

ParkingSpotAttribute::ParkingSpotAttribute(::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingSpotAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

ParkingSpotAttribute::ParkingSpotAttribute(ParkingSpotAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::venue::details::attributes::ParkingSpotAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

ParkingSpotAttribute::ParkingSpotAttribute(const ParkingSpotAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingSpotAttribute& ParkingSpotAttribute::operator=(const ParkingSpotAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttribute::ParkingSpotAttribute(ParkingSpotAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

ParkingSpotAttribute& ParkingSpotAttribute::operator=(ParkingSpotAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttribute::ParkingSpotAttribute(::zserio::PropagateAllocatorT,
        const ParkingSpotAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void ParkingSpotAttribute::initialize(
        ::nds::venue::details::attributes::ParkingSpotAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSpotAttribute::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSpotAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()));
}

::nds::venue::details::attributes::ParkingSpotAttributeType ParkingSpotAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'ParkingSpotAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingSpotAttributeValue& ParkingSpotAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingSpotAttributeValue& ParkingSpotAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingSpotAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingSpotAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingSpotAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingSpotAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void ParkingSpotAttribute::initPackingContext(ParkingSpotAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t ParkingSpotAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttribute::bitSizeOf(ParkingSpotAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ParkingSpotAttribute::initializeOffsets(ParkingSpotAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool ParkingSpotAttribute::operator==(const ParkingSpotAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t ParkingSpotAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void ParkingSpotAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingSpotAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void ParkingSpotAttribute::write(ParkingSpotAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingSpotAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::venue::details::attributes::ParkingSpotAttributeValue ParkingSpotAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingSpotAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingSpotAttributeValue ParkingSpotAttribute::readAttributeValue(ParkingSpotAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingSpotAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/VenueProperty.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

VenueProperty::VenueProperty(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_propertyTypeCode_(allocator),
        m_propertyValue_(allocator)
{
}

VenueProperty::VenueProperty(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(in, allocator)),
        m_propertyValue_(readPropertyValue(in, allocator))
{
}

VenueProperty::VenueProperty(VenueProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(context, in, allocator)),
        m_propertyValue_(readPropertyValue(context, in, allocator))
{
}

VenueProperty::VenueProperty(const VenueProperty& other) :
        m_propertyTypeCode_(other.m_propertyTypeCode_),
        m_propertyValue_(other.m_propertyValue_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

VenueProperty& VenueProperty::operator=(const VenueProperty& other)
{
    m_propertyTypeCode_ = other.m_propertyTypeCode_;
    m_propertyValue_ = other.m_propertyValue_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

VenueProperty::VenueProperty(VenueProperty&& other) :
        m_propertyTypeCode_(::std::move(other.m_propertyTypeCode_)),
        m_propertyValue_(::std::move(other.m_propertyValue_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

VenueProperty& VenueProperty::operator=(VenueProperty&& other)
{
    m_propertyTypeCode_ = ::std::move(other.m_propertyTypeCode_);
    m_propertyValue_ = ::std::move(other.m_propertyValue_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

VenueProperty::VenueProperty(::zserio::PropagateAllocatorT,
        const VenueProperty& other, const allocator_type& allocator) :
        m_propertyTypeCode_(::zserio::allocatorPropagatingCopy(other.m_propertyTypeCode_, allocator)),
        m_propertyValue_(::zserio::allocatorPropagatingCopy(other.m_propertyValue_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void VenueProperty::initializeChildren()
{
    m_propertyValue_.initialize(getPropertyTypeCode());

    m_areChildrenInitialized = true;
}

::nds::venue::details::properties::VenuePropertyType& VenueProperty::getPropertyTypeCode()
{
    return m_propertyTypeCode_;
}

const ::nds::venue::details::properties::VenuePropertyType& VenueProperty::getPropertyTypeCode() const
{
    return m_propertyTypeCode_;
}

void VenueProperty::setPropertyTypeCode(const ::nds::venue::details::properties::VenuePropertyType& propertyTypeCode_)
{
    m_propertyTypeCode_ = propertyTypeCode_;
}

void VenueProperty::setPropertyTypeCode(::nds::venue::details::properties::VenuePropertyType&& propertyTypeCode_)
{
    m_propertyTypeCode_ = ::std::move(propertyTypeCode_);
}

::nds::venue::details::properties::VenuePropertyValue& VenueProperty::getPropertyValue()
{
    return m_propertyValue_;
}

const ::nds::venue::details::properties::VenuePropertyValue& VenueProperty::getPropertyValue() const
{
    return m_propertyValue_;
}

void VenueProperty::setPropertyValue(const ::nds::venue::details::properties::VenuePropertyValue& propertyValue_)
{
    m_propertyValue_ = propertyValue_;
}

void VenueProperty::setPropertyValue(::nds::venue::details::properties::VenuePropertyValue&& propertyValue_)
{
    m_propertyValue_ = ::std::move(propertyValue_);
}

void VenueProperty::initPackingContext(VenueProperty::ZserioPackingContext& context) const
{
    m_propertyTypeCode_.initPackingContext(context.getPropertyTypeCode());
    m_propertyValue_.initPackingContext(context.getPropertyValue());
}

size_t VenueProperty::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t VenueProperty::bitSizeOf(VenueProperty::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(context.getPropertyValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t VenueProperty::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t VenueProperty::initializeOffsets(VenueProperty::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(context.getPropertyValue(), endBitPosition);

    return endBitPosition;
}

bool VenueProperty::operator==(const VenueProperty& other) const
{
    if (this != &other)
    {
        return
                (m_propertyTypeCode_ == other.m_propertyTypeCode_) &&
                (m_propertyValue_ == other.m_propertyValue_);
    }

    return true;
}

uint32_t VenueProperty::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_propertyTypeCode_);
    result = ::zserio::calcHashCode(result, m_propertyValue_);

    return result;
}

void VenueProperty::write(::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field VenueProperty.propertyValue!");
    }
    m_propertyValue_.write(out);
}

void VenueProperty::write(VenueProperty::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(context.getPropertyTypeCode(), out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field VenueProperty.propertyValue!");
    }
    m_propertyValue_.write(context.getPropertyValue(), out);
}

::nds::venue::details::properties::VenuePropertyType VenueProperty::readPropertyTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::properties::VenuePropertyType(in, allocator);
}

::nds::venue::details::properties::VenuePropertyType VenueProperty::readPropertyTypeCode(VenueProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::properties::VenuePropertyType(context.getPropertyTypeCode(), in, allocator);
}
::nds::venue::details::properties::VenuePropertyValue VenueProperty::readPropertyValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::properties::VenuePropertyValue(in, getPropertyTypeCode(), allocator);
}

::nds::venue::details::properties::VenuePropertyValue VenueProperty::readPropertyValue(VenueProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::properties::VenuePropertyValue(context.getPropertyValue(), in, getPropertyTypeCode(), allocator);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingFacilityAttributeSet.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingFacilityAttributeSet::ParkingFacilityAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

ParkingFacilityAttributeSet::ParkingFacilityAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

ParkingFacilityAttributeSet::ParkingFacilityAttributeSet(ParkingFacilityAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

ParkingFacilityAttributeSet::ParkingFacilityAttributeSet(::zserio::PropagateAllocatorT,
        const ParkingFacilityAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void ParkingFacilityAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t ParkingFacilityAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void ParkingFacilityAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityFullAttribute>& ParkingFacilityAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityFullAttribute>& ParkingFacilityAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void ParkingFacilityAttributeSet::setAttributes(const ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void ParkingFacilityAttributeSet::setAttributes(::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void ParkingFacilityAttributeSet::initPackingContext(ParkingFacilityAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t ParkingFacilityAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeSet::bitSizeOf(ParkingFacilityAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingFacilityAttributeSet::initializeOffsets(ParkingFacilityAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingFacilityAttributeSet::operator==(const ParkingFacilityAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t ParkingFacilityAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void ParkingFacilityAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingFacilityAttributeSet::write(ParkingFacilityAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingFacilityAttributeSet::ZserioArrayExpressions_attributes::initializeElement(ParkingFacilityAttributeSet&,
        ::nds::venue::details::instantiations::ParkingFacilityFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void ParkingFacilityAttributeSet::ZserioElementFactory_attributes::create(ParkingFacilityAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingFacilityAttributeSet::ZserioElementFactory_attributes::create(ParkingFacilityAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityFullAttribute>& array,
        ::nds::venue::details::instantiations::ParkingFacilityFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t ParkingFacilityAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingFacilityAttributeSet::readNumEntries(ParkingFacilityAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingFacilityAttributeSet::ZserioArrayType_attributes ParkingFacilityAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

ParkingFacilityAttributeSet::ZserioArrayType_attributes ParkingFacilityAttributeSet::readAttributes(ParkingFacilityAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingLevelAttributeSet.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingLevelAttributeSet::ParkingLevelAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

ParkingLevelAttributeSet::ParkingLevelAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

ParkingLevelAttributeSet::ParkingLevelAttributeSet(ParkingLevelAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

ParkingLevelAttributeSet::ParkingLevelAttributeSet(::zserio::PropagateAllocatorT,
        const ParkingLevelAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void ParkingLevelAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t ParkingLevelAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void ParkingLevelAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingLevelFullAttribute>& ParkingLevelAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelFullAttribute>& ParkingLevelAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void ParkingLevelAttributeSet::setAttributes(const ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void ParkingLevelAttributeSet::setAttributes(::zserio::vector<::nds::venue::details::instantiations::ParkingLevelFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void ParkingLevelAttributeSet::initPackingContext(ParkingLevelAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t ParkingLevelAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeSet::bitSizeOf(ParkingLevelAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingLevelAttributeSet::initializeOffsets(ParkingLevelAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingLevelAttributeSet::operator==(const ParkingLevelAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t ParkingLevelAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void ParkingLevelAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingLevelAttributeSet::write(ParkingLevelAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingLevelAttributeSet::ZserioArrayExpressions_attributes::initializeElement(ParkingLevelAttributeSet&,
        ::nds::venue::details::instantiations::ParkingLevelFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void ParkingLevelAttributeSet::ZserioElementFactory_attributes::create(ParkingLevelAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingLevelAttributeSet::ZserioElementFactory_attributes::create(ParkingLevelAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelFullAttribute>& array,
        ::nds::venue::details::instantiations::ParkingLevelFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t ParkingLevelAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingLevelAttributeSet::readNumEntries(ParkingLevelAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingLevelAttributeSet::ZserioArrayType_attributes ParkingLevelAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

ParkingLevelAttributeSet::ZserioArrayType_attributes ParkingLevelAttributeSet::readAttributes(ParkingLevelAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSectionAttributeSet.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSectionAttributeSet::ParkingSectionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

ParkingSectionAttributeSet::ParkingSectionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

ParkingSectionAttributeSet::ParkingSectionAttributeSet(ParkingSectionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

ParkingSectionAttributeSet::ParkingSectionAttributeSet(::zserio::PropagateAllocatorT,
        const ParkingSectionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void ParkingSectionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t ParkingSectionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void ParkingSectionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingSectionFullAttribute>& ParkingSectionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionFullAttribute>& ParkingSectionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void ParkingSectionAttributeSet::setAttributes(const ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void ParkingSectionAttributeSet::setAttributes(::zserio::vector<::nds::venue::details::instantiations::ParkingSectionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void ParkingSectionAttributeSet::initPackingContext(ParkingSectionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t ParkingSectionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeSet::bitSizeOf(ParkingSectionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSectionAttributeSet::initializeOffsets(ParkingSectionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSectionAttributeSet::operator==(const ParkingSectionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t ParkingSectionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void ParkingSectionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingSectionAttributeSet::write(ParkingSectionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingSectionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(ParkingSectionAttributeSet&,
        ::nds::venue::details::instantiations::ParkingSectionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void ParkingSectionAttributeSet::ZserioElementFactory_attributes::create(ParkingSectionAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSectionAttributeSet::ZserioElementFactory_attributes::create(ParkingSectionAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionFullAttribute>& array,
        ::nds::venue::details::instantiations::ParkingSectionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t ParkingSectionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingSectionAttributeSet::readNumEntries(ParkingSectionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSectionAttributeSet::ZserioArrayType_attributes ParkingSectionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

ParkingSectionAttributeSet::ZserioArrayType_attributes ParkingSectionAttributeSet::readAttributes(ParkingSectionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingRowAttributeSet.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingRowAttributeSet::ParkingRowAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

ParkingRowAttributeSet::ParkingRowAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

ParkingRowAttributeSet::ParkingRowAttributeSet(ParkingRowAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

ParkingRowAttributeSet::ParkingRowAttributeSet(::zserio::PropagateAllocatorT,
        const ParkingRowAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void ParkingRowAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t ParkingRowAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void ParkingRowAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingRowFullAttribute>& ParkingRowAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingRowFullAttribute>& ParkingRowAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void ParkingRowAttributeSet::setAttributes(const ::zserio::vector<::nds::venue::details::instantiations::ParkingRowFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void ParkingRowAttributeSet::setAttributes(::zserio::vector<::nds::venue::details::instantiations::ParkingRowFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void ParkingRowAttributeSet::initPackingContext(ParkingRowAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t ParkingRowAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeSet::bitSizeOf(ParkingRowAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingRowAttributeSet::initializeOffsets(ParkingRowAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingRowAttributeSet::operator==(const ParkingRowAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t ParkingRowAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void ParkingRowAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingRowAttributeSet::write(ParkingRowAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingRowAttributeSet::ZserioArrayExpressions_attributes::initializeElement(ParkingRowAttributeSet&,
        ::nds::venue::details::instantiations::ParkingRowFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void ParkingRowAttributeSet::ZserioElementFactory_attributes::create(ParkingRowAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingRowFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingRowAttributeSet::ZserioElementFactory_attributes::create(ParkingRowAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingRowFullAttribute>& array,
        ::nds::venue::details::instantiations::ParkingRowFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t ParkingRowAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingRowAttributeSet::readNumEntries(ParkingRowAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingRowAttributeSet::ZserioArrayType_attributes ParkingRowAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

ParkingRowAttributeSet::ZserioArrayType_attributes ParkingRowAttributeSet::readAttributes(ParkingRowAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSpotAttributeSet.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSpotAttributeSet::ParkingSpotAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

ParkingSpotAttributeSet::ParkingSpotAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

ParkingSpotAttributeSet::ParkingSpotAttributeSet(ParkingSpotAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

ParkingSpotAttributeSet::ParkingSpotAttributeSet(::zserio::PropagateAllocatorT,
        const ParkingSpotAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void ParkingSpotAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t ParkingSpotAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void ParkingSpotAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingSpotFullAttribute>& ParkingSpotAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotFullAttribute>& ParkingSpotAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void ParkingSpotAttributeSet::setAttributes(const ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void ParkingSpotAttributeSet::setAttributes(::zserio::vector<::nds::venue::details::instantiations::ParkingSpotFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void ParkingSpotAttributeSet::initPackingContext(ParkingSpotAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t ParkingSpotAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeSet::bitSizeOf(ParkingSpotAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSpotAttributeSet::initializeOffsets(ParkingSpotAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSpotAttributeSet::operator==(const ParkingSpotAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t ParkingSpotAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void ParkingSpotAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingSpotAttributeSet::write(ParkingSpotAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void ParkingSpotAttributeSet::ZserioArrayExpressions_attributes::initializeElement(ParkingSpotAttributeSet&,
        ::nds::venue::details::instantiations::ParkingSpotFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void ParkingSpotAttributeSet::ZserioElementFactory_attributes::create(ParkingSpotAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSpotAttributeSet::ZserioElementFactory_attributes::create(ParkingSpotAttributeSet&        ,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotFullAttribute>& array,
        ::nds::venue::details::instantiations::ParkingSpotFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t ParkingSpotAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingSpotAttributeSet::readNumEntries(ParkingSpotAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSpotAttributeSet::ZserioArrayType_attributes ParkingSpotAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

ParkingSpotAttributeSet::ZserioArrayType_attributes ParkingSpotAttributeSet::readAttributes(ParkingSpotAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingFacilityFullAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingFacilityFullAttribute::ParkingFacilityFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingFacilityAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

ParkingFacilityFullAttribute::ParkingFacilityFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

ParkingFacilityFullAttribute::ParkingFacilityFullAttribute(ParkingFacilityFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

ParkingFacilityFullAttribute::ParkingFacilityFullAttribute(const ParkingFacilityFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingFacilityFullAttribute& ParkingFacilityFullAttribute::operator=(const ParkingFacilityFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingFacilityFullAttribute::ParkingFacilityFullAttribute(ParkingFacilityFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingFacilityFullAttribute& ParkingFacilityFullAttribute::operator=(ParkingFacilityFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingFacilityFullAttribute::ParkingFacilityFullAttribute(::zserio::PropagateAllocatorT,
        const ParkingFacilityFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ParkingFacilityFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::venue::details::attributes::ParkingFacilityAttributeType ParkingFacilityFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingFacilityFullAttribute::setAttributeTypeCode(::nds::venue::details::attributes::ParkingFacilityAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingFacilityAttributeValue& ParkingFacilityFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingFacilityAttributeValue& ParkingFacilityFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingFacilityFullAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingFacilityAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingFacilityFullAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingFacilityAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::venue::details::instantiations::VenuePropertyList& ParkingFacilityFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::venue::details::instantiations::VenuePropertyList& ParkingFacilityFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void ParkingFacilityFullAttribute::setProperties(const ::nds::venue::details::instantiations::VenuePropertyList& properties_)
{
    m_properties_ = properties_;
}

void ParkingFacilityFullAttribute::setProperties(::nds::venue::details::instantiations::VenuePropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool ParkingFacilityFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool ParkingFacilityFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void ParkingFacilityFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& ParkingFacilityFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& ParkingFacilityFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void ParkingFacilityFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void ParkingFacilityFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool ParkingFacilityFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool ParkingFacilityFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void ParkingFacilityFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void ParkingFacilityFullAttribute::initPackingContext(ParkingFacilityFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t ParkingFacilityFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityFullAttribute::bitSizeOf(ParkingFacilityFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t ParkingFacilityFullAttribute::initializeOffsets(ParkingFacilityFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool ParkingFacilityFullAttribute::operator==(const ParkingFacilityFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t ParkingFacilityFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void ParkingFacilityFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingFacilityFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingFacilityFullAttribute::write(ParkingFacilityFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingFacilityFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::venue::details::attributes::ParkingFacilityAttributeType ParkingFacilityFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingFacilityAttributeType>(in);
}

::nds::venue::details::attributes::ParkingFacilityAttributeType ParkingFacilityFullAttribute::readAttributeTypeCode(ParkingFacilityFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingFacilityAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::venue::details::attributes::ParkingFacilityAttributeValue ParkingFacilityFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingFacilityAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingFacilityAttributeValue ParkingFacilityFullAttribute::readAttributeValue(ParkingFacilityFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingFacilityAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingFacilityAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingFacilityFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingFacilityFullAttribute::readProperties(ParkingFacilityFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingFacilityFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingFacilityFullAttribute::readConditions(ParkingFacilityFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingLevelFullAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingLevelFullAttribute::ParkingLevelFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingLevelAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

ParkingLevelFullAttribute::ParkingLevelFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

ParkingLevelFullAttribute::ParkingLevelFullAttribute(ParkingLevelFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

ParkingLevelFullAttribute::ParkingLevelFullAttribute(const ParkingLevelFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingLevelFullAttribute& ParkingLevelFullAttribute::operator=(const ParkingLevelFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingLevelFullAttribute::ParkingLevelFullAttribute(ParkingLevelFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingLevelFullAttribute& ParkingLevelFullAttribute::operator=(ParkingLevelFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingLevelFullAttribute::ParkingLevelFullAttribute(::zserio::PropagateAllocatorT,
        const ParkingLevelFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ParkingLevelFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::venue::details::attributes::ParkingLevelAttributeType ParkingLevelFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingLevelFullAttribute::setAttributeTypeCode(::nds::venue::details::attributes::ParkingLevelAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingLevelAttributeValue& ParkingLevelFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingLevelAttributeValue& ParkingLevelFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingLevelFullAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingLevelAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingLevelFullAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingLevelAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::venue::details::instantiations::VenuePropertyList& ParkingLevelFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::venue::details::instantiations::VenuePropertyList& ParkingLevelFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void ParkingLevelFullAttribute::setProperties(const ::nds::venue::details::instantiations::VenuePropertyList& properties_)
{
    m_properties_ = properties_;
}

void ParkingLevelFullAttribute::setProperties(::nds::venue::details::instantiations::VenuePropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool ParkingLevelFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool ParkingLevelFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void ParkingLevelFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& ParkingLevelFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& ParkingLevelFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void ParkingLevelFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void ParkingLevelFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool ParkingLevelFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool ParkingLevelFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void ParkingLevelFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void ParkingLevelFullAttribute::initPackingContext(ParkingLevelFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t ParkingLevelFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingLevelFullAttribute::bitSizeOf(ParkingLevelFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingLevelFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t ParkingLevelFullAttribute::initializeOffsets(ParkingLevelFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool ParkingLevelFullAttribute::operator==(const ParkingLevelFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t ParkingLevelFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void ParkingLevelFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingLevelFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingLevelFullAttribute::write(ParkingLevelFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingLevelFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::venue::details::attributes::ParkingLevelAttributeType ParkingLevelFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingLevelAttributeType>(in);
}

::nds::venue::details::attributes::ParkingLevelAttributeType ParkingLevelFullAttribute::readAttributeTypeCode(ParkingLevelFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingLevelAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::venue::details::attributes::ParkingLevelAttributeValue ParkingLevelFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingLevelAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingLevelAttributeValue ParkingLevelFullAttribute::readAttributeValue(ParkingLevelFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingLevelAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingLevelAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingLevelFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingLevelFullAttribute::readProperties(ParkingLevelFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingLevelFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingLevelFullAttribute::readConditions(ParkingLevelFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSectionFullAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSectionFullAttribute::ParkingSectionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingSectionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

ParkingSectionFullAttribute::ParkingSectionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

ParkingSectionFullAttribute::ParkingSectionFullAttribute(ParkingSectionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

ParkingSectionFullAttribute::ParkingSectionFullAttribute(const ParkingSectionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingSectionFullAttribute& ParkingSectionFullAttribute::operator=(const ParkingSectionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingSectionFullAttribute::ParkingSectionFullAttribute(ParkingSectionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingSectionFullAttribute& ParkingSectionFullAttribute::operator=(ParkingSectionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingSectionFullAttribute::ParkingSectionFullAttribute(::zserio::PropagateAllocatorT,
        const ParkingSectionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ParkingSectionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::venue::details::attributes::ParkingSectionAttributeType ParkingSectionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingSectionFullAttribute::setAttributeTypeCode(::nds::venue::details::attributes::ParkingSectionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingSectionAttributeValue& ParkingSectionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingSectionAttributeValue& ParkingSectionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingSectionFullAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingSectionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingSectionFullAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingSectionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::venue::details::instantiations::VenuePropertyList& ParkingSectionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::venue::details::instantiations::VenuePropertyList& ParkingSectionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void ParkingSectionFullAttribute::setProperties(const ::nds::venue::details::instantiations::VenuePropertyList& properties_)
{
    m_properties_ = properties_;
}

void ParkingSectionFullAttribute::setProperties(::nds::venue::details::instantiations::VenuePropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool ParkingSectionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool ParkingSectionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void ParkingSectionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& ParkingSectionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& ParkingSectionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void ParkingSectionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void ParkingSectionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool ParkingSectionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool ParkingSectionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void ParkingSectionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void ParkingSectionFullAttribute::initPackingContext(ParkingSectionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t ParkingSectionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSectionFullAttribute::bitSizeOf(ParkingSectionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSectionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t ParkingSectionFullAttribute::initializeOffsets(ParkingSectionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool ParkingSectionFullAttribute::operator==(const ParkingSectionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t ParkingSectionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void ParkingSectionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingSectionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingSectionFullAttribute::write(ParkingSectionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingSectionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::venue::details::attributes::ParkingSectionAttributeType ParkingSectionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingSectionAttributeType>(in);
}

::nds::venue::details::attributes::ParkingSectionAttributeType ParkingSectionFullAttribute::readAttributeTypeCode(ParkingSectionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingSectionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::venue::details::attributes::ParkingSectionAttributeValue ParkingSectionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingSectionAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingSectionAttributeValue ParkingSectionFullAttribute::readAttributeValue(ParkingSectionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingSectionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingSectionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingSectionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingSectionFullAttribute::readProperties(ParkingSectionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingSectionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingSectionFullAttribute::readConditions(ParkingSectionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingRowFullAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingRowFullAttribute::ParkingRowFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingRowAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

ParkingRowFullAttribute::ParkingRowFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

ParkingRowFullAttribute::ParkingRowFullAttribute(ParkingRowFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

ParkingRowFullAttribute::ParkingRowFullAttribute(const ParkingRowFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingRowFullAttribute& ParkingRowFullAttribute::operator=(const ParkingRowFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingRowFullAttribute::ParkingRowFullAttribute(ParkingRowFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingRowFullAttribute& ParkingRowFullAttribute::operator=(ParkingRowFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingRowFullAttribute::ParkingRowFullAttribute(::zserio::PropagateAllocatorT,
        const ParkingRowFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ParkingRowFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::venue::details::attributes::ParkingRowAttributeType ParkingRowFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingRowFullAttribute::setAttributeTypeCode(::nds::venue::details::attributes::ParkingRowAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingRowAttributeValue& ParkingRowFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingRowAttributeValue& ParkingRowFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingRowFullAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingRowAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingRowFullAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingRowAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::venue::details::instantiations::VenuePropertyList& ParkingRowFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::venue::details::instantiations::VenuePropertyList& ParkingRowFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void ParkingRowFullAttribute::setProperties(const ::nds::venue::details::instantiations::VenuePropertyList& properties_)
{
    m_properties_ = properties_;
}

void ParkingRowFullAttribute::setProperties(::nds::venue::details::instantiations::VenuePropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool ParkingRowFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool ParkingRowFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void ParkingRowFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& ParkingRowFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& ParkingRowFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void ParkingRowFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void ParkingRowFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool ParkingRowFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool ParkingRowFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void ParkingRowFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void ParkingRowFullAttribute::initPackingContext(ParkingRowFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t ParkingRowFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingRowFullAttribute::bitSizeOf(ParkingRowFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingRowFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t ParkingRowFullAttribute::initializeOffsets(ParkingRowFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool ParkingRowFullAttribute::operator==(const ParkingRowFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t ParkingRowFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void ParkingRowFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingRowFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingRowFullAttribute::write(ParkingRowFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingRowFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::venue::details::attributes::ParkingRowAttributeType ParkingRowFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingRowAttributeType>(in);
}

::nds::venue::details::attributes::ParkingRowAttributeType ParkingRowFullAttribute::readAttributeTypeCode(ParkingRowFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingRowAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::venue::details::attributes::ParkingRowAttributeValue ParkingRowFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingRowAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingRowAttributeValue ParkingRowFullAttribute::readAttributeValue(ParkingRowFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingRowAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingRowAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingRowFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingRowFullAttribute::readProperties(ParkingRowFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingRowFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingRowFullAttribute::readConditions(ParkingRowFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSpotFullAttribute.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSpotFullAttribute::ParkingSpotFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::venue::details::attributes::ParkingSpotAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

ParkingSpotFullAttribute::ParkingSpotFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

ParkingSpotFullAttribute::ParkingSpotFullAttribute(ParkingSpotFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

ParkingSpotFullAttribute::ParkingSpotFullAttribute(const ParkingSpotFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingSpotFullAttribute& ParkingSpotFullAttribute::operator=(const ParkingSpotFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingSpotFullAttribute::ParkingSpotFullAttribute(ParkingSpotFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ParkingSpotFullAttribute& ParkingSpotFullAttribute::operator=(ParkingSpotFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ParkingSpotFullAttribute::ParkingSpotFullAttribute(::zserio::PropagateAllocatorT,
        const ParkingSpotFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ParkingSpotFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::venue::details::attributes::ParkingSpotAttributeType ParkingSpotFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void ParkingSpotFullAttribute::setAttributeTypeCode(::nds::venue::details::attributes::ParkingSpotAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::venue::details::attributes::ParkingSpotAttributeValue& ParkingSpotFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::venue::details::attributes::ParkingSpotAttributeValue& ParkingSpotFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void ParkingSpotFullAttribute::setAttributeValue(const ::nds::venue::details::attributes::ParkingSpotAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void ParkingSpotFullAttribute::setAttributeValue(::nds::venue::details::attributes::ParkingSpotAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::venue::details::instantiations::VenuePropertyList& ParkingSpotFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::venue::details::instantiations::VenuePropertyList& ParkingSpotFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void ParkingSpotFullAttribute::setProperties(const ::nds::venue::details::instantiations::VenuePropertyList& properties_)
{
    m_properties_ = properties_;
}

void ParkingSpotFullAttribute::setProperties(::nds::venue::details::instantiations::VenuePropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool ParkingSpotFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool ParkingSpotFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void ParkingSpotFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& ParkingSpotFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& ParkingSpotFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void ParkingSpotFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void ParkingSpotFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool ParkingSpotFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool ParkingSpotFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void ParkingSpotFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void ParkingSpotFullAttribute::initPackingContext(ParkingSpotFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t ParkingSpotFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSpotFullAttribute::bitSizeOf(ParkingSpotFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ParkingSpotFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t ParkingSpotFullAttribute::initializeOffsets(ParkingSpotFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool ParkingSpotFullAttribute::operator==(const ParkingSpotFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t ParkingSpotFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void ParkingSpotFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingSpotFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void ParkingSpotFullAttribute::write(ParkingSpotFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ParkingSpotFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::venue::details::attributes::ParkingSpotAttributeType ParkingSpotFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingSpotAttributeType>(in);
}

::nds::venue::details::attributes::ParkingSpotAttributeType ParkingSpotFullAttribute::readAttributeTypeCode(ParkingSpotFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::venue::details::attributes::ParkingSpotAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::venue::details::attributes::ParkingSpotAttributeValue ParkingSpotFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingSpotAttributeValue(in, static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::venue::details::attributes::ParkingSpotAttributeValue ParkingSpotFullAttribute::readAttributeValue(ParkingSpotFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::attributes::ParkingSpotAttributeValue(context.getAttributeValue(), in, static_cast<::nds::venue::details::attributes::ParkingSpotAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingSpotFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList> ParkingSpotFullAttribute::readProperties(ParkingSpotFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::nds::venue::details::instantiations::VenuePropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::venue::details::instantiations::VenuePropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingSpotFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> ParkingSpotFullAttribute::readConditions(ParkingSpotFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/VenuePropertyList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

VenuePropertyList::VenuePropertyList(const allocator_type&) noexcept :
        m_numProperties_(uint8_t()),
        m_property_(::zserio::NullOpt)
{
}

VenuePropertyList::VenuePropertyList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(in)),
        m_property_(readProperty(in, allocator))
{
}

VenuePropertyList::VenuePropertyList(VenuePropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(context, in)),
        m_property_(readProperty(context, in, allocator))
{
}

VenuePropertyList::VenuePropertyList(::zserio::PropagateAllocatorT,
        const VenuePropertyList& other, const allocator_type& allocator) :
        m_numProperties_(::zserio::allocatorPropagatingCopy(other.m_numProperties_, allocator)),
        m_property_(::zserio::allocatorPropagatingCopy(other.m_property_, allocator))
{
}

void VenuePropertyList::initializeChildren()
{
    if (getNumProperties() > 0)
        m_property_.value().initializeElements(*this);
}

uint8_t VenuePropertyList::getNumProperties() const
{
    return m_numProperties_;
}

void VenuePropertyList::setNumProperties(uint8_t numProperties_)
{
    m_numProperties_ = numProperties_;
}

::zserio::vector<::nds::venue::details::instantiations::VenueProperty>& VenuePropertyList::getProperty()
{
    return m_property_.value().getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::VenueProperty>& VenuePropertyList::getProperty() const
{
    return m_property_.value().getRawArray();
}

void VenuePropertyList::setProperty(const ::zserio::vector<::nds::venue::details::instantiations::VenueProperty>& property_)
{
    m_property_ = ZserioArrayType_property(property_);
}

void VenuePropertyList::setProperty(::zserio::vector<::nds::venue::details::instantiations::VenueProperty>&& property_)
{
    m_property_ = ZserioArrayType_property(std::move(property_));
}

bool VenuePropertyList::isPropertyUsed() const
{
    return (getNumProperties() > 0);
}

bool VenuePropertyList::isPropertySet() const
{
    return m_property_.hasValue();
}

void VenuePropertyList::resetProperty()
{
    m_property_.reset();
}

void VenuePropertyList::initPackingContext(VenuePropertyList::ZserioPackingContext& context) const
{
    context.getNumProperties().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
}

size_t VenuePropertyList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t VenuePropertyList::bitSizeOf(VenuePropertyList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t VenuePropertyList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t VenuePropertyList::initializeOffsets(VenuePropertyList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool VenuePropertyList::operator==(const VenuePropertyList& other) const
{
    if (this != &other)
    {
        return
                (m_numProperties_ == other.m_numProperties_) &&
                (!isPropertyUsed() ? !other.isPropertyUsed() : (m_property_ == other.m_property_));
    }

    return true;
}

uint32_t VenuePropertyList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numProperties_);
    if (isPropertyUsed())
        result = ::zserio::calcHashCode(result, m_property_);

    return result;
}

void VenuePropertyList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numProperties_, UINT8_C(8));

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field VenuePropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void VenuePropertyList::write(VenuePropertyList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumProperties().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numProperties_);

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field VenuePropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void VenuePropertyList::ZserioArrayExpressions_property::initializeElement(VenuePropertyList&,
        ::nds::venue::details::instantiations::VenueProperty& element, size_t)
{
    element.initializeChildren();
}

void VenuePropertyList::ZserioElementFactory_property::create(VenuePropertyList&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenueProperty>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void VenuePropertyList::ZserioElementFactory_property::create(VenuePropertyList&        ,
        ::zserio::vector<::nds::venue::details::instantiations::VenueProperty>& array,
        ::nds::venue::details::instantiations::VenueProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t VenuePropertyList::readNumProperties(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t VenuePropertyList::readNumProperties(VenuePropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumProperties().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::zserio::InplaceOptionalHolder<VenuePropertyList::ZserioArrayType_property> VenuePropertyList::readProperty(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<VenuePropertyList::ZserioArrayType_property> VenuePropertyList::readProperty(VenuePropertyList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingFacilityAttributeSetMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingFacilityAttributeSetMap::ParkingFacilityAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

ParkingFacilityAttributeSetMap::ParkingFacilityAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingFacilityAttributeSetMap::ParkingFacilityAttributeSetMap(ParkingFacilityAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingFacilityAttributeSetMap::ParkingFacilityAttributeSetMap(const ParkingFacilityAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeSetMap& ParkingFacilityAttributeSetMap::operator=(const ParkingFacilityAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeSetMap::ParkingFacilityAttributeSetMap(ParkingFacilityAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeSetMap& ParkingFacilityAttributeSetMap::operator=(ParkingFacilityAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeSetMap::ParkingFacilityAttributeSetMap(::zserio::PropagateAllocatorT,
        const ParkingFacilityAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingFacilityAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingFacilityAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingFacilityAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingFacilityAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingFacilityAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::instantiations::ParkingFacilityAttributeSet& ParkingFacilityAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::venue::details::instantiations::ParkingFacilityAttributeSet& ParkingFacilityAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void ParkingFacilityAttributeSetMap::setAttributeSet(const ::nds::venue::details::instantiations::ParkingFacilityAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void ParkingFacilityAttributeSetMap::setAttributeSet(::nds::venue::details::instantiations::ParkingFacilityAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator ParkingFacilityAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void ParkingFacilityAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& ParkingFacilityAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& ParkingFacilityAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void ParkingFacilityAttributeSetMap::setReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void ParkingFacilityAttributeSetMap::setReferences(::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingFacilityAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingFacilityAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void ParkingFacilityAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void ParkingFacilityAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void ParkingFacilityAttributeSetMap::initPackingContext(ParkingFacilityAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t ParkingFacilityAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeSetMap::bitSizeOf(ParkingFacilityAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingFacilityAttributeSetMap::initializeOffsets(ParkingFacilityAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingFacilityAttributeSetMap::operator==(const ParkingFacilityAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t ParkingFacilityAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void ParkingFacilityAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingFacilityAttributeSetMap::write(ParkingFacilityAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingFacilityAttributeSetMap::ZserioElementFactory_references::create(ParkingFacilityAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingFacilityAttributeSetMap::ZserioElementFactory_references::create(ParkingFacilityAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingFacilityId>& array,
        ::nds::venue::reference::types::ParkingFacilityId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingFacilityAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(ParkingFacilityAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingFacilityAttributeSetMap::ZserioElementFactory_validities::create(ParkingFacilityAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::venue::details::instantiations::ParkingFacilityAttributeSet ParkingFacilityAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingFacilityAttributeSet(in, allocator);
}

::nds::venue::details::instantiations::ParkingFacilityAttributeSet ParkingFacilityAttributeSetMap::readAttributeSet(ParkingFacilityAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingFacilityAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator ParkingFacilityAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingFacilityAttributeSetMap::readFeature(ParkingFacilityAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingFacilityAttributeSetMap::ZserioArrayType_references ParkingFacilityAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingFacilityAttributeSetMap::ZserioArrayType_references ParkingFacilityAttributeSetMap::readReferences(ParkingFacilityAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingFacilityAttributeSetMap::ZserioArrayType_validities ParkingFacilityAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingLevelAttributeSetMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingLevelAttributeSetMap::ParkingLevelAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

ParkingLevelAttributeSetMap::ParkingLevelAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingLevelAttributeSetMap::ParkingLevelAttributeSetMap(ParkingLevelAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingLevelAttributeSetMap::ParkingLevelAttributeSetMap(const ParkingLevelAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeSetMap& ParkingLevelAttributeSetMap::operator=(const ParkingLevelAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeSetMap::ParkingLevelAttributeSetMap(ParkingLevelAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeSetMap& ParkingLevelAttributeSetMap::operator=(ParkingLevelAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeSetMap::ParkingLevelAttributeSetMap(::zserio::PropagateAllocatorT,
        const ParkingLevelAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingLevelAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingLevelAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingLevelAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingLevelAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingLevelAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::instantiations::ParkingLevelAttributeSet& ParkingLevelAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::venue::details::instantiations::ParkingLevelAttributeSet& ParkingLevelAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void ParkingLevelAttributeSetMap::setAttributeSet(const ::nds::venue::details::instantiations::ParkingLevelAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void ParkingLevelAttributeSetMap::setAttributeSet(::nds::venue::details::instantiations::ParkingLevelAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator ParkingLevelAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void ParkingLevelAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& ParkingLevelAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& ParkingLevelAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void ParkingLevelAttributeSetMap::setReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void ParkingLevelAttributeSetMap::setReferences(::zserio::vector<::nds::venue::reference::types::ParkingLevelId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingLevelAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingLevelAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void ParkingLevelAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void ParkingLevelAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void ParkingLevelAttributeSetMap::initPackingContext(ParkingLevelAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t ParkingLevelAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeSetMap::bitSizeOf(ParkingLevelAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingLevelAttributeSetMap::initializeOffsets(ParkingLevelAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingLevelAttributeSetMap::operator==(const ParkingLevelAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t ParkingLevelAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void ParkingLevelAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingLevelAttributeSetMap::write(ParkingLevelAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingLevelAttributeSetMap::ZserioElementFactory_references::create(ParkingLevelAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingLevelAttributeSetMap::ZserioElementFactory_references::create(ParkingLevelAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingLevelId>& array,
        ::nds::venue::reference::types::ParkingLevelId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingLevelAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(ParkingLevelAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingLevelAttributeSetMap::ZserioElementFactory_validities::create(ParkingLevelAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::venue::details::instantiations::ParkingLevelAttributeSet ParkingLevelAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingLevelAttributeSet(in, allocator);
}

::nds::venue::details::instantiations::ParkingLevelAttributeSet ParkingLevelAttributeSetMap::readAttributeSet(ParkingLevelAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingLevelAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator ParkingLevelAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingLevelAttributeSetMap::readFeature(ParkingLevelAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingLevelAttributeSetMap::ZserioArrayType_references ParkingLevelAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingLevelAttributeSetMap::ZserioArrayType_references ParkingLevelAttributeSetMap::readReferences(ParkingLevelAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingLevelAttributeSetMap::ZserioArrayType_validities ParkingLevelAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSectionAttributeSetMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSectionAttributeSetMap::ParkingSectionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

ParkingSectionAttributeSetMap::ParkingSectionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingSectionAttributeSetMap::ParkingSectionAttributeSetMap(ParkingSectionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingSectionAttributeSetMap::ParkingSectionAttributeSetMap(const ParkingSectionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeSetMap& ParkingSectionAttributeSetMap::operator=(const ParkingSectionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeSetMap::ParkingSectionAttributeSetMap(ParkingSectionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeSetMap& ParkingSectionAttributeSetMap::operator=(ParkingSectionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeSetMap::ParkingSectionAttributeSetMap(::zserio::PropagateAllocatorT,
        const ParkingSectionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingSectionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSectionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSectionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingSectionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingSectionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::instantiations::ParkingSectionAttributeSet& ParkingSectionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::venue::details::instantiations::ParkingSectionAttributeSet& ParkingSectionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void ParkingSectionAttributeSetMap::setAttributeSet(const ::nds::venue::details::instantiations::ParkingSectionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void ParkingSectionAttributeSetMap::setAttributeSet(::nds::venue::details::instantiations::ParkingSectionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator ParkingSectionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void ParkingSectionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& ParkingSectionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& ParkingSectionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void ParkingSectionAttributeSetMap::setReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void ParkingSectionAttributeSetMap::setReferences(::zserio::vector<::nds::venue::reference::types::ParkingSectionId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingSectionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingSectionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void ParkingSectionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void ParkingSectionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void ParkingSectionAttributeSetMap::initPackingContext(ParkingSectionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t ParkingSectionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeSetMap::bitSizeOf(ParkingSectionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSectionAttributeSetMap::initializeOffsets(ParkingSectionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSectionAttributeSetMap::operator==(const ParkingSectionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t ParkingSectionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void ParkingSectionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingSectionAttributeSetMap::write(ParkingSectionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingSectionAttributeSetMap::ZserioElementFactory_references::create(ParkingSectionAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSectionAttributeSetMap::ZserioElementFactory_references::create(ParkingSectionAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingSectionId>& array,
        ::nds::venue::reference::types::ParkingSectionId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingSectionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(ParkingSectionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingSectionAttributeSetMap::ZserioElementFactory_validities::create(ParkingSectionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::venue::details::instantiations::ParkingSectionAttributeSet ParkingSectionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingSectionAttributeSet(in, allocator);
}

::nds::venue::details::instantiations::ParkingSectionAttributeSet ParkingSectionAttributeSetMap::readAttributeSet(ParkingSectionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingSectionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator ParkingSectionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingSectionAttributeSetMap::readFeature(ParkingSectionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSectionAttributeSetMap::ZserioArrayType_references ParkingSectionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingSectionAttributeSetMap::ZserioArrayType_references ParkingSectionAttributeSetMap::readReferences(ParkingSectionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingSectionAttributeSetMap::ZserioArrayType_validities ParkingSectionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingRowAttributeSetMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingRowAttributeSetMap::ParkingRowAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

ParkingRowAttributeSetMap::ParkingRowAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingRowAttributeSetMap::ParkingRowAttributeSetMap(ParkingRowAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingRowAttributeSetMap::ParkingRowAttributeSetMap(const ParkingRowAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeSetMap& ParkingRowAttributeSetMap::operator=(const ParkingRowAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeSetMap::ParkingRowAttributeSetMap(ParkingRowAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeSetMap& ParkingRowAttributeSetMap::operator=(ParkingRowAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeSetMap::ParkingRowAttributeSetMap(::zserio::PropagateAllocatorT,
        const ParkingRowAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingRowAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingRowAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingRowAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingRowAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingRowAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::instantiations::ParkingRowAttributeSet& ParkingRowAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::venue::details::instantiations::ParkingRowAttributeSet& ParkingRowAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void ParkingRowAttributeSetMap::setAttributeSet(const ::nds::venue::details::instantiations::ParkingRowAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void ParkingRowAttributeSetMap::setAttributeSet(::nds::venue::details::instantiations::ParkingRowAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator ParkingRowAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void ParkingRowAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingRowId>& ParkingRowAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingRowId>& ParkingRowAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void ParkingRowAttributeSetMap::setReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingRowId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void ParkingRowAttributeSetMap::setReferences(::zserio::vector<::nds::venue::reference::types::ParkingRowId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingRowAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingRowAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void ParkingRowAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void ParkingRowAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void ParkingRowAttributeSetMap::initPackingContext(ParkingRowAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t ParkingRowAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeSetMap::bitSizeOf(ParkingRowAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingRowAttributeSetMap::initializeOffsets(ParkingRowAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingRowAttributeSetMap::operator==(const ParkingRowAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t ParkingRowAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void ParkingRowAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingRowAttributeSetMap::write(ParkingRowAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingRowAttributeSetMap::ZserioElementFactory_references::create(ParkingRowAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingRowId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingRowAttributeSetMap::ZserioElementFactory_references::create(ParkingRowAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingRowId>& array,
        ::nds::venue::reference::types::ParkingRowId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingRowAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(ParkingRowAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingRowAttributeSetMap::ZserioElementFactory_validities::create(ParkingRowAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::venue::details::instantiations::ParkingRowAttributeSet ParkingRowAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingRowAttributeSet(in, allocator);
}

::nds::venue::details::instantiations::ParkingRowAttributeSet ParkingRowAttributeSetMap::readAttributeSet(ParkingRowAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingRowAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator ParkingRowAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingRowAttributeSetMap::readFeature(ParkingRowAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingRowAttributeSetMap::ZserioArrayType_references ParkingRowAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingRowAttributeSetMap::ZserioArrayType_references ParkingRowAttributeSetMap::readReferences(ParkingRowAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingRowAttributeSetMap::ZserioArrayType_validities ParkingRowAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSpotAttributeSetMap.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSpotAttributeSetMap::ParkingSpotAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

ParkingSpotAttributeSetMap::ParkingSpotAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingSpotAttributeSetMap::ParkingSpotAttributeSetMap(ParkingSpotAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

ParkingSpotAttributeSetMap::ParkingSpotAttributeSetMap(const ParkingSpotAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeSetMap& ParkingSpotAttributeSetMap::operator=(const ParkingSpotAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeSetMap::ParkingSpotAttributeSetMap(ParkingSpotAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeSetMap& ParkingSpotAttributeSetMap::operator=(ParkingSpotAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeSetMap::ParkingSpotAttributeSetMap(::zserio::PropagateAllocatorT,
        const ParkingSpotAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingSpotAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSpotAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSpotAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingSpotAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingSpotAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::venue::details::instantiations::ParkingSpotAttributeSet& ParkingSpotAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::venue::details::instantiations::ParkingSpotAttributeSet& ParkingSpotAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void ParkingSpotAttributeSetMap::setAttributeSet(const ::nds::venue::details::instantiations::ParkingSpotAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void ParkingSpotAttributeSetMap::setAttributeSet(::nds::venue::details::instantiations::ParkingSpotAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator ParkingSpotAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void ParkingSpotAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& ParkingSpotAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& ParkingSpotAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void ParkingSpotAttributeSetMap::setReferences(const ::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void ParkingSpotAttributeSetMap::setReferences(::zserio::vector<::nds::venue::reference::types::ParkingSpotId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& ParkingSpotAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& ParkingSpotAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void ParkingSpotAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void ParkingSpotAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void ParkingSpotAttributeSetMap::initPackingContext(ParkingSpotAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t ParkingSpotAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeSetMap::bitSizeOf(ParkingSpotAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSpotAttributeSetMap::initializeOffsets(ParkingSpotAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSpotAttributeSetMap::operator==(const ParkingSpotAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t ParkingSpotAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void ParkingSpotAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingSpotAttributeSetMap::write(ParkingSpotAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void ParkingSpotAttributeSetMap::ZserioElementFactory_references::create(ParkingSpotAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ParkingSpotAttributeSetMap::ZserioElementFactory_references::create(ParkingSpotAttributeSetMap&        ,
        ::zserio::vector<::nds::venue::reference::types::ParkingSpotId>& array,
        ::nds::venue::reference::types::ParkingSpotId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ParkingSpotAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(ParkingSpotAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingSpotAttributeSetMap::ZserioElementFactory_validities::create(ParkingSpotAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::venue::details::instantiations::ParkingSpotAttributeSet ParkingSpotAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingSpotAttributeSet(in, allocator);
}

::nds::venue::details::instantiations::ParkingSpotAttributeSet ParkingSpotAttributeSetMap::readAttributeSet(ParkingSpotAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::venue::details::instantiations::ParkingSpotAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator ParkingSpotAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator ParkingSpotAttributeSetMap::readFeature(ParkingSpotAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSpotAttributeSetMap::ZserioArrayType_references ParkingSpotAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

ParkingSpotAttributeSetMap::ZserioArrayType_references ParkingSpotAttributeSetMap::readReferences(ParkingSpotAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
ParkingSpotAttributeSetMap::ZserioArrayType_validities ParkingSpotAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingFacilityAttributeSetList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingFacilityAttributeSetList::ParkingFacilityAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

ParkingFacilityAttributeSetList::ParkingFacilityAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

ParkingFacilityAttributeSetList::ParkingFacilityAttributeSetList(ParkingFacilityAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

ParkingFacilityAttributeSetList::ParkingFacilityAttributeSetList(const ParkingFacilityAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeSetList& ParkingFacilityAttributeSetList::operator=(const ParkingFacilityAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeSetList::ParkingFacilityAttributeSetList(ParkingFacilityAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingFacilityAttributeSetList& ParkingFacilityAttributeSetList::operator=(ParkingFacilityAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingFacilityAttributeSetList::ParkingFacilityAttributeSetList(::zserio::PropagateAllocatorT,
        const ParkingFacilityAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingFacilityAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingFacilityAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingFacilityAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingFacilityAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingFacilityAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingFacilityAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void ParkingFacilityAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeSetMap>& ParkingFacilityAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeSetMap>& ParkingFacilityAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void ParkingFacilityAttributeSetList::setSets(const ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void ParkingFacilityAttributeSetList::setSets(::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void ParkingFacilityAttributeSetList::initPackingContext(ParkingFacilityAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t ParkingFacilityAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeSetList::bitSizeOf(ParkingFacilityAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingFacilityAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingFacilityAttributeSetList::initializeOffsets(ParkingFacilityAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingFacilityAttributeSetList::operator==(const ParkingFacilityAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t ParkingFacilityAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void ParkingFacilityAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingFacilityAttributeSetList::write(ParkingFacilityAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingFacilityAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingFacilityAttributeSetList::ZserioArrayExpressions_sets::initializeElement(ParkingFacilityAttributeSetList& owner,
        ::nds::venue::details::instantiations::ParkingFacilityAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingFacilityAttributeSetList::ZserioElementFactory_sets::create(ParkingFacilityAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingFacilityAttributeSetList::ZserioElementFactory_sets::create(ParkingFacilityAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingFacilityAttributeSetMap>& array,
        ::nds::venue::details::instantiations::ParkingFacilityAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingFacilityAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingFacilityAttributeSetList::readNumAttributeSets(ParkingFacilityAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingFacilityAttributeSetList::ZserioArrayType_sets ParkingFacilityAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

ParkingFacilityAttributeSetList::ZserioArrayType_sets ParkingFacilityAttributeSetList::readSets(ParkingFacilityAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingLevelAttributeSetList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingLevelAttributeSetList::ParkingLevelAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

ParkingLevelAttributeSetList::ParkingLevelAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

ParkingLevelAttributeSetList::ParkingLevelAttributeSetList(ParkingLevelAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

ParkingLevelAttributeSetList::ParkingLevelAttributeSetList(const ParkingLevelAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeSetList& ParkingLevelAttributeSetList::operator=(const ParkingLevelAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeSetList::ParkingLevelAttributeSetList(ParkingLevelAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingLevelAttributeSetList& ParkingLevelAttributeSetList::operator=(ParkingLevelAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingLevelAttributeSetList::ParkingLevelAttributeSetList(::zserio::PropagateAllocatorT,
        const ParkingLevelAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingLevelAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingLevelAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingLevelAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingLevelAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingLevelAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingLevelAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void ParkingLevelAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeSetMap>& ParkingLevelAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeSetMap>& ParkingLevelAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void ParkingLevelAttributeSetList::setSets(const ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void ParkingLevelAttributeSetList::setSets(::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void ParkingLevelAttributeSetList::initPackingContext(ParkingLevelAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t ParkingLevelAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeSetList::bitSizeOf(ParkingLevelAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingLevelAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingLevelAttributeSetList::initializeOffsets(ParkingLevelAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingLevelAttributeSetList::operator==(const ParkingLevelAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t ParkingLevelAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void ParkingLevelAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingLevelAttributeSetList::write(ParkingLevelAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingLevelAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingLevelAttributeSetList::ZserioArrayExpressions_sets::initializeElement(ParkingLevelAttributeSetList& owner,
        ::nds::venue::details::instantiations::ParkingLevelAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingLevelAttributeSetList::ZserioElementFactory_sets::create(ParkingLevelAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingLevelAttributeSetList::ZserioElementFactory_sets::create(ParkingLevelAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingLevelAttributeSetMap>& array,
        ::nds::venue::details::instantiations::ParkingLevelAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingLevelAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingLevelAttributeSetList::readNumAttributeSets(ParkingLevelAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingLevelAttributeSetList::ZserioArrayType_sets ParkingLevelAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

ParkingLevelAttributeSetList::ZserioArrayType_sets ParkingLevelAttributeSetList::readSets(ParkingLevelAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSectionAttributeSetList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSectionAttributeSetList::ParkingSectionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

ParkingSectionAttributeSetList::ParkingSectionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

ParkingSectionAttributeSetList::ParkingSectionAttributeSetList(ParkingSectionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

ParkingSectionAttributeSetList::ParkingSectionAttributeSetList(const ParkingSectionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeSetList& ParkingSectionAttributeSetList::operator=(const ParkingSectionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeSetList::ParkingSectionAttributeSetList(ParkingSectionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSectionAttributeSetList& ParkingSectionAttributeSetList::operator=(ParkingSectionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSectionAttributeSetList::ParkingSectionAttributeSetList(::zserio::PropagateAllocatorT,
        const ParkingSectionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingSectionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSectionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSectionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingSectionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingSectionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingSectionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void ParkingSectionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeSetMap>& ParkingSectionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeSetMap>& ParkingSectionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void ParkingSectionAttributeSetList::setSets(const ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void ParkingSectionAttributeSetList::setSets(::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void ParkingSectionAttributeSetList::initPackingContext(ParkingSectionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t ParkingSectionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeSetList::bitSizeOf(ParkingSectionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSectionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSectionAttributeSetList::initializeOffsets(ParkingSectionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSectionAttributeSetList::operator==(const ParkingSectionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t ParkingSectionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void ParkingSectionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingSectionAttributeSetList::write(ParkingSectionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSectionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingSectionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(ParkingSectionAttributeSetList& owner,
        ::nds::venue::details::instantiations::ParkingSectionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingSectionAttributeSetList::ZserioElementFactory_sets::create(ParkingSectionAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingSectionAttributeSetList::ZserioElementFactory_sets::create(ParkingSectionAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSectionAttributeSetMap>& array,
        ::nds::venue::details::instantiations::ParkingSectionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingSectionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingSectionAttributeSetList::readNumAttributeSets(ParkingSectionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSectionAttributeSetList::ZserioArrayType_sets ParkingSectionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

ParkingSectionAttributeSetList::ZserioArrayType_sets ParkingSectionAttributeSetList::readSets(ParkingSectionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingRowAttributeSetList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingRowAttributeSetList::ParkingRowAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

ParkingRowAttributeSetList::ParkingRowAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

ParkingRowAttributeSetList::ParkingRowAttributeSetList(ParkingRowAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

ParkingRowAttributeSetList::ParkingRowAttributeSetList(const ParkingRowAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeSetList& ParkingRowAttributeSetList::operator=(const ParkingRowAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeSetList::ParkingRowAttributeSetList(ParkingRowAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingRowAttributeSetList& ParkingRowAttributeSetList::operator=(ParkingRowAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingRowAttributeSetList::ParkingRowAttributeSetList(::zserio::PropagateAllocatorT,
        const ParkingRowAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingRowAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingRowAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingRowAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingRowAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingRowAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingRowAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void ParkingRowAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeSetMap>& ParkingRowAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeSetMap>& ParkingRowAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void ParkingRowAttributeSetList::setSets(const ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void ParkingRowAttributeSetList::setSets(::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void ParkingRowAttributeSetList::initPackingContext(ParkingRowAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t ParkingRowAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeSetList::bitSizeOf(ParkingRowAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingRowAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingRowAttributeSetList::initializeOffsets(ParkingRowAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingRowAttributeSetList::operator==(const ParkingRowAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t ParkingRowAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void ParkingRowAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingRowAttributeSetList::write(ParkingRowAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingRowAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingRowAttributeSetList::ZserioArrayExpressions_sets::initializeElement(ParkingRowAttributeSetList& owner,
        ::nds::venue::details::instantiations::ParkingRowAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingRowAttributeSetList::ZserioElementFactory_sets::create(ParkingRowAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingRowAttributeSetList::ZserioElementFactory_sets::create(ParkingRowAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingRowAttributeSetMap>& array,
        ::nds::venue::details::instantiations::ParkingRowAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingRowAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingRowAttributeSetList::readNumAttributeSets(ParkingRowAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingRowAttributeSetList::ZserioArrayType_sets ParkingRowAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

ParkingRowAttributeSetList::ZserioArrayType_sets ParkingRowAttributeSetList::readSets(ParkingRowAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/venue/details/instantiations/ParkingSpotAttributeSetList.h>

namespace nds
{
namespace venue
{
namespace details
{
namespace instantiations
{

ParkingSpotAttributeSetList::ParkingSpotAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

ParkingSpotAttributeSetList::ParkingSpotAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

ParkingSpotAttributeSetList::ParkingSpotAttributeSetList(ParkingSpotAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

ParkingSpotAttributeSetList::ParkingSpotAttributeSetList(const ParkingSpotAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeSetList& ParkingSpotAttributeSetList::operator=(const ParkingSpotAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeSetList::ParkingSpotAttributeSetList(ParkingSpotAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

ParkingSpotAttributeSetList& ParkingSpotAttributeSetList::operator=(ParkingSpotAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

ParkingSpotAttributeSetList::ParkingSpotAttributeSetList(::zserio::PropagateAllocatorT,
        const ParkingSpotAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void ParkingSpotAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ParkingSpotAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void ParkingSpotAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift ParkingSpotAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'ParkingSpotAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t ParkingSpotAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void ParkingSpotAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeSetMap>& ParkingSpotAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeSetMap>& ParkingSpotAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void ParkingSpotAttributeSetList::setSets(const ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void ParkingSpotAttributeSetList::setSets(::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void ParkingSpotAttributeSetList::initPackingContext(ParkingSpotAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t ParkingSpotAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeSetList::bitSizeOf(ParkingSpotAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ParkingSpotAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ParkingSpotAttributeSetList::initializeOffsets(ParkingSpotAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ParkingSpotAttributeSetList::operator==(const ParkingSpotAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t ParkingSpotAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void ParkingSpotAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingSpotAttributeSetList::write(ParkingSpotAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ParkingSpotAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void ParkingSpotAttributeSetList::ZserioArrayExpressions_sets::initializeElement(ParkingSpotAttributeSetList& owner,
        ::nds::venue::details::instantiations::ParkingSpotAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void ParkingSpotAttributeSetList::ZserioElementFactory_sets::create(ParkingSpotAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void ParkingSpotAttributeSetList::ZserioElementFactory_sets::create(ParkingSpotAttributeSetList&         owner,
        ::zserio::vector<::nds::venue::details::instantiations::ParkingSpotAttributeSetMap>& array,
        ::nds::venue::details::instantiations::ParkingSpotAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t ParkingSpotAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ParkingSpotAttributeSetList::readNumAttributeSets(ParkingSpotAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
ParkingSpotAttributeSetList::ZserioArrayType_sets ParkingSpotAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

ParkingSpotAttributeSetList::ZserioArrayType_sets ParkingSpotAttributeSetList::readSets(ParkingSpotAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace details
} // namespace venue
} // namespace nds
