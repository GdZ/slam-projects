/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/SmartLayerTile.h>

namespace nds
{
namespace smart
{
namespace tile
{

SmartLayerTile::SmartLayerTile(const allocator_type& allocator) noexcept :
        m_tileId_(::nds::core::types::PackedTileId()),
        m_header_(allocator),
        m_layers_(allocator)
{
}

SmartLayerTile::SmartLayerTile(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_tileId_(readTileId(in)),
        m_header_(readHeader(in, allocator)),
        m_layers_(readLayers(in, allocator))
{
}

SmartLayerTile::SmartLayerTile(SmartLayerTile::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_tileId_(readTileId(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_layers_(readLayers(in, allocator))
{
}

SmartLayerTile::SmartLayerTile(::zserio::PropagateAllocatorT,
        const SmartLayerTile& other, const allocator_type& allocator) :
        m_tileId_(::zserio::allocatorPropagatingCopy(other.m_tileId_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_layers_(::zserio::allocatorPropagatingCopy(other.m_layers_, allocator))
{
}

void SmartLayerTile::initializeChildren()
{
    m_header_.initializeChildren();
}

::nds::core::types::PackedTileId SmartLayerTile::getTileId() const
{
    return m_tileId_;
}

void SmartLayerTile::setTileId(::nds::core::types::PackedTileId tileId_)
{
    m_tileId_ = tileId_;
}

::nds::smart::types::SmartLayerHeader& SmartLayerTile::getHeader()
{
    return m_header_;
}

const ::nds::smart::types::SmartLayerHeader& SmartLayerTile::getHeader() const
{
    return m_header_;
}

void SmartLayerTile::setHeader(const ::nds::smart::types::SmartLayerHeader& header_)
{
    m_header_ = header_;
}

void SmartLayerTile::setHeader(::nds::smart::types::SmartLayerHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::smart::types::DataLayer>& SmartLayerTile::getLayers()
{
    return m_layers_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayer>& SmartLayerTile::getLayers() const
{
    return m_layers_.getRawArray();
}

void SmartLayerTile::setLayers(const ::zserio::vector<::nds::smart::types::DataLayer>& layers_)
{
    m_layers_ = ZserioArrayType_layers(layers_);
}

void SmartLayerTile::setLayers(::zserio::vector<::nds::smart::types::DataLayer>&& layers_)
{
    m_layers_ = ZserioArrayType_layers(std::move(layers_));
}

void SmartLayerTile::initPackingContext(SmartLayerTile::ZserioPackingContext& context) const
{
    context.getTileId().init<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_tileId_);
    m_header_.initPackingContext(context.getHeader());
}

size_t SmartLayerTile::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTile::bitSizeOf(SmartLayerTile::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTileId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_tileId_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTile::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerTile::initializeOffsets(SmartLayerTile::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTileId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_tileId_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerTile::operator==(const SmartLayerTile& other) const
{
    if (this != &other)
    {
        return
                (m_tileId_ == other.m_tileId_) &&
                (m_header_ == other.m_header_) &&
                (m_layers_ == other.m_layers_);
    }

    return true;
}

uint32_t SmartLayerTile::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_tileId_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_layers_);

    return result;
}

void SmartLayerTile::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_tileId_, UINT8_C(32));

    m_header_.write(out);

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getHeader().getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTile.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getHeader().getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void SmartLayerTile::write(SmartLayerTile::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getTileId().write<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(out, m_tileId_);

    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getHeader().getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTile.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getHeader().getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void SmartLayerTile::ZserioElementFactory_layers::create(SmartLayerTile&        ,
        ::zserio::vector<::nds::smart::types::DataLayer>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

::nds::core::types::PackedTileId SmartLayerTile::readTileId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::PackedTileId>(in.readSignedBits(UINT8_C(32)));
}

::nds::core::types::PackedTileId SmartLayerTile::readTileId(SmartLayerTile::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTileId().read<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(in);
}
::nds::smart::types::SmartLayerHeader SmartLayerTile::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::types::SmartLayerHeader(in, allocator);
}

::nds::smart::types::SmartLayerHeader SmartLayerTile::readHeader(SmartLayerTile::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::types::SmartLayerHeader(context.getHeader(), in, allocator);
}
SmartLayerTile::ZserioArrayType_layers SmartLayerTile::readLayers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_layers readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getHeader().getNumDataLayers()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/SmartLayerTileList.h>

namespace nds
{
namespace smart
{
namespace tile
{

SmartLayerTileList::SmartLayerTileList(const allocator_type& allocator) noexcept :
        m_numTiles_(uint32_t()),
        m_tileList_(allocator)
{
}

SmartLayerTileList::SmartLayerTileList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(in)),
        m_tileList_(readTileList(in, allocator))
{
}

SmartLayerTileList::SmartLayerTileList(SmartLayerTileList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(context, in)),
        m_tileList_(readTileList(context, in, allocator))
{
}

SmartLayerTileList::SmartLayerTileList(::zserio::PropagateAllocatorT,
        const SmartLayerTileList& other, const allocator_type& allocator) :
        m_numTiles_(::zserio::allocatorPropagatingCopy(other.m_numTiles_, allocator)),
        m_tileList_(::zserio::allocatorPropagatingCopy(other.m_tileList_, allocator))
{
}

void SmartLayerTileList::initializeChildren()
{
    m_tileList_.initializeElements(*this);
}

uint32_t SmartLayerTileList::getNumTiles() const
{
    return m_numTiles_;
}

void SmartLayerTileList::setNumTiles(uint32_t numTiles_)
{
    m_numTiles_ = numTiles_;
}

::zserio::vector<::nds::smart::tile::SmartLayerTile>& SmartLayerTileList::getTileList()
{
    return m_tileList_.getRawArray();
}

const ::zserio::vector<::nds::smart::tile::SmartLayerTile>& SmartLayerTileList::getTileList() const
{
    return m_tileList_.getRawArray();
}

void SmartLayerTileList::setTileList(const ::zserio::vector<::nds::smart::tile::SmartLayerTile>& tileList_)
{
    m_tileList_ = ZserioArrayType_tileList(tileList_);
}

void SmartLayerTileList::setTileList(::zserio::vector<::nds::smart::tile::SmartLayerTile>&& tileList_)
{
    m_tileList_ = ZserioArrayType_tileList(std::move(tileList_));
}

void SmartLayerTileList::initPackingContext(SmartLayerTileList::ZserioPackingContext& context) const
{
    context.getNumTiles().init<::zserio::VarSizeArrayTraits>(m_numTiles_);
}

size_t SmartLayerTileList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition += m_tileList_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTileList::bitSizeOf(SmartLayerTileList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition += m_tileList_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTileList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition = m_tileList_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerTileList::initializeOffsets(SmartLayerTileList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition = m_tileList_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerTileList::operator==(const SmartLayerTileList& other) const
{
    if (this != &other)
    {
        return
                (m_numTiles_ == other.m_numTiles_) &&
                (m_tileList_ == other.m_tileList_);
    }

    return true;
}

uint32_t SmartLayerTileList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numTiles_);
    result = ::zserio::calcHashCode(result, m_tileList_);

    return result;
}

void SmartLayerTileList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numTiles_);

    // check array length
    if (m_tileList_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileList.tileList: ") <<
                m_tileList_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileList_.write(*this, out);
}

void SmartLayerTileList::write(SmartLayerTileList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumTiles().write<::zserio::VarSizeArrayTraits>(out, m_numTiles_);

    // check array length
    if (m_tileList_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileList.tileList: ") <<
                m_tileList_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileList_.writePacked(*this, out);
}

void SmartLayerTileList::ZserioArrayExpressions_tileList::initializeElement(SmartLayerTileList&,
        ::nds::smart::tile::SmartLayerTile& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerTileList::ZserioElementFactory_tileList::create(SmartLayerTileList&        ,
        ::zserio::vector<::nds::smart::tile::SmartLayerTile>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerTileList::ZserioElementFactory_tileList::create(SmartLayerTileList&        ,
        ::zserio::vector<::nds::smart::tile::SmartLayerTile>& array,
        ::nds::smart::tile::SmartLayerTile::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t SmartLayerTileList::readNumTiles(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t SmartLayerTileList::readNumTiles(SmartLayerTileList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumTiles().read<::zserio::VarSizeArrayTraits>(in);
}
SmartLayerTileList::ZserioArrayType_tileList SmartLayerTileList::readTileList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_tileList readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

SmartLayerTileList::ZserioArrayType_tileList SmartLayerTileList::readTileList(SmartLayerTileList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_tileList readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/SmartLayerTileHeaderList.h>

namespace nds
{
namespace smart
{
namespace tile
{

SmartLayerTileHeaderList::SmartLayerTileHeaderList(const allocator_type& allocator) noexcept :
        m_numTiles_(uint32_t()),
        m_tileIds_(allocator),
        m_headers_(allocator)
{
}

SmartLayerTileHeaderList::SmartLayerTileHeaderList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(in)),
        m_tileIds_(readTileIds(in, allocator)),
        m_headers_(readHeaders(in, allocator))
{
}

SmartLayerTileHeaderList::SmartLayerTileHeaderList(SmartLayerTileHeaderList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(context, in)),
        m_tileIds_(readTileIds(context, in, allocator)),
        m_headers_(readHeaders(context, in, allocator))
{
}

SmartLayerTileHeaderList::SmartLayerTileHeaderList(::zserio::PropagateAllocatorT,
        const SmartLayerTileHeaderList& other, const allocator_type& allocator) :
        m_numTiles_(::zserio::allocatorPropagatingCopy(other.m_numTiles_, allocator)),
        m_tileIds_(::zserio::allocatorPropagatingCopy(other.m_tileIds_, allocator)),
        m_headers_(::zserio::allocatorPropagatingCopy(other.m_headers_, allocator))
{
}

void SmartLayerTileHeaderList::initializeChildren()
{
    m_headers_.initializeElements(*this);
}

uint32_t SmartLayerTileHeaderList::getNumTiles() const
{
    return m_numTiles_;
}

void SmartLayerTileHeaderList::setNumTiles(uint32_t numTiles_)
{
    m_numTiles_ = numTiles_;
}

::zserio::vector<::nds::core::types::PackedTileId>& SmartLayerTileHeaderList::getTileIds()
{
    return m_tileIds_.getRawArray();
}

const ::zserio::vector<::nds::core::types::PackedTileId>& SmartLayerTileHeaderList::getTileIds() const
{
    return m_tileIds_.getRawArray();
}

void SmartLayerTileHeaderList::setTileIds(const ::zserio::vector<::nds::core::types::PackedTileId>& tileIds_)
{
    m_tileIds_ = ZserioArrayType_tileIds(tileIds_);
}

void SmartLayerTileHeaderList::setTileIds(::zserio::vector<::nds::core::types::PackedTileId>&& tileIds_)
{
    m_tileIds_ = ZserioArrayType_tileIds(std::move(tileIds_));
}

::zserio::vector<::nds::smart::types::SmartLayerHeader>& SmartLayerTileHeaderList::getHeaders()
{
    return m_headers_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::SmartLayerHeader>& SmartLayerTileHeaderList::getHeaders() const
{
    return m_headers_.getRawArray();
}

void SmartLayerTileHeaderList::setHeaders(const ::zserio::vector<::nds::smart::types::SmartLayerHeader>& headers_)
{
    m_headers_ = ZserioArrayType_headers(headers_);
}

void SmartLayerTileHeaderList::setHeaders(::zserio::vector<::nds::smart::types::SmartLayerHeader>&& headers_)
{
    m_headers_ = ZserioArrayType_headers(std::move(headers_));
}

void SmartLayerTileHeaderList::initPackingContext(SmartLayerTileHeaderList::ZserioPackingContext& context) const
{
    context.getNumTiles().init<::zserio::VarSizeArrayTraits>(m_numTiles_);
}

size_t SmartLayerTileHeaderList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition += m_tileIds_.bitSizeOf(endBitPosition);
    endBitPosition += m_headers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTileHeaderList::bitSizeOf(SmartLayerTileHeaderList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition += m_tileIds_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_headers_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTileHeaderList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition = m_tileIds_.initializeOffsets(endBitPosition);
    endBitPosition = m_headers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerTileHeaderList::initializeOffsets(SmartLayerTileHeaderList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition = m_tileIds_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_headers_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerTileHeaderList::operator==(const SmartLayerTileHeaderList& other) const
{
    if (this != &other)
    {
        return
                (m_numTiles_ == other.m_numTiles_) &&
                (m_tileIds_ == other.m_tileIds_) &&
                (m_headers_ == other.m_headers_);
    }

    return true;
}

uint32_t SmartLayerTileHeaderList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numTiles_);
    result = ::zserio::calcHashCode(result, m_tileIds_);
    result = ::zserio::calcHashCode(result, m_headers_);

    return result;
}

void SmartLayerTileHeaderList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numTiles_);

    // check array length
    if (m_tileIds_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileHeaderList.tileIds: ") <<
                m_tileIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileIds_.write(out);

    // check array length
    if (m_headers_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileHeaderList.headers: ") <<
                m_headers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_headers_.write(*this, out);
}

void SmartLayerTileHeaderList::write(SmartLayerTileHeaderList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumTiles().write<::zserio::VarSizeArrayTraits>(out, m_numTiles_);

    // check array length
    if (m_tileIds_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileHeaderList.tileIds: ") <<
                m_tileIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileIds_.writePacked(out);

    // check array length
    if (m_headers_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileHeaderList.headers: ") <<
                m_headers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_headers_.writePacked(*this, out);
}

void SmartLayerTileHeaderList::ZserioArrayExpressions_headers::initializeElement(SmartLayerTileHeaderList&,
        ::nds::smart::types::SmartLayerHeader& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerTileHeaderList::ZserioElementFactory_headers::create(SmartLayerTileHeaderList&        ,
        ::zserio::vector<::nds::smart::types::SmartLayerHeader>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerTileHeaderList::ZserioElementFactory_headers::create(SmartLayerTileHeaderList&        ,
        ::zserio::vector<::nds::smart::types::SmartLayerHeader>& array,
        ::nds::smart::types::SmartLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t SmartLayerTileHeaderList::readNumTiles(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t SmartLayerTileHeaderList::readNumTiles(SmartLayerTileHeaderList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumTiles().read<::zserio::VarSizeArrayTraits>(in);
}
SmartLayerTileHeaderList::ZserioArrayType_tileIds SmartLayerTileHeaderList::readTileIds(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_tileIds readField(allocator);
    readField.read(in, static_cast<size_t>(getNumTiles()));

    return readField;
}

SmartLayerTileHeaderList::ZserioArrayType_tileIds SmartLayerTileHeaderList::readTileIds(SmartLayerTileHeaderList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_tileIds readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumTiles()));

    return readField;
}
SmartLayerTileHeaderList::ZserioArrayType_headers SmartLayerTileHeaderList::readHeaders(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_headers readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

SmartLayerTileHeaderList::ZserioArrayType_headers SmartLayerTileHeaderList::readHeaders(SmartLayerTileHeaderList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_headers readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/DeltaTileInfo.h>

namespace nds
{
namespace smart
{
namespace tile
{

DeltaTileInfo::DeltaTileInfo(const allocator_type& allocator) noexcept :
        m_tileId_(allocator),
        m_sourceLayerInfo_(allocator)
{
}

DeltaTileInfo::DeltaTileInfo(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_tileId_(readTileId(in, allocator)),
        m_sourceLayerInfo_(readSourceLayerInfo(in, allocator))
{
}

DeltaTileInfo::DeltaTileInfo(DeltaTileInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_tileId_(readTileId(context, in, allocator)),
        m_sourceLayerInfo_(readSourceLayerInfo(context, in, allocator))
{
}

DeltaTileInfo::DeltaTileInfo(::zserio::PropagateAllocatorT,
        const DeltaTileInfo& other, const allocator_type& allocator) :
        m_tileId_(::zserio::allocatorPropagatingCopy(other.m_tileId_, allocator)),
        m_sourceLayerInfo_(::zserio::allocatorPropagatingCopy(other.m_sourceLayerInfo_, allocator))
{
}

::nds::core::types::TileId& DeltaTileInfo::getTileId()
{
    return m_tileId_;
}

const ::nds::core::types::TileId& DeltaTileInfo::getTileId() const
{
    return m_tileId_;
}

void DeltaTileInfo::setTileId(const ::nds::core::types::TileId& tileId_)
{
    m_tileId_ = tileId_;
}

void DeltaTileInfo::setTileId(::nds::core::types::TileId&& tileId_)
{
    m_tileId_ = ::std::move(tileId_);
}

::nds::smart::tile::SourceLayerInfo& DeltaTileInfo::getSourceLayerInfo()
{
    return m_sourceLayerInfo_;
}

const ::nds::smart::tile::SourceLayerInfo& DeltaTileInfo::getSourceLayerInfo() const
{
    return m_sourceLayerInfo_;
}

void DeltaTileInfo::setSourceLayerInfo(const ::nds::smart::tile::SourceLayerInfo& sourceLayerInfo_)
{
    m_sourceLayerInfo_ = sourceLayerInfo_;
}

void DeltaTileInfo::setSourceLayerInfo(::nds::smart::tile::SourceLayerInfo&& sourceLayerInfo_)
{
    m_sourceLayerInfo_ = ::std::move(sourceLayerInfo_);
}

void DeltaTileInfo::initPackingContext(DeltaTileInfo::ZserioPackingContext& context) const
{
    m_tileId_.initPackingContext(context.getTileId());
    m_sourceLayerInfo_.initPackingContext(context.getSourceLayerInfo());
}

size_t DeltaTileInfo::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_tileId_.bitSizeOf(endBitPosition);
    endBitPosition += m_sourceLayerInfo_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DeltaTileInfo::bitSizeOf(DeltaTileInfo::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_tileId_.bitSizeOf(context.getTileId(), endBitPosition);
    endBitPosition += m_sourceLayerInfo_.bitSizeOf(context.getSourceLayerInfo(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DeltaTileInfo::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_tileId_.initializeOffsets(endBitPosition);
    endBitPosition = m_sourceLayerInfo_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t DeltaTileInfo::initializeOffsets(DeltaTileInfo::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_tileId_.initializeOffsets(context.getTileId(), endBitPosition);
    endBitPosition = m_sourceLayerInfo_.initializeOffsets(context.getSourceLayerInfo(), endBitPosition);

    return endBitPosition;
}

bool DeltaTileInfo::operator==(const DeltaTileInfo& other) const
{
    if (this != &other)
    {
        return
                (m_tileId_ == other.m_tileId_) &&
                (m_sourceLayerInfo_ == other.m_sourceLayerInfo_);
    }

    return true;
}

uint32_t DeltaTileInfo::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_tileId_);
    result = ::zserio::calcHashCode(result, m_sourceLayerInfo_);

    return result;
}

void DeltaTileInfo::write(::zserio::BitStreamWriter& out) const
{
    m_tileId_.write(out);
    m_sourceLayerInfo_.write(out);
}

void DeltaTileInfo::write(DeltaTileInfo::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_tileId_.write(context.getTileId(), out);
    m_sourceLayerInfo_.write(context.getSourceLayerInfo(), out);
}

::nds::core::types::TileId DeltaTileInfo::readTileId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TileId(in, allocator);
}

::nds::core::types::TileId DeltaTileInfo::readTileId(DeltaTileInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TileId(context.getTileId(), in, allocator);
}
::nds::smart::tile::SourceLayerInfo DeltaTileInfo::readSourceLayerInfo(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::tile::SourceLayerInfo(in, allocator);
}

::nds::smart::tile::SourceLayerInfo DeltaTileInfo::readSourceLayerInfo(DeltaTileInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::tile::SourceLayerInfo(context.getSourceLayerInfo(), in, allocator);
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/SourceLayerInfo.h>

namespace nds
{
namespace smart
{
namespace tile
{

SourceLayerInfo::SourceLayerInfo(const allocator_type& allocator) noexcept :
        m_numDataLayers_(uint16_t()),
        m_availableLayers_(allocator),
        m_versionId_(allocator)
{
}

SourceLayerInfo::SourceLayerInfo(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numDataLayers_(readNumDataLayers(in)),
        m_availableLayers_(readAvailableLayers(in, allocator)),
        m_versionId_(readVersionId(in, allocator))
{
}

SourceLayerInfo::SourceLayerInfo(SourceLayerInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numDataLayers_(readNumDataLayers(context, in)),
        m_availableLayers_(readAvailableLayers(context, in, allocator)),
        m_versionId_(readVersionId(context, in, allocator))
{
}

SourceLayerInfo::SourceLayerInfo(::zserio::PropagateAllocatorT,
        const SourceLayerInfo& other, const allocator_type& allocator) :
        m_numDataLayers_(::zserio::allocatorPropagatingCopy(other.m_numDataLayers_, allocator)),
        m_availableLayers_(::zserio::allocatorPropagatingCopy(other.m_availableLayers_, allocator)),
        m_versionId_(::zserio::allocatorPropagatingCopy(other.m_versionId_, allocator))
{
}

uint16_t SourceLayerInfo::getNumDataLayers() const
{
    return m_numDataLayers_;
}

void SourceLayerInfo::setNumDataLayers(uint16_t numDataLayers_)
{
    m_numDataLayers_ = numDataLayers_;
}

::zserio::vector<::nds::smart::types::DataLayerId>& SourceLayerInfo::getAvailableLayers()
{
    return m_availableLayers_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayerId>& SourceLayerInfo::getAvailableLayers() const
{
    return m_availableLayers_.getRawArray();
}

void SourceLayerInfo::setAvailableLayers(const ::zserio::vector<::nds::smart::types::DataLayerId>& availableLayers_)
{
    m_availableLayers_ = ZserioArrayType_availableLayers(availableLayers_);
}

void SourceLayerInfo::setAvailableLayers(::zserio::vector<::nds::smart::types::DataLayerId>&& availableLayers_)
{
    m_availableLayers_ = ZserioArrayType_availableLayers(std::move(availableLayers_));
}

::zserio::vector<::nds::core::types::VersionId>& SourceLayerInfo::getVersionId()
{
    return m_versionId_.getRawArray();
}

const ::zserio::vector<::nds::core::types::VersionId>& SourceLayerInfo::getVersionId() const
{
    return m_versionId_.getRawArray();
}

void SourceLayerInfo::setVersionId(const ::zserio::vector<::nds::core::types::VersionId>& versionId_)
{
    m_versionId_ = ZserioArrayType_versionId(versionId_);
}

void SourceLayerInfo::setVersionId(::zserio::vector<::nds::core::types::VersionId>&& versionId_)
{
    m_versionId_ = ZserioArrayType_versionId(std::move(versionId_));
}

void SourceLayerInfo::initPackingContext(SourceLayerInfo::ZserioPackingContext& context) const
{
    context.getNumDataLayers().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
}

size_t SourceLayerInfo::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition += m_availableLayers_.bitSizeOf(endBitPosition);
    endBitPosition += m_versionId_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SourceLayerInfo::bitSizeOf(SourceLayerInfo::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition += m_availableLayers_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_versionId_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SourceLayerInfo::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition = m_availableLayers_.initializeOffsets(endBitPosition);
    endBitPosition = m_versionId_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t SourceLayerInfo::initializeOffsets(SourceLayerInfo::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition = m_availableLayers_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_versionId_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool SourceLayerInfo::operator==(const SourceLayerInfo& other) const
{
    if (this != &other)
    {
        return
                (m_numDataLayers_ == other.m_numDataLayers_) &&
                (m_availableLayers_ == other.m_availableLayers_) &&
                (m_versionId_ == other.m_versionId_);
    }

    return true;
}

uint32_t SourceLayerInfo::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numDataLayers_);
    result = ::zserio::calcHashCode(result, m_availableLayers_);
    result = ::zserio::calcHashCode(result, m_versionId_);

    return result;
}

void SourceLayerInfo::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numDataLayers_);

    // check array length
    if (m_availableLayers_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SourceLayerInfo.availableLayers: ") <<
                m_availableLayers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_availableLayers_.write(out);

    // check array length
    if (m_versionId_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SourceLayerInfo.versionId: ") <<
                m_versionId_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_versionId_.write(out);
}

void SourceLayerInfo::write(SourceLayerInfo::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumDataLayers().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numDataLayers_);

    // check array length
    if (m_availableLayers_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SourceLayerInfo.availableLayers: ") <<
                m_availableLayers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_availableLayers_.writePacked(out);

    // check array length
    if (m_versionId_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SourceLayerInfo.versionId: ") <<
                m_versionId_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_versionId_.writePacked(out);
}

uint16_t SourceLayerInfo::readNumDataLayers(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t SourceLayerInfo::readNumDataLayers(SourceLayerInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumDataLayers().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
SourceLayerInfo::ZserioArrayType_availableLayers SourceLayerInfo::readAvailableLayers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableLayers readField(allocator);
    readField.read(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

SourceLayerInfo::ZserioArrayType_availableLayers SourceLayerInfo::readAvailableLayers(SourceLayerInfo::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableLayers readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}
SourceLayerInfo::ZserioArrayType_versionId SourceLayerInfo::readVersionId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_versionId readField(allocator);
    readField.read(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

SourceLayerInfo::ZserioArrayType_versionId SourceLayerInfo::readVersionId(SourceLayerInfo::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_versionId readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/DeltaTileListInfo.h>

namespace nds
{
namespace smart
{
namespace tile
{

DeltaTileListInfo::DeltaTileListInfo(const allocator_type& allocator) noexcept :
        m_numTiles_(uint32_t()),
        m_tileIds_(allocator),
        m_headers_(allocator)
{
}

DeltaTileListInfo::DeltaTileListInfo(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(in)),
        m_tileIds_(readTileIds(in, allocator)),
        m_headers_(readHeaders(in, allocator))
{
}

DeltaTileListInfo::DeltaTileListInfo(DeltaTileListInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(context, in)),
        m_tileIds_(readTileIds(context, in, allocator)),
        m_headers_(readHeaders(context, in, allocator))
{
}

DeltaTileListInfo::DeltaTileListInfo(::zserio::PropagateAllocatorT,
        const DeltaTileListInfo& other, const allocator_type& allocator) :
        m_numTiles_(::zserio::allocatorPropagatingCopy(other.m_numTiles_, allocator)),
        m_tileIds_(::zserio::allocatorPropagatingCopy(other.m_tileIds_, allocator)),
        m_headers_(::zserio::allocatorPropagatingCopy(other.m_headers_, allocator))
{
}

uint32_t DeltaTileListInfo::getNumTiles() const
{
    return m_numTiles_;
}

void DeltaTileListInfo::setNumTiles(uint32_t numTiles_)
{
    m_numTiles_ = numTiles_;
}

::zserio::vector<::nds::core::types::PackedTileId>& DeltaTileListInfo::getTileIds()
{
    return m_tileIds_.getRawArray();
}

const ::zserio::vector<::nds::core::types::PackedTileId>& DeltaTileListInfo::getTileIds() const
{
    return m_tileIds_.getRawArray();
}

void DeltaTileListInfo::setTileIds(const ::zserio::vector<::nds::core::types::PackedTileId>& tileIds_)
{
    m_tileIds_ = ZserioArrayType_tileIds(tileIds_);
}

void DeltaTileListInfo::setTileIds(::zserio::vector<::nds::core::types::PackedTileId>&& tileIds_)
{
    m_tileIds_ = ZserioArrayType_tileIds(std::move(tileIds_));
}

::zserio::vector<::nds::smart::tile::SourceLayerInfo>& DeltaTileListInfo::getHeaders()
{
    return m_headers_.getRawArray();
}

const ::zserio::vector<::nds::smart::tile::SourceLayerInfo>& DeltaTileListInfo::getHeaders() const
{
    return m_headers_.getRawArray();
}

void DeltaTileListInfo::setHeaders(const ::zserio::vector<::nds::smart::tile::SourceLayerInfo>& headers_)
{
    m_headers_ = ZserioArrayType_headers(headers_);
}

void DeltaTileListInfo::setHeaders(::zserio::vector<::nds::smart::tile::SourceLayerInfo>&& headers_)
{
    m_headers_ = ZserioArrayType_headers(std::move(headers_));
}

void DeltaTileListInfo::initPackingContext(DeltaTileListInfo::ZserioPackingContext& context) const
{
    context.getNumTiles().init<::zserio::VarSizeArrayTraits>(m_numTiles_);
}

size_t DeltaTileListInfo::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition += m_tileIds_.bitSizeOf(endBitPosition);
    endBitPosition += m_headers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DeltaTileListInfo::bitSizeOf(DeltaTileListInfo::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition += m_tileIds_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_headers_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DeltaTileListInfo::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition = m_tileIds_.initializeOffsets(endBitPosition);
    endBitPosition = m_headers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t DeltaTileListInfo::initializeOffsets(DeltaTileListInfo::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition = m_tileIds_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_headers_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool DeltaTileListInfo::operator==(const DeltaTileListInfo& other) const
{
    if (this != &other)
    {
        return
                (m_numTiles_ == other.m_numTiles_) &&
                (m_tileIds_ == other.m_tileIds_) &&
                (m_headers_ == other.m_headers_);
    }

    return true;
}

uint32_t DeltaTileListInfo::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numTiles_);
    result = ::zserio::calcHashCode(result, m_tileIds_);
    result = ::zserio::calcHashCode(result, m_headers_);

    return result;
}

void DeltaTileListInfo::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numTiles_);

    // check array length
    if (m_tileIds_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field DeltaTileListInfo.tileIds: ") <<
                m_tileIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileIds_.write(out);

    // check array length
    if (m_headers_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field DeltaTileListInfo.headers: ") <<
                m_headers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_headers_.write(*this, out);
}

void DeltaTileListInfo::write(DeltaTileListInfo::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumTiles().write<::zserio::VarSizeArrayTraits>(out, m_numTiles_);

    // check array length
    if (m_tileIds_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field DeltaTileListInfo.tileIds: ") <<
                m_tileIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileIds_.writePacked(out);

    // check array length
    if (m_headers_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field DeltaTileListInfo.headers: ") <<
                m_headers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_headers_.writePacked(*this, out);
}

void DeltaTileListInfo::ZserioElementFactory_headers::create(DeltaTileListInfo&        ,
        ::zserio::vector<::nds::smart::tile::SourceLayerInfo>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void DeltaTileListInfo::ZserioElementFactory_headers::create(DeltaTileListInfo&        ,
        ::zserio::vector<::nds::smart::tile::SourceLayerInfo>& array,
        ::nds::smart::tile::SourceLayerInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t DeltaTileListInfo::readNumTiles(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t DeltaTileListInfo::readNumTiles(DeltaTileListInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumTiles().read<::zserio::VarSizeArrayTraits>(in);
}
DeltaTileListInfo::ZserioArrayType_tileIds DeltaTileListInfo::readTileIds(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_tileIds readField(allocator);
    readField.read(in, static_cast<size_t>(getNumTiles()));

    return readField;
}

DeltaTileListInfo::ZserioArrayType_tileIds DeltaTileListInfo::readTileIds(DeltaTileListInfo::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_tileIds readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumTiles()));

    return readField;
}
DeltaTileListInfo::ZserioArrayType_headers DeltaTileListInfo::readHeaders(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_headers readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

DeltaTileListInfo::ZserioArrayType_headers DeltaTileListInfo::readHeaders(DeltaTileListInfo::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_headers readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/SmartLayerTileVersionRequest.h>

namespace nds
{
namespace smart
{
namespace tile
{

SmartLayerTileVersionRequest::SmartLayerTileVersionRequest(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_numDataLayers_(uint16_t()),
        m_layerIds_(allocator),
        m_lifetimeInfo_(allocator)
{
}

SmartLayerTileVersionRequest::SmartLayerTileVersionRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_numDataLayers_(readNumDataLayers(in)),
        m_layerIds_(readLayerIds(in, allocator)),
        m_lifetimeInfo_(readLifetimeInfo(in, allocator))
{
}

SmartLayerTileVersionRequest::SmartLayerTileVersionRequest(SmartLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_numDataLayers_(readNumDataLayers(context, in)),
        m_layerIds_(readLayerIds(context, in, allocator)),
        m_lifetimeInfo_(readLifetimeInfo(context, in, allocator))
{
}

SmartLayerTileVersionRequest::SmartLayerTileVersionRequest(::zserio::PropagateAllocatorT,
        const SmartLayerTileVersionRequest& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_numDataLayers_(::zserio::allocatorPropagatingCopy(other.m_numDataLayers_, allocator)),
        m_layerIds_(::zserio::allocatorPropagatingCopy(other.m_layerIds_, allocator)),
        m_lifetimeInfo_(::zserio::allocatorPropagatingCopy(other.m_lifetimeInfo_, allocator))
{
}

void SmartLayerTileVersionRequest::initializeChildren()
{
    m_lifetimeInfo_.initializeElements(*this);
}

::nds::core::types::TileId& SmartLayerTileVersionRequest::getId()
{
    return m_id_;
}

const ::nds::core::types::TileId& SmartLayerTileVersionRequest::getId() const
{
    return m_id_;
}

void SmartLayerTileVersionRequest::setId(const ::nds::core::types::TileId& id_)
{
    m_id_ = id_;
}

void SmartLayerTileVersionRequest::setId(::nds::core::types::TileId&& id_)
{
    m_id_ = ::std::move(id_);
}

uint16_t SmartLayerTileVersionRequest::getNumDataLayers() const
{
    return m_numDataLayers_;
}

void SmartLayerTileVersionRequest::setNumDataLayers(uint16_t numDataLayers_)
{
    m_numDataLayers_ = numDataLayers_;
}

::zserio::vector<::nds::smart::types::DataLayerId>& SmartLayerTileVersionRequest::getLayerIds()
{
    return m_layerIds_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayerId>& SmartLayerTileVersionRequest::getLayerIds() const
{
    return m_layerIds_.getRawArray();
}

void SmartLayerTileVersionRequest::setLayerIds(const ::zserio::vector<::nds::smart::types::DataLayerId>& layerIds_)
{
    m_layerIds_ = ZserioArrayType_layerIds(layerIds_);
}

void SmartLayerTileVersionRequest::setLayerIds(::zserio::vector<::nds::smart::types::DataLayerId>&& layerIds_)
{
    m_layerIds_ = ZserioArrayType_layerIds(std::move(layerIds_));
}

::zserio::vector<::nds::smart::types::DataLayerLifetime>& SmartLayerTileVersionRequest::getLifetimeInfo()
{
    return m_lifetimeInfo_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayerLifetime>& SmartLayerTileVersionRequest::getLifetimeInfo() const
{
    return m_lifetimeInfo_.getRawArray();
}

void SmartLayerTileVersionRequest::setLifetimeInfo(const ::zserio::vector<::nds::smart::types::DataLayerLifetime>& lifetimeInfo_)
{
    m_lifetimeInfo_ = ZserioArrayType_lifetimeInfo(lifetimeInfo_);
}

void SmartLayerTileVersionRequest::setLifetimeInfo(::zserio::vector<::nds::smart::types::DataLayerLifetime>&& lifetimeInfo_)
{
    m_lifetimeInfo_ = ZserioArrayType_lifetimeInfo(std::move(lifetimeInfo_));
}

void SmartLayerTileVersionRequest::initPackingContext(SmartLayerTileVersionRequest::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
    context.getNumDataLayers().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
}

size_t SmartLayerTileVersionRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition += m_layerIds_.bitSizeOf(endBitPosition);
    endBitPosition += m_lifetimeInfo_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTileVersionRequest::bitSizeOf(SmartLayerTileVersionRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition += m_layerIds_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_lifetimeInfo_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTileVersionRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition = m_layerIds_.initializeOffsets(endBitPosition);
    endBitPosition = m_lifetimeInfo_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerTileVersionRequest::initializeOffsets(SmartLayerTileVersionRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition = m_layerIds_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_lifetimeInfo_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerTileVersionRequest::operator==(const SmartLayerTileVersionRequest& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_numDataLayers_ == other.m_numDataLayers_) &&
                (m_layerIds_ == other.m_layerIds_) &&
                (m_lifetimeInfo_ == other.m_lifetimeInfo_);
    }

    return true;
}

uint32_t SmartLayerTileVersionRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_numDataLayers_);
    result = ::zserio::calcHashCode(result, m_layerIds_);
    result = ::zserio::calcHashCode(result, m_lifetimeInfo_);

    return result;
}

void SmartLayerTileVersionRequest::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);

    out.writeVarUInt16(m_numDataLayers_);

    // check array length
    if (m_layerIds_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileVersionRequest.layerIds: ") <<
                m_layerIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_layerIds_.write(out);

    // check array length
    if (m_lifetimeInfo_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileVersionRequest.lifetimeInfo: ") <<
                m_lifetimeInfo_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_lifetimeInfo_.write(*this, out);
}

void SmartLayerTileVersionRequest::write(SmartLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);

    context.getNumDataLayers().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numDataLayers_);

    // check array length
    if (m_layerIds_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileVersionRequest.layerIds: ") <<
                m_layerIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_layerIds_.writePacked(out);

    // check array length
    if (m_lifetimeInfo_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileVersionRequest.lifetimeInfo: ") <<
                m_lifetimeInfo_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_lifetimeInfo_.writePacked(*this, out);
}

void SmartLayerTileVersionRequest::ZserioArrayExpressions_lifetimeInfo::initializeElement(SmartLayerTileVersionRequest&,
        ::nds::smart::types::DataLayerLifetime& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerTileVersionRequest::ZserioElementFactory_lifetimeInfo::create(SmartLayerTileVersionRequest&        ,
        ::zserio::vector<::nds::smart::types::DataLayerLifetime>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerTileVersionRequest::ZserioElementFactory_lifetimeInfo::create(SmartLayerTileVersionRequest&        ,
        ::zserio::vector<::nds::smart::types::DataLayerLifetime>& array,
        ::nds::smart::types::DataLayerLifetime::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::types::TileId SmartLayerTileVersionRequest::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TileId(in, allocator);
}

::nds::core::types::TileId SmartLayerTileVersionRequest::readId(SmartLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TileId(context.getId(), in, allocator);
}
uint16_t SmartLayerTileVersionRequest::readNumDataLayers(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t SmartLayerTileVersionRequest::readNumDataLayers(SmartLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumDataLayers().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
SmartLayerTileVersionRequest::ZserioArrayType_layerIds SmartLayerTileVersionRequest::readLayerIds(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_layerIds readField(allocator);
    readField.read(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

SmartLayerTileVersionRequest::ZserioArrayType_layerIds SmartLayerTileVersionRequest::readLayerIds(SmartLayerTileVersionRequest::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_layerIds readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}
SmartLayerTileVersionRequest::ZserioArrayType_lifetimeInfo SmartLayerTileVersionRequest::readLifetimeInfo(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lifetimeInfo readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

SmartLayerTileVersionRequest::ZserioArrayType_lifetimeInfo SmartLayerTileVersionRequest::readLifetimeInfo(SmartLayerTileVersionRequest::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lifetimeInfo readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/SmartLayerTileVersionRequestList.h>

namespace nds
{
namespace smart
{
namespace tile
{

SmartLayerTileVersionRequestList::SmartLayerTileVersionRequestList(const allocator_type& allocator) noexcept :
        m_numTiles_(uint32_t()),
        m_tileVersionRequests_(allocator)
{
}

SmartLayerTileVersionRequestList::SmartLayerTileVersionRequestList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(in)),
        m_tileVersionRequests_(readTileVersionRequests(in, allocator))
{
}

SmartLayerTileVersionRequestList::SmartLayerTileVersionRequestList(SmartLayerTileVersionRequestList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(context, in)),
        m_tileVersionRequests_(readTileVersionRequests(context, in, allocator))
{
}

SmartLayerTileVersionRequestList::SmartLayerTileVersionRequestList(::zserio::PropagateAllocatorT,
        const SmartLayerTileVersionRequestList& other, const allocator_type& allocator) :
        m_numTiles_(::zserio::allocatorPropagatingCopy(other.m_numTiles_, allocator)),
        m_tileVersionRequests_(::zserio::allocatorPropagatingCopy(other.m_tileVersionRequests_, allocator))
{
}

void SmartLayerTileVersionRequestList::initializeChildren()
{
    m_tileVersionRequests_.initializeElements(*this);
}

uint32_t SmartLayerTileVersionRequestList::getNumTiles() const
{
    return m_numTiles_;
}

void SmartLayerTileVersionRequestList::setNumTiles(uint32_t numTiles_)
{
    m_numTiles_ = numTiles_;
}

::zserio::vector<::nds::smart::tile::SmartLayerTileVersionRequest>& SmartLayerTileVersionRequestList::getTileVersionRequests()
{
    return m_tileVersionRequests_.getRawArray();
}

const ::zserio::vector<::nds::smart::tile::SmartLayerTileVersionRequest>& SmartLayerTileVersionRequestList::getTileVersionRequests() const
{
    return m_tileVersionRequests_.getRawArray();
}

void SmartLayerTileVersionRequestList::setTileVersionRequests(const ::zserio::vector<::nds::smart::tile::SmartLayerTileVersionRequest>& tileVersionRequests_)
{
    m_tileVersionRequests_ = ZserioArrayType_tileVersionRequests(tileVersionRequests_);
}

void SmartLayerTileVersionRequestList::setTileVersionRequests(::zserio::vector<::nds::smart::tile::SmartLayerTileVersionRequest>&& tileVersionRequests_)
{
    m_tileVersionRequests_ = ZserioArrayType_tileVersionRequests(std::move(tileVersionRequests_));
}

void SmartLayerTileVersionRequestList::initPackingContext(SmartLayerTileVersionRequestList::ZserioPackingContext& context) const
{
    context.getNumTiles().init<::zserio::VarSizeArrayTraits>(m_numTiles_);
}

size_t SmartLayerTileVersionRequestList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition += m_tileVersionRequests_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTileVersionRequestList::bitSizeOf(SmartLayerTileVersionRequestList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition += m_tileVersionRequests_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerTileVersionRequestList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition = m_tileVersionRequests_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerTileVersionRequestList::initializeOffsets(SmartLayerTileVersionRequestList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition = m_tileVersionRequests_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerTileVersionRequestList::operator==(const SmartLayerTileVersionRequestList& other) const
{
    if (this != &other)
    {
        return
                (m_numTiles_ == other.m_numTiles_) &&
                (m_tileVersionRequests_ == other.m_tileVersionRequests_);
    }

    return true;
}

uint32_t SmartLayerTileVersionRequestList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numTiles_);
    result = ::zserio::calcHashCode(result, m_tileVersionRequests_);

    return result;
}

void SmartLayerTileVersionRequestList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numTiles_);

    // check array length
    if (m_tileVersionRequests_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileVersionRequestList.tileVersionRequests: ") <<
                m_tileVersionRequests_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileVersionRequests_.write(*this, out);
}

void SmartLayerTileVersionRequestList::write(SmartLayerTileVersionRequestList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumTiles().write<::zserio::VarSizeArrayTraits>(out, m_numTiles_);

    // check array length
    if (m_tileVersionRequests_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerTileVersionRequestList.tileVersionRequests: ") <<
                m_tileVersionRequests_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileVersionRequests_.writePacked(*this, out);
}

void SmartLayerTileVersionRequestList::ZserioArrayExpressions_tileVersionRequests::initializeElement(SmartLayerTileVersionRequestList&,
        ::nds::smart::tile::SmartLayerTileVersionRequest& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerTileVersionRequestList::ZserioElementFactory_tileVersionRequests::create(SmartLayerTileVersionRequestList&        ,
        ::zserio::vector<::nds::smart::tile::SmartLayerTileVersionRequest>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerTileVersionRequestList::ZserioElementFactory_tileVersionRequests::create(SmartLayerTileVersionRequestList&        ,
        ::zserio::vector<::nds::smart::tile::SmartLayerTileVersionRequest>& array,
        ::nds::smart::tile::SmartLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t SmartLayerTileVersionRequestList::readNumTiles(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t SmartLayerTileVersionRequestList::readNumTiles(SmartLayerTileVersionRequestList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumTiles().read<::zserio::VarSizeArrayTraits>(in);
}
SmartLayerTileVersionRequestList::ZserioArrayType_tileVersionRequests SmartLayerTileVersionRequestList::readTileVersionRequests(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_tileVersionRequests readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

SmartLayerTileVersionRequestList::ZserioArrayType_tileVersionRequests SmartLayerTileVersionRequestList::readTileVersionRequests(SmartLayerTileVersionRequestList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_tileVersionRequests readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/DataLayerTileVersionRequest.h>

namespace nds
{
namespace smart
{
namespace tile
{

DataLayerTileVersionRequest::DataLayerTileVersionRequest(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_layerId_(::nds::smart::types::DataLayerId()),
        m_lifetimeInfo_(allocator)
{
}

DataLayerTileVersionRequest::DataLayerTileVersionRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_layerId_(readLayerId(in)),
        m_lifetimeInfo_(readLifetimeInfo(in, allocator))
{
}

DataLayerTileVersionRequest::DataLayerTileVersionRequest(DataLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_layerId_(readLayerId(context, in)),
        m_lifetimeInfo_(readLifetimeInfo(context, in, allocator))
{
}

DataLayerTileVersionRequest::DataLayerTileVersionRequest(::zserio::PropagateAllocatorT,
        const DataLayerTileVersionRequest& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_layerId_(::zserio::allocatorPropagatingCopy(other.m_layerId_, allocator)),
        m_lifetimeInfo_(::zserio::allocatorPropagatingCopy(other.m_lifetimeInfo_, allocator))
{
}

void DataLayerTileVersionRequest::initializeChildren()
{
    m_lifetimeInfo_.initializeChildren();
}

::nds::core::types::TileId& DataLayerTileVersionRequest::getId()
{
    return m_id_;
}

const ::nds::core::types::TileId& DataLayerTileVersionRequest::getId() const
{
    return m_id_;
}

void DataLayerTileVersionRequest::setId(const ::nds::core::types::TileId& id_)
{
    m_id_ = id_;
}

void DataLayerTileVersionRequest::setId(::nds::core::types::TileId&& id_)
{
    m_id_ = ::std::move(id_);
}

::nds::smart::types::DataLayerId DataLayerTileVersionRequest::getLayerId() const
{
    return m_layerId_;
}

void DataLayerTileVersionRequest::setLayerId(::nds::smart::types::DataLayerId layerId_)
{
    m_layerId_ = layerId_;
}

::nds::smart::types::DataLayerLifetime& DataLayerTileVersionRequest::getLifetimeInfo()
{
    return m_lifetimeInfo_;
}

const ::nds::smart::types::DataLayerLifetime& DataLayerTileVersionRequest::getLifetimeInfo() const
{
    return m_lifetimeInfo_;
}

void DataLayerTileVersionRequest::setLifetimeInfo(const ::nds::smart::types::DataLayerLifetime& lifetimeInfo_)
{
    m_lifetimeInfo_ = lifetimeInfo_;
}

void DataLayerTileVersionRequest::setLifetimeInfo(::nds::smart::types::DataLayerLifetime&& lifetimeInfo_)
{
    m_lifetimeInfo_ = ::std::move(lifetimeInfo_);
}

void DataLayerTileVersionRequest::initPackingContext(DataLayerTileVersionRequest::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
    context.getLayerId().init<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(m_layerId_);
    m_lifetimeInfo_.initPackingContext(context.getLifetimeInfo());
}

size_t DataLayerTileVersionRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_layerId_);
    endBitPosition += m_lifetimeInfo_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DataLayerTileVersionRequest::bitSizeOf(DataLayerTileVersionRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += context.getLayerId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(m_layerId_);
    endBitPosition += m_lifetimeInfo_.bitSizeOf(context.getLifetimeInfo(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DataLayerTileVersionRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_layerId_);
    endBitPosition = m_lifetimeInfo_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t DataLayerTileVersionRequest::initializeOffsets(DataLayerTileVersionRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition += context.getLayerId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(m_layerId_);
    endBitPosition = m_lifetimeInfo_.initializeOffsets(context.getLifetimeInfo(), endBitPosition);

    return endBitPosition;
}

bool DataLayerTileVersionRequest::operator==(const DataLayerTileVersionRequest& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_layerId_ == other.m_layerId_) &&
                (m_lifetimeInfo_ == other.m_lifetimeInfo_);
    }

    return true;
}

uint32_t DataLayerTileVersionRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_layerId_);
    result = ::zserio::calcHashCode(result, m_lifetimeInfo_);

    return result;
}

void DataLayerTileVersionRequest::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);
    out.writeVarUInt16(m_layerId_);
    m_lifetimeInfo_.write(out);
}

void DataLayerTileVersionRequest::write(DataLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);
    context.getLayerId().write<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(out, m_layerId_);
    m_lifetimeInfo_.write(context.getLifetimeInfo(), out);
}

::nds::core::types::TileId DataLayerTileVersionRequest::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TileId(in, allocator);
}

::nds::core::types::TileId DataLayerTileVersionRequest::readId(DataLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TileId(context.getId(), in, allocator);
}
::nds::smart::types::DataLayerId DataLayerTileVersionRequest::readLayerId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::smart::types::DataLayerId>(in.readVarUInt16());
}

::nds::smart::types::DataLayerId DataLayerTileVersionRequest::readLayerId(DataLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLayerId().read<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(in);
}
::nds::smart::types::DataLayerLifetime DataLayerTileVersionRequest::readLifetimeInfo(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::types::DataLayerLifetime(in, allocator);
}

::nds::smart::types::DataLayerLifetime DataLayerTileVersionRequest::readLifetimeInfo(DataLayerTileVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::types::DataLayerLifetime(context.getLifetimeInfo(), in, allocator);
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/MultiDataLayerTileRequest.h>

namespace nds
{
namespace smart
{
namespace tile
{

MultiDataLayerTileRequest::MultiDataLayerTileRequest(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_numDataLayers_(uint16_t()),
        m_layerIds_(allocator),
        m_lifetimeInfo_(allocator)
{
}

MultiDataLayerTileRequest::MultiDataLayerTileRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_numDataLayers_(readNumDataLayers(in)),
        m_layerIds_(readLayerIds(in, allocator)),
        m_lifetimeInfo_(readLifetimeInfo(in, allocator))
{
}

MultiDataLayerTileRequest::MultiDataLayerTileRequest(MultiDataLayerTileRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_numDataLayers_(readNumDataLayers(context, in)),
        m_layerIds_(readLayerIds(context, in, allocator)),
        m_lifetimeInfo_(readLifetimeInfo(context, in, allocator))
{
}

MultiDataLayerTileRequest::MultiDataLayerTileRequest(::zserio::PropagateAllocatorT,
        const MultiDataLayerTileRequest& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_numDataLayers_(::zserio::allocatorPropagatingCopy(other.m_numDataLayers_, allocator)),
        m_layerIds_(::zserio::allocatorPropagatingCopy(other.m_layerIds_, allocator)),
        m_lifetimeInfo_(::zserio::allocatorPropagatingCopy(other.m_lifetimeInfo_, allocator))
{
}

void MultiDataLayerTileRequest::initializeChildren()
{
    m_lifetimeInfo_.initializeElements(*this);
}

::nds::core::types::TileId& MultiDataLayerTileRequest::getId()
{
    return m_id_;
}

const ::nds::core::types::TileId& MultiDataLayerTileRequest::getId() const
{
    return m_id_;
}

void MultiDataLayerTileRequest::setId(const ::nds::core::types::TileId& id_)
{
    m_id_ = id_;
}

void MultiDataLayerTileRequest::setId(::nds::core::types::TileId&& id_)
{
    m_id_ = ::std::move(id_);
}

uint16_t MultiDataLayerTileRequest::getNumDataLayers() const
{
    return m_numDataLayers_;
}

void MultiDataLayerTileRequest::setNumDataLayers(uint16_t numDataLayers_)
{
    m_numDataLayers_ = numDataLayers_;
}

::zserio::vector<::nds::smart::types::DataLayerId>& MultiDataLayerTileRequest::getLayerIds()
{
    return m_layerIds_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayerId>& MultiDataLayerTileRequest::getLayerIds() const
{
    return m_layerIds_.getRawArray();
}

void MultiDataLayerTileRequest::setLayerIds(const ::zserio::vector<::nds::smart::types::DataLayerId>& layerIds_)
{
    m_layerIds_ = ZserioArrayType_layerIds(layerIds_);
}

void MultiDataLayerTileRequest::setLayerIds(::zserio::vector<::nds::smart::types::DataLayerId>&& layerIds_)
{
    m_layerIds_ = ZserioArrayType_layerIds(std::move(layerIds_));
}

::zserio::vector<::nds::smart::types::DataLayerLifetime>& MultiDataLayerTileRequest::getLifetimeInfo()
{
    return m_lifetimeInfo_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayerLifetime>& MultiDataLayerTileRequest::getLifetimeInfo() const
{
    return m_lifetimeInfo_.getRawArray();
}

void MultiDataLayerTileRequest::setLifetimeInfo(const ::zserio::vector<::nds::smart::types::DataLayerLifetime>& lifetimeInfo_)
{
    m_lifetimeInfo_ = ZserioArrayType_lifetimeInfo(lifetimeInfo_);
}

void MultiDataLayerTileRequest::setLifetimeInfo(::zserio::vector<::nds::smart::types::DataLayerLifetime>&& lifetimeInfo_)
{
    m_lifetimeInfo_ = ZserioArrayType_lifetimeInfo(std::move(lifetimeInfo_));
}

void MultiDataLayerTileRequest::initPackingContext(MultiDataLayerTileRequest::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
    context.getNumDataLayers().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
}

size_t MultiDataLayerTileRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition += m_layerIds_.bitSizeOf(endBitPosition);
    endBitPosition += m_lifetimeInfo_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MultiDataLayerTileRequest::bitSizeOf(MultiDataLayerTileRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition += m_layerIds_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_lifetimeInfo_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MultiDataLayerTileRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition = m_layerIds_.initializeOffsets(endBitPosition);
    endBitPosition = m_lifetimeInfo_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t MultiDataLayerTileRequest::initializeOffsets(MultiDataLayerTileRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition = m_layerIds_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_lifetimeInfo_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool MultiDataLayerTileRequest::operator==(const MultiDataLayerTileRequest& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_numDataLayers_ == other.m_numDataLayers_) &&
                (m_layerIds_ == other.m_layerIds_) &&
                (m_lifetimeInfo_ == other.m_lifetimeInfo_);
    }

    return true;
}

uint32_t MultiDataLayerTileRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_numDataLayers_);
    result = ::zserio::calcHashCode(result, m_layerIds_);
    result = ::zserio::calcHashCode(result, m_lifetimeInfo_);

    return result;
}

void MultiDataLayerTileRequest::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);

    out.writeVarUInt16(m_numDataLayers_);

    // check array length
    if (m_layerIds_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerTileRequest.layerIds: ") <<
                m_layerIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_layerIds_.write(out);

    // check array length
    if (m_lifetimeInfo_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerTileRequest.lifetimeInfo: ") <<
                m_lifetimeInfo_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_lifetimeInfo_.write(*this, out);
}

void MultiDataLayerTileRequest::write(MultiDataLayerTileRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);

    context.getNumDataLayers().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numDataLayers_);

    // check array length
    if (m_layerIds_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerTileRequest.layerIds: ") <<
                m_layerIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_layerIds_.writePacked(out);

    // check array length
    if (m_lifetimeInfo_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerTileRequest.lifetimeInfo: ") <<
                m_lifetimeInfo_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_lifetimeInfo_.writePacked(*this, out);
}

void MultiDataLayerTileRequest::ZserioArrayExpressions_lifetimeInfo::initializeElement(MultiDataLayerTileRequest&,
        ::nds::smart::types::DataLayerLifetime& element, size_t)
{
    element.initializeChildren();
}

void MultiDataLayerTileRequest::ZserioElementFactory_lifetimeInfo::create(MultiDataLayerTileRequest&        ,
        ::zserio::vector<::nds::smart::types::DataLayerLifetime>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void MultiDataLayerTileRequest::ZserioElementFactory_lifetimeInfo::create(MultiDataLayerTileRequest&        ,
        ::zserio::vector<::nds::smart::types::DataLayerLifetime>& array,
        ::nds::smart::types::DataLayerLifetime::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::types::TileId MultiDataLayerTileRequest::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TileId(in, allocator);
}

::nds::core::types::TileId MultiDataLayerTileRequest::readId(MultiDataLayerTileRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TileId(context.getId(), in, allocator);
}
uint16_t MultiDataLayerTileRequest::readNumDataLayers(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t MultiDataLayerTileRequest::readNumDataLayers(MultiDataLayerTileRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumDataLayers().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
MultiDataLayerTileRequest::ZserioArrayType_layerIds MultiDataLayerTileRequest::readLayerIds(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_layerIds readField(allocator);
    readField.read(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

MultiDataLayerTileRequest::ZserioArrayType_layerIds MultiDataLayerTileRequest::readLayerIds(MultiDataLayerTileRequest::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_layerIds readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}
MultiDataLayerTileRequest::ZserioArrayType_lifetimeInfo MultiDataLayerTileRequest::readLifetimeInfo(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lifetimeInfo readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

MultiDataLayerTileRequest::ZserioArrayType_lifetimeInfo MultiDataLayerTileRequest::readLifetimeInfo(MultiDataLayerTileRequest::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lifetimeInfo readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/MultiDataLayerMultiTileRequest.h>

namespace nds
{
namespace smart
{
namespace tile
{

MultiDataLayerMultiTileRequest::MultiDataLayerMultiTileRequest(const allocator_type& allocator) noexcept :
        m_numTiles_(uint32_t()),
        m_tileVersionRequests_(allocator)
{
}

MultiDataLayerMultiTileRequest::MultiDataLayerMultiTileRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(in)),
        m_tileVersionRequests_(readTileVersionRequests(in, allocator))
{
}

MultiDataLayerMultiTileRequest::MultiDataLayerMultiTileRequest(MultiDataLayerMultiTileRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(context, in)),
        m_tileVersionRequests_(readTileVersionRequests(context, in, allocator))
{
}

MultiDataLayerMultiTileRequest::MultiDataLayerMultiTileRequest(::zserio::PropagateAllocatorT,
        const MultiDataLayerMultiTileRequest& other, const allocator_type& allocator) :
        m_numTiles_(::zserio::allocatorPropagatingCopy(other.m_numTiles_, allocator)),
        m_tileVersionRequests_(::zserio::allocatorPropagatingCopy(other.m_tileVersionRequests_, allocator))
{
}

void MultiDataLayerMultiTileRequest::initializeChildren()
{
    m_tileVersionRequests_.initializeElements(*this);
}

uint32_t MultiDataLayerMultiTileRequest::getNumTiles() const
{
    return m_numTiles_;
}

void MultiDataLayerMultiTileRequest::setNumTiles(uint32_t numTiles_)
{
    m_numTiles_ = numTiles_;
}

::zserio::vector<::nds::smart::tile::MultiDataLayerTileRequest>& MultiDataLayerMultiTileRequest::getTileVersionRequests()
{
    return m_tileVersionRequests_.getRawArray();
}

const ::zserio::vector<::nds::smart::tile::MultiDataLayerTileRequest>& MultiDataLayerMultiTileRequest::getTileVersionRequests() const
{
    return m_tileVersionRequests_.getRawArray();
}

void MultiDataLayerMultiTileRequest::setTileVersionRequests(const ::zserio::vector<::nds::smart::tile::MultiDataLayerTileRequest>& tileVersionRequests_)
{
    m_tileVersionRequests_ = ZserioArrayType_tileVersionRequests(tileVersionRequests_);
}

void MultiDataLayerMultiTileRequest::setTileVersionRequests(::zserio::vector<::nds::smart::tile::MultiDataLayerTileRequest>&& tileVersionRequests_)
{
    m_tileVersionRequests_ = ZserioArrayType_tileVersionRequests(std::move(tileVersionRequests_));
}

void MultiDataLayerMultiTileRequest::initPackingContext(MultiDataLayerMultiTileRequest::ZserioPackingContext& context) const
{
    context.getNumTiles().init<::zserio::VarSizeArrayTraits>(m_numTiles_);
}

size_t MultiDataLayerMultiTileRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition += m_tileVersionRequests_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MultiDataLayerMultiTileRequest::bitSizeOf(MultiDataLayerMultiTileRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition += m_tileVersionRequests_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MultiDataLayerMultiTileRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition = m_tileVersionRequests_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t MultiDataLayerMultiTileRequest::initializeOffsets(MultiDataLayerMultiTileRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition = m_tileVersionRequests_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool MultiDataLayerMultiTileRequest::operator==(const MultiDataLayerMultiTileRequest& other) const
{
    if (this != &other)
    {
        return
                (m_numTiles_ == other.m_numTiles_) &&
                (m_tileVersionRequests_ == other.m_tileVersionRequests_);
    }

    return true;
}

uint32_t MultiDataLayerMultiTileRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numTiles_);
    result = ::zserio::calcHashCode(result, m_tileVersionRequests_);

    return result;
}

void MultiDataLayerMultiTileRequest::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numTiles_);

    // check array length
    if (m_tileVersionRequests_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerMultiTileRequest.tileVersionRequests: ") <<
                m_tileVersionRequests_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileVersionRequests_.write(*this, out);
}

void MultiDataLayerMultiTileRequest::write(MultiDataLayerMultiTileRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumTiles().write<::zserio::VarSizeArrayTraits>(out, m_numTiles_);

    // check array length
    if (m_tileVersionRequests_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerMultiTileRequest.tileVersionRequests: ") <<
                m_tileVersionRequests_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileVersionRequests_.writePacked(*this, out);
}

void MultiDataLayerMultiTileRequest::ZserioArrayExpressions_tileVersionRequests::initializeElement(MultiDataLayerMultiTileRequest&,
        ::nds::smart::tile::MultiDataLayerTileRequest& element, size_t)
{
    element.initializeChildren();
}

void MultiDataLayerMultiTileRequest::ZserioElementFactory_tileVersionRequests::create(MultiDataLayerMultiTileRequest&        ,
        ::zserio::vector<::nds::smart::tile::MultiDataLayerTileRequest>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void MultiDataLayerMultiTileRequest::ZserioElementFactory_tileVersionRequests::create(MultiDataLayerMultiTileRequest&        ,
        ::zserio::vector<::nds::smart::tile::MultiDataLayerTileRequest>& array,
        ::nds::smart::tile::MultiDataLayerTileRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t MultiDataLayerMultiTileRequest::readNumTiles(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t MultiDataLayerMultiTileRequest::readNumTiles(MultiDataLayerMultiTileRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumTiles().read<::zserio::VarSizeArrayTraits>(in);
}
MultiDataLayerMultiTileRequest::ZserioArrayType_tileVersionRequests MultiDataLayerMultiTileRequest::readTileVersionRequests(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_tileVersionRequests readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

MultiDataLayerMultiTileRequest::ZserioArrayType_tileVersionRequests MultiDataLayerMultiTileRequest::readTileVersionRequests(MultiDataLayerMultiTileRequest::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_tileVersionRequests readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/MultiDataLayerMultiTileResponse.h>

namespace nds
{
namespace smart
{
namespace tile
{

MultiDataLayerMultiTileResponse::MultiDataLayerMultiTileResponse(const allocator_type& allocator) noexcept :
        m_numTiles_(uint32_t()),
        m_tileVersionResponses_(allocator)
{
}

MultiDataLayerMultiTileResponse::MultiDataLayerMultiTileResponse(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(in)),
        m_tileVersionResponses_(readTileVersionResponses(in, allocator))
{
}

MultiDataLayerMultiTileResponse::MultiDataLayerMultiTileResponse(MultiDataLayerMultiTileResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numTiles_(readNumTiles(context, in)),
        m_tileVersionResponses_(readTileVersionResponses(context, in, allocator))
{
}

MultiDataLayerMultiTileResponse::MultiDataLayerMultiTileResponse(::zserio::PropagateAllocatorT,
        const MultiDataLayerMultiTileResponse& other, const allocator_type& allocator) :
        m_numTiles_(::zserio::allocatorPropagatingCopy(other.m_numTiles_, allocator)),
        m_tileVersionResponses_(::zserio::allocatorPropagatingCopy(other.m_tileVersionResponses_, allocator))
{
}

uint32_t MultiDataLayerMultiTileResponse::getNumTiles() const
{
    return m_numTiles_;
}

void MultiDataLayerMultiTileResponse::setNumTiles(uint32_t numTiles_)
{
    m_numTiles_ = numTiles_;
}

::zserio::vector<::nds::smart::tile::MultiDataLayerTileResponse>& MultiDataLayerMultiTileResponse::getTileVersionResponses()
{
    return m_tileVersionResponses_.getRawArray();
}

const ::zserio::vector<::nds::smart::tile::MultiDataLayerTileResponse>& MultiDataLayerMultiTileResponse::getTileVersionResponses() const
{
    return m_tileVersionResponses_.getRawArray();
}

void MultiDataLayerMultiTileResponse::setTileVersionResponses(const ::zserio::vector<::nds::smart::tile::MultiDataLayerTileResponse>& tileVersionResponses_)
{
    m_tileVersionResponses_ = ZserioArrayType_tileVersionResponses(tileVersionResponses_);
}

void MultiDataLayerMultiTileResponse::setTileVersionResponses(::zserio::vector<::nds::smart::tile::MultiDataLayerTileResponse>&& tileVersionResponses_)
{
    m_tileVersionResponses_ = ZserioArrayType_tileVersionResponses(std::move(tileVersionResponses_));
}

void MultiDataLayerMultiTileResponse::initPackingContext(MultiDataLayerMultiTileResponse::ZserioPackingContext& context) const
{
    context.getNumTiles().init<::zserio::VarSizeArrayTraits>(m_numTiles_);
}

size_t MultiDataLayerMultiTileResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition += m_tileVersionResponses_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MultiDataLayerMultiTileResponse::bitSizeOf(MultiDataLayerMultiTileResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition += m_tileVersionResponses_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MultiDataLayerMultiTileResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numTiles_);
    endBitPosition = m_tileVersionResponses_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t MultiDataLayerMultiTileResponse::initializeOffsets(MultiDataLayerMultiTileResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTiles_);
    endBitPosition = m_tileVersionResponses_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool MultiDataLayerMultiTileResponse::operator==(const MultiDataLayerMultiTileResponse& other) const
{
    if (this != &other)
    {
        return
                (m_numTiles_ == other.m_numTiles_) &&
                (m_tileVersionResponses_ == other.m_tileVersionResponses_);
    }

    return true;
}

uint32_t MultiDataLayerMultiTileResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numTiles_);
    result = ::zserio::calcHashCode(result, m_tileVersionResponses_);

    return result;
}

void MultiDataLayerMultiTileResponse::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numTiles_);

    // check array length
    if (m_tileVersionResponses_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerMultiTileResponse.tileVersionResponses: ") <<
                m_tileVersionResponses_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileVersionResponses_.write(*this, out);
}

void MultiDataLayerMultiTileResponse::write(MultiDataLayerMultiTileResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumTiles().write<::zserio::VarSizeArrayTraits>(out, m_numTiles_);

    // check array length
    if (m_tileVersionResponses_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerMultiTileResponse.tileVersionResponses: ") <<
                m_tileVersionResponses_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileVersionResponses_.writePacked(*this, out);
}

void MultiDataLayerMultiTileResponse::ZserioElementFactory_tileVersionResponses::create(MultiDataLayerMultiTileResponse&        ,
        ::zserio::vector<::nds::smart::tile::MultiDataLayerTileResponse>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void MultiDataLayerMultiTileResponse::ZserioElementFactory_tileVersionResponses::create(MultiDataLayerMultiTileResponse&        ,
        ::zserio::vector<::nds::smart::tile::MultiDataLayerTileResponse>& array,
        ::nds::smart::tile::MultiDataLayerTileResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t MultiDataLayerMultiTileResponse::readNumTiles(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t MultiDataLayerMultiTileResponse::readNumTiles(MultiDataLayerMultiTileResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumTiles().read<::zserio::VarSizeArrayTraits>(in);
}
MultiDataLayerMultiTileResponse::ZserioArrayType_tileVersionResponses MultiDataLayerMultiTileResponse::readTileVersionResponses(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_tileVersionResponses readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

MultiDataLayerMultiTileResponse::ZserioArrayType_tileVersionResponses MultiDataLayerMultiTileResponse::readTileVersionResponses(MultiDataLayerMultiTileResponse::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_tileVersionResponses readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/tile/MultiDataLayerTileResponse.h>

namespace nds
{
namespace smart
{
namespace tile
{

MultiDataLayerTileResponse::MultiDataLayerTileResponse(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_numDataLayers_(uint16_t()),
        m_layers_(allocator)
{
}

MultiDataLayerTileResponse::MultiDataLayerTileResponse(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_numDataLayers_(readNumDataLayers(in)),
        m_layers_(readLayers(in, allocator))
{
}

MultiDataLayerTileResponse::MultiDataLayerTileResponse(MultiDataLayerTileResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_numDataLayers_(readNumDataLayers(context, in)),
        m_layers_(readLayers(in, allocator))
{
}

MultiDataLayerTileResponse::MultiDataLayerTileResponse(::zserio::PropagateAllocatorT,
        const MultiDataLayerTileResponse& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_numDataLayers_(::zserio::allocatorPropagatingCopy(other.m_numDataLayers_, allocator)),
        m_layers_(::zserio::allocatorPropagatingCopy(other.m_layers_, allocator))
{
}

::nds::core::types::TileId& MultiDataLayerTileResponse::getId()
{
    return m_id_;
}

const ::nds::core::types::TileId& MultiDataLayerTileResponse::getId() const
{
    return m_id_;
}

void MultiDataLayerTileResponse::setId(const ::nds::core::types::TileId& id_)
{
    m_id_ = id_;
}

void MultiDataLayerTileResponse::setId(::nds::core::types::TileId&& id_)
{
    m_id_ = ::std::move(id_);
}

uint16_t MultiDataLayerTileResponse::getNumDataLayers() const
{
    return m_numDataLayers_;
}

void MultiDataLayerTileResponse::setNumDataLayers(uint16_t numDataLayers_)
{
    m_numDataLayers_ = numDataLayers_;
}

::zserio::vector<::nds::smart::types::DataLayer>& MultiDataLayerTileResponse::getLayers()
{
    return m_layers_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayer>& MultiDataLayerTileResponse::getLayers() const
{
    return m_layers_.getRawArray();
}

void MultiDataLayerTileResponse::setLayers(const ::zserio::vector<::nds::smart::types::DataLayer>& layers_)
{
    m_layers_ = ZserioArrayType_layers(layers_);
}

void MultiDataLayerTileResponse::setLayers(::zserio::vector<::nds::smart::types::DataLayer>&& layers_)
{
    m_layers_ = ZserioArrayType_layers(std::move(layers_));
}

void MultiDataLayerTileResponse::initPackingContext(MultiDataLayerTileResponse::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
    context.getNumDataLayers().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
}

size_t MultiDataLayerTileResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MultiDataLayerTileResponse::bitSizeOf(MultiDataLayerTileResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MultiDataLayerTileResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t MultiDataLayerTileResponse::initializeOffsets(MultiDataLayerTileResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool MultiDataLayerTileResponse::operator==(const MultiDataLayerTileResponse& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_numDataLayers_ == other.m_numDataLayers_) &&
                (m_layers_ == other.m_layers_);
    }

    return true;
}

uint32_t MultiDataLayerTileResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_numDataLayers_);
    result = ::zserio::calcHashCode(result, m_layers_);

    return result;
}

void MultiDataLayerTileResponse::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);

    out.writeVarUInt16(m_numDataLayers_);

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerTileResponse.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void MultiDataLayerTileResponse::write(MultiDataLayerTileResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);

    context.getNumDataLayers().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numDataLayers_);

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MultiDataLayerTileResponse.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void MultiDataLayerTileResponse::ZserioElementFactory_layers::create(MultiDataLayerTileResponse&        ,
        ::zserio::vector<::nds::smart::types::DataLayer>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

::nds::core::types::TileId MultiDataLayerTileResponse::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TileId(in, allocator);
}

::nds::core::types::TileId MultiDataLayerTileResponse::readId(MultiDataLayerTileResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TileId(context.getId(), in, allocator);
}
uint16_t MultiDataLayerTileResponse::readNumDataLayers(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t MultiDataLayerTileResponse::readNumDataLayers(MultiDataLayerTileResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumDataLayers().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
MultiDataLayerTileResponse::ZserioArrayType_layers MultiDataLayerTileResponse::readLayers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_layers readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

} // namespace tile
} // namespace smart
} // namespace nds
