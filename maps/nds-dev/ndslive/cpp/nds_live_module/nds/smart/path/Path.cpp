/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/smart/path/SmartLayerPath.h>

namespace nds
{
namespace smart
{
namespace path
{

SmartLayerPath::SmartLayerPath(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_header_(allocator),
        m_numSegments_(uint32_t()),
        m_exactMatch_(bool()),
        m_pathLocation_(::zserio::NullOpt),
        m_segments_(allocator)
{
}

SmartLayerPath::SmartLayerPath(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_header_(readHeader(in, allocator)),
        m_numSegments_(readNumSegments(in)),
        m_exactMatch_(readExactMatch(in)),
        m_pathLocation_(readPathLocation(in, allocator)),
        m_segments_(readSegments(in, allocator))
{
}

SmartLayerPath::SmartLayerPath(SmartLayerPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_header_(readHeader(context, in, allocator)),
        m_numSegments_(readNumSegments(context, in)),
        m_exactMatch_(readExactMatch(in)),
        m_pathLocation_(readPathLocation(context, in, allocator)),
        m_segments_(readSegments(context, in, allocator))
{
}

SmartLayerPath::SmartLayerPath(const SmartLayerPath& other) :
        m_header_(other.m_header_),
        m_numSegments_(other.m_numSegments_),
        m_exactMatch_(other.m_exactMatch_),
        m_pathLocation_(other.m_pathLocation_),
        m_segments_(other.m_segments_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

SmartLayerPath& SmartLayerPath::operator=(const SmartLayerPath& other)
{
    m_header_ = other.m_header_;
    m_numSegments_ = other.m_numSegments_;
    m_exactMatch_ = other.m_exactMatch_;
    m_pathLocation_ = other.m_pathLocation_;
    m_segments_ = other.m_segments_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

SmartLayerPath::SmartLayerPath(SmartLayerPath&& other) :
        m_header_(::std::move(other.m_header_)),
        m_numSegments_(::std::move(other.m_numSegments_)),
        m_exactMatch_(::std::move(other.m_exactMatch_)),
        m_pathLocation_(::std::move(other.m_pathLocation_)),
        m_segments_(::std::move(other.m_segments_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

SmartLayerPath& SmartLayerPath::operator=(SmartLayerPath&& other)
{
    m_header_ = ::std::move(other.m_header_);
    m_numSegments_ = ::std::move(other.m_numSegments_);
    m_exactMatch_ = ::std::move(other.m_exactMatch_);
    m_pathLocation_ = ::std::move(other.m_pathLocation_);
    m_segments_ = ::std::move(other.m_segments_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

SmartLayerPath::SmartLayerPath(::zserio::PropagateAllocatorT,
        const SmartLayerPath& other, const allocator_type& allocator) :
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_numSegments_(::zserio::allocatorPropagatingCopy(other.m_numSegments_, allocator)),
        m_exactMatch_(::zserio::allocatorPropagatingCopy(other.m_exactMatch_, allocator)),
        m_pathLocation_(::zserio::allocatorPropagatingCopy(other.m_pathLocation_, allocator)),
        m_segments_(::zserio::allocatorPropagatingCopy(other.m_segments_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void SmartLayerPath::initializeChildren()
{
    m_header_.initializeChildren();
    if (!(getExactMatch() && getNumSegments() == 1))
        m_pathLocation_.value().initialize(static_cast<uint32_t>(getNumSegments()));
    m_segments_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::nds::smart::types::SmartLayerHeader& SmartLayerPath::getHeader()
{
    return m_header_;
}

const ::nds::smart::types::SmartLayerHeader& SmartLayerPath::getHeader() const
{
    return m_header_;
}

void SmartLayerPath::setHeader(const ::nds::smart::types::SmartLayerHeader& header_)
{
    m_header_ = header_;
}

void SmartLayerPath::setHeader(::nds::smart::types::SmartLayerHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

uint32_t SmartLayerPath::getNumSegments() const
{
    return m_numSegments_;
}

void SmartLayerPath::setNumSegments(uint32_t numSegments_)
{
    m_numSegments_ = numSegments_;
}

bool SmartLayerPath::getExactMatch() const
{
    return m_exactMatch_;
}

void SmartLayerPath::setExactMatch(bool exactMatch_)
{
    m_exactMatch_ = exactMatch_;
}

::nds::smart::path::SmartLayerPathLocation& SmartLayerPath::getPathLocation()
{
    return m_pathLocation_.value();
}

const ::nds::smart::path::SmartLayerPathLocation& SmartLayerPath::getPathLocation() const
{
    return m_pathLocation_.value();
}

void SmartLayerPath::setPathLocation(const ::nds::smart::path::SmartLayerPathLocation& pathLocation_)
{
    m_pathLocation_ = pathLocation_;
}

void SmartLayerPath::setPathLocation(::nds::smart::path::SmartLayerPathLocation&& pathLocation_)
{
    m_pathLocation_ = ::std::move(pathLocation_);
}

bool SmartLayerPath::isPathLocationUsed() const
{
    return (!(getExactMatch() && getNumSegments() == 1));
}

bool SmartLayerPath::isPathLocationSet() const
{
    return m_pathLocation_.hasValue();
}

void SmartLayerPath::resetPathLocation()
{
    m_pathLocation_.reset();
}

::zserio::vector<::nds::smart::path::SmartLayerPathSegment>& SmartLayerPath::getSegments()
{
    return m_segments_.getRawArray();
}

const ::zserio::vector<::nds::smart::path::SmartLayerPathSegment>& SmartLayerPath::getSegments() const
{
    return m_segments_.getRawArray();
}

void SmartLayerPath::setSegments(const ::zserio::vector<::nds::smart::path::SmartLayerPathSegment>& segments_)
{
    m_segments_ = ZserioArrayType_segments(segments_);
}

void SmartLayerPath::setSegments(::zserio::vector<::nds::smart::path::SmartLayerPathSegment>&& segments_)
{
    m_segments_ = ZserioArrayType_segments(std::move(segments_));
}

void SmartLayerPath::initPackingContext(SmartLayerPath::ZserioPackingContext& context) const
{
    m_header_.initPackingContext(context.getHeader());
    context.getNumSegments().init<::zserio::VarSizeArrayTraits>(m_numSegments_);
    if (!(getExactMatch() && getNumSegments() == 1))
    {
        m_pathLocation_.value().initPackingContext(context.getPathLocation());
    }
}

size_t SmartLayerPath::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numSegments_);
    endBitPosition += UINT8_C(1);
    if (!(getExactMatch() && getNumSegments() == 1))
    {
        endBitPosition += m_pathLocation_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += m_segments_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerPath::bitSizeOf(SmartLayerPath::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += context.getNumSegments().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numSegments_);
    endBitPosition += UINT8_C(1);
    if (!(getExactMatch() && getNumSegments() == 1))
    {
        endBitPosition += m_pathLocation_.value().bitSizeOf(context.getPathLocation(), endBitPosition);
    }
    endBitPosition += m_segments_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerPath::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numSegments_);
    endBitPosition += UINT8_C(1);
    if (!(getExactMatch() && getNumSegments() == 1))
    {
        endBitPosition = m_pathLocation_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = m_segments_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerPath::initializeOffsets(SmartLayerPath::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition += context.getNumSegments().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numSegments_);
    endBitPosition += UINT8_C(1);
    if (!(getExactMatch() && getNumSegments() == 1))
    {
        endBitPosition = m_pathLocation_.value().initializeOffsets(context.getPathLocation(), endBitPosition);
    }
    endBitPosition = m_segments_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerPath::operator==(const SmartLayerPath& other) const
{
    if (this != &other)
    {
        return
                (m_header_ == other.m_header_) &&
                (m_numSegments_ == other.m_numSegments_) &&
                (m_exactMatch_ == other.m_exactMatch_) &&
                (!isPathLocationUsed() ? !other.isPathLocationUsed() : (m_pathLocation_ == other.m_pathLocation_)) &&
                (m_segments_ == other.m_segments_);
    }

    return true;
}

uint32_t SmartLayerPath::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_numSegments_);
    result = ::zserio::calcHashCode(result, m_exactMatch_);
    if (isPathLocationUsed())
        result = ::zserio::calcHashCode(result, m_pathLocation_);
    result = ::zserio::calcHashCode(result, m_segments_);

    return result;
}

void SmartLayerPath::write(::zserio::BitStreamWriter& out) const
{
    m_header_.write(out);

    // check constraint
    if (!(getNumSegments() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at SmartLayerPath.numSegments!");
    out.writeVarSize(m_numSegments_);

    out.writeBool(m_exactMatch_);

    if (!(getExactMatch() && getNumSegments() == 1))
    {
        // check parameters
        if (m_pathLocation_.value().getNumSegments() != static_cast<uint32_t>(getNumSegments()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numSegments for field SmartLayerPath.pathLocation: ") <<
                    m_pathLocation_.value().getNumSegments() << " != " << static_cast<uint32_t>(getNumSegments()) << "!";
        }
        m_pathLocation_.value().write(out);
    }

    // check array length
    if (m_segments_.getRawArray().size() != static_cast<size_t>(getNumSegments()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerPath.segments: ") <<
                m_segments_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSegments()) << "!";
    }
    m_segments_.write(*this, out);
}

void SmartLayerPath::write(SmartLayerPath::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_header_.write(context.getHeader(), out);

    // check constraint
    if (!(getNumSegments() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at SmartLayerPath.numSegments!");
    context.getNumSegments().write<::zserio::VarSizeArrayTraits>(out, m_numSegments_);

    out.writeBool(m_exactMatch_);

    if (!(getExactMatch() && getNumSegments() == 1))
    {
        // check parameters
        if (m_pathLocation_.value().getNumSegments() != static_cast<uint32_t>(getNumSegments()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numSegments for field SmartLayerPath.pathLocation: ") <<
                    m_pathLocation_.value().getNumSegments() << " != " << static_cast<uint32_t>(getNumSegments()) << "!";
        }
        m_pathLocation_.value().write(context.getPathLocation(), out);
    }

    // check array length
    if (m_segments_.getRawArray().size() != static_cast<size_t>(getNumSegments()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerPath.segments: ") <<
                m_segments_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSegments()) << "!";
    }
    m_segments_.writePacked(*this, out);
}

void SmartLayerPath::ZserioArrayExpressions_segments::initializeElement(SmartLayerPath& owner,
        ::nds::smart::path::SmartLayerPathSegment& element, size_t)
{
    element.initialize(owner.getHeader());
}

void SmartLayerPath::ZserioElementFactory_segments::create(SmartLayerPath&         owner,
        ::zserio::vector<::nds::smart::path::SmartLayerPathSegment>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getHeader(), array.get_allocator());
}

void SmartLayerPath::ZserioElementFactory_segments::create(SmartLayerPath&         owner,
        ::zserio::vector<::nds::smart::path::SmartLayerPathSegment>& array,
        ::nds::smart::path::SmartLayerPathSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getHeader(), array.get_allocator());
}

::nds::smart::types::SmartLayerHeader SmartLayerPath::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::types::SmartLayerHeader(in, allocator);
}

::nds::smart::types::SmartLayerHeader SmartLayerPath::readHeader(SmartLayerPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::types::SmartLayerHeader(context.getHeader(), in, allocator);
}
uint32_t SmartLayerPath::readNumSegments(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readVarSize());
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at SmartLayerPath.numSegments!");

    return readField;
}

uint32_t SmartLayerPath::readNumSegments(SmartLayerPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getNumSegments().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at SmartLayerPath.numSegments!");

    return readField;
}
bool SmartLayerPath::readExactMatch(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::smart::path::SmartLayerPathLocation> SmartLayerPath::readPathLocation(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!(getExactMatch() && getNumSegments() == 1))
    {
        return ::zserio::InplaceOptionalHolder<::nds::smart::path::SmartLayerPathLocation>(::nds::smart::path::SmartLayerPathLocation(in, static_cast<uint32_t>(getNumSegments()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::smart::path::SmartLayerPathLocation>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::smart::path::SmartLayerPathLocation> SmartLayerPath::readPathLocation(SmartLayerPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!(getExactMatch() && getNumSegments() == 1))
    {
        return ::zserio::InplaceOptionalHolder<::nds::smart::path::SmartLayerPathLocation>(::nds::smart::path::SmartLayerPathLocation(context.getPathLocation(), in, static_cast<uint32_t>(getNumSegments()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::smart::path::SmartLayerPathLocation>(::zserio::NullOpt);
}
SmartLayerPath::ZserioArrayType_segments SmartLayerPath::readSegments(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumSegments()));

    return readField;
}

SmartLayerPath::ZserioArrayType_segments SmartLayerPath::readSegments(SmartLayerPath::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumSegments()));

    return readField;
}

} // namespace path
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/path/SmartLayerPathList.h>

namespace nds
{
namespace smart
{
namespace path
{

SmartLayerPathList::SmartLayerPathList(const allocator_type& allocator) noexcept :
        m_numPaths_(uint32_t()),
        m_pathList_(allocator)
{
}

SmartLayerPathList::SmartLayerPathList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numPaths_(readNumPaths(in)),
        m_pathList_(readPathList(in, allocator))
{
}

SmartLayerPathList::SmartLayerPathList(SmartLayerPathList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numPaths_(readNumPaths(context, in)),
        m_pathList_(readPathList(context, in, allocator))
{
}

SmartLayerPathList::SmartLayerPathList(::zserio::PropagateAllocatorT,
        const SmartLayerPathList& other, const allocator_type& allocator) :
        m_numPaths_(::zserio::allocatorPropagatingCopy(other.m_numPaths_, allocator)),
        m_pathList_(::zserio::allocatorPropagatingCopy(other.m_pathList_, allocator))
{
}

void SmartLayerPathList::initializeChildren()
{
    m_pathList_.initializeElements(*this);
}

uint32_t SmartLayerPathList::getNumPaths() const
{
    return m_numPaths_;
}

void SmartLayerPathList::setNumPaths(uint32_t numPaths_)
{
    m_numPaths_ = numPaths_;
}

::zserio::vector<::nds::smart::path::SmartLayerPath>& SmartLayerPathList::getPathList()
{
    return m_pathList_.getRawArray();
}

const ::zserio::vector<::nds::smart::path::SmartLayerPath>& SmartLayerPathList::getPathList() const
{
    return m_pathList_.getRawArray();
}

void SmartLayerPathList::setPathList(const ::zserio::vector<::nds::smart::path::SmartLayerPath>& pathList_)
{
    m_pathList_ = ZserioArrayType_pathList(pathList_);
}

void SmartLayerPathList::setPathList(::zserio::vector<::nds::smart::path::SmartLayerPath>&& pathList_)
{
    m_pathList_ = ZserioArrayType_pathList(std::move(pathList_));
}

void SmartLayerPathList::initPackingContext(SmartLayerPathList::ZserioPackingContext& context) const
{
    context.getNumPaths().init<::zserio::VarSizeArrayTraits>(m_numPaths_);
}

size_t SmartLayerPathList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPaths_);
    endBitPosition += m_pathList_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerPathList::bitSizeOf(SmartLayerPathList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPaths().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPaths_);
    endBitPosition += m_pathList_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerPathList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPaths_);
    endBitPosition = m_pathList_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerPathList::initializeOffsets(SmartLayerPathList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPaths().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPaths_);
    endBitPosition = m_pathList_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerPathList::operator==(const SmartLayerPathList& other) const
{
    if (this != &other)
    {
        return
                (m_numPaths_ == other.m_numPaths_) &&
                (m_pathList_ == other.m_pathList_);
    }

    return true;
}

uint32_t SmartLayerPathList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numPaths_);
    result = ::zserio::calcHashCode(result, m_pathList_);

    return result;
}

void SmartLayerPathList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numPaths_);

    // check array length
    if (m_pathList_.getRawArray().size() != static_cast<size_t>(getNumPaths()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerPathList.pathList: ") <<
                m_pathList_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPaths()) << "!";
    }
    m_pathList_.write(*this, out);
}

void SmartLayerPathList::write(SmartLayerPathList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumPaths().write<::zserio::VarSizeArrayTraits>(out, m_numPaths_);

    // check array length
    if (m_pathList_.getRawArray().size() != static_cast<size_t>(getNumPaths()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerPathList.pathList: ") <<
                m_pathList_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPaths()) << "!";
    }
    m_pathList_.writePacked(*this, out);
}

void SmartLayerPathList::ZserioArrayExpressions_pathList::initializeElement(SmartLayerPathList&,
        ::nds::smart::path::SmartLayerPath& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerPathList::ZserioElementFactory_pathList::create(SmartLayerPathList&        ,
        ::zserio::vector<::nds::smart::path::SmartLayerPath>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerPathList::ZserioElementFactory_pathList::create(SmartLayerPathList&        ,
        ::zserio::vector<::nds::smart::path::SmartLayerPath>& array,
        ::nds::smart::path::SmartLayerPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t SmartLayerPathList::readNumPaths(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t SmartLayerPathList::readNumPaths(SmartLayerPathList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumPaths().read<::zserio::VarSizeArrayTraits>(in);
}
SmartLayerPathList::ZserioArrayType_pathList SmartLayerPathList::readPathList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_pathList readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumPaths()));

    return readField;
}

SmartLayerPathList::ZserioArrayType_pathList SmartLayerPathList::readPathList(SmartLayerPathList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_pathList readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPaths()));

    return readField;
}

} // namespace path
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/path/SmartLayerPathLocation.h>

namespace nds
{
namespace smart
{
namespace path
{

SmartLayerPathLocation::SmartLayerPathLocation(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_path_(allocator),
        m_ranges_(::zserio::NullOpt)
{
}

SmartLayerPathLocation::SmartLayerPathLocation(::zserio::BitStreamReader& in,
        uint32_t numSegments_, const allocator_type& allocator) :
        m_numSegments_(numSegments_),
        m_isInitialized(true),
        m_path_(readPath(in, allocator)),
        m_ranges_(readRanges(in, allocator))
{
}

SmartLayerPathLocation::SmartLayerPathLocation(SmartLayerPathLocation::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint32_t numSegments_, const allocator_type& allocator) :
        m_numSegments_(numSegments_),
        m_isInitialized(true),
        m_path_(readPath(context, in, allocator)),
        m_ranges_(readRanges(context, in, allocator))
{
}

SmartLayerPathLocation::SmartLayerPathLocation(const SmartLayerPathLocation& other) :
        m_path_(other.m_path_),
        m_ranges_(other.m_ranges_)
{
    if (other.m_isInitialized)
        initialize(other.m_numSegments_);
    else
        m_isInitialized = false;
}

SmartLayerPathLocation& SmartLayerPathLocation::operator=(const SmartLayerPathLocation& other)
{
    m_path_ = other.m_path_;
    m_ranges_ = other.m_ranges_;
    if (other.m_isInitialized)
        initialize(other.m_numSegments_);
    else
        m_isInitialized = false;

    return *this;
}

SmartLayerPathLocation::SmartLayerPathLocation(SmartLayerPathLocation&& other) :
        m_path_(::std::move(other.m_path_)),
        m_ranges_(::std::move(other.m_ranges_))
{
    if (other.m_isInitialized)
        initialize(other.m_numSegments_);
    else
        m_isInitialized = false;
}

SmartLayerPathLocation& SmartLayerPathLocation::operator=(SmartLayerPathLocation&& other)
{
    m_path_ = ::std::move(other.m_path_);
    m_ranges_ = ::std::move(other.m_ranges_);
    if (other.m_isInitialized)
        initialize(other.m_numSegments_);
    else
        m_isInitialized = false;

    return *this;
}

SmartLayerPathLocation::SmartLayerPathLocation(::zserio::PropagateAllocatorT,
        const SmartLayerPathLocation& other, const allocator_type& allocator) :
        m_path_(::zserio::allocatorPropagatingCopy(other.m_path_, allocator)),
        m_ranges_(::zserio::allocatorPropagatingCopy(other.m_ranges_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numSegments_);
    else
        m_isInitialized = false;
}

void SmartLayerPathLocation::initialize(
        uint32_t numSegments_)
{
    m_numSegments_ = numSegments_;
    m_isInitialized = true;

    initializeChildren();
}

bool SmartLayerPathLocation::isInitialized() const
{
    return m_isInitialized;
}

void SmartLayerPathLocation::initializeChildren()
{
    m_path_.initializeChildren();
    if (getNumSegments() > 1)
        m_ranges_.value().initializeElements(*this);
}

uint32_t SmartLayerPathLocation::getNumSegments() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numSegments' of compound 'SmartLayerPathLocation' is not initialized!");

    return m_numSegments_;
}

::nds::core::location::LocationGeometry& SmartLayerPathLocation::getPath()
{
    return m_path_;
}

const ::nds::core::location::LocationGeometry& SmartLayerPathLocation::getPath() const
{
    return m_path_;
}

void SmartLayerPathLocation::setPath(const ::nds::core::location::LocationGeometry& path_)
{
    m_path_ = path_;
}

void SmartLayerPathLocation::setPath(::nds::core::location::LocationGeometry&& path_)
{
    m_path_ = ::std::move(path_);
}

::zserio::vector<::nds::core::location::LocationPathRange>& SmartLayerPathLocation::getRanges()
{
    return m_ranges_.value().getRawArray();
}

const ::zserio::vector<::nds::core::location::LocationPathRange>& SmartLayerPathLocation::getRanges() const
{
    return m_ranges_.value().getRawArray();
}

void SmartLayerPathLocation::setRanges(const ::zserio::vector<::nds::core::location::LocationPathRange>& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(ranges_);
}

void SmartLayerPathLocation::setRanges(::zserio::vector<::nds::core::location::LocationPathRange>&& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(std::move(ranges_));
}

bool SmartLayerPathLocation::isRangesUsed() const
{
    return (getNumSegments() > 1);
}

bool SmartLayerPathLocation::isRangesSet() const
{
    return m_ranges_.hasValue();
}

void SmartLayerPathLocation::resetRanges()
{
    m_ranges_.reset();
}

void SmartLayerPathLocation::initPackingContext(SmartLayerPathLocation::ZserioPackingContext& context) const
{
    m_path_.initPackingContext(context.getPath());
}

size_t SmartLayerPathLocation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_path_.bitSizeOf(endBitPosition);
    if (getNumSegments() > 1)
    {
        endBitPosition += m_ranges_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerPathLocation::bitSizeOf(SmartLayerPathLocation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_path_.bitSizeOf(context.getPath(), endBitPosition);
    if (getNumSegments() > 1)
    {
        endBitPosition += m_ranges_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerPathLocation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_path_.initializeOffsets(endBitPosition);
    if (getNumSegments() > 1)
    {
        endBitPosition = m_ranges_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t SmartLayerPathLocation::initializeOffsets(SmartLayerPathLocation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_path_.initializeOffsets(context.getPath(), endBitPosition);
    if (getNumSegments() > 1)
    {
        endBitPosition = m_ranges_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool SmartLayerPathLocation::operator==(const SmartLayerPathLocation& other) const
{
    if (this != &other)
    {
        return
                (getNumSegments() == other.getNumSegments()) &&
                (m_path_ == other.m_path_) &&
                (!isRangesUsed() ? !other.isRangesUsed() : (m_ranges_ == other.m_ranges_));
    }

    return true;
}

uint32_t SmartLayerPathLocation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumSegments());
    result = ::zserio::calcHashCode(result, m_path_);
    if (isRangesUsed())
        result = ::zserio::calcHashCode(result, m_ranges_);

    return result;
}

void SmartLayerPathLocation::write(::zserio::BitStreamWriter& out) const
{
    m_path_.write(out);

    if (getNumSegments() > 1)
    {
        // check array length
        if (m_ranges_.value().getRawArray().size() != static_cast<size_t>(getNumSegments()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerPathLocation.ranges: ") <<
                    m_ranges_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumSegments()) << "!";
        }
        m_ranges_.value().write(*this, out);
    }
}

void SmartLayerPathLocation::write(SmartLayerPathLocation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_path_.write(context.getPath(), out);

    if (getNumSegments() > 1)
    {
        // check array length
        if (m_ranges_.value().getRawArray().size() != static_cast<size_t>(getNumSegments()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerPathLocation.ranges: ") <<
                    m_ranges_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumSegments()) << "!";
        }
        m_ranges_.value().writePacked(*this, out);
    }
}

void SmartLayerPathLocation::ZserioArrayExpressions_ranges::initializeElement(SmartLayerPathLocation& owner,
        ::nds::core::location::LocationPathRange& element, size_t)
{
    element.initialize(owner.getPath().getLine());
}

void SmartLayerPathLocation::ZserioElementFactory_ranges::create(SmartLayerPathLocation&         owner,
        ::zserio::vector<::nds::core::location::LocationPathRange>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getPath().getLine(), array.get_allocator());
}

void SmartLayerPathLocation::ZserioElementFactory_ranges::create(SmartLayerPathLocation&         owner,
        ::zserio::vector<::nds::core::location::LocationPathRange>& array,
        ::nds::core::location::LocationPathRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getPath().getLine(), array.get_allocator());
}

::nds::core::location::LocationGeometry SmartLayerPathLocation::readPath(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::LocationGeometry(in, allocator);
}

::nds::core::location::LocationGeometry SmartLayerPathLocation::readPath(SmartLayerPathLocation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::LocationGeometry(context.getPath(), in, allocator);
}
::zserio::InplaceOptionalHolder<SmartLayerPathLocation::ZserioArrayType_ranges> SmartLayerPathLocation::readRanges(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getNumSegments() > 1)
    {
        ZserioArrayType_ranges readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumSegments()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<SmartLayerPathLocation::ZserioArrayType_ranges> SmartLayerPathLocation::readRanges(SmartLayerPathLocation::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getNumSegments() > 1)
    {
        ZserioArrayType_ranges readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumSegments()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::zserio::NullOpt);
}

} // namespace path
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/path/SmartLayerPathSegment.h>

namespace nds
{
namespace smart
{
namespace path
{

SmartLayerPathSegment::SmartLayerPathSegment(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_tileId_(::nds::core::types::PackedTileId()),
        m_completeTileContent_(bool()),
        m_layers_(allocator)
{
}

SmartLayerPathSegment::SmartLayerPathSegment(::zserio::BitStreamReader& in,
        ::nds::smart::types::SmartLayerHeader& header_, const allocator_type& allocator) :
        m_header_(&header_),
        m_isInitialized(true),
        m_tileId_(readTileId(in)),
        m_completeTileContent_(readCompleteTileContent(in)),
        m_layers_(readLayers(in, allocator))
{
}

SmartLayerPathSegment::SmartLayerPathSegment(SmartLayerPathSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::smart::types::SmartLayerHeader& header_, const allocator_type& allocator) :
        m_header_(&header_),
        m_isInitialized(true),
        m_tileId_(readTileId(context, in)),
        m_completeTileContent_(readCompleteTileContent(in)),
        m_layers_(readLayers(in, allocator))
{
}

SmartLayerPathSegment::SmartLayerPathSegment(const SmartLayerPathSegment& other) :
        m_tileId_(other.m_tileId_),
        m_completeTileContent_(other.m_completeTileContent_),
        m_layers_(other.m_layers_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

SmartLayerPathSegment& SmartLayerPathSegment::operator=(const SmartLayerPathSegment& other)
{
    m_tileId_ = other.m_tileId_;
    m_completeTileContent_ = other.m_completeTileContent_;
    m_layers_ = other.m_layers_;
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

SmartLayerPathSegment::SmartLayerPathSegment(SmartLayerPathSegment&& other) :
        m_tileId_(::std::move(other.m_tileId_)),
        m_completeTileContent_(::std::move(other.m_completeTileContent_)),
        m_layers_(::std::move(other.m_layers_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

SmartLayerPathSegment& SmartLayerPathSegment::operator=(SmartLayerPathSegment&& other)
{
    m_tileId_ = ::std::move(other.m_tileId_);
    m_completeTileContent_ = ::std::move(other.m_completeTileContent_);
    m_layers_ = ::std::move(other.m_layers_);
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

SmartLayerPathSegment::SmartLayerPathSegment(::zserio::PropagateAllocatorT,
        const SmartLayerPathSegment& other, const allocator_type& allocator) :
        m_tileId_(::zserio::allocatorPropagatingCopy(other.m_tileId_, allocator)),
        m_completeTileContent_(::zserio::allocatorPropagatingCopy(other.m_completeTileContent_, allocator)),
        m_layers_(::zserio::allocatorPropagatingCopy(other.m_layers_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

void SmartLayerPathSegment::initialize(
        ::nds::smart::types::SmartLayerHeader& header_)
{
    m_header_ = &header_;
    m_isInitialized = true;
}

bool SmartLayerPathSegment::isInitialized() const
{
    return m_isInitialized;
}

::nds::smart::types::SmartLayerHeader& SmartLayerPathSegment::getHeader()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'SmartLayerPathSegment' is not initialized!");

    return *m_header_;
}

const ::nds::smart::types::SmartLayerHeader& SmartLayerPathSegment::getHeader() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'SmartLayerPathSegment' is not initialized!");

    return *m_header_;
}

::nds::core::types::PackedTileId SmartLayerPathSegment::getTileId() const
{
    return m_tileId_;
}

void SmartLayerPathSegment::setTileId(::nds::core::types::PackedTileId tileId_)
{
    m_tileId_ = tileId_;
}

bool SmartLayerPathSegment::getCompleteTileContent() const
{
    return m_completeTileContent_;
}

void SmartLayerPathSegment::setCompleteTileContent(bool completeTileContent_)
{
    m_completeTileContent_ = completeTileContent_;
}

::zserio::vector<::nds::smart::types::DataLayer>& SmartLayerPathSegment::getLayers()
{
    return m_layers_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayer>& SmartLayerPathSegment::getLayers() const
{
    return m_layers_.getRawArray();
}

void SmartLayerPathSegment::setLayers(const ::zserio::vector<::nds::smart::types::DataLayer>& layers_)
{
    m_layers_ = ZserioArrayType_layers(layers_);
}

void SmartLayerPathSegment::setLayers(::zserio::vector<::nds::smart::types::DataLayer>&& layers_)
{
    m_layers_ = ZserioArrayType_layers(std::move(layers_));
}

void SmartLayerPathSegment::initPackingContext(SmartLayerPathSegment::ZserioPackingContext& context) const
{
    context.getTileId().init<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_tileId_);
}

size_t SmartLayerPathSegment::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerPathSegment::bitSizeOf(SmartLayerPathSegment::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTileId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_tileId_);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerPathSegment::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerPathSegment::initializeOffsets(SmartLayerPathSegment::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTileId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_tileId_);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerPathSegment::operator==(const SmartLayerPathSegment& other) const
{
    if (this != &other)
    {
        return
                (getHeader() == other.getHeader()) &&
                (m_tileId_ == other.m_tileId_) &&
                (m_completeTileContent_ == other.m_completeTileContent_) &&
                (m_layers_ == other.m_layers_);
    }

    return true;
}

uint32_t SmartLayerPathSegment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHeader());
    result = ::zserio::calcHashCode(result, m_tileId_);
    result = ::zserio::calcHashCode(result, m_completeTileContent_);
    result = ::zserio::calcHashCode(result, m_layers_);

    return result;
}

void SmartLayerPathSegment::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_tileId_, UINT8_C(32));

    out.writeBool(m_completeTileContent_);

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getHeader().getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerPathSegment.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getHeader().getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void SmartLayerPathSegment::write(SmartLayerPathSegment::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getTileId().write<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(out, m_tileId_);

    out.writeBool(m_completeTileContent_);

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getHeader().getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerPathSegment.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getHeader().getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void SmartLayerPathSegment::ZserioElementFactory_layers::create(SmartLayerPathSegment&        ,
        ::zserio::vector<::nds::smart::types::DataLayer>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

::nds::core::types::PackedTileId SmartLayerPathSegment::readTileId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::PackedTileId>(in.readSignedBits(UINT8_C(32)));
}

::nds::core::types::PackedTileId SmartLayerPathSegment::readTileId(SmartLayerPathSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTileId().read<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(in);
}
bool SmartLayerPathSegment::readCompleteTileContent(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
SmartLayerPathSegment::ZserioArrayType_layers SmartLayerPathSegment::readLayers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_layers readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getHeader().getNumDataLayers()));

    return readField;
}

} // namespace path
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/path/SmartLayerLocationIdPath.h>

namespace nds
{
namespace smart
{
namespace path
{

SmartLayerLocationIdPath::SmartLayerLocationIdPath(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_header_(allocator),
        m_locationId_(allocator),
        m_segments_(allocator)
{
}

SmartLayerLocationIdPath::SmartLayerLocationIdPath(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_header_(readHeader(in, allocator)),
        m_locationId_(readLocationId(in, allocator)),
        m_segments_(readSegments(in, allocator))
{
}

SmartLayerLocationIdPath::SmartLayerLocationIdPath(SmartLayerLocationIdPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_header_(readHeader(context, in, allocator)),
        m_locationId_(readLocationId(context, in, allocator)),
        m_segments_(readSegments(context, in, allocator))
{
}

SmartLayerLocationIdPath::SmartLayerLocationIdPath(const SmartLayerLocationIdPath& other) :
        m_header_(other.m_header_),
        m_locationId_(other.m_locationId_),
        m_segments_(other.m_segments_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

SmartLayerLocationIdPath& SmartLayerLocationIdPath::operator=(const SmartLayerLocationIdPath& other)
{
    m_header_ = other.m_header_;
    m_locationId_ = other.m_locationId_;
    m_segments_ = other.m_segments_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

SmartLayerLocationIdPath::SmartLayerLocationIdPath(SmartLayerLocationIdPath&& other) :
        m_header_(::std::move(other.m_header_)),
        m_locationId_(::std::move(other.m_locationId_)),
        m_segments_(::std::move(other.m_segments_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

SmartLayerLocationIdPath& SmartLayerLocationIdPath::operator=(SmartLayerLocationIdPath&& other)
{
    m_header_ = ::std::move(other.m_header_);
    m_locationId_ = ::std::move(other.m_locationId_);
    m_segments_ = ::std::move(other.m_segments_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

SmartLayerLocationIdPath::SmartLayerLocationIdPath(::zserio::PropagateAllocatorT,
        const SmartLayerLocationIdPath& other, const allocator_type& allocator) :
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_locationId_(::zserio::allocatorPropagatingCopy(other.m_locationId_, allocator)),
        m_segments_(::zserio::allocatorPropagatingCopy(other.m_segments_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void SmartLayerLocationIdPath::initializeChildren()
{
    m_header_.initializeChildren();
    m_segments_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::nds::smart::types::SmartLayerHeader& SmartLayerLocationIdPath::getHeader()
{
    return m_header_;
}

const ::nds::smart::types::SmartLayerHeader& SmartLayerLocationIdPath::getHeader() const
{
    return m_header_;
}

void SmartLayerLocationIdPath::setHeader(const ::nds::smart::types::SmartLayerHeader& header_)
{
    m_header_ = header_;
}

void SmartLayerLocationIdPath::setHeader(::nds::smart::types::SmartLayerHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::nds::core::location::RoadLocationId& SmartLayerLocationIdPath::getLocationId()
{
    return m_locationId_;
}

const ::nds::core::location::RoadLocationId& SmartLayerLocationIdPath::getLocationId() const
{
    return m_locationId_;
}

void SmartLayerLocationIdPath::setLocationId(const ::nds::core::location::RoadLocationId& locationId_)
{
    m_locationId_ = locationId_;
}

void SmartLayerLocationIdPath::setLocationId(::nds::core::location::RoadLocationId&& locationId_)
{
    m_locationId_ = ::std::move(locationId_);
}

::zserio::vector<::nds::smart::path::SmartLayerLocationIdPathSegment>& SmartLayerLocationIdPath::getSegments()
{
    return m_segments_.getRawArray();
}

const ::zserio::vector<::nds::smart::path::SmartLayerLocationIdPathSegment>& SmartLayerLocationIdPath::getSegments() const
{
    return m_segments_.getRawArray();
}

void SmartLayerLocationIdPath::setSegments(const ::zserio::vector<::nds::smart::path::SmartLayerLocationIdPathSegment>& segments_)
{
    m_segments_ = ZserioArrayType_segments(segments_);
}

void SmartLayerLocationIdPath::setSegments(::zserio::vector<::nds::smart::path::SmartLayerLocationIdPathSegment>&& segments_)
{
    m_segments_ = ZserioArrayType_segments(std::move(segments_));
}

void SmartLayerLocationIdPath::initPackingContext(SmartLayerLocationIdPath::ZserioPackingContext& context) const
{
    m_header_.initPackingContext(context.getHeader());
    m_locationId_.initPackingContext(context.getLocationId());
}

size_t SmartLayerLocationIdPath::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_locationId_.bitSizeOf(endBitPosition);
    endBitPosition += m_segments_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerLocationIdPath::bitSizeOf(SmartLayerLocationIdPath::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_locationId_.bitSizeOf(context.getLocationId(), endBitPosition);
    endBitPosition += m_segments_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerLocationIdPath::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_locationId_.initializeOffsets(endBitPosition);
    endBitPosition = m_segments_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerLocationIdPath::initializeOffsets(SmartLayerLocationIdPath::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_locationId_.initializeOffsets(context.getLocationId(), endBitPosition);
    endBitPosition = m_segments_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerLocationIdPath::operator==(const SmartLayerLocationIdPath& other) const
{
    if (this != &other)
    {
        return
                (m_header_ == other.m_header_) &&
                (m_locationId_ == other.m_locationId_) &&
                (m_segments_ == other.m_segments_);
    }

    return true;
}

uint32_t SmartLayerLocationIdPath::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_locationId_);
    result = ::zserio::calcHashCode(result, m_segments_);

    return result;
}

void SmartLayerLocationIdPath::write(::zserio::BitStreamWriter& out) const
{
    m_header_.write(out);
    m_locationId_.write(out);
    m_segments_.write(*this, out);
}

void SmartLayerLocationIdPath::write(SmartLayerLocationIdPath::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_header_.write(context.getHeader(), out);
    m_locationId_.write(context.getLocationId(), out);
    m_segments_.writePacked(*this, out);
}

void SmartLayerLocationIdPath::ZserioArrayExpressions_segments::initializeElement(SmartLayerLocationIdPath& owner,
        ::nds::smart::path::SmartLayerLocationIdPathSegment& element, size_t)
{
    element.initialize(owner.getHeader());
}

void SmartLayerLocationIdPath::ZserioElementFactory_segments::create(SmartLayerLocationIdPath&         owner,
        ::zserio::vector<::nds::smart::path::SmartLayerLocationIdPathSegment>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getHeader(), array.get_allocator());
}

void SmartLayerLocationIdPath::ZserioElementFactory_segments::create(SmartLayerLocationIdPath&         owner,
        ::zserio::vector<::nds::smart::path::SmartLayerLocationIdPathSegment>& array,
        ::nds::smart::path::SmartLayerLocationIdPathSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getHeader(), array.get_allocator());
}

::nds::smart::types::SmartLayerHeader SmartLayerLocationIdPath::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::types::SmartLayerHeader(in, allocator);
}

::nds::smart::types::SmartLayerHeader SmartLayerLocationIdPath::readHeader(SmartLayerLocationIdPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::types::SmartLayerHeader(context.getHeader(), in, allocator);
}
::nds::core::location::RoadLocationId SmartLayerLocationIdPath::readLocationId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(in, allocator);
}

::nds::core::location::RoadLocationId SmartLayerLocationIdPath::readLocationId(SmartLayerLocationIdPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationId(context.getLocationId(), in, allocator);
}
SmartLayerLocationIdPath::ZserioArrayType_segments SmartLayerLocationIdPath::readSegments(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.read(*this, in);

    return readField;
}

SmartLayerLocationIdPath::ZserioArrayType_segments SmartLayerLocationIdPath::readSegments(SmartLayerLocationIdPath::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace path
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/path/SmartLayerLocationIdPathSegment.h>

namespace nds
{
namespace smart
{
namespace path
{

SmartLayerLocationIdPathSegment::SmartLayerLocationIdPathSegment(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_range_(allocator),
        m_tileId_(::nds::core::types::PackedTileId()),
        m_layers_(allocator)
{
}

SmartLayerLocationIdPathSegment::SmartLayerLocationIdPathSegment(::zserio::BitStreamReader& in,
        ::nds::smart::types::SmartLayerHeader& header_, const allocator_type& allocator) :
        m_header_(&header_),
        m_isInitialized(true),
        m_range_(readRange(in, allocator)),
        m_tileId_(readTileId(in)),
        m_layers_(readLayers(in, allocator))
{
}

SmartLayerLocationIdPathSegment::SmartLayerLocationIdPathSegment(SmartLayerLocationIdPathSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::smart::types::SmartLayerHeader& header_, const allocator_type& allocator) :
        m_header_(&header_),
        m_isInitialized(true),
        m_range_(readRange(context, in, allocator)),
        m_tileId_(readTileId(context, in)),
        m_layers_(readLayers(in, allocator))
{
}

SmartLayerLocationIdPathSegment::SmartLayerLocationIdPathSegment(const SmartLayerLocationIdPathSegment& other) :
        m_range_(other.m_range_),
        m_tileId_(other.m_tileId_),
        m_layers_(other.m_layers_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

SmartLayerLocationIdPathSegment& SmartLayerLocationIdPathSegment::operator=(const SmartLayerLocationIdPathSegment& other)
{
    m_range_ = other.m_range_;
    m_tileId_ = other.m_tileId_;
    m_layers_ = other.m_layers_;
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

SmartLayerLocationIdPathSegment::SmartLayerLocationIdPathSegment(SmartLayerLocationIdPathSegment&& other) :
        m_range_(::std::move(other.m_range_)),
        m_tileId_(::std::move(other.m_tileId_)),
        m_layers_(::std::move(other.m_layers_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

SmartLayerLocationIdPathSegment& SmartLayerLocationIdPathSegment::operator=(SmartLayerLocationIdPathSegment&& other)
{
    m_range_ = ::std::move(other.m_range_);
    m_tileId_ = ::std::move(other.m_tileId_);
    m_layers_ = ::std::move(other.m_layers_);
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

SmartLayerLocationIdPathSegment::SmartLayerLocationIdPathSegment(::zserio::PropagateAllocatorT,
        const SmartLayerLocationIdPathSegment& other, const allocator_type& allocator) :
        m_range_(::zserio::allocatorPropagatingCopy(other.m_range_, allocator)),
        m_tileId_(::zserio::allocatorPropagatingCopy(other.m_tileId_, allocator)),
        m_layers_(::zserio::allocatorPropagatingCopy(other.m_layers_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

void SmartLayerLocationIdPathSegment::initialize(
        ::nds::smart::types::SmartLayerHeader& header_)
{
    m_header_ = &header_;
    m_isInitialized = true;
}

bool SmartLayerLocationIdPathSegment::isInitialized() const
{
    return m_isInitialized;
}

::nds::smart::types::SmartLayerHeader& SmartLayerLocationIdPathSegment::getHeader()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'SmartLayerLocationIdPathSegment' is not initialized!");

    return *m_header_;
}

const ::nds::smart::types::SmartLayerHeader& SmartLayerLocationIdPathSegment::getHeader() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'SmartLayerLocationIdPathSegment' is not initialized!");

    return *m_header_;
}

::nds::core::location::RoadLocationIdRange& SmartLayerLocationIdPathSegment::getRange()
{
    return m_range_;
}

const ::nds::core::location::RoadLocationIdRange& SmartLayerLocationIdPathSegment::getRange() const
{
    return m_range_;
}

void SmartLayerLocationIdPathSegment::setRange(const ::nds::core::location::RoadLocationIdRange& range_)
{
    m_range_ = range_;
}

void SmartLayerLocationIdPathSegment::setRange(::nds::core::location::RoadLocationIdRange&& range_)
{
    m_range_ = ::std::move(range_);
}

::nds::core::types::PackedTileId SmartLayerLocationIdPathSegment::getTileId() const
{
    return m_tileId_;
}

void SmartLayerLocationIdPathSegment::setTileId(::nds::core::types::PackedTileId tileId_)
{
    m_tileId_ = tileId_;
}

::zserio::vector<::nds::smart::types::DataLayer>& SmartLayerLocationIdPathSegment::getLayers()
{
    return m_layers_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayer>& SmartLayerLocationIdPathSegment::getLayers() const
{
    return m_layers_.getRawArray();
}

void SmartLayerLocationIdPathSegment::setLayers(const ::zserio::vector<::nds::smart::types::DataLayer>& layers_)
{
    m_layers_ = ZserioArrayType_layers(layers_);
}

void SmartLayerLocationIdPathSegment::setLayers(::zserio::vector<::nds::smart::types::DataLayer>&& layers_)
{
    m_layers_ = ZserioArrayType_layers(std::move(layers_));
}

void SmartLayerLocationIdPathSegment::initPackingContext(SmartLayerLocationIdPathSegment::ZserioPackingContext& context) const
{
    m_range_.initPackingContext(context.getRange());
    context.getTileId().init<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_tileId_);
}

size_t SmartLayerLocationIdPathSegment::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_range_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(32);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerLocationIdPathSegment::bitSizeOf(SmartLayerLocationIdPathSegment::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_range_.bitSizeOf(context.getRange(), endBitPosition);
    endBitPosition += context.getTileId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_tileId_);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerLocationIdPathSegment::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_range_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(32);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerLocationIdPathSegment::initializeOffsets(SmartLayerLocationIdPathSegment::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_range_.initializeOffsets(context.getRange(), endBitPosition);
    endBitPosition += context.getTileId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_tileId_);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerLocationIdPathSegment::operator==(const SmartLayerLocationIdPathSegment& other) const
{
    if (this != &other)
    {
        return
                (getHeader() == other.getHeader()) &&
                (m_range_ == other.m_range_) &&
                (m_tileId_ == other.m_tileId_) &&
                (m_layers_ == other.m_layers_);
    }

    return true;
}

uint32_t SmartLayerLocationIdPathSegment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHeader());
    result = ::zserio::calcHashCode(result, m_range_);
    result = ::zserio::calcHashCode(result, m_tileId_);
    result = ::zserio::calcHashCode(result, m_layers_);

    return result;
}

void SmartLayerLocationIdPathSegment::write(::zserio::BitStreamWriter& out) const
{
    m_range_.write(out);

    out.writeSignedBits(m_tileId_, UINT8_C(32));

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getHeader().getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerLocationIdPathSegment.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getHeader().getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void SmartLayerLocationIdPathSegment::write(SmartLayerLocationIdPathSegment::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_range_.write(context.getRange(), out);

    context.getTileId().write<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(out, m_tileId_);

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getHeader().getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerLocationIdPathSegment.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getHeader().getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void SmartLayerLocationIdPathSegment::ZserioElementFactory_layers::create(SmartLayerLocationIdPathSegment&        ,
        ::zserio::vector<::nds::smart::types::DataLayer>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

::nds::core::location::RoadLocationIdRange SmartLayerLocationIdPathSegment::readRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationIdRange(in, allocator);
}

::nds::core::location::RoadLocationIdRange SmartLayerLocationIdPathSegment::readRange(SmartLayerLocationIdPathSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationIdRange(context.getRange(), in, allocator);
}
::nds::core::types::PackedTileId SmartLayerLocationIdPathSegment::readTileId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::PackedTileId>(in.readSignedBits(UINT8_C(32)));
}

::nds::core::types::PackedTileId SmartLayerLocationIdPathSegment::readTileId(SmartLayerLocationIdPathSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTileId().read<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(in);
}
SmartLayerLocationIdPathSegment::ZserioArrayType_layers SmartLayerLocationIdPathSegment::readLayers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_layers readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getHeader().getNumDataLayers()));

    return readField;
}

} // namespace path
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/path/SmartLayerPosePathRequest.h>

namespace nds
{
namespace smart
{
namespace path
{

SmartLayerPosePathRequest::SmartLayerPosePathRequest(const allocator_type& allocator) noexcept :
        m_poses_(allocator)
{
}

SmartLayerPosePathRequest::SmartLayerPosePathRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_poses_(readPoses(in, allocator))
{
}

SmartLayerPosePathRequest::SmartLayerPosePathRequest(SmartLayerPosePathRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_poses_(readPoses(context, in, allocator))
{
}

SmartLayerPosePathRequest::SmartLayerPosePathRequest(::zserio::PropagateAllocatorT,
        const SmartLayerPosePathRequest& other, const allocator_type& allocator) :
        m_poses_(::zserio::allocatorPropagatingCopy(other.m_poses_, allocator))
{
}

::zserio::vector<::nds::core::vehicle::TimedRawPose>& SmartLayerPosePathRequest::getPoses()
{
    return m_poses_.getRawArray();
}

const ::zserio::vector<::nds::core::vehicle::TimedRawPose>& SmartLayerPosePathRequest::getPoses() const
{
    return m_poses_.getRawArray();
}

void SmartLayerPosePathRequest::setPoses(const ::zserio::vector<::nds::core::vehicle::TimedRawPose>& poses_)
{
    m_poses_ = ZserioArrayType_poses(poses_);
}

void SmartLayerPosePathRequest::setPoses(::zserio::vector<::nds::core::vehicle::TimedRawPose>&& poses_)
{
    m_poses_ = ZserioArrayType_poses(std::move(poses_));
}

void SmartLayerPosePathRequest::initPackingContext(SmartLayerPosePathRequest::ZserioPackingContext&) const
{
}

size_t SmartLayerPosePathRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_poses_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerPosePathRequest::bitSizeOf(SmartLayerPosePathRequest::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_poses_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerPosePathRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_poses_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerPosePathRequest::initializeOffsets(SmartLayerPosePathRequest::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_poses_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerPosePathRequest::operator==(const SmartLayerPosePathRequest& other) const
{
    if (this != &other)
    {
        return
                (m_poses_ == other.m_poses_);
    }

    return true;
}

uint32_t SmartLayerPosePathRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_poses_);

    return result;
}

void SmartLayerPosePathRequest::write(::zserio::BitStreamWriter& out) const
{
    m_poses_.write(*this, out);
}

void SmartLayerPosePathRequest::write(SmartLayerPosePathRequest::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_poses_.writePacked(*this, out);
}

void SmartLayerPosePathRequest::ZserioElementFactory_poses::create(SmartLayerPosePathRequest&        ,
        ::zserio::vector<::nds::core::vehicle::TimedRawPose>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerPosePathRequest::ZserioElementFactory_poses::create(SmartLayerPosePathRequest&        ,
        ::zserio::vector<::nds::core::vehicle::TimedRawPose>& array,
        ::nds::core::vehicle::TimedRawPose::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

SmartLayerPosePathRequest::ZserioArrayType_poses SmartLayerPosePathRequest::readPoses(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_poses readField(allocator);
    readField.read(*this, in);

    return readField;
}

SmartLayerPosePathRequest::ZserioArrayType_poses SmartLayerPosePathRequest::readPoses(SmartLayerPosePathRequest::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_poses readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace path
} // namespace smart
} // namespace nds
