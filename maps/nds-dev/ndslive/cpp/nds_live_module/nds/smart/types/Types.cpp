/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/smart/types/DataLayerLifetimeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DataLayerLifetimeType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::smart::types::DataLayerLifetimeType>::names;
constexpr ::std::array<::nds::smart::types::DataLayerLifetimeType, 3> EnumTraits<::nds::smart::types::DataLayerLifetimeType>::values;
constexpr const char* EnumTraits<::nds::smart::types::DataLayerLifetimeType>::enumName;

template <>
size_t enumToOrdinal(::nds::smart::types::DataLayerLifetimeType value)
{
    switch (value)
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        return 0;
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        return 1;
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DataLayerLifetimeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::smart::types::DataLayerLifetimeType>::type>(value) << "!";
    }
}

template <>
::nds::smart::types::DataLayerLifetimeType valueToEnum(
        typename ::std::underlying_type<::nds::smart::types::DataLayerLifetimeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::smart::types::DataLayerLifetimeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DataLayerLifetimeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::smart::types::DataLayerLifetimeType>(::nds::smart::types::DataLayerLifetimeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::smart::types::DataLayerLifetimeType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::smart::types::DataLayerLifetimeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::smart::types::DataLayerLifetimeType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::smart::types::DataLayerLifetimeType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::smart::types::DataLayerLifetimeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::smart::types::DataLayerLifetimeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::smart::types::DataLayerLifetimeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::smart::types::DataLayerLifetimeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::smart::types::DataLayerLifetimeType>(
            static_cast<typename ::std::underlying_type<::nds::smart::types::DataLayerLifetimeType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::smart::types::DataLayerLifetimeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::smart::types::DataLayerLifetimeType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::smart::types::DataLayerLifetimeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::smart::types::DataLayerLifetimeType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::smart::types::DataLayerLifetimeType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::smart::types::DataLayerLifetimeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/smart/types/SmartLayerType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for SmartLayerType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::smart::types::SmartLayerType>::names;
constexpr ::std::array<::nds::smart::types::SmartLayerType, 5> EnumTraits<::nds::smart::types::SmartLayerType>::values;
constexpr const char* EnumTraits<::nds::smart::types::SmartLayerType>::enumName;

template <>
size_t enumToOrdinal(::nds::smart::types::SmartLayerType value)
{
    switch (value)
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        return 0;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        return 1;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        return 2;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        return 3;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration SmartLayerType: ") <<
                static_cast<typename ::std::underlying_type<::nds::smart::types::SmartLayerType>::type>(value) << "!";
    }
}

template <>
::nds::smart::types::SmartLayerType valueToEnum(
        typename ::std::underlying_type<::nds::smart::types::SmartLayerType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::smart::types::SmartLayerType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration SmartLayerType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::smart::types::SmartLayerType>(::nds::smart::types::SmartLayerType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::smart::types::SmartLayerType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::smart::types::SmartLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::smart::types::SmartLayerType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::smart::types::SmartLayerType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::smart::types::SmartLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::smart::types::SmartLayerType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::smart::types::SmartLayerType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::smart::types::SmartLayerType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::smart::types::SmartLayerType>(
            static_cast<typename ::std::underlying_type<::nds::smart::types::SmartLayerType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::smart::types::SmartLayerType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::smart::types::SmartLayerType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::smart::types::SmartLayerType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::smart::types::SmartLayerType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::smart::types::SmartLayerType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::smart::types::SmartLayerType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/types/DataLayer.h>

namespace nds
{
namespace smart
{
namespace types
{

DataLayer::DataLayer(const allocator_type& allocator) noexcept :
        m_hasSignature_(bool()),
        m_signature_(::zserio::NullOpt),
        m_layer_(allocator)
{
}

DataLayer::DataLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_hasSignature_(readHasSignature(in)),
        m_signature_(readSignature(in, allocator)),
        m_layer_(readLayer(in, allocator))
{
}

DataLayer::DataLayer(::zserio::PropagateAllocatorT,
        const DataLayer& other, const allocator_type& allocator) :
        m_hasSignature_(::zserio::allocatorPropagatingCopy(other.m_hasSignature_, allocator)),
        m_signature_(::zserio::allocatorPropagatingCopy(other.m_signature_, allocator)),
        m_layer_(::zserio::allocatorPropagatingCopy(other.m_layer_, allocator))
{
}

bool DataLayer::getHasSignature() const
{
    return m_hasSignature_;
}

void DataLayer::setHasSignature(bool hasSignature_)
{
    m_hasSignature_ = hasSignature_;
}

::zserio::BitBuffer& DataLayer::getSignature()
{
    return m_signature_.value();
}

const ::zserio::BitBuffer& DataLayer::getSignature() const
{
    return m_signature_.value();
}

void DataLayer::setSignature(const ::zserio::BitBuffer& signature_)
{
    m_signature_ = signature_;
}

void DataLayer::setSignature(::zserio::BitBuffer&& signature_)
{
    m_signature_ = ::std::move(signature_);
}

bool DataLayer::isSignatureUsed() const
{
    return (getHasSignature());
}

bool DataLayer::isSignatureSet() const
{
    return m_signature_.hasValue();
}

void DataLayer::resetSignature()
{
    m_signature_.reset();
}

::nds::system::types::ExternData& DataLayer::getLayer()
{
    return m_layer_;
}

const ::nds::system::types::ExternData& DataLayer::getLayer() const
{
    return m_layer_;
}

void DataLayer::setLayer(const ::nds::system::types::ExternData& layer_)
{
    m_layer_ = layer_;
}

void DataLayer::setLayer(::nds::system::types::ExternData&& layer_)
{
    m_layer_ = ::std::move(layer_);
}

size_t DataLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasSignature())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_signature_.value());
    }
    endBitPosition += m_layer_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DataLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasSignature())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_signature_.value());
    }
    endBitPosition = m_layer_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

bool DataLayer::operator==(const DataLayer& other) const
{
    if (this != &other)
    {
        return
                (m_hasSignature_ == other.m_hasSignature_) &&
                (!isSignatureUsed() ? !other.isSignatureUsed() : (m_signature_ == other.m_signature_)) &&
                (m_layer_ == other.m_layer_);
    }

    return true;
}

uint32_t DataLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_hasSignature_);
    if (isSignatureUsed())
        result = ::zserio::calcHashCode(result, m_signature_);
    result = ::zserio::calcHashCode(result, m_layer_);

    return result;
}

void DataLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasSignature_);
    if (getHasSignature())
    {
        out.alignTo(8);
        out.writeBitBuffer(m_signature_.value());
    }
    m_layer_.write(out);
}

bool DataLayer::readHasSignature(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::zserio::BitBuffer> DataLayer::readSignature(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasSignature())
    {
        in.alignTo(8);
        return ::zserio::InplaceOptionalHolder<::zserio::BitBuffer>(static_cast<::zserio::BitBuffer>(in.readBitBuffer(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::BitBuffer>(::zserio::NullOpt);
}
::nds::system::types::ExternData DataLayer::readLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::ExternData(in, allocator);
}

} // namespace types
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/types/DataLayerDefinition.h>

namespace nds
{
namespace smart
{
namespace types
{

DataLayerDefinition::DataLayerDefinition(const allocator_type& allocator) noexcept :
        m_dataLayerId_(::nds::smart::types::DataLayerId()),
        m_lifetime_(::nds::smart::types::DataLayerLifetimeType()),
        m_isCustomExtension_(static_cast<bool>(false)),
        m_layerDescriptor_(allocator),
        m_customExtensionIdentifier_(::zserio::NullOpt),
        m_name_(allocator),
        m_contentType_(::nds::smart::types::DataLayerContentType()),
        m_signatureDefinition_(::zserio::NullOpt),
        m_layerMetadata_(::zserio::NullOpt),
        m_customExtensionMetadata_(::zserio::NullOpt)
{
}

DataLayerDefinition::DataLayerDefinition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_dataLayerId_(readDataLayerId(in)),
        m_lifetime_(readLifetime(in)),
        m_isCustomExtension_(readIsCustomExtension(in)),
        m_layerDescriptor_(readLayerDescriptor(in, allocator)),
        m_customExtensionIdentifier_(readCustomExtensionIdentifier(in, allocator)),
        m_name_(readName(in, allocator)),
        m_contentType_(readContentType(in)),
        m_signatureDefinition_(readSignatureDefinition(in, allocator)),
        m_layerMetadata_(readLayerMetadata(in, allocator)),
        m_customExtensionMetadata_(readCustomExtensionMetadata(in, allocator))
{
}

DataLayerDefinition::DataLayerDefinition(DataLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_dataLayerId_(readDataLayerId(context, in)),
        m_lifetime_(readLifetime(context, in)),
        m_isCustomExtension_(readIsCustomExtension(in)),
        m_layerDescriptor_(readLayerDescriptor(in, allocator)),
        m_customExtensionIdentifier_(readCustomExtensionIdentifier(in, allocator)),
        m_name_(readName(in, allocator)),
        m_contentType_(readContentType(context, in)),
        m_signatureDefinition_(readSignatureDefinition(context, in, allocator)),
        m_layerMetadata_(readLayerMetadata(in, allocator)),
        m_customExtensionMetadata_(readCustomExtensionMetadata(in, allocator))
{
}

DataLayerDefinition::DataLayerDefinition(::zserio::PropagateAllocatorT,
        const DataLayerDefinition& other, const allocator_type& allocator) :
        m_dataLayerId_(::zserio::allocatorPropagatingCopy(other.m_dataLayerId_, allocator)),
        m_lifetime_(::zserio::allocatorPropagatingCopy(other.m_lifetime_, allocator)),
        m_isCustomExtension_(::zserio::allocatorPropagatingCopy(other.m_isCustomExtension_, allocator)),
        m_layerDescriptor_(::zserio::allocatorPropagatingCopy(other.m_layerDescriptor_, allocator)),
        m_customExtensionIdentifier_(::zserio::allocatorPropagatingCopy(other.m_customExtensionIdentifier_, allocator)),
        m_name_(::zserio::allocatorPropagatingCopy(other.m_name_, allocator)),
        m_contentType_(::zserio::allocatorPropagatingCopy(other.m_contentType_, allocator)),
        m_signatureDefinition_(::zserio::allocatorPropagatingCopy(other.m_signatureDefinition_, allocator)),
        m_layerMetadata_(::zserio::allocatorPropagatingCopy(other.m_layerMetadata_, allocator)),
        m_customExtensionMetadata_(::zserio::allocatorPropagatingCopy(other.m_customExtensionMetadata_, allocator))
{
}

::nds::smart::types::DataLayerId DataLayerDefinition::getDataLayerId() const
{
    return m_dataLayerId_;
}

void DataLayerDefinition::setDataLayerId(::nds::smart::types::DataLayerId dataLayerId_)
{
    m_dataLayerId_ = dataLayerId_;
}

::nds::smart::types::DataLayerLifetimeType DataLayerDefinition::getLifetime() const
{
    return m_lifetime_;
}

void DataLayerDefinition::setLifetime(::nds::smart::types::DataLayerLifetimeType lifetime_)
{
    m_lifetime_ = lifetime_;
}

bool DataLayerDefinition::getIsCustomExtension() const
{
    return m_isCustomExtension_;
}

void DataLayerDefinition::setIsCustomExtension(bool isCustomExtension_)
{
    m_isCustomExtension_ = isCustomExtension_;
}

::nds::system::types::ExternDescriptor& DataLayerDefinition::getLayerDescriptor()
{
    return m_layerDescriptor_;
}

const ::nds::system::types::ExternDescriptor& DataLayerDefinition::getLayerDescriptor() const
{
    return m_layerDescriptor_;
}

void DataLayerDefinition::setLayerDescriptor(const ::nds::system::types::ExternDescriptor& layerDescriptor_)
{
    m_layerDescriptor_ = layerDescriptor_;
}

void DataLayerDefinition::setLayerDescriptor(::nds::system::types::ExternDescriptor&& layerDescriptor_)
{
    m_layerDescriptor_ = ::std::move(layerDescriptor_);
}

::nds::smart::types::CustomExtensionIdentifier& DataLayerDefinition::getCustomExtensionIdentifier()
{
    return m_customExtensionIdentifier_.value();
}

const ::nds::smart::types::CustomExtensionIdentifier& DataLayerDefinition::getCustomExtensionIdentifier() const
{
    return m_customExtensionIdentifier_.value();
}

void DataLayerDefinition::setCustomExtensionIdentifier(const ::nds::smart::types::CustomExtensionIdentifier& customExtensionIdentifier_)
{
    m_customExtensionIdentifier_ = customExtensionIdentifier_;
}

void DataLayerDefinition::setCustomExtensionIdentifier(::nds::smart::types::CustomExtensionIdentifier&& customExtensionIdentifier_)
{
    m_customExtensionIdentifier_ = ::std::move(customExtensionIdentifier_);
}

bool DataLayerDefinition::isCustomExtensionIdentifierUsed() const
{
    return (getIsCustomExtension());
}

bool DataLayerDefinition::isCustomExtensionIdentifierSet() const
{
    return m_customExtensionIdentifier_.hasValue();
}

void DataLayerDefinition::resetCustomExtensionIdentifier()
{
    m_customExtensionIdentifier_.reset();
}

::nds::smart::types::DataLayerName& DataLayerDefinition::getName()
{
    return m_name_;
}

const ::nds::smart::types::DataLayerName& DataLayerDefinition::getName() const
{
    return m_name_;
}

void DataLayerDefinition::setName(const ::nds::smart::types::DataLayerName& name_)
{
    m_name_ = name_;
}

void DataLayerDefinition::setName(::nds::smart::types::DataLayerName&& name_)
{
    m_name_ = ::std::move(name_);
}

::nds::smart::types::DataLayerContentType DataLayerDefinition::getContentType() const
{
    return m_contentType_;
}

void DataLayerDefinition::setContentType(::nds::smart::types::DataLayerContentType contentType_)
{
    m_contentType_ = contentType_;
}

::nds::core::packaging::SignatureDefinition& DataLayerDefinition::getSignatureDefinition()
{
    return m_signatureDefinition_.value();
}

const ::nds::core::packaging::SignatureDefinition& DataLayerDefinition::getSignatureDefinition() const
{
    return m_signatureDefinition_.value();
}

void DataLayerDefinition::setSignatureDefinition(const ::nds::core::packaging::SignatureDefinition& signatureDefinition_)
{
    m_signatureDefinition_ = signatureDefinition_;
}

void DataLayerDefinition::setSignatureDefinition(::nds::core::packaging::SignatureDefinition&& signatureDefinition_)
{
    m_signatureDefinition_ = ::std::move(signatureDefinition_);
}

bool DataLayerDefinition::isSignatureDefinitionUsed() const
{
    return (isSignatureDefinitionSet());
}

bool DataLayerDefinition::isSignatureDefinitionSet() const
{
    return m_signatureDefinition_.hasValue();
}

void DataLayerDefinition::resetSignatureDefinition()
{
    m_signatureDefinition_.reset();
}

::nds::system::types::ExternData& DataLayerDefinition::getLayerMetadata()
{
    return m_layerMetadata_.value();
}

const ::nds::system::types::ExternData& DataLayerDefinition::getLayerMetadata() const
{
    return m_layerMetadata_.value();
}

void DataLayerDefinition::setLayerMetadata(const ::nds::system::types::ExternData& layerMetadata_)
{
    m_layerMetadata_ = layerMetadata_;
}

void DataLayerDefinition::setLayerMetadata(::nds::system::types::ExternData&& layerMetadata_)
{
    m_layerMetadata_ = ::std::move(layerMetadata_);
}

bool DataLayerDefinition::isLayerMetadataUsed() const
{
    return (!getIsCustomExtension());
}

bool DataLayerDefinition::isLayerMetadataSet() const
{
    return m_layerMetadata_.hasValue();
}

void DataLayerDefinition::resetLayerMetadata()
{
    m_layerMetadata_.reset();
}

::zserio::BitBuffer& DataLayerDefinition::getCustomExtensionMetadata()
{
    return m_customExtensionMetadata_.value();
}

const ::zserio::BitBuffer& DataLayerDefinition::getCustomExtensionMetadata() const
{
    return m_customExtensionMetadata_.value();
}

void DataLayerDefinition::setCustomExtensionMetadata(const ::zserio::BitBuffer& customExtensionMetadata_)
{
    m_customExtensionMetadata_ = customExtensionMetadata_;
}

void DataLayerDefinition::setCustomExtensionMetadata(::zserio::BitBuffer&& customExtensionMetadata_)
{
    m_customExtensionMetadata_ = ::std::move(customExtensionMetadata_);
}

bool DataLayerDefinition::isCustomExtensionMetadataUsed() const
{
    return (getIsCustomExtension());
}

bool DataLayerDefinition::isCustomExtensionMetadataSet() const
{
    return m_customExtensionMetadata_.hasValue();
}

void DataLayerDefinition::resetCustomExtensionMetadata()
{
    m_customExtensionMetadata_.reset();
}

void DataLayerDefinition::initPackingContext(DataLayerDefinition::ZserioPackingContext& context) const
{
    context.getDataLayerId().init<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(m_dataLayerId_);
    ::zserio::initPackingContext(context.getLifetime(), m_lifetime_);
    ::zserio::initPackingContext(context.getContentType(), m_contentType_);
    if (isSignatureDefinitionSet())
    {
        m_signatureDefinition_.value().initPackingContext(context.getSignatureDefinition());
    }
}

size_t DataLayerDefinition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_dataLayerId_);
    endBitPosition += ::zserio::bitSizeOf(m_lifetime_);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_layerDescriptor_.bitSizeOf(endBitPosition);
    if (getIsCustomExtension())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_customExtensionIdentifier_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOf(m_contentType_);
    endBitPosition += 1;
    if (isSignatureDefinitionSet())
    {
        endBitPosition += m_signatureDefinition_.value().bitSizeOf(endBitPosition);
    }
    if (!getIsCustomExtension())
    {
        endBitPosition += m_layerMetadata_.value().bitSizeOf(endBitPosition);
    }
    if (getIsCustomExtension())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customExtensionMetadata_.value());
    }

    return endBitPosition - bitPosition;
}

size_t DataLayerDefinition::bitSizeOf(DataLayerDefinition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDataLayerId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(m_dataLayerId_);
    endBitPosition += ::zserio::bitSizeOf(context.getLifetime(), m_lifetime_);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_layerDescriptor_.bitSizeOf(endBitPosition);
    if (getIsCustomExtension())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_customExtensionIdentifier_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOf(context.getContentType(), m_contentType_);
    endBitPosition += 1;
    if (isSignatureDefinitionSet())
    {
        endBitPosition += m_signatureDefinition_.value().bitSizeOf(context.getSignatureDefinition(), endBitPosition);
    }
    if (!getIsCustomExtension())
    {
        endBitPosition += m_layerMetadata_.value().bitSizeOf(endBitPosition);
    }
    if (getIsCustomExtension())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customExtensionMetadata_.value());
    }

    return endBitPosition - bitPosition;
}

size_t DataLayerDefinition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_dataLayerId_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_lifetime_);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_layerDescriptor_.initializeOffsets(endBitPosition);
    if (getIsCustomExtension())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_customExtensionIdentifier_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_contentType_);
    endBitPosition += 1;
    if (isSignatureDefinitionSet())
    {
        endBitPosition = m_signatureDefinition_.value().initializeOffsets(endBitPosition);
    }
    if (!getIsCustomExtension())
    {
        endBitPosition = m_layerMetadata_.value().initializeOffsets(endBitPosition);
    }
    if (getIsCustomExtension())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customExtensionMetadata_.value());
    }

    return endBitPosition;
}

size_t DataLayerDefinition::initializeOffsets(DataLayerDefinition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDataLayerId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(m_dataLayerId_);
    endBitPosition = ::zserio::initializeOffsets(context.getLifetime(), endBitPosition,
        m_lifetime_);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_layerDescriptor_.initializeOffsets(endBitPosition);
    if (getIsCustomExtension())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_customExtensionIdentifier_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition = ::zserio::initializeOffsets(context.getContentType(), endBitPosition,
        m_contentType_);
    endBitPosition += 1;
    if (isSignatureDefinitionSet())
    {
        endBitPosition = m_signatureDefinition_.value().initializeOffsets(context.getSignatureDefinition(), endBitPosition);
    }
    if (!getIsCustomExtension())
    {
        endBitPosition = m_layerMetadata_.value().initializeOffsets(endBitPosition);
    }
    if (getIsCustomExtension())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customExtensionMetadata_.value());
    }

    return endBitPosition;
}

bool DataLayerDefinition::operator==(const DataLayerDefinition& other) const
{
    if (this != &other)
    {
        return
                (m_dataLayerId_ == other.m_dataLayerId_) &&
                (m_lifetime_ == other.m_lifetime_) &&
                (m_isCustomExtension_ == other.m_isCustomExtension_) &&
                (m_layerDescriptor_ == other.m_layerDescriptor_) &&
                (!isCustomExtensionIdentifierUsed() ? !other.isCustomExtensionIdentifierUsed() : (m_customExtensionIdentifier_ == other.m_customExtensionIdentifier_)) &&
                (m_name_ == other.m_name_) &&
                (m_contentType_ == other.m_contentType_) &&
                (!isSignatureDefinitionUsed() ? !other.isSignatureDefinitionUsed() : (m_signatureDefinition_ == other.m_signatureDefinition_)) &&
                (!isLayerMetadataUsed() ? !other.isLayerMetadataUsed() : (m_layerMetadata_ == other.m_layerMetadata_)) &&
                (!isCustomExtensionMetadataUsed() ? !other.isCustomExtensionMetadataUsed() : (m_customExtensionMetadata_ == other.m_customExtensionMetadata_));
    }

    return true;
}

uint32_t DataLayerDefinition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_dataLayerId_);
    result = ::zserio::calcHashCode(result, m_lifetime_);
    result = ::zserio::calcHashCode(result, m_isCustomExtension_);
    result = ::zserio::calcHashCode(result, m_layerDescriptor_);
    if (isCustomExtensionIdentifierUsed())
        result = ::zserio::calcHashCode(result, m_customExtensionIdentifier_);
    result = ::zserio::calcHashCode(result, m_name_);
    result = ::zserio::calcHashCode(result, m_contentType_);
    if (isSignatureDefinitionUsed())
        result = ::zserio::calcHashCode(result, m_signatureDefinition_);
    if (isLayerMetadataUsed())
        result = ::zserio::calcHashCode(result, m_layerMetadata_);
    if (isCustomExtensionMetadataUsed())
        result = ::zserio::calcHashCode(result, m_customExtensionMetadata_);

    return result;
}

void DataLayerDefinition::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_dataLayerId_);
    ::zserio::write(out, m_lifetime_);
    out.writeBool(m_isCustomExtension_);
    m_layerDescriptor_.write(out);
    if (getIsCustomExtension())
    {
        out.writeString(m_customExtensionIdentifier_.value());
    }
    out.writeString(m_name_);
    ::zserio::write(out, m_contentType_);
    if (isSignatureDefinitionSet())
    {
        out.writeBool(true);
        m_signatureDefinition_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (!getIsCustomExtension())
    {
        m_layerMetadata_.value().write(out);
    }
    if (getIsCustomExtension())
    {
        out.alignTo(8);
        out.writeBitBuffer(m_customExtensionMetadata_.value());
    }
}

void DataLayerDefinition::write(DataLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getDataLayerId().write<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(out, m_dataLayerId_);
    ::zserio::write(context.getLifetime(), out, m_lifetime_);
    out.writeBool(m_isCustomExtension_);
    m_layerDescriptor_.write(out);
    if (getIsCustomExtension())
    {
        out.writeString(m_customExtensionIdentifier_.value());
    }
    out.writeString(m_name_);
    ::zserio::write(context.getContentType(), out, m_contentType_);
    if (isSignatureDefinitionSet())
    {
        out.writeBool(true);
        m_signatureDefinition_.value().write(context.getSignatureDefinition(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (!getIsCustomExtension())
    {
        m_layerMetadata_.value().write(out);
    }
    if (getIsCustomExtension())
    {
        out.alignTo(8);
        out.writeBitBuffer(m_customExtensionMetadata_.value());
    }
}

::nds::smart::types::DataLayerId DataLayerDefinition::readDataLayerId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::smart::types::DataLayerId>(in.readVarUInt16());
}

::nds::smart::types::DataLayerId DataLayerDefinition::readDataLayerId(DataLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDataLayerId().read<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(in);
}
::nds::smart::types::DataLayerLifetimeType DataLayerDefinition::readLifetime(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::smart::types::DataLayerLifetimeType>(in);
}

::nds::smart::types::DataLayerLifetimeType DataLayerDefinition::readLifetime(DataLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::smart::types::DataLayerLifetimeType>(context.getLifetime(), in);
}
bool DataLayerDefinition::readIsCustomExtension(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::system::types::ExternDescriptor DataLayerDefinition::readLayerDescriptor(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::ExternDescriptor(in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::smart::types::CustomExtensionIdentifier> DataLayerDefinition::readCustomExtensionIdentifier(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getIsCustomExtension())
    {
        return ::zserio::InplaceOptionalHolder<::nds::smart::types::CustomExtensionIdentifier>(static_cast<::nds::smart::types::CustomExtensionIdentifier>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::nds::smart::types::CustomExtensionIdentifier>(::zserio::NullOpt);
}
::nds::smart::types::DataLayerName DataLayerDefinition::readName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::smart::types::DataLayerName>(in.readString(allocator));
}
::nds::smart::types::DataLayerContentType DataLayerDefinition::readContentType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::smart::types::DataLayerContentType>(in);
}

::nds::smart::types::DataLayerContentType DataLayerDefinition::readContentType(DataLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::smart::types::DataLayerContentType>(context.getContentType(), in);
}
::zserio::InplaceOptionalHolder<::nds::core::packaging::SignatureDefinition> DataLayerDefinition::readSignatureDefinition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::packaging::SignatureDefinition>(::nds::core::packaging::SignatureDefinition(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::packaging::SignatureDefinition>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::packaging::SignatureDefinition> DataLayerDefinition::readSignatureDefinition(DataLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::packaging::SignatureDefinition>(::nds::core::packaging::SignatureDefinition(context.getSignatureDefinition(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::packaging::SignatureDefinition>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::system::types::ExternData> DataLayerDefinition::readLayerMetadata(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getIsCustomExtension())
    {
        return ::zserio::InplaceOptionalHolder<::nds::system::types::ExternData>(::nds::system::types::ExternData(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::system::types::ExternData>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::zserio::BitBuffer> DataLayerDefinition::readCustomExtensionMetadata(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getIsCustomExtension())
    {
        in.alignTo(8);
        return ::zserio::InplaceOptionalHolder<::zserio::BitBuffer>(static_cast<::zserio::BitBuffer>(in.readBitBuffer(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::BitBuffer>(::zserio::NullOpt);
}

} // namespace types
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/types/DataLayerLifetime.h>

namespace nds
{
namespace smart
{
namespace types
{

DataLayerLifetime::DataLayerLifetime(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_lifetime_(::nds::smart::types::DataLayerLifetimeType()),
        m_layerLifetimeInfo_(allocator)
{
}

DataLayerLifetime::DataLayerLifetime(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_lifetime_(readLifetime(in)),
        m_layerLifetimeInfo_(readLayerLifetimeInfo(in, allocator))
{
}

DataLayerLifetime::DataLayerLifetime(DataLayerLifetime::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_lifetime_(readLifetime(context, in)),
        m_layerLifetimeInfo_(readLayerLifetimeInfo(context, in, allocator))
{
}

DataLayerLifetime::DataLayerLifetime(const DataLayerLifetime& other) :
        m_lifetime_(other.m_lifetime_),
        m_layerLifetimeInfo_(other.m_layerLifetimeInfo_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

DataLayerLifetime& DataLayerLifetime::operator=(const DataLayerLifetime& other)
{
    m_lifetime_ = other.m_lifetime_;
    m_layerLifetimeInfo_ = other.m_layerLifetimeInfo_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

DataLayerLifetime::DataLayerLifetime(DataLayerLifetime&& other) :
        m_lifetime_(::std::move(other.m_lifetime_)),
        m_layerLifetimeInfo_(::std::move(other.m_layerLifetimeInfo_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

DataLayerLifetime& DataLayerLifetime::operator=(DataLayerLifetime&& other)
{
    m_lifetime_ = ::std::move(other.m_lifetime_);
    m_layerLifetimeInfo_ = ::std::move(other.m_layerLifetimeInfo_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

DataLayerLifetime::DataLayerLifetime(::zserio::PropagateAllocatorT,
        const DataLayerLifetime& other, const allocator_type& allocator) :
        m_lifetime_(::zserio::allocatorPropagatingCopy(other.m_lifetime_, allocator)),
        m_layerLifetimeInfo_(::zserio::allocatorPropagatingCopy(other.m_layerLifetimeInfo_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void DataLayerLifetime::initializeChildren()
{
    m_layerLifetimeInfo_.initialize(static_cast<::nds::smart::types::DataLayerLifetimeType>(getLifetime()));

    m_areChildrenInitialized = true;
}

::nds::smart::types::DataLayerLifetimeType DataLayerLifetime::getLifetime() const
{
    return m_lifetime_;
}

void DataLayerLifetime::setLifetime(::nds::smart::types::DataLayerLifetimeType lifetime_)
{
    m_lifetime_ = lifetime_;
}

::nds::smart::types::DataLayerLifetimeInfo& DataLayerLifetime::getLayerLifetimeInfo()
{
    return m_layerLifetimeInfo_;
}

const ::nds::smart::types::DataLayerLifetimeInfo& DataLayerLifetime::getLayerLifetimeInfo() const
{
    return m_layerLifetimeInfo_;
}

void DataLayerLifetime::setLayerLifetimeInfo(const ::nds::smart::types::DataLayerLifetimeInfo& layerLifetimeInfo_)
{
    m_layerLifetimeInfo_ = layerLifetimeInfo_;
}

void DataLayerLifetime::setLayerLifetimeInfo(::nds::smart::types::DataLayerLifetimeInfo&& layerLifetimeInfo_)
{
    m_layerLifetimeInfo_ = ::std::move(layerLifetimeInfo_);
}

void DataLayerLifetime::initPackingContext(DataLayerLifetime::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getLifetime(), m_lifetime_);
    m_layerLifetimeInfo_.initPackingContext(context.getLayerLifetimeInfo());
}

size_t DataLayerLifetime::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_lifetime_);
    endBitPosition += m_layerLifetimeInfo_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DataLayerLifetime::bitSizeOf(DataLayerLifetime::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getLifetime(), m_lifetime_);
    endBitPosition += m_layerLifetimeInfo_.bitSizeOf(context.getLayerLifetimeInfo(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DataLayerLifetime::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_lifetime_);
    endBitPosition = m_layerLifetimeInfo_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t DataLayerLifetime::initializeOffsets(DataLayerLifetime::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getLifetime(), endBitPosition,
        m_lifetime_);
    endBitPosition = m_layerLifetimeInfo_.initializeOffsets(context.getLayerLifetimeInfo(), endBitPosition);

    return endBitPosition;
}

bool DataLayerLifetime::operator==(const DataLayerLifetime& other) const
{
    if (this != &other)
    {
        return
                (m_lifetime_ == other.m_lifetime_) &&
                (m_layerLifetimeInfo_ == other.m_layerLifetimeInfo_);
    }

    return true;
}

uint32_t DataLayerLifetime::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_lifetime_);
    result = ::zserio::calcHashCode(result, m_layerLifetimeInfo_);

    return result;
}

void DataLayerLifetime::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_lifetime_);

    // check parameters
    if (m_layerLifetimeInfo_.getLifetime() != static_cast<::nds::smart::types::DataLayerLifetimeType>(getLifetime()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter lifetime for field DataLayerLifetime.layerLifetimeInfo: ") <<
                m_layerLifetimeInfo_.getLifetime() << " != " << static_cast<::nds::smart::types::DataLayerLifetimeType>(getLifetime()) << "!";
    }
    m_layerLifetimeInfo_.write(out);
}

void DataLayerLifetime::write(DataLayerLifetime::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getLifetime(), out, m_lifetime_);

    // check parameters
    if (m_layerLifetimeInfo_.getLifetime() != static_cast<::nds::smart::types::DataLayerLifetimeType>(getLifetime()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter lifetime for field DataLayerLifetime.layerLifetimeInfo: ") <<
                m_layerLifetimeInfo_.getLifetime() << " != " << static_cast<::nds::smart::types::DataLayerLifetimeType>(getLifetime()) << "!";
    }
    m_layerLifetimeInfo_.write(context.getLayerLifetimeInfo(), out);
}

::nds::smart::types::DataLayerLifetimeType DataLayerLifetime::readLifetime(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::smart::types::DataLayerLifetimeType>(in);
}

::nds::smart::types::DataLayerLifetimeType DataLayerLifetime::readLifetime(DataLayerLifetime::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::smart::types::DataLayerLifetimeType>(context.getLifetime(), in);
}
::nds::smart::types::DataLayerLifetimeInfo DataLayerLifetime::readLayerLifetimeInfo(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::types::DataLayerLifetimeInfo(in, static_cast<::nds::smart::types::DataLayerLifetimeType>(getLifetime()), allocator);
}

::nds::smart::types::DataLayerLifetimeInfo DataLayerLifetime::readLayerLifetimeInfo(DataLayerLifetime::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::types::DataLayerLifetimeInfo(context.getLayerLifetimeInfo(), in, static_cast<::nds::smart::types::DataLayerLifetimeType>(getLifetime()), allocator);
}

} // namespace types
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/types/DynamicDataLifetimeInfo.h>

namespace nds
{
namespace smart
{
namespace types
{

DynamicDataLifetimeInfo::DynamicDataLifetimeInfo(const allocator_type& allocator) noexcept :
        m_collectionTime_(allocator),
        m_expirationTime_(allocator)
{
}

DynamicDataLifetimeInfo::DynamicDataLifetimeInfo(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_collectionTime_(readCollectionTime(in, allocator)),
        m_expirationTime_(readExpirationTime(in, allocator))
{
}

DynamicDataLifetimeInfo::DynamicDataLifetimeInfo(DynamicDataLifetimeInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_collectionTime_(readCollectionTime(context, in, allocator)),
        m_expirationTime_(readExpirationTime(context, in, allocator))
{
}

DynamicDataLifetimeInfo::DynamicDataLifetimeInfo(::zserio::PropagateAllocatorT,
        const DynamicDataLifetimeInfo& other, const allocator_type& allocator) :
        m_collectionTime_(::zserio::allocatorPropagatingCopy(other.m_collectionTime_, allocator)),
        m_expirationTime_(::zserio::allocatorPropagatingCopy(other.m_expirationTime_, allocator))
{
}

::nds::core::types::TimeStamp& DynamicDataLifetimeInfo::getCollectionTime()
{
    return m_collectionTime_;
}

const ::nds::core::types::TimeStamp& DynamicDataLifetimeInfo::getCollectionTime() const
{
    return m_collectionTime_;
}

void DynamicDataLifetimeInfo::setCollectionTime(const ::nds::core::types::TimeStamp& collectionTime_)
{
    m_collectionTime_ = collectionTime_;
}

void DynamicDataLifetimeInfo::setCollectionTime(::nds::core::types::TimeStamp&& collectionTime_)
{
    m_collectionTime_ = ::std::move(collectionTime_);
}

::nds::core::types::TimeStamp& DynamicDataLifetimeInfo::getExpirationTime()
{
    return m_expirationTime_;
}

const ::nds::core::types::TimeStamp& DynamicDataLifetimeInfo::getExpirationTime() const
{
    return m_expirationTime_;
}

void DynamicDataLifetimeInfo::setExpirationTime(const ::nds::core::types::TimeStamp& expirationTime_)
{
    m_expirationTime_ = expirationTime_;
}

void DynamicDataLifetimeInfo::setExpirationTime(::nds::core::types::TimeStamp&& expirationTime_)
{
    m_expirationTime_ = ::std::move(expirationTime_);
}

void DynamicDataLifetimeInfo::initPackingContext(DynamicDataLifetimeInfo::ZserioPackingContext& context) const
{
    m_collectionTime_.initPackingContext(context.getCollectionTime());
    m_expirationTime_.initPackingContext(context.getExpirationTime());
}

size_t DynamicDataLifetimeInfo::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_collectionTime_.bitSizeOf(endBitPosition);
    endBitPosition += m_expirationTime_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DynamicDataLifetimeInfo::bitSizeOf(DynamicDataLifetimeInfo::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_collectionTime_.bitSizeOf(context.getCollectionTime(), endBitPosition);
    endBitPosition += m_expirationTime_.bitSizeOf(context.getExpirationTime(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DynamicDataLifetimeInfo::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_collectionTime_.initializeOffsets(endBitPosition);
    endBitPosition = m_expirationTime_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t DynamicDataLifetimeInfo::initializeOffsets(DynamicDataLifetimeInfo::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_collectionTime_.initializeOffsets(context.getCollectionTime(), endBitPosition);
    endBitPosition = m_expirationTime_.initializeOffsets(context.getExpirationTime(), endBitPosition);

    return endBitPosition;
}

bool DynamicDataLifetimeInfo::operator==(const DynamicDataLifetimeInfo& other) const
{
    if (this != &other)
    {
        return
                (m_collectionTime_ == other.m_collectionTime_) &&
                (m_expirationTime_ == other.m_expirationTime_);
    }

    return true;
}

uint32_t DynamicDataLifetimeInfo::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_collectionTime_);
    result = ::zserio::calcHashCode(result, m_expirationTime_);

    return result;
}

void DynamicDataLifetimeInfo::write(::zserio::BitStreamWriter& out) const
{
    m_collectionTime_.write(out);
    m_expirationTime_.write(out);
}

void DynamicDataLifetimeInfo::write(DynamicDataLifetimeInfo::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_collectionTime_.write(context.getCollectionTime(), out);
    m_expirationTime_.write(context.getExpirationTime(), out);
}

::nds::core::types::TimeStamp DynamicDataLifetimeInfo::readCollectionTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(in, allocator);
}

::nds::core::types::TimeStamp DynamicDataLifetimeInfo::readCollectionTime(DynamicDataLifetimeInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(context.getCollectionTime(), in, allocator);
}
::nds::core::types::TimeStamp DynamicDataLifetimeInfo::readExpirationTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(in, allocator);
}

::nds::core::types::TimeStamp DynamicDataLifetimeInfo::readExpirationTime(DynamicDataLifetimeInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TimeStamp(context.getExpirationTime(), in, allocator);
}

} // namespace types
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/types/SmartLayerHeader.h>

namespace nds
{
namespace smart
{
namespace types
{

SmartLayerHeader::SmartLayerHeader(const allocator_type& allocator) noexcept :
        m_numDataLayers_(uint16_t()),
        m_availableLayers_(allocator),
        m_layerLifetime_(allocator),
        m_packagingDetails_(allocator)
{
}

SmartLayerHeader::SmartLayerHeader(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numDataLayers_(readNumDataLayers(in)),
        m_availableLayers_(readAvailableLayers(in, allocator)),
        m_layerLifetime_(readLayerLifetime(in, allocator)),
        m_packagingDetails_(readPackagingDetails(in, allocator))
{
}

SmartLayerHeader::SmartLayerHeader(SmartLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numDataLayers_(readNumDataLayers(context, in)),
        m_availableLayers_(readAvailableLayers(context, in, allocator)),
        m_layerLifetime_(readLayerLifetime(context, in, allocator)),
        m_packagingDetails_(readPackagingDetails(context, in, allocator))
{
}

SmartLayerHeader::SmartLayerHeader(::zserio::PropagateAllocatorT,
        const SmartLayerHeader& other, const allocator_type& allocator) :
        m_numDataLayers_(::zserio::allocatorPropagatingCopy(other.m_numDataLayers_, allocator)),
        m_availableLayers_(::zserio::allocatorPropagatingCopy(other.m_availableLayers_, allocator)),
        m_layerLifetime_(::zserio::allocatorPropagatingCopy(other.m_layerLifetime_, allocator)),
        m_packagingDetails_(::zserio::allocatorPropagatingCopy(other.m_packagingDetails_, allocator))
{
}

void SmartLayerHeader::initializeChildren()
{
    m_layerLifetime_.initializeElements(*this);
}

uint16_t SmartLayerHeader::getNumDataLayers() const
{
    return m_numDataLayers_;
}

void SmartLayerHeader::setNumDataLayers(uint16_t numDataLayers_)
{
    m_numDataLayers_ = numDataLayers_;
}

::zserio::vector<::nds::smart::types::DataLayerId>& SmartLayerHeader::getAvailableLayers()
{
    return m_availableLayers_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayerId>& SmartLayerHeader::getAvailableLayers() const
{
    return m_availableLayers_.getRawArray();
}

void SmartLayerHeader::setAvailableLayers(const ::zserio::vector<::nds::smart::types::DataLayerId>& availableLayers_)
{
    m_availableLayers_ = ZserioArrayType_availableLayers(availableLayers_);
}

void SmartLayerHeader::setAvailableLayers(::zserio::vector<::nds::smart::types::DataLayerId>&& availableLayers_)
{
    m_availableLayers_ = ZserioArrayType_availableLayers(std::move(availableLayers_));
}

::zserio::vector<::nds::smart::types::DataLayerLifetime>& SmartLayerHeader::getLayerLifetime()
{
    return m_layerLifetime_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayerLifetime>& SmartLayerHeader::getLayerLifetime() const
{
    return m_layerLifetime_.getRawArray();
}

void SmartLayerHeader::setLayerLifetime(const ::zserio::vector<::nds::smart::types::DataLayerLifetime>& layerLifetime_)
{
    m_layerLifetime_ = ZserioArrayType_layerLifetime(layerLifetime_);
}

void SmartLayerHeader::setLayerLifetime(::zserio::vector<::nds::smart::types::DataLayerLifetime>&& layerLifetime_)
{
    m_layerLifetime_ = ZserioArrayType_layerLifetime(std::move(layerLifetime_));
}

::zserio::vector<::nds::core::packaging::PackagingDetails>& SmartLayerHeader::getPackagingDetails()
{
    return m_packagingDetails_.getRawArray();
}

const ::zserio::vector<::nds::core::packaging::PackagingDetails>& SmartLayerHeader::getPackagingDetails() const
{
    return m_packagingDetails_.getRawArray();
}

void SmartLayerHeader::setPackagingDetails(const ::zserio::vector<::nds::core::packaging::PackagingDetails>& packagingDetails_)
{
    m_packagingDetails_ = ZserioArrayType_packagingDetails(packagingDetails_);
}

void SmartLayerHeader::setPackagingDetails(::zserio::vector<::nds::core::packaging::PackagingDetails>&& packagingDetails_)
{
    m_packagingDetails_ = ZserioArrayType_packagingDetails(std::move(packagingDetails_));
}

void SmartLayerHeader::initPackingContext(SmartLayerHeader::ZserioPackingContext& context) const
{
    context.getNumDataLayers().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
}

size_t SmartLayerHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition += m_availableLayers_.bitSizeOf(endBitPosition);
    endBitPosition += m_layerLifetime_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_packagingDetails_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerHeader::bitSizeOf(SmartLayerHeader::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition += m_availableLayers_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_layerLifetime_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_packagingDetails_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numDataLayers_);
    endBitPosition = m_availableLayers_.initializeOffsets(endBitPosition);
    endBitPosition = m_layerLifetime_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_packagingDetails_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerHeader::initializeOffsets(SmartLayerHeader::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumDataLayers().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numDataLayers_);
    endBitPosition = m_availableLayers_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_layerLifetime_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_packagingDetails_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerHeader::operator==(const SmartLayerHeader& other) const
{
    if (this != &other)
    {
        return
                (m_numDataLayers_ == other.m_numDataLayers_) &&
                (m_availableLayers_ == other.m_availableLayers_) &&
                (m_layerLifetime_ == other.m_layerLifetime_) &&
                (m_packagingDetails_ == other.m_packagingDetails_);
    }

    return true;
}

uint32_t SmartLayerHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numDataLayers_);
    result = ::zserio::calcHashCode(result, m_availableLayers_);
    result = ::zserio::calcHashCode(result, m_layerLifetime_);
    result = ::zserio::calcHashCode(result, m_packagingDetails_);

    return result;
}

void SmartLayerHeader::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numDataLayers_);

    // check array length
    if (m_availableLayers_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerHeader.availableLayers: ") <<
                m_availableLayers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_availableLayers_.write(out);

    // check array length
    if (m_layerLifetime_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerHeader.layerLifetime: ") <<
                m_layerLifetime_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_layerLifetime_.write(*this, out);

    // check array length
    if (m_packagingDetails_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerHeader.packagingDetails: ") <<
                m_packagingDetails_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_packagingDetails_.write(*this, out);
}

void SmartLayerHeader::write(SmartLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumDataLayers().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numDataLayers_);

    // check array length
    if (m_availableLayers_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerHeader.availableLayers: ") <<
                m_availableLayers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_availableLayers_.writePacked(out);

    // check array length
    if (m_layerLifetime_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerHeader.layerLifetime: ") <<
                m_layerLifetime_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_layerLifetime_.writePacked(*this, out);

    // check array length
    if (m_packagingDetails_.getRawArray().size() != static_cast<size_t>(getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerHeader.packagingDetails: ") <<
                m_packagingDetails_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumDataLayers()) << "!";
    }
    m_packagingDetails_.writePacked(*this, out);
}

void SmartLayerHeader::ZserioArrayExpressions_layerLifetime::initializeElement(SmartLayerHeader&,
        ::nds::smart::types::DataLayerLifetime& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerHeader::ZserioElementFactory_layerLifetime::create(SmartLayerHeader&        ,
        ::zserio::vector<::nds::smart::types::DataLayerLifetime>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerHeader::ZserioElementFactory_layerLifetime::create(SmartLayerHeader&        ,
        ::zserio::vector<::nds::smart::types::DataLayerLifetime>& array,
        ::nds::smart::types::DataLayerLifetime::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void SmartLayerHeader::ZserioElementFactory_packagingDetails::create(SmartLayerHeader&        ,
        ::zserio::vector<::nds::core::packaging::PackagingDetails>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerHeader::ZserioElementFactory_packagingDetails::create(SmartLayerHeader&        ,
        ::zserio::vector<::nds::core::packaging::PackagingDetails>& array,
        ::nds::core::packaging::PackagingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint16_t SmartLayerHeader::readNumDataLayers(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t SmartLayerHeader::readNumDataLayers(SmartLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumDataLayers().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
SmartLayerHeader::ZserioArrayType_availableLayers SmartLayerHeader::readAvailableLayers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableLayers readField(allocator);
    readField.read(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

SmartLayerHeader::ZserioArrayType_availableLayers SmartLayerHeader::readAvailableLayers(SmartLayerHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableLayers readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}
SmartLayerHeader::ZserioArrayType_layerLifetime SmartLayerHeader::readLayerLifetime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_layerLifetime readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

SmartLayerHeader::ZserioArrayType_layerLifetime SmartLayerHeader::readLayerLifetime(SmartLayerHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_layerLifetime readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}
SmartLayerHeader::ZserioArrayType_packagingDetails SmartLayerHeader::readPackagingDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_packagingDetails readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

SmartLayerHeader::ZserioArrayType_packagingDetails SmartLayerHeader::readPackagingDetails(SmartLayerHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_packagingDetails readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumDataLayers()));

    return readField;
}

} // namespace types
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/types/RasterTileImageRequest.h>

namespace nds
{
namespace smart
{
namespace types
{

RasterTileImageRequest::RasterTileImageRequest(const allocator_type& allocator) noexcept :
        m_tileId_(allocator),
        m_configuration_(allocator)
{
}

RasterTileImageRequest::RasterTileImageRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_tileId_(readTileId(in, allocator)),
        m_configuration_(readConfiguration(in, allocator))
{
}

RasterTileImageRequest::RasterTileImageRequest(RasterTileImageRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_tileId_(readTileId(context, in, allocator)),
        m_configuration_(readConfiguration(in, allocator))
{
}

RasterTileImageRequest::RasterTileImageRequest(::zserio::PropagateAllocatorT,
        const RasterTileImageRequest& other, const allocator_type& allocator) :
        m_tileId_(::zserio::allocatorPropagatingCopy(other.m_tileId_, allocator)),
        m_configuration_(::zserio::allocatorPropagatingCopy(other.m_configuration_, allocator))
{
}

::nds::core::types::TileId& RasterTileImageRequest::getTileId()
{
    return m_tileId_;
}

const ::nds::core::types::TileId& RasterTileImageRequest::getTileId() const
{
    return m_tileId_;
}

void RasterTileImageRequest::setTileId(const ::nds::core::types::TileId& tileId_)
{
    m_tileId_ = tileId_;
}

void RasterTileImageRequest::setTileId(::nds::core::types::TileId&& tileId_)
{
    m_tileId_ = ::std::move(tileId_);
}

::nds::smart::types::RasterImageConfigBase64& RasterTileImageRequest::getConfiguration()
{
    return m_configuration_;
}

const ::nds::smart::types::RasterImageConfigBase64& RasterTileImageRequest::getConfiguration() const
{
    return m_configuration_;
}

void RasterTileImageRequest::setConfiguration(const ::nds::smart::types::RasterImageConfigBase64& configuration_)
{
    m_configuration_ = configuration_;
}

void RasterTileImageRequest::setConfiguration(::nds::smart::types::RasterImageConfigBase64&& configuration_)
{
    m_configuration_ = ::std::move(configuration_);
}

void RasterTileImageRequest::initPackingContext(RasterTileImageRequest::ZserioPackingContext& context) const
{
    m_tileId_.initPackingContext(context.getTileId());
}

size_t RasterTileImageRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_tileId_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_configuration_);

    return endBitPosition - bitPosition;
}

size_t RasterTileImageRequest::bitSizeOf(RasterTileImageRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_tileId_.bitSizeOf(context.getTileId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_configuration_);

    return endBitPosition - bitPosition;
}

size_t RasterTileImageRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_tileId_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_configuration_);

    return endBitPosition;
}

size_t RasterTileImageRequest::initializeOffsets(RasterTileImageRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_tileId_.initializeOffsets(context.getTileId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_configuration_);

    return endBitPosition;
}

bool RasterTileImageRequest::operator==(const RasterTileImageRequest& other) const
{
    if (this != &other)
    {
        return
                (m_tileId_ == other.m_tileId_) &&
                (m_configuration_ == other.m_configuration_);
    }

    return true;
}

uint32_t RasterTileImageRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_tileId_);
    result = ::zserio::calcHashCode(result, m_configuration_);

    return result;
}

void RasterTileImageRequest::write(::zserio::BitStreamWriter& out) const
{
    m_tileId_.write(out);
    out.writeString(m_configuration_);
}

void RasterTileImageRequest::write(RasterTileImageRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_tileId_.write(context.getTileId(), out);
    out.writeString(m_configuration_);
}

::nds::core::types::TileId RasterTileImageRequest::readTileId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TileId(in, allocator);
}

::nds::core::types::TileId RasterTileImageRequest::readTileId(RasterTileImageRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TileId(context.getTileId(), in, allocator);
}
::nds::smart::types::RasterImageConfigBase64 RasterTileImageRequest::readConfiguration(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::smart::types::RasterImageConfigBase64>(in.readString(allocator));
}

} // namespace types
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/types/RasterTileInfo.h>

namespace nds
{
namespace smart
{
namespace types
{

RasterTileInfo::RasterTileInfo(const allocator_type& allocator) noexcept :
        m_lifetimeInfo_(allocator),
        m_configurations_(allocator)
{
}

RasterTileInfo::RasterTileInfo(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_lifetimeInfo_(readLifetimeInfo(in, allocator)),
        m_configurations_(readConfigurations(in, allocator))
{
}

RasterTileInfo::RasterTileInfo(RasterTileInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_lifetimeInfo_(readLifetimeInfo(context, in, allocator)),
        m_configurations_(readConfigurations(in, allocator))
{
}

RasterTileInfo::RasterTileInfo(::zserio::PropagateAllocatorT,
        const RasterTileInfo& other, const allocator_type& allocator) :
        m_lifetimeInfo_(::zserio::allocatorPropagatingCopy(other.m_lifetimeInfo_, allocator)),
        m_configurations_(::zserio::allocatorPropagatingCopy(other.m_configurations_, allocator))
{
}

void RasterTileInfo::initializeChildren()
{
    m_lifetimeInfo_.initializeChildren();
}

::nds::smart::types::RasterImageLifetime& RasterTileInfo::getLifetimeInfo()
{
    return m_lifetimeInfo_;
}

const ::nds::smart::types::RasterImageLifetime& RasterTileInfo::getLifetimeInfo() const
{
    return m_lifetimeInfo_;
}

void RasterTileInfo::setLifetimeInfo(const ::nds::smart::types::RasterImageLifetime& lifetimeInfo_)
{
    m_lifetimeInfo_ = lifetimeInfo_;
}

void RasterTileInfo::setLifetimeInfo(::nds::smart::types::RasterImageLifetime&& lifetimeInfo_)
{
    m_lifetimeInfo_ = ::std::move(lifetimeInfo_);
}

::zserio::vector<::nds::smart::types::RasterImageConfigExtern>& RasterTileInfo::getConfigurations()
{
    return m_configurations_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::RasterImageConfigExtern>& RasterTileInfo::getConfigurations() const
{
    return m_configurations_.getRawArray();
}

void RasterTileInfo::setConfigurations(const ::zserio::vector<::nds::smart::types::RasterImageConfigExtern>& configurations_)
{
    m_configurations_ = ZserioArrayType_configurations(configurations_);
}

void RasterTileInfo::setConfigurations(::zserio::vector<::nds::smart::types::RasterImageConfigExtern>&& configurations_)
{
    m_configurations_ = ZserioArrayType_configurations(std::move(configurations_));
}

void RasterTileInfo::initPackingContext(RasterTileInfo::ZserioPackingContext& context) const
{
    m_lifetimeInfo_.initPackingContext(context.getLifetimeInfo());
}

size_t RasterTileInfo::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_lifetimeInfo_.bitSizeOf(endBitPosition);
    endBitPosition += m_configurations_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RasterTileInfo::bitSizeOf(RasterTileInfo::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_lifetimeInfo_.bitSizeOf(context.getLifetimeInfo(), endBitPosition);
    endBitPosition += m_configurations_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RasterTileInfo::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_lifetimeInfo_.initializeOffsets(endBitPosition);
    endBitPosition = m_configurations_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RasterTileInfo::initializeOffsets(RasterTileInfo::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_lifetimeInfo_.initializeOffsets(context.getLifetimeInfo(), endBitPosition);
    endBitPosition = m_configurations_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool RasterTileInfo::operator==(const RasterTileInfo& other) const
{
    if (this != &other)
    {
        return
                (m_lifetimeInfo_ == other.m_lifetimeInfo_) &&
                (m_configurations_ == other.m_configurations_);
    }

    return true;
}

uint32_t RasterTileInfo::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_lifetimeInfo_);
    result = ::zserio::calcHashCode(result, m_configurations_);

    return result;
}

void RasterTileInfo::write(::zserio::BitStreamWriter& out) const
{
    m_lifetimeInfo_.write(out);
    m_configurations_.write(*this, out);
}

void RasterTileInfo::write(RasterTileInfo::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_lifetimeInfo_.write(context.getLifetimeInfo(), out);
    m_configurations_.write(*this, out);
}

void RasterTileInfo::ZserioElementFactory_configurations::create(RasterTileInfo&        ,
        ::zserio::vector<::nds::smart::types::RasterImageConfigExtern>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

::nds::smart::types::RasterImageLifetime RasterTileInfo::readLifetimeInfo(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::types::RasterImageLifetime(in, allocator);
}

::nds::smart::types::RasterImageLifetime RasterTileInfo::readLifetimeInfo(RasterTileInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::types::RasterImageLifetime(context.getLifetimeInfo(), in, allocator);
}
RasterTileInfo::ZserioArrayType_configurations RasterTileInfo::readConfigurations(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_configurations readField(allocator);
    readField.read(*this, in);

    return readField;
}

} // namespace types
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/types/RasterTileImageVersionRequest.h>

namespace nds
{
namespace smart
{
namespace types
{

RasterTileImageVersionRequest::RasterTileImageVersionRequest(const allocator_type& allocator) noexcept :
        m_tileId_(allocator),
        m_configuration_(allocator),
        m_lifetimeInfo_(allocator)
{
}

RasterTileImageVersionRequest::RasterTileImageVersionRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_tileId_(readTileId(in, allocator)),
        m_configuration_(readConfiguration(in, allocator)),
        m_lifetimeInfo_(readLifetimeInfo(in, allocator))
{
}

RasterTileImageVersionRequest::RasterTileImageVersionRequest(RasterTileImageVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_tileId_(readTileId(context, in, allocator)),
        m_configuration_(readConfiguration(in, allocator)),
        m_lifetimeInfo_(readLifetimeInfo(context, in, allocator))
{
}

RasterTileImageVersionRequest::RasterTileImageVersionRequest(::zserio::PropagateAllocatorT,
        const RasterTileImageVersionRequest& other, const allocator_type& allocator) :
        m_tileId_(::zserio::allocatorPropagatingCopy(other.m_tileId_, allocator)),
        m_configuration_(::zserio::allocatorPropagatingCopy(other.m_configuration_, allocator)),
        m_lifetimeInfo_(::zserio::allocatorPropagatingCopy(other.m_lifetimeInfo_, allocator))
{
}

void RasterTileImageVersionRequest::initializeChildren()
{
    m_lifetimeInfo_.initializeChildren();
}

::nds::core::types::TileId& RasterTileImageVersionRequest::getTileId()
{
    return m_tileId_;
}

const ::nds::core::types::TileId& RasterTileImageVersionRequest::getTileId() const
{
    return m_tileId_;
}

void RasterTileImageVersionRequest::setTileId(const ::nds::core::types::TileId& tileId_)
{
    m_tileId_ = tileId_;
}

void RasterTileImageVersionRequest::setTileId(::nds::core::types::TileId&& tileId_)
{
    m_tileId_ = ::std::move(tileId_);
}

::nds::smart::types::RasterImageConfigBase64& RasterTileImageVersionRequest::getConfiguration()
{
    return m_configuration_;
}

const ::nds::smart::types::RasterImageConfigBase64& RasterTileImageVersionRequest::getConfiguration() const
{
    return m_configuration_;
}

void RasterTileImageVersionRequest::setConfiguration(const ::nds::smart::types::RasterImageConfigBase64& configuration_)
{
    m_configuration_ = configuration_;
}

void RasterTileImageVersionRequest::setConfiguration(::nds::smart::types::RasterImageConfigBase64&& configuration_)
{
    m_configuration_ = ::std::move(configuration_);
}

::nds::smart::types::RasterImageLifetime& RasterTileImageVersionRequest::getLifetimeInfo()
{
    return m_lifetimeInfo_;
}

const ::nds::smart::types::RasterImageLifetime& RasterTileImageVersionRequest::getLifetimeInfo() const
{
    return m_lifetimeInfo_;
}

void RasterTileImageVersionRequest::setLifetimeInfo(const ::nds::smart::types::RasterImageLifetime& lifetimeInfo_)
{
    m_lifetimeInfo_ = lifetimeInfo_;
}

void RasterTileImageVersionRequest::setLifetimeInfo(::nds::smart::types::RasterImageLifetime&& lifetimeInfo_)
{
    m_lifetimeInfo_ = ::std::move(lifetimeInfo_);
}

void RasterTileImageVersionRequest::initPackingContext(RasterTileImageVersionRequest::ZserioPackingContext& context) const
{
    m_tileId_.initPackingContext(context.getTileId());
    m_lifetimeInfo_.initPackingContext(context.getLifetimeInfo());
}

size_t RasterTileImageVersionRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_tileId_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_configuration_);
    endBitPosition += m_lifetimeInfo_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RasterTileImageVersionRequest::bitSizeOf(RasterTileImageVersionRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_tileId_.bitSizeOf(context.getTileId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_configuration_);
    endBitPosition += m_lifetimeInfo_.bitSizeOf(context.getLifetimeInfo(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RasterTileImageVersionRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_tileId_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_configuration_);
    endBitPosition = m_lifetimeInfo_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RasterTileImageVersionRequest::initializeOffsets(RasterTileImageVersionRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_tileId_.initializeOffsets(context.getTileId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_configuration_);
    endBitPosition = m_lifetimeInfo_.initializeOffsets(context.getLifetimeInfo(), endBitPosition);

    return endBitPosition;
}

bool RasterTileImageVersionRequest::operator==(const RasterTileImageVersionRequest& other) const
{
    if (this != &other)
    {
        return
                (m_tileId_ == other.m_tileId_) &&
                (m_configuration_ == other.m_configuration_) &&
                (m_lifetimeInfo_ == other.m_lifetimeInfo_);
    }

    return true;
}

uint32_t RasterTileImageVersionRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_tileId_);
    result = ::zserio::calcHashCode(result, m_configuration_);
    result = ::zserio::calcHashCode(result, m_lifetimeInfo_);

    return result;
}

void RasterTileImageVersionRequest::write(::zserio::BitStreamWriter& out) const
{
    m_tileId_.write(out);
    out.writeString(m_configuration_);
    m_lifetimeInfo_.write(out);
}

void RasterTileImageVersionRequest::write(RasterTileImageVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_tileId_.write(context.getTileId(), out);
    out.writeString(m_configuration_);
    m_lifetimeInfo_.write(context.getLifetimeInfo(), out);
}

::nds::core::types::TileId RasterTileImageVersionRequest::readTileId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::TileId(in, allocator);
}

::nds::core::types::TileId RasterTileImageVersionRequest::readTileId(RasterTileImageVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::TileId(context.getTileId(), in, allocator);
}
::nds::smart::types::RasterImageConfigBase64 RasterTileImageVersionRequest::readConfiguration(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::smart::types::RasterImageConfigBase64>(in.readString(allocator));
}
::nds::smart::types::RasterImageLifetime RasterTileImageVersionRequest::readLifetimeInfo(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::types::RasterImageLifetime(in, allocator);
}

::nds::smart::types::RasterImageLifetime RasterTileImageVersionRequest::readLifetimeInfo(RasterTileImageVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::types::RasterImageLifetime(context.getLifetimeInfo(), in, allocator);
}

} // namespace types
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/types/DataLayerLifetimeInfo.h>

namespace nds
{
namespace smart
{
namespace types
{

DataLayerLifetimeInfo::DataLayerLifetimeInfo(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

DataLayerLifetimeInfo::DataLayerLifetimeInfo(::zserio::BitStreamReader& in,
        ::nds::smart::types::DataLayerLifetimeType lifetime_, const allocator_type& allocator) :
        m_lifetime_(lifetime_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

DataLayerLifetimeInfo::DataLayerLifetimeInfo(DataLayerLifetimeInfo::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::smart::types::DataLayerLifetimeType lifetime_, const allocator_type& allocator) :
        m_lifetime_(lifetime_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

DataLayerLifetimeInfo::DataLayerLifetimeInfo(const DataLayerLifetimeInfo& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_lifetime_);
    else
        m_isInitialized = false;
}

DataLayerLifetimeInfo& DataLayerLifetimeInfo::operator=(const DataLayerLifetimeInfo& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_lifetime_);
    else
        m_isInitialized = false;

    return *this;
}

DataLayerLifetimeInfo::DataLayerLifetimeInfo(DataLayerLifetimeInfo&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_lifetime_);
    else
        m_isInitialized = false;
}

DataLayerLifetimeInfo& DataLayerLifetimeInfo::operator=(DataLayerLifetimeInfo&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_lifetime_);
    else
        m_isInitialized = false;

    return *this;
}

DataLayerLifetimeInfo::DataLayerLifetimeInfo(::zserio::PropagateAllocatorT,
        const DataLayerLifetimeInfo& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_lifetime_);
    else
        m_isInitialized = false;
}

void DataLayerLifetimeInfo::initialize(
        ::nds::smart::types::DataLayerLifetimeType lifetime_)
{
    m_lifetime_ = lifetime_;
    m_isInitialized = true;
}

bool DataLayerLifetimeInfo::isInitialized() const
{
    return m_isInitialized;
}

::nds::smart::types::DataLayerLifetimeType DataLayerLifetimeInfo::getLifetime() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'lifetime' of compound 'DataLayerLifetimeInfo' is not initialized!");

    return m_lifetime_;
}

::nds::core::types::VersionId DataLayerLifetimeInfo::getVersionId() const
{
    return m_objectChoice.get<::nds::core::types::VersionId>();
}

void DataLayerLifetimeInfo::setVersionId(::nds::core::types::VersionId versionId_)
{
    m_objectChoice = versionId_;
}

::nds::smart::types::DynamicDataLifetimeInfo& DataLayerLifetimeInfo::getDynamicDataLifetimeInfo()
{
    return m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>();
}

const ::nds::smart::types::DynamicDataLifetimeInfo& DataLayerLifetimeInfo::getDynamicDataLifetimeInfo() const
{
    return m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>();
}

void DataLayerLifetimeInfo::setDynamicDataLifetimeInfo(const ::nds::smart::types::DynamicDataLifetimeInfo& dynamicDataLifetimeInfo_)
{
    m_objectChoice = dynamicDataLifetimeInfo_;
}

void DataLayerLifetimeInfo::setDynamicDataLifetimeInfo(::nds::smart::types::DynamicDataLifetimeInfo&& dynamicDataLifetimeInfo_)
{
    m_objectChoice = ::std::move(dynamicDataLifetimeInfo_);
}

DataLayerLifetimeInfo::ChoiceTag DataLayerLifetimeInfo::choiceTag() const
{
    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        return CHOICE_versionId;
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        return CHOICE_dynamicDataLifetimeInfo;
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        return UNDEFINED_CHOICE;
    default:
        return UNDEFINED_CHOICE;
    }
}

void DataLayerLifetimeInfo::initPackingContext(DataLayerLifetimeInfo::ZserioPackingContext& context) const
{
    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        context.getVersionId().init<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(m_objectChoice.get<::nds::core::types::VersionId>());
        break;
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>().initPackingContext(context.getDynamicDataLifetimeInfo());
        break;
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }
}

size_t DataLayerLifetimeInfo::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_objectChoice.get<::nds::core::types::VersionId>());
        break;
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        endBitPosition += m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>().bitSizeOf(endBitPosition);
        break;
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }

    return endBitPosition - bitPosition;
}

size_t DataLayerLifetimeInfo::bitSizeOf(DataLayerLifetimeInfo::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        endBitPosition += context.getVersionId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(m_objectChoice.get<::nds::core::types::VersionId>());
        break;
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        endBitPosition += m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>().bitSizeOf(context.getDynamicDataLifetimeInfo(), endBitPosition);
        break;
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }

    return endBitPosition - bitPosition;
}

size_t DataLayerLifetimeInfo::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_objectChoice.get<::nds::core::types::VersionId>());
        break;
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        endBitPosition = m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>().initializeOffsets(endBitPosition);
        break;
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }

    return endBitPosition;
}

size_t DataLayerLifetimeInfo::initializeOffsets(DataLayerLifetimeInfo::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        endBitPosition += context.getVersionId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(m_objectChoice.get<::nds::core::types::VersionId>());
        break;
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        endBitPosition = m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>().initializeOffsets(context.getDynamicDataLifetimeInfo(), endBitPosition);
        break;
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }

    return endBitPosition;
}

bool DataLayerLifetimeInfo::operator==(const DataLayerLifetimeInfo& other) const
{
    if (this == &other)
        return true;

    if (!(getLifetime() == other.getLifetime()))
        return false;

    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::types::VersionId>() == other.m_objectChoice.get<::nds::core::types::VersionId>());
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>() == other.m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>());
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        return true; // empty
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }
}

uint32_t DataLayerLifetimeInfo::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getLifetime());
    if (m_objectChoice.hasValue())
    {
        switch (getLifetime())
        {
        case ::nds::smart::types::DataLayerLifetimeType::STATIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::types::VersionId>());
            break;
        case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>());
            break;
        case ::nds::smart::types::DataLayerLifetimeType::LIVE:
            // empty
            break;
        default:
            break;
        }
    }

    return result;
}

void DataLayerLifetimeInfo::write(::zserio::BitStreamWriter& out) const
{
    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        out.writeVarUInt(m_objectChoice.get<::nds::core::types::VersionId>());
        break;
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>().write(out);
        break;
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }
}

void DataLayerLifetimeInfo::write(DataLayerLifetimeInfo::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        context.getVersionId().write<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(out, m_objectChoice.get<::nds::core::types::VersionId>());
        break;
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        m_objectChoice.get<::nds::smart::types::DynamicDataLifetimeInfo>().write(context.getDynamicDataLifetimeInfo(), out);
        break;
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }
}

::zserio::AnyHolder<> DataLayerLifetimeInfo::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::core::types::VersionId>(in.readVarUInt()), allocator);
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        return ::zserio::AnyHolder<>(::nds::smart::types::DynamicDataLifetimeInfo(in, allocator), allocator);
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        return ::zserio::AnyHolder<>(allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }
}

::zserio::AnyHolder<> DataLayerLifetimeInfo::readObject(DataLayerLifetimeInfo::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        return ::zserio::AnyHolder<>(context.getVersionId().read<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(in), allocator);
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        return ::zserio::AnyHolder<>(::nds::smart::types::DynamicDataLifetimeInfo(context.getDynamicDataLifetimeInfo(), in, allocator), allocator);
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        return ::zserio::AnyHolder<>(allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }
}

::zserio::AnyHolder<> DataLayerLifetimeInfo::copyObject(const allocator_type& allocator) const
{
    switch (getLifetime())
    {
    case ::nds::smart::types::DataLayerLifetimeType::STATIC:
        return ::zserio::allocatorPropagatingCopy<::nds::core::types::VersionId>(m_objectChoice, allocator);
    case ::nds::smart::types::DataLayerLifetimeType::DYNAMIC:
        return ::zserio::allocatorPropagatingCopy<::nds::smart::types::DynamicDataLifetimeInfo>(m_objectChoice, allocator);
    case ::nds::smart::types::DataLayerLifetimeType::LIVE:
        return ::zserio::AnyHolder<>(allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DataLayerLifetimeInfo!");
    }
}

} // namespace types
} // namespace smart
} // namespace nds
