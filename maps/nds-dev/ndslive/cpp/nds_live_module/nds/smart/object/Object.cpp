/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/object/SmartLayerObjectList.h>

namespace nds
{
namespace smart
{
namespace object
{

SmartLayerObjectList::SmartLayerObjectList(const allocator_type& allocator) noexcept :
        m_list_(allocator)
{
}

SmartLayerObjectList::SmartLayerObjectList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_list_(readList(in, allocator))
{
}

SmartLayerObjectList::SmartLayerObjectList(SmartLayerObjectList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_list_(readList(context, in, allocator))
{
}

SmartLayerObjectList::SmartLayerObjectList(::zserio::PropagateAllocatorT,
        const SmartLayerObjectList& other, const allocator_type& allocator) :
        m_list_(::zserio::allocatorPropagatingCopy(other.m_list_, allocator))
{
}

void SmartLayerObjectList::initializeChildren()
{
    m_list_.initializeElements(*this);
}

::zserio::vector<::nds::smart::object::SmartLayerObject>& SmartLayerObjectList::getList()
{
    return m_list_.getRawArray();
}

const ::zserio::vector<::nds::smart::object::SmartLayerObject>& SmartLayerObjectList::getList() const
{
    return m_list_.getRawArray();
}

void SmartLayerObjectList::setList(const ::zserio::vector<::nds::smart::object::SmartLayerObject>& list_)
{
    m_list_ = ZserioArrayType_list(list_);
}

void SmartLayerObjectList::setList(::zserio::vector<::nds::smart::object::SmartLayerObject>&& list_)
{
    m_list_ = ZserioArrayType_list(std::move(list_));
}

void SmartLayerObjectList::initPackingContext(SmartLayerObjectList::ZserioPackingContext&) const
{
}

size_t SmartLayerObjectList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_list_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectList::bitSizeOf(SmartLayerObjectList::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_list_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_list_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerObjectList::initializeOffsets(SmartLayerObjectList::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_list_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerObjectList::operator==(const SmartLayerObjectList& other) const
{
    if (this != &other)
    {
        return
                (m_list_ == other.m_list_);
    }

    return true;
}

uint32_t SmartLayerObjectList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_list_);

    return result;
}

void SmartLayerObjectList::write(::zserio::BitStreamWriter& out) const
{
    m_list_.write(*this, out);
}

void SmartLayerObjectList::write(SmartLayerObjectList::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_list_.writePacked(*this, out);
}

void SmartLayerObjectList::ZserioArrayExpressions_list::initializeElement(SmartLayerObjectList&,
        ::nds::smart::object::SmartLayerObject& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerObjectList::ZserioElementFactory_list::create(SmartLayerObjectList&        ,
        ::zserio::vector<::nds::smart::object::SmartLayerObject>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerObjectList::ZserioElementFactory_list::create(SmartLayerObjectList&        ,
        ::zserio::vector<::nds::smart::object::SmartLayerObject>& array,
        ::nds::smart::object::SmartLayerObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

SmartLayerObjectList::ZserioArrayType_list SmartLayerObjectList::readList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_list readField(allocator);
    readField.read(*this, in);

    return readField;
}

SmartLayerObjectList::ZserioArrayType_list SmartLayerObjectList::readList(SmartLayerObjectList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_list readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace object
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/object/SmartLayerObject.h>

namespace nds
{
namespace smart
{
namespace object
{

SmartLayerObject::SmartLayerObject(const allocator_type& allocator) noexcept :
        m_id_(::nds::smart::object::SmartLayerObjectId()),
        m_header_(allocator),
        m_layers_(allocator)
{
}

SmartLayerObject::SmartLayerObject(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in)),
        m_header_(readHeader(in, allocator)),
        m_layers_(readLayers(in, allocator))
{
}

SmartLayerObject::SmartLayerObject(SmartLayerObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_layers_(readLayers(in, allocator))
{
}

SmartLayerObject::SmartLayerObject(::zserio::PropagateAllocatorT,
        const SmartLayerObject& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_layers_(::zserio::allocatorPropagatingCopy(other.m_layers_, allocator))
{
}

void SmartLayerObject::initializeChildren()
{
    m_header_.initializeChildren();
}

::nds::smart::object::SmartLayerObjectId SmartLayerObject::getId() const
{
    return m_id_;
}

void SmartLayerObject::setId(::nds::smart::object::SmartLayerObjectId id_)
{
    m_id_ = id_;
}

::nds::smart::types::SmartLayerHeader& SmartLayerObject::getHeader()
{
    return m_header_;
}

const ::nds::smart::types::SmartLayerHeader& SmartLayerObject::getHeader() const
{
    return m_header_;
}

void SmartLayerObject::setHeader(const ::nds::smart::types::SmartLayerHeader& header_)
{
    m_header_ = header_;
}

void SmartLayerObject::setHeader(::nds::smart::types::SmartLayerHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::smart::types::DataLayer>& SmartLayerObject::getLayers()
{
    return m_layers_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayer>& SmartLayerObject::getLayers() const
{
    return m_layers_.getRawArray();
}

void SmartLayerObject::setLayers(const ::zserio::vector<::nds::smart::types::DataLayer>& layers_)
{
    m_layers_ = ZserioArrayType_layers(layers_);
}

void SmartLayerObject::setLayers(::zserio::vector<::nds::smart::types::DataLayer>&& layers_)
{
    m_layers_ = ZserioArrayType_layers(std::move(layers_));
}

void SmartLayerObject::initPackingContext(SmartLayerObject::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(m_id_);
    m_header_.initPackingContext(context.getHeader());
}

size_t SmartLayerObject::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_id_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObject::bitSizeOf(SmartLayerObject::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(m_id_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_layers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObject::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_id_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerObject::initializeOffsets(SmartLayerObject::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(m_id_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_layers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerObject::operator==(const SmartLayerObject& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_header_ == other.m_header_) &&
                (m_layers_ == other.m_layers_);
    }

    return true;
}

uint32_t SmartLayerObject::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_layers_);

    return result;
}

void SmartLayerObject::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt(m_id_);

    m_header_.write(out);

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getHeader().getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObject.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getHeader().getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void SmartLayerObject::write(SmartLayerObject::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(out, m_id_);

    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_layers_.getRawArray().size() != static_cast<size_t>(getHeader().getNumDataLayers()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObject.layers: ") <<
                m_layers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getHeader().getNumDataLayers()) << "!";
    }
    m_layers_.write(*this, out);
}

void SmartLayerObject::ZserioElementFactory_layers::create(SmartLayerObject&        ,
        ::zserio::vector<::nds::smart::types::DataLayer>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

::nds::smart::object::SmartLayerObjectId SmartLayerObject::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::smart::object::SmartLayerObjectId>(in.readVarUInt());
}

::nds::smart::object::SmartLayerObjectId SmartLayerObject::readId(SmartLayerObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(in);
}
::nds::smart::types::SmartLayerHeader SmartLayerObject::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::types::SmartLayerHeader(in, allocator);
}

::nds::smart::types::SmartLayerHeader SmartLayerObject::readHeader(SmartLayerObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::types::SmartLayerHeader(context.getHeader(), in, allocator);
}
SmartLayerObject::ZserioArrayType_layers SmartLayerObject::readLayers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_layers readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getHeader().getNumDataLayers()));

    return readField;
}

} // namespace object
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/object/SmartLayerObjectReferenceList.h>

namespace nds
{
namespace smart
{
namespace object
{

SmartLayerObjectReferenceList::SmartLayerObjectReferenceList(const allocator_type& allocator) noexcept :
        m_numObjects_(uint32_t()),
        m_list_(allocator),
        m_extent_(::zserio::NullOpt)
{
}

SmartLayerObjectReferenceList::SmartLayerObjectReferenceList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numObjects_(readNumObjects(in)),
        m_list_(readList(in, allocator)),
        m_extent_(readExtent(in, allocator))
{
}

SmartLayerObjectReferenceList::SmartLayerObjectReferenceList(SmartLayerObjectReferenceList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numObjects_(readNumObjects(context, in)),
        m_list_(readList(context, in, allocator)),
        m_extent_(readExtent(context, in, allocator))
{
}

SmartLayerObjectReferenceList::SmartLayerObjectReferenceList(::zserio::PropagateAllocatorT,
        const SmartLayerObjectReferenceList& other, const allocator_type& allocator) :
        m_numObjects_(::zserio::allocatorPropagatingCopy(other.m_numObjects_, allocator)),
        m_list_(::zserio::allocatorPropagatingCopy(other.m_list_, allocator)),
        m_extent_(::zserio::allocatorPropagatingCopy(other.m_extent_, allocator))
{
}

void SmartLayerObjectReferenceList::initializeChildren()
{
    if (isExtentSet())
        m_extent_.value().initializeElements(*this);
}

uint32_t SmartLayerObjectReferenceList::getNumObjects() const
{
    return m_numObjects_;
}

void SmartLayerObjectReferenceList::setNumObjects(uint32_t numObjects_)
{
    m_numObjects_ = numObjects_;
}

::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& SmartLayerObjectReferenceList::getList()
{
    return m_list_.getRawArray();
}

const ::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& SmartLayerObjectReferenceList::getList() const
{
    return m_list_.getRawArray();
}

void SmartLayerObjectReferenceList::setList(const ::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& list_)
{
    m_list_ = ZserioArrayType_list(list_);
}

void SmartLayerObjectReferenceList::setList(::zserio::vector<::nds::smart::object::SmartLayerObjectReference>&& list_)
{
    m_list_ = ZserioArrayType_list(std::move(list_));
}

::zserio::vector<::nds::core::geometry::SpatialExtent>& SmartLayerObjectReferenceList::getExtent()
{
    return m_extent_.value().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::SpatialExtent>& SmartLayerObjectReferenceList::getExtent() const
{
    return m_extent_.value().getRawArray();
}

void SmartLayerObjectReferenceList::setExtent(const ::zserio::vector<::nds::core::geometry::SpatialExtent>& extent_)
{
    m_extent_ = ZserioArrayType_extent(extent_);
}

void SmartLayerObjectReferenceList::setExtent(::zserio::vector<::nds::core::geometry::SpatialExtent>&& extent_)
{
    m_extent_ = ZserioArrayType_extent(std::move(extent_));
}

bool SmartLayerObjectReferenceList::isExtentUsed() const
{
    return (isExtentSet());
}

bool SmartLayerObjectReferenceList::isExtentSet() const
{
    return m_extent_.hasValue();
}

void SmartLayerObjectReferenceList::resetExtent()
{
    m_extent_.reset();
}

void SmartLayerObjectReferenceList::initPackingContext(SmartLayerObjectReferenceList::ZserioPackingContext& context) const
{
    context.getNumObjects().init<::zserio::VarSizeArrayTraits>(m_numObjects_);
}

size_t SmartLayerObjectReferenceList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numObjects_);
    endBitPosition += m_list_.bitSizeOf(*this, endBitPosition);
    endBitPosition += 1;
    if (isExtentSet())
    {
        endBitPosition += m_extent_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectReferenceList::bitSizeOf(SmartLayerObjectReferenceList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumObjects().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numObjects_);
    endBitPosition += m_list_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isExtentSet())
    {
        endBitPosition += m_extent_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectReferenceList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numObjects_);
    endBitPosition = m_list_.initializeOffsets(*this, endBitPosition);
    endBitPosition += 1;
    if (isExtentSet())
    {
        endBitPosition = m_extent_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t SmartLayerObjectReferenceList::initializeOffsets(SmartLayerObjectReferenceList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumObjects().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numObjects_);
    endBitPosition = m_list_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isExtentSet())
    {
        endBitPosition = m_extent_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool SmartLayerObjectReferenceList::operator==(const SmartLayerObjectReferenceList& other) const
{
    if (this != &other)
    {
        return
                (m_numObjects_ == other.m_numObjects_) &&
                (m_list_ == other.m_list_) &&
                (!isExtentUsed() ? !other.isExtentUsed() : (m_extent_ == other.m_extent_));
    }

    return true;
}

uint32_t SmartLayerObjectReferenceList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numObjects_);
    result = ::zserio::calcHashCode(result, m_list_);
    if (isExtentUsed())
        result = ::zserio::calcHashCode(result, m_extent_);

    return result;
}

void SmartLayerObjectReferenceList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numObjects_);

    // check array length
    if (m_list_.getRawArray().size() != static_cast<size_t>(getNumObjects()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObjectReferenceList.list: ") <<
                m_list_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumObjects()) << "!";
    }
    m_list_.write(*this, out);

    if (isExtentSet())
    {
        out.writeBool(true);
        // check array length
        if (m_extent_.value().getRawArray().size() != static_cast<size_t>(getNumObjects()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObjectReferenceList.extent: ") <<
                    m_extent_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumObjects()) << "!";
        }
        m_extent_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void SmartLayerObjectReferenceList::write(SmartLayerObjectReferenceList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumObjects().write<::zserio::VarSizeArrayTraits>(out, m_numObjects_);

    // check array length
    if (m_list_.getRawArray().size() != static_cast<size_t>(getNumObjects()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObjectReferenceList.list: ") <<
                m_list_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumObjects()) << "!";
    }
    m_list_.writePacked(*this, out);

    if (isExtentSet())
    {
        out.writeBool(true);
        // check array length
        if (m_extent_.value().getRawArray().size() != static_cast<size_t>(getNumObjects()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObjectReferenceList.extent: ") <<
                    m_extent_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumObjects()) << "!";
        }
        m_extent_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void SmartLayerObjectReferenceList::ZserioElementFactory_list::create(SmartLayerObjectReferenceList&        ,
        ::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerObjectReferenceList::ZserioElementFactory_list::create(SmartLayerObjectReferenceList&        ,
        ::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& array,
        ::nds::smart::object::SmartLayerObjectReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void SmartLayerObjectReferenceList::ZserioArrayExpressions_extent::initializeElement(SmartLayerObjectReferenceList&,
        ::nds::core::geometry::SpatialExtent& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerObjectReferenceList::ZserioElementFactory_extent::create(SmartLayerObjectReferenceList&        ,
        ::zserio::vector<::nds::core::geometry::SpatialExtent>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerObjectReferenceList::ZserioElementFactory_extent::create(SmartLayerObjectReferenceList&        ,
        ::zserio::vector<::nds::core::geometry::SpatialExtent>& array,
        ::nds::core::geometry::SpatialExtent::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t SmartLayerObjectReferenceList::readNumObjects(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t SmartLayerObjectReferenceList::readNumObjects(SmartLayerObjectReferenceList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumObjects().read<::zserio::VarSizeArrayTraits>(in);
}
SmartLayerObjectReferenceList::ZserioArrayType_list SmartLayerObjectReferenceList::readList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_list readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumObjects()));

    return readField;
}

SmartLayerObjectReferenceList::ZserioArrayType_list SmartLayerObjectReferenceList::readList(SmartLayerObjectReferenceList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_list readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumObjects()));

    return readField;
}
::zserio::InplaceOptionalHolder<SmartLayerObjectReferenceList::ZserioArrayType_extent> SmartLayerObjectReferenceList::readExtent(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_extent readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumObjects()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_extent>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_extent>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<SmartLayerObjectReferenceList::ZserioArrayType_extent> SmartLayerObjectReferenceList::readExtent(SmartLayerObjectReferenceList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_extent readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumObjects()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_extent>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_extent>(::zserio::NullOpt);
}

} // namespace object
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/object/SmartLayerObjectReference.h>

namespace nds
{
namespace smart
{
namespace object
{

SmartLayerObjectReference::SmartLayerObjectReference(const allocator_type&) noexcept :
        m_id_(::nds::smart::object::SmartLayerObjectId())
{
}

SmartLayerObjectReference::SmartLayerObjectReference(::zserio::BitStreamReader& in, const allocator_type&) :
        m_id_(readId(in))
{
}

SmartLayerObjectReference::SmartLayerObjectReference(SmartLayerObjectReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_id_(readId(context, in))
{
}

SmartLayerObjectReference::SmartLayerObjectReference(::zserio::PropagateAllocatorT,
        const SmartLayerObjectReference& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator))
{
}

::nds::smart::object::SmartLayerObjectId SmartLayerObjectReference::getId() const
{
    return m_id_;
}

void SmartLayerObjectReference::setId(::nds::smart::object::SmartLayerObjectId id_)
{
    m_id_ = id_;
}

void SmartLayerObjectReference::initPackingContext(SmartLayerObjectReference::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(m_id_);
}

size_t SmartLayerObjectReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_id_);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectReference::bitSizeOf(SmartLayerObjectReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(m_id_);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_id_);

    return endBitPosition;
}

size_t SmartLayerObjectReference::initializeOffsets(SmartLayerObjectReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(m_id_);

    return endBitPosition;
}

bool SmartLayerObjectReference::operator==(const SmartLayerObjectReference& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_);
    }

    return true;
}

uint32_t SmartLayerObjectReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);

    return result;
}

void SmartLayerObjectReference::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt(m_id_);
}

void SmartLayerObjectReference::write(SmartLayerObjectReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(out, m_id_);
}

::nds::smart::object::SmartLayerObjectId SmartLayerObjectReference::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::smart::object::SmartLayerObjectId>(in.readVarUInt());
}

::nds::smart::object::SmartLayerObjectId SmartLayerObjectReference::readId(SmartLayerObjectReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::VarIntArrayTraits<::nds::smart::object::SmartLayerObjectId>>(in);
}

} // namespace object
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/object/SmartLayerObjectDefinition.h>

namespace nds
{
namespace smart
{
namespace object
{

SmartLayerObjectDefinition::SmartLayerObjectDefinition(const allocator_type& allocator) noexcept :
        m_smartObjectClass_(::nds::smart::object::SmartLayerObjectClass()),
        m_smartLayerDefinition_(allocator)
{
}

SmartLayerObjectDefinition::SmartLayerObjectDefinition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_smartObjectClass_(readSmartObjectClass(in)),
        m_smartLayerDefinition_(readSmartLayerDefinition(in, allocator))
{
}

SmartLayerObjectDefinition::SmartLayerObjectDefinition(SmartLayerObjectDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_smartObjectClass_(readSmartObjectClass(context, in)),
        m_smartLayerDefinition_(readSmartLayerDefinition(context, in, allocator))
{
}

SmartLayerObjectDefinition::SmartLayerObjectDefinition(::zserio::PropagateAllocatorT,
        const SmartLayerObjectDefinition& other, const allocator_type& allocator) :
        m_smartObjectClass_(::zserio::allocatorPropagatingCopy(other.m_smartObjectClass_, allocator)),
        m_smartLayerDefinition_(::zserio::allocatorPropagatingCopy(other.m_smartLayerDefinition_, allocator))
{
}

::nds::smart::object::SmartLayerObjectClass SmartLayerObjectDefinition::getSmartObjectClass() const
{
    return m_smartObjectClass_;
}

void SmartLayerObjectDefinition::setSmartObjectClass(::nds::smart::object::SmartLayerObjectClass smartObjectClass_)
{
    m_smartObjectClass_ = smartObjectClass_;
}

::nds::smart::metadata::SmartLayerDefinition& SmartLayerObjectDefinition::getSmartLayerDefinition()
{
    return m_smartLayerDefinition_;
}

const ::nds::smart::metadata::SmartLayerDefinition& SmartLayerObjectDefinition::getSmartLayerDefinition() const
{
    return m_smartLayerDefinition_;
}

void SmartLayerObjectDefinition::setSmartLayerDefinition(const ::nds::smart::metadata::SmartLayerDefinition& smartLayerDefinition_)
{
    m_smartLayerDefinition_ = smartLayerDefinition_;
}

void SmartLayerObjectDefinition::setSmartLayerDefinition(::nds::smart::metadata::SmartLayerDefinition&& smartLayerDefinition_)
{
    m_smartLayerDefinition_ = ::std::move(smartLayerDefinition_);
}

void SmartLayerObjectDefinition::initPackingContext(SmartLayerObjectDefinition::ZserioPackingContext& context) const
{
    context.getSmartObjectClass().init<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(m_smartObjectClass_);
    m_smartLayerDefinition_.initPackingContext(context.getSmartLayerDefinition());
}

size_t SmartLayerObjectDefinition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_smartObjectClass_);
    endBitPosition += m_smartLayerDefinition_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectDefinition::bitSizeOf(SmartLayerObjectDefinition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getSmartObjectClass().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(m_smartObjectClass_);
    endBitPosition += m_smartLayerDefinition_.bitSizeOf(context.getSmartLayerDefinition(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectDefinition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_smartObjectClass_);
    endBitPosition = m_smartLayerDefinition_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t SmartLayerObjectDefinition::initializeOffsets(SmartLayerObjectDefinition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getSmartObjectClass().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(m_smartObjectClass_);
    endBitPosition = m_smartLayerDefinition_.initializeOffsets(context.getSmartLayerDefinition(), endBitPosition);

    return endBitPosition;
}

bool SmartLayerObjectDefinition::operator==(const SmartLayerObjectDefinition& other) const
{
    if (this != &other)
    {
        return
                (m_smartObjectClass_ == other.m_smartObjectClass_) &&
                (m_smartLayerDefinition_ == other.m_smartLayerDefinition_);
    }

    return true;
}

uint32_t SmartLayerObjectDefinition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_smartObjectClass_);
    result = ::zserio::calcHashCode(result, m_smartLayerDefinition_);

    return result;
}

void SmartLayerObjectDefinition::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_smartObjectClass_);
    m_smartLayerDefinition_.write(out);
}

void SmartLayerObjectDefinition::write(SmartLayerObjectDefinition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getSmartObjectClass().write<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(out, m_smartObjectClass_);
    m_smartLayerDefinition_.write(context.getSmartLayerDefinition(), out);
}

::nds::smart::object::SmartLayerObjectClass SmartLayerObjectDefinition::readSmartObjectClass(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::smart::object::SmartLayerObjectClass>(in.readVarUInt32());
}

::nds::smart::object::SmartLayerObjectClass SmartLayerObjectDefinition::readSmartObjectClass(SmartLayerObjectDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getSmartObjectClass().read<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(in);
}
::nds::smart::metadata::SmartLayerDefinition SmartLayerObjectDefinition::readSmartLayerDefinition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::metadata::SmartLayerDefinition(in, allocator);
}

::nds::smart::metadata::SmartLayerDefinition SmartLayerObjectDefinition::readSmartLayerDefinition(SmartLayerObjectDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::metadata::SmartLayerDefinition(context.getSmartLayerDefinition(), in, allocator);
}

} // namespace object
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/object/DataLayerObjectVersionRequest.h>

namespace nds
{
namespace smart
{
namespace object
{

DataLayerObjectVersionRequest::DataLayerObjectVersionRequest(const allocator_type& allocator) noexcept :
        m_objectReference_(allocator),
        m_layerId_(::nds::smart::types::DataLayerId()),
        m_lifetimeInfo_(allocator)
{
}

DataLayerObjectVersionRequest::DataLayerObjectVersionRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_objectReference_(readObjectReference(in, allocator)),
        m_layerId_(readLayerId(in)),
        m_lifetimeInfo_(readLifetimeInfo(in, allocator))
{
}

DataLayerObjectVersionRequest::DataLayerObjectVersionRequest(DataLayerObjectVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_objectReference_(readObjectReference(context, in, allocator)),
        m_layerId_(readLayerId(context, in)),
        m_lifetimeInfo_(readLifetimeInfo(context, in, allocator))
{
}

DataLayerObjectVersionRequest::DataLayerObjectVersionRequest(::zserio::PropagateAllocatorT,
        const DataLayerObjectVersionRequest& other, const allocator_type& allocator) :
        m_objectReference_(::zserio::allocatorPropagatingCopy(other.m_objectReference_, allocator)),
        m_layerId_(::zserio::allocatorPropagatingCopy(other.m_layerId_, allocator)),
        m_lifetimeInfo_(::zserio::allocatorPropagatingCopy(other.m_lifetimeInfo_, allocator))
{
}

void DataLayerObjectVersionRequest::initializeChildren()
{
    m_lifetimeInfo_.initializeChildren();
}

::nds::smart::object::SmartLayerObjectReference& DataLayerObjectVersionRequest::getObjectReference()
{
    return m_objectReference_;
}

const ::nds::smart::object::SmartLayerObjectReference& DataLayerObjectVersionRequest::getObjectReference() const
{
    return m_objectReference_;
}

void DataLayerObjectVersionRequest::setObjectReference(const ::nds::smart::object::SmartLayerObjectReference& objectReference_)
{
    m_objectReference_ = objectReference_;
}

void DataLayerObjectVersionRequest::setObjectReference(::nds::smart::object::SmartLayerObjectReference&& objectReference_)
{
    m_objectReference_ = ::std::move(objectReference_);
}

::nds::smart::types::DataLayerId DataLayerObjectVersionRequest::getLayerId() const
{
    return m_layerId_;
}

void DataLayerObjectVersionRequest::setLayerId(::nds::smart::types::DataLayerId layerId_)
{
    m_layerId_ = layerId_;
}

::nds::smart::types::DataLayerLifetime& DataLayerObjectVersionRequest::getLifetimeInfo()
{
    return m_lifetimeInfo_;
}

const ::nds::smart::types::DataLayerLifetime& DataLayerObjectVersionRequest::getLifetimeInfo() const
{
    return m_lifetimeInfo_;
}

void DataLayerObjectVersionRequest::setLifetimeInfo(const ::nds::smart::types::DataLayerLifetime& lifetimeInfo_)
{
    m_lifetimeInfo_ = lifetimeInfo_;
}

void DataLayerObjectVersionRequest::setLifetimeInfo(::nds::smart::types::DataLayerLifetime&& lifetimeInfo_)
{
    m_lifetimeInfo_ = ::std::move(lifetimeInfo_);
}

void DataLayerObjectVersionRequest::initPackingContext(DataLayerObjectVersionRequest::ZserioPackingContext& context) const
{
    m_objectReference_.initPackingContext(context.getObjectReference());
    context.getLayerId().init<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(m_layerId_);
    m_lifetimeInfo_.initPackingContext(context.getLifetimeInfo());
}

size_t DataLayerObjectVersionRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_objectReference_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_layerId_);
    endBitPosition += m_lifetimeInfo_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DataLayerObjectVersionRequest::bitSizeOf(DataLayerObjectVersionRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_objectReference_.bitSizeOf(context.getObjectReference(), endBitPosition);
    endBitPosition += context.getLayerId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(m_layerId_);
    endBitPosition += m_lifetimeInfo_.bitSizeOf(context.getLifetimeInfo(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DataLayerObjectVersionRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_objectReference_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_layerId_);
    endBitPosition = m_lifetimeInfo_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t DataLayerObjectVersionRequest::initializeOffsets(DataLayerObjectVersionRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_objectReference_.initializeOffsets(context.getObjectReference(), endBitPosition);
    endBitPosition += context.getLayerId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(m_layerId_);
    endBitPosition = m_lifetimeInfo_.initializeOffsets(context.getLifetimeInfo(), endBitPosition);

    return endBitPosition;
}

bool DataLayerObjectVersionRequest::operator==(const DataLayerObjectVersionRequest& other) const
{
    if (this != &other)
    {
        return
                (m_objectReference_ == other.m_objectReference_) &&
                (m_layerId_ == other.m_layerId_) &&
                (m_lifetimeInfo_ == other.m_lifetimeInfo_);
    }

    return true;
}

uint32_t DataLayerObjectVersionRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_objectReference_);
    result = ::zserio::calcHashCode(result, m_layerId_);
    result = ::zserio::calcHashCode(result, m_lifetimeInfo_);

    return result;
}

void DataLayerObjectVersionRequest::write(::zserio::BitStreamWriter& out) const
{
    m_objectReference_.write(out);
    out.writeVarUInt16(m_layerId_);
    m_lifetimeInfo_.write(out);
}

void DataLayerObjectVersionRequest::write(DataLayerObjectVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_objectReference_.write(context.getObjectReference(), out);
    context.getLayerId().write<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(out, m_layerId_);
    m_lifetimeInfo_.write(context.getLifetimeInfo(), out);
}

::nds::smart::object::SmartLayerObjectReference DataLayerObjectVersionRequest::readObjectReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::object::SmartLayerObjectReference(in, allocator);
}

::nds::smart::object::SmartLayerObjectReference DataLayerObjectVersionRequest::readObjectReference(DataLayerObjectVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::object::SmartLayerObjectReference(context.getObjectReference(), in, allocator);
}
::nds::smart::types::DataLayerId DataLayerObjectVersionRequest::readLayerId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::smart::types::DataLayerId>(in.readVarUInt16());
}

::nds::smart::types::DataLayerId DataLayerObjectVersionRequest::readLayerId(DataLayerObjectVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLayerId().read<::zserio::VarIntNNArrayTraits<::nds::smart::types::DataLayerId>>(in);
}
::nds::smart::types::DataLayerLifetime DataLayerObjectVersionRequest::readLifetimeInfo(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::types::DataLayerLifetime(in, allocator);
}

::nds::smart::types::DataLayerLifetime DataLayerObjectVersionRequest::readLifetimeInfo(DataLayerObjectVersionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::types::DataLayerLifetime(context.getLifetimeInfo(), in, allocator);
}

} // namespace object
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/object/SmartLayerObjectHeaderList.h>

namespace nds
{
namespace smart
{
namespace object
{

SmartLayerObjectHeaderList::SmartLayerObjectHeaderList(const allocator_type& allocator) noexcept :
        m_numObjects_(uint32_t()),
        m_references_(allocator),
        m_headers_(allocator)
{
}

SmartLayerObjectHeaderList::SmartLayerObjectHeaderList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numObjects_(readNumObjects(in)),
        m_references_(readReferences(in, allocator)),
        m_headers_(readHeaders(in, allocator))
{
}

SmartLayerObjectHeaderList::SmartLayerObjectHeaderList(SmartLayerObjectHeaderList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numObjects_(readNumObjects(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_headers_(readHeaders(context, in, allocator))
{
}

SmartLayerObjectHeaderList::SmartLayerObjectHeaderList(::zserio::PropagateAllocatorT,
        const SmartLayerObjectHeaderList& other, const allocator_type& allocator) :
        m_numObjects_(::zserio::allocatorPropagatingCopy(other.m_numObjects_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_headers_(::zserio::allocatorPropagatingCopy(other.m_headers_, allocator))
{
}

void SmartLayerObjectHeaderList::initializeChildren()
{
    m_headers_.initializeElements(*this);
}

uint32_t SmartLayerObjectHeaderList::getNumObjects() const
{
    return m_numObjects_;
}

void SmartLayerObjectHeaderList::setNumObjects(uint32_t numObjects_)
{
    m_numObjects_ = numObjects_;
}

::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& SmartLayerObjectHeaderList::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& SmartLayerObjectHeaderList::getReferences() const
{
    return m_references_.getRawArray();
}

void SmartLayerObjectHeaderList::setReferences(const ::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void SmartLayerObjectHeaderList::setReferences(::zserio::vector<::nds::smart::object::SmartLayerObjectReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::smart::types::SmartLayerHeader>& SmartLayerObjectHeaderList::getHeaders()
{
    return m_headers_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::SmartLayerHeader>& SmartLayerObjectHeaderList::getHeaders() const
{
    return m_headers_.getRawArray();
}

void SmartLayerObjectHeaderList::setHeaders(const ::zserio::vector<::nds::smart::types::SmartLayerHeader>& headers_)
{
    m_headers_ = ZserioArrayType_headers(headers_);
}

void SmartLayerObjectHeaderList::setHeaders(::zserio::vector<::nds::smart::types::SmartLayerHeader>&& headers_)
{
    m_headers_ = ZserioArrayType_headers(std::move(headers_));
}

void SmartLayerObjectHeaderList::initPackingContext(SmartLayerObjectHeaderList::ZserioPackingContext& context) const
{
    context.getNumObjects().init<::zserio::VarSizeArrayTraits>(m_numObjects_);
}

size_t SmartLayerObjectHeaderList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numObjects_);
    endBitPosition += m_references_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_headers_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectHeaderList::bitSizeOf(SmartLayerObjectHeaderList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumObjects().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numObjects_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_headers_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerObjectHeaderList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numObjects_);
    endBitPosition = m_references_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_headers_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerObjectHeaderList::initializeOffsets(SmartLayerObjectHeaderList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumObjects().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numObjects_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_headers_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerObjectHeaderList::operator==(const SmartLayerObjectHeaderList& other) const
{
    if (this != &other)
    {
        return
                (m_numObjects_ == other.m_numObjects_) &&
                (m_references_ == other.m_references_) &&
                (m_headers_ == other.m_headers_);
    }

    return true;
}

uint32_t SmartLayerObjectHeaderList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numObjects_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_headers_);

    return result;
}

void SmartLayerObjectHeaderList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numObjects_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getNumObjects()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObjectHeaderList.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumObjects()) << "!";
    }
    m_references_.write(*this, out);

    // check array length
    if (m_headers_.getRawArray().size() != static_cast<size_t>(getNumObjects()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObjectHeaderList.headers: ") <<
                m_headers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumObjects()) << "!";
    }
    m_headers_.write(*this, out);
}

void SmartLayerObjectHeaderList::write(SmartLayerObjectHeaderList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumObjects().write<::zserio::VarSizeArrayTraits>(out, m_numObjects_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getNumObjects()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObjectHeaderList.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumObjects()) << "!";
    }
    m_references_.writePacked(*this, out);

    // check array length
    if (m_headers_.getRawArray().size() != static_cast<size_t>(getNumObjects()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerObjectHeaderList.headers: ") <<
                m_headers_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumObjects()) << "!";
    }
    m_headers_.writePacked(*this, out);
}

void SmartLayerObjectHeaderList::ZserioElementFactory_references::create(SmartLayerObjectHeaderList&        ,
        ::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerObjectHeaderList::ZserioElementFactory_references::create(SmartLayerObjectHeaderList&        ,
        ::zserio::vector<::nds::smart::object::SmartLayerObjectReference>& array,
        ::nds::smart::object::SmartLayerObjectReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void SmartLayerObjectHeaderList::ZserioArrayExpressions_headers::initializeElement(SmartLayerObjectHeaderList&,
        ::nds::smart::types::SmartLayerHeader& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerObjectHeaderList::ZserioElementFactory_headers::create(SmartLayerObjectHeaderList&        ,
        ::zserio::vector<::nds::smart::types::SmartLayerHeader>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerObjectHeaderList::ZserioElementFactory_headers::create(SmartLayerObjectHeaderList&        ,
        ::zserio::vector<::nds::smart::types::SmartLayerHeader>& array,
        ::nds::smart::types::SmartLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t SmartLayerObjectHeaderList::readNumObjects(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t SmartLayerObjectHeaderList::readNumObjects(SmartLayerObjectHeaderList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumObjects().read<::zserio::VarSizeArrayTraits>(in);
}
SmartLayerObjectHeaderList::ZserioArrayType_references SmartLayerObjectHeaderList::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumObjects()));

    return readField;
}

SmartLayerObjectHeaderList::ZserioArrayType_references SmartLayerObjectHeaderList::readReferences(SmartLayerObjectHeaderList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumObjects()));

    return readField;
}
SmartLayerObjectHeaderList::ZserioArrayType_headers SmartLayerObjectHeaderList::readHeaders(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_headers readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumObjects()));

    return readField;
}

SmartLayerObjectHeaderList::ZserioArrayType_headers SmartLayerObjectHeaderList::readHeaders(SmartLayerObjectHeaderList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_headers readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumObjects()));

    return readField;
}

} // namespace object
} // namespace smart
} // namespace nds
