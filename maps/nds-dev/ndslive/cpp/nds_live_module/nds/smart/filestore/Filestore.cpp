/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/SqliteException.h>

#include <nds/smart/filestore/SmartLayerTileStore.h>

namespace nds
{
namespace smart
{
namespace filestore
{

SmartLayerTileStore::SmartLayerTileStore(const ::zserio::string<>& dbFileName, const TRelocationMap& tableToDbFileNameRelocationMap,
        const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_tableToAttachedDbNameRelocationMap(allocator)
{
    sqlite3 *internalConnection = nullptr;
    const int sqliteOpenMode = SQLITE_OPEN_URI | SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE;
    const int result = sqlite3_open_v2(dbFileName.c_str(), &internalConnection, sqliteOpenMode, nullptr);
    m_db.reset(internalConnection, ::zserio::SqliteConnection::INTERNAL_CONNECTION);
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerTileStore::open(): can't open DB ") << dbFileName.c_str() << ": " <<
                ::zserio::SqliteErrorCode(result);
    }

    ::std::map<::zserio::StringView, ::zserio::string<>> dbFileNameToAttachedDbNameMap(
            get_allocator_ref());
    for (const auto& relocation : tableToDbFileNameRelocationMap)
    {
        const ::zserio::string<>& tableName = relocation.first;
        const ::zserio::string<>& fileName = relocation.second;
        auto attachedDbIt = dbFileNameToAttachedDbNameMap.find(fileName);
        if (attachedDbIt == dbFileNameToAttachedDbNameMap.end())
        {
            ::zserio::string<> attachedDbName =
                    ::zserio::stringViewToString(databaseName(), get_allocator_ref()) + "_" + tableName;
            attachDatabase(fileName, attachedDbName);
            attachedDbIt = dbFileNameToAttachedDbNameMap.emplace(fileName, ::std::move(attachedDbName)).first;
        }
        m_tableToAttachedDbNameRelocationMap.emplace(
                ::zserio::string<>(tableName, get_allocator_ref()),
                ::zserio::string<>(attachedDbIt->second, get_allocator_ref()));
    }

    initTables();
}

SmartLayerTileStore::SmartLayerTileStore(const ::zserio::string<>& dbFileName, const allocator_type& allocator) :
        SmartLayerTileStore(dbFileName, TRelocationMap(allocator), allocator)
{}

SmartLayerTileStore::SmartLayerTileStore(sqlite3* externalConnection, const TRelocationMap& tableToAttachedDbNameRelocationMap,
        const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_tableToAttachedDbNameRelocationMap(tableToAttachedDbNameRelocationMap, allocator)
{
    m_db.reset(externalConnection, ::zserio::SqliteConnection::EXTERNAL_CONNECTION);
    initTables();
}

SmartLayerTileStore::SmartLayerTileStore(sqlite3* externalConnection, const allocator_type& allocator) :
        SmartLayerTileStore(externalConnection, TRelocationMap(allocator), allocator)
{}

SmartLayerTileStore::~SmartLayerTileStore()
{
    detachDatabases();
}

::zserio::SqliteConnection& SmartLayerTileStore::connection() noexcept
{
    return m_db;
}

::nds::smart::filestore::SmartLayerMetadataTable& SmartLayerTileStore::getMetadataTable() noexcept
{
    return *m_metadataTable_;
}

::nds::smart::filestore::SmartLayerTileTable& SmartLayerTileStore::getTileTable() noexcept
{
    return *m_tileTable_;
}

void SmartLayerTileStore::createSchema()
{
    const bool wasTransactionStarted = m_db.startTransaction();

    m_metadataTable_->createTable();
    m_tileTable_->createTable();

    m_db.endTransaction(wasTransactionStarted);
}

void SmartLayerTileStore::createSchema(const ::std::set<::zserio::string<>>&)
{
    createSchema();
}

void SmartLayerTileStore::deleteSchema()
{
    const bool wasTransactionStarted = m_db.startTransaction();

    m_metadataTable_->deleteTable();
    m_tileTable_->deleteTable();

    m_db.endTransaction(wasTransactionStarted);
}

::zserio::StringView SmartLayerTileStore::databaseName() noexcept
{
    return ::zserio::makeStringView("SmartLayerTileStore");
}

::zserio::StringView SmartLayerTileStore::tableNameMetadataTable() noexcept
{
    return ::zserio::makeStringView("metadataTable");
}

::zserio::StringView SmartLayerTileStore::tableNameTileTable() noexcept
{
    return ::zserio::makeStringView("tileTable");
}

const ::std::array<::zserio::StringView, 2>& SmartLayerTileStore::tableNames() noexcept
{
    static const ::std::array<::zserio::StringView, 2> names =
    {
        tableNameMetadataTable(),
        tableNameTileTable()
    };

    return names;
}

void SmartLayerTileStore::initTables()
{
    static ::zserio::StringView EMPTY_STR = ::zserio::StringView();
    auto relocationIt = m_tableToAttachedDbNameRelocationMap.find(
            ::zserio::stringViewToString(tableNameMetadataTable(), get_allocator_ref()));
    m_metadataTable_ = ::zserio::allocate_unique<::nds::smart::filestore::SmartLayerMetadataTable>(
            get_allocator_ref(), this->m_db, tableNameMetadataTable(),
            relocationIt != m_tableToAttachedDbNameRelocationMap.end() ? relocationIt->second : EMPTY_STR,
            get_allocator_ref());

    relocationIt = m_tableToAttachedDbNameRelocationMap.find(
            ::zserio::stringViewToString(tableNameTileTable(), get_allocator_ref()));
    m_tileTable_ = ::zserio::allocate_unique<::nds::smart::filestore::SmartLayerTileTable>(
            get_allocator_ref(), this->m_db, tableNameTileTable(),
            relocationIt != m_tableToAttachedDbNameRelocationMap.end() ? relocationIt->second : EMPTY_STR,
            get_allocator_ref());
}

void SmartLayerTileStore::attachDatabase(::zserio::StringView fileName, ::zserio::StringView attachedDbName)
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "ATTACH DATABASE '";
    sqlQuery += fileName;
    sqlQuery += "' AS ";
    sqlQuery += attachedDbName;

    m_db.executeUpdate(sqlQuery);

    m_attachedDbList.push_back(::zserio::stringViewToString(attachedDbName, get_allocator_ref()));
}

void SmartLayerTileStore::detachDatabases()
{
    for (const auto& attachedDb : m_attachedDbList)
    {
        try
        {
            ::zserio::string<> sqlQuery(get_allocator_ref());
            sqlQuery += "DETACH DATABASE ";
            sqlQuery += attachedDb;
            m_db.executeUpdate(sqlQuery);
        }
        catch (const ::zserio::SqliteException&)
        {
            // ignore since we have no logging sub-system and we need to prevent exception in SQLDatabase destructor
        }
    }
    m_attachedDbList.clear();
}

} // namespace filestore
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/SqliteException.h>

#include <nds/smart/filestore/SmartLayerObjectStore.h>

namespace nds
{
namespace smart
{
namespace filestore
{

SmartLayerObjectStore::SmartLayerObjectStore(const ::zserio::string<>& dbFileName, const TRelocationMap& tableToDbFileNameRelocationMap,
        const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_tableToAttachedDbNameRelocationMap(allocator)
{
    sqlite3 *internalConnection = nullptr;
    const int sqliteOpenMode = SQLITE_OPEN_URI | SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE;
    const int result = sqlite3_open_v2(dbFileName.c_str(), &internalConnection, sqliteOpenMode, nullptr);
    m_db.reset(internalConnection, ::zserio::SqliteConnection::INTERNAL_CONNECTION);
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerObjectStore::open(): can't open DB ") << dbFileName.c_str() << ": " <<
                ::zserio::SqliteErrorCode(result);
    }

    ::std::map<::zserio::StringView, ::zserio::string<>> dbFileNameToAttachedDbNameMap(
            get_allocator_ref());
    for (const auto& relocation : tableToDbFileNameRelocationMap)
    {
        const ::zserio::string<>& tableName = relocation.first;
        const ::zserio::string<>& fileName = relocation.second;
        auto attachedDbIt = dbFileNameToAttachedDbNameMap.find(fileName);
        if (attachedDbIt == dbFileNameToAttachedDbNameMap.end())
        {
            ::zserio::string<> attachedDbName =
                    ::zserio::stringViewToString(databaseName(), get_allocator_ref()) + "_" + tableName;
            attachDatabase(fileName, attachedDbName);
            attachedDbIt = dbFileNameToAttachedDbNameMap.emplace(fileName, ::std::move(attachedDbName)).first;
        }
        m_tableToAttachedDbNameRelocationMap.emplace(
                ::zserio::string<>(tableName, get_allocator_ref()),
                ::zserio::string<>(attachedDbIt->second, get_allocator_ref()));
    }

    initTables();
}

SmartLayerObjectStore::SmartLayerObjectStore(const ::zserio::string<>& dbFileName, const allocator_type& allocator) :
        SmartLayerObjectStore(dbFileName, TRelocationMap(allocator), allocator)
{}

SmartLayerObjectStore::SmartLayerObjectStore(sqlite3* externalConnection, const TRelocationMap& tableToAttachedDbNameRelocationMap,
        const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_tableToAttachedDbNameRelocationMap(tableToAttachedDbNameRelocationMap, allocator)
{
    m_db.reset(externalConnection, ::zserio::SqliteConnection::EXTERNAL_CONNECTION);
    initTables();
}

SmartLayerObjectStore::SmartLayerObjectStore(sqlite3* externalConnection, const allocator_type& allocator) :
        SmartLayerObjectStore(externalConnection, TRelocationMap(allocator), allocator)
{}

SmartLayerObjectStore::~SmartLayerObjectStore()
{
    detachDatabases();
}

::zserio::SqliteConnection& SmartLayerObjectStore::connection() noexcept
{
    return m_db;
}

::nds::smart::filestore::SmartLayerMetadataTable& SmartLayerObjectStore::getMetadataTable() noexcept
{
    return *m_metadataTable_;
}

::nds::smart::filestore::SmartLayerObjectTable& SmartLayerObjectStore::getObjectTable() noexcept
{
    return *m_objectTable_;
}

void SmartLayerObjectStore::createSchema()
{
    const bool wasTransactionStarted = m_db.startTransaction();

    m_metadataTable_->createTable();
    m_objectTable_->createTable();

    m_db.endTransaction(wasTransactionStarted);
}

void SmartLayerObjectStore::createSchema(const ::std::set<::zserio::string<>>&)
{
    createSchema();
}

void SmartLayerObjectStore::deleteSchema()
{
    const bool wasTransactionStarted = m_db.startTransaction();

    m_metadataTable_->deleteTable();
    m_objectTable_->deleteTable();

    m_db.endTransaction(wasTransactionStarted);
}

::zserio::StringView SmartLayerObjectStore::databaseName() noexcept
{
    return ::zserio::makeStringView("SmartLayerObjectStore");
}

::zserio::StringView SmartLayerObjectStore::tableNameMetadataTable() noexcept
{
    return ::zserio::makeStringView("metadataTable");
}

::zserio::StringView SmartLayerObjectStore::tableNameObjectTable() noexcept
{
    return ::zserio::makeStringView("objectTable");
}

const ::std::array<::zserio::StringView, 2>& SmartLayerObjectStore::tableNames() noexcept
{
    static const ::std::array<::zserio::StringView, 2> names =
    {
        tableNameMetadataTable(),
        tableNameObjectTable()
    };

    return names;
}

void SmartLayerObjectStore::initTables()
{
    static ::zserio::StringView EMPTY_STR = ::zserio::StringView();
    auto relocationIt = m_tableToAttachedDbNameRelocationMap.find(
            ::zserio::stringViewToString(tableNameMetadataTable(), get_allocator_ref()));
    m_metadataTable_ = ::zserio::allocate_unique<::nds::smart::filestore::SmartLayerMetadataTable>(
            get_allocator_ref(), this->m_db, tableNameMetadataTable(),
            relocationIt != m_tableToAttachedDbNameRelocationMap.end() ? relocationIt->second : EMPTY_STR,
            get_allocator_ref());

    relocationIt = m_tableToAttachedDbNameRelocationMap.find(
            ::zserio::stringViewToString(tableNameObjectTable(), get_allocator_ref()));
    m_objectTable_ = ::zserio::allocate_unique<::nds::smart::filestore::SmartLayerObjectTable>(
            get_allocator_ref(), this->m_db, tableNameObjectTable(),
            relocationIt != m_tableToAttachedDbNameRelocationMap.end() ? relocationIt->second : EMPTY_STR,
            get_allocator_ref());
}

void SmartLayerObjectStore::attachDatabase(::zserio::StringView fileName, ::zserio::StringView attachedDbName)
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "ATTACH DATABASE '";
    sqlQuery += fileName;
    sqlQuery += "' AS ";
    sqlQuery += attachedDbName;

    m_db.executeUpdate(sqlQuery);

    m_attachedDbList.push_back(::zserio::stringViewToString(attachedDbName, get_allocator_ref()));
}

void SmartLayerObjectStore::detachDatabases()
{
    for (const auto& attachedDb : m_attachedDbList)
    {
        try
        {
            ::zserio::string<> sqlQuery(get_allocator_ref());
            sqlQuery += "DETACH DATABASE ";
            sqlQuery += attachedDb;
            m_db.executeUpdate(sqlQuery);
        }
        catch (const ::zserio::SqliteException&)
        {
            // ignore since we have no logging sub-system and we need to prevent exception in SQLDatabase destructor
        }
    }
    m_attachedDbList.clear();
}

} // namespace filestore
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/CppRuntimeException.h>
#include <zserio/SqliteException.h>
#include <zserio/BitStreamReader.h>
#include <algorithm>
#include <zserio/BitFieldUtil.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/StringView.h>

#include <nds/smart/filestore/SmartLayerMetadataTable.h>

namespace nds
{
namespace smart
{
namespace filestore
{

SmartLayerMetadataTable::SmartLayerMetadataTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        ::zserio::StringView attachedDbName, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_db(db), m_name(tableName), m_attachedDbName(attachedDbName)
{
}

SmartLayerMetadataTable::SmartLayerMetadataTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        const allocator_type& allocator) :
        SmartLayerMetadataTable(db, tableName, ::zserio::StringView(), allocator)
{
}

void SmartLayerMetadataTable::createTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    appendCreateTableToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

void SmartLayerMetadataTable::deleteTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "DROP TABLE ";
    appendTableNameToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

SmartLayerMetadataTable::Reader SmartLayerMetadataTable::createReader(::zserio::StringView condition) const
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery +=
            "SELECT "
            "id, "
            "registryMetadata, "
            "moduleDefinition, "
            "definition, "
            "nodeSystemReference, "
            "nodeLegalInfo"
            " FROM ";
    appendTableNameToQuery(sqlQuery);
    if (!condition.empty())
    {
        sqlQuery += " WHERE ";
        sqlQuery += condition;
    }

    return Reader(m_db, sqlQuery, get_allocator_ref());
}

SmartLayerMetadataTable::Reader::Reader(::zserio::SqliteConnection& db, const ::zserio::string<>& sqlQuery, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_stmt(db.prepareStatement(sqlQuery))
{
    makeStep();
}

bool SmartLayerMetadataTable::Reader::hasNext() const noexcept
{
    return m_lastResult == SQLITE_ROW;
}

SmartLayerMetadataTable::Row SmartLayerMetadataTable::Reader::next()
{
    if (!hasNext())
    {
        throw ::zserio::SqliteException("Table::Reader::next: next row is not available: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }

    Row row;

    // field id
    if (sqlite3_column_type(m_stmt.get(), 0) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 0);
        row.setId(static_cast<uint8_t>(intValue));
    }

    // field registryMetadata
    if (sqlite3_column_type(m_stmt.get(), 1) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 1);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 1);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::smart::metadata::SmartLayerRegistryMetadata blob(reader, get_allocator_ref());
        row.setRegistryMetadata(::std::move(blob));
    }

    // field moduleDefinition
    if (sqlite3_column_type(m_stmt.get(), 2) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 2);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 2);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::system::types::ModuleDefinition blob(reader, get_allocator_ref());
        row.setModuleDefinition(::std::move(blob));
    }

    // field definition
    if (sqlite3_column_type(m_stmt.get(), 3) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 3);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 3);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::smart::metadata::SmartLayerDefinition blob(reader, get_allocator_ref());
        row.setDefinition(::std::move(blob));
    }

    // field nodeSystemReference
    if (sqlite3_column_type(m_stmt.get(), 4) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 4);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 4);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::system::types::NdsSystemToken blob(reader, get_allocator_ref());
        row.setNodeSystemReference(::std::move(blob));
    }

    // field nodeLegalInfo
    if (sqlite3_column_type(m_stmt.get(), 5) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 5);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 5);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::system::types::NdsNodeLegalInfo blob(reader, get_allocator_ref());
        row.setNodeLegalInfo(::std::move(blob));
    }

    makeStep();

    return row;
}

void SmartLayerMetadataTable::Reader::makeStep()
{
    m_lastResult = sqlite3_step(m_stmt.get());
    if (m_lastResult != SQLITE_ROW && m_lastResult != SQLITE_DONE)
    {
        throw ::zserio::SqliteException("SmartLayerMetadataTable::Read: sqlite3_step() failed: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }
}

void SmartLayerMetadataTable::write(::zserio::Span<Row> rows)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "INSERT INTO ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            "("
            "id, "
            "registryMetadata, "
            "moduleDefinition, "
            "definition, "
            "nodeSystemReference, "
            "nodeLegalInfo"
            ") VALUES (?, ?, ?, ?, ?, ?);";

    // write rows
    const bool wasTransactionStarted = m_db.startTransaction();
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));

    for (Row& row : rows)
    {
        writeRow(row, *statement);
        int result = sqlite3_step(statement.get());
        if (result != SQLITE_DONE)
        {
            throw ::zserio::SqliteException("Write: sqlite3_step() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }

        sqlite3_clear_bindings(statement.get());
        result = sqlite3_reset(statement.get());
        if (result != SQLITE_OK)
        {
            throw ::zserio::SqliteException("Write: sqlite3_reset() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }
    }

    m_db.endTransaction(wasTransactionStarted);
}

void SmartLayerMetadataTable::update(Row& row, ::zserio::StringView whereCondition)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "UPDATE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            " SET"
            " id=?,"
            " registryMetadata=?,"
            " moduleDefinition=?,"
            " definition=?,"
            " nodeSystemReference=?,"
            " nodeLegalInfo=?"
            " WHERE ";
    sqlQuery += whereCondition;

    // update row
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));
    writeRow(row, *statement);
    const int result = sqlite3_step(statement.get());
    if (result != SQLITE_DONE)
        throw ::zserio::SqliteException("Update: sqlite3_step() failed: ") << ::zserio::SqliteErrorCode(result);
}

void SmartLayerMetadataTable::writeRow(Row& row, sqlite3_stmt& statement)
{
    row.initializeChildren();

    int result = SQLITE_ERROR;

    // field id
    if (!row.isIdSet())
    {
        result = sqlite3_bind_null(&statement, 1);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(row.getId());
        result = sqlite3_bind_int64(&statement, 1, intValue);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerMetadataTable::WriteRow: sqlite3_bind() for field id failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field registryMetadata
    if (!row.isRegistryMetadataSet())
    {
        result = sqlite3_bind_null(&statement, 2);
    }
    else
    {
        const ::nds::smart::metadata::SmartLayerRegistryMetadata& blob = row.getRegistryMetadata();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 2, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerMetadataTable::WriteRow: sqlite3_bind() for field registryMetadata failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field moduleDefinition
    if (!row.isModuleDefinitionSet())
    {
        result = sqlite3_bind_null(&statement, 3);
    }
    else
    {
        const ::nds::system::types::ModuleDefinition& blob = row.getModuleDefinition();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 3, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerMetadataTable::WriteRow: sqlite3_bind() for field moduleDefinition failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field definition
    if (!row.isDefinitionSet())
    {
        result = sqlite3_bind_null(&statement, 4);
    }
    else
    {
        const ::nds::smart::metadata::SmartLayerDefinition& blob = row.getDefinition();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 4, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerMetadataTable::WriteRow: sqlite3_bind() for field definition failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field nodeSystemReference
    if (!row.isNodeSystemReferenceSet())
    {
        result = sqlite3_bind_null(&statement, 5);
    }
    else
    {
        const ::nds::system::types::NdsSystemToken& blob = row.getNodeSystemReference();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 5, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerMetadataTable::WriteRow: sqlite3_bind() for field nodeSystemReference failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field nodeLegalInfo
    if (!row.isNodeLegalInfoSet())
    {
        result = sqlite3_bind_null(&statement, 6);
    }
    else
    {
        const ::nds::system::types::NdsNodeLegalInfo& blob = row.getNodeLegalInfo();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 6, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerMetadataTable::WriteRow: sqlite3_bind() for field nodeLegalInfo failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }
}

void SmartLayerMetadataTable::appendCreateTableToQuery(::zserio::string<>& sqlQuery) const
{
    sqlQuery += "CREATE TABLE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery += '(';
    sqlQuery += "id INTEGER";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("PRIMARY KEY DEFAULT 0 NOT NULL");
    sqlQuery += ", registryMetadata BLOB";
    sqlQuery += ", moduleDefinition BLOB";
    sqlQuery += ", definition BLOB";
    sqlQuery += ", nodeSystemReference BLOB";
    sqlQuery += ", nodeLegalInfo BLOB";
    sqlQuery += ", ";
    sqlQuery += ::zserio::makeStringView("check(id == 0)");
    sqlQuery += ')';
}

void SmartLayerMetadataTable::appendTableNameToQuery(::zserio::string<>& sqlQuery) const
{
    if (!m_attachedDbName.empty())
    {
        sqlQuery += m_attachedDbName;
        sqlQuery += '.';
    }
    sqlQuery += m_name;
}

uint8_t SmartLayerMetadataTable::Row::getId() const
{
    return m_id_.value();
}

void SmartLayerMetadataTable::Row::setId(uint8_t id_)
{
    m_id_ = id_;
}

void SmartLayerMetadataTable::Row::resetId()
{
    m_id_.reset();
}

bool SmartLayerMetadataTable::Row::isIdSet() const
{
    return m_id_.hasValue();
}

::nds::smart::metadata::SmartLayerRegistryMetadata& SmartLayerMetadataTable::Row::getRegistryMetadata()
{
    return m_registryMetadata_.value();
}

const ::nds::smart::metadata::SmartLayerRegistryMetadata& SmartLayerMetadataTable::Row::getRegistryMetadata() const
{
    return m_registryMetadata_.value();
}

void SmartLayerMetadataTable::Row::setRegistryMetadata(const ::nds::smart::metadata::SmartLayerRegistryMetadata& registryMetadata_)
{
    m_registryMetadata_ = registryMetadata_;
}

void SmartLayerMetadataTable::Row::setRegistryMetadata(::nds::smart::metadata::SmartLayerRegistryMetadata&& registryMetadata_)
{
    m_registryMetadata_ = ::std::move(registryMetadata_);
}

void SmartLayerMetadataTable::Row::resetRegistryMetadata()
{
    m_registryMetadata_.reset();
}

bool SmartLayerMetadataTable::Row::isRegistryMetadataSet() const
{
    return m_registryMetadata_.hasValue();
}

::nds::system::types::ModuleDefinition& SmartLayerMetadataTable::Row::getModuleDefinition()
{
    return m_moduleDefinition_.value();
}

const ::nds::system::types::ModuleDefinition& SmartLayerMetadataTable::Row::getModuleDefinition() const
{
    return m_moduleDefinition_.value();
}

void SmartLayerMetadataTable::Row::setModuleDefinition(const ::nds::system::types::ModuleDefinition& moduleDefinition_)
{
    m_moduleDefinition_ = moduleDefinition_;
}

void SmartLayerMetadataTable::Row::setModuleDefinition(::nds::system::types::ModuleDefinition&& moduleDefinition_)
{
    m_moduleDefinition_ = ::std::move(moduleDefinition_);
}

void SmartLayerMetadataTable::Row::resetModuleDefinition()
{
    m_moduleDefinition_.reset();
}

bool SmartLayerMetadataTable::Row::isModuleDefinitionSet() const
{
    return m_moduleDefinition_.hasValue();
}

::nds::smart::metadata::SmartLayerDefinition& SmartLayerMetadataTable::Row::getDefinition()
{
    return m_definition_.value();
}

const ::nds::smart::metadata::SmartLayerDefinition& SmartLayerMetadataTable::Row::getDefinition() const
{
    return m_definition_.value();
}

void SmartLayerMetadataTable::Row::setDefinition(const ::nds::smart::metadata::SmartLayerDefinition& definition_)
{
    m_definition_ = definition_;
}

void SmartLayerMetadataTable::Row::setDefinition(::nds::smart::metadata::SmartLayerDefinition&& definition_)
{
    m_definition_ = ::std::move(definition_);
}

void SmartLayerMetadataTable::Row::resetDefinition()
{
    m_definition_.reset();
}

bool SmartLayerMetadataTable::Row::isDefinitionSet() const
{
    return m_definition_.hasValue();
}

::nds::system::types::NdsSystemToken& SmartLayerMetadataTable::Row::getNodeSystemReference()
{
    return m_nodeSystemReference_.value();
}

const ::nds::system::types::NdsSystemToken& SmartLayerMetadataTable::Row::getNodeSystemReference() const
{
    return m_nodeSystemReference_.value();
}

void SmartLayerMetadataTable::Row::setNodeSystemReference(const ::nds::system::types::NdsSystemToken& nodeSystemReference_)
{
    m_nodeSystemReference_ = nodeSystemReference_;
}

void SmartLayerMetadataTable::Row::setNodeSystemReference(::nds::system::types::NdsSystemToken&& nodeSystemReference_)
{
    m_nodeSystemReference_ = ::std::move(nodeSystemReference_);
}

void SmartLayerMetadataTable::Row::resetNodeSystemReference()
{
    m_nodeSystemReference_.reset();
}

bool SmartLayerMetadataTable::Row::isNodeSystemReferenceSet() const
{
    return m_nodeSystemReference_.hasValue();
}

::nds::system::types::NdsNodeLegalInfo& SmartLayerMetadataTable::Row::getNodeLegalInfo()
{
    return m_nodeLegalInfo_.value();
}

const ::nds::system::types::NdsNodeLegalInfo& SmartLayerMetadataTable::Row::getNodeLegalInfo() const
{
    return m_nodeLegalInfo_.value();
}

void SmartLayerMetadataTable::Row::setNodeLegalInfo(const ::nds::system::types::NdsNodeLegalInfo& nodeLegalInfo_)
{
    m_nodeLegalInfo_ = nodeLegalInfo_;
}

void SmartLayerMetadataTable::Row::setNodeLegalInfo(::nds::system::types::NdsNodeLegalInfo&& nodeLegalInfo_)
{
    m_nodeLegalInfo_ = ::std::move(nodeLegalInfo_);
}

void SmartLayerMetadataTable::Row::resetNodeLegalInfo()
{
    m_nodeLegalInfo_.reset();
}

bool SmartLayerMetadataTable::Row::isNodeLegalInfoSet() const
{
    return m_nodeLegalInfo_.hasValue();
}

void SmartLayerMetadataTable::Row::initializeChildren()
{
    if (m_registryMetadata_)
    {
        m_registryMetadata_->initializeChildren();
    }
}

} // namespace filestore
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/CppRuntimeException.h>
#include <zserio/SqliteException.h>
#include <zserio/BitStreamReader.h>
#include <algorithm>
#include <zserio/BitFieldUtil.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/StringView.h>

#include <nds/smart/filestore/SmartLayerTileTable.h>

namespace nds
{
namespace smart
{
namespace filestore
{

SmartLayerTileTable::SmartLayerTileTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        ::zserio::StringView attachedDbName, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_db(db), m_name(tableName), m_attachedDbName(attachedDbName)
{
}

SmartLayerTileTable::SmartLayerTileTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        const allocator_type& allocator) :
        SmartLayerTileTable(db, tableName, ::zserio::StringView(), allocator)
{
}

void SmartLayerTileTable::createTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    appendCreateTableToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

void SmartLayerTileTable::deleteTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "DROP TABLE ";
    appendTableNameToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

SmartLayerTileTable::Reader SmartLayerTileTable::createReader(::zserio::StringView condition) const
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery +=
            "SELECT "
            "tileId, "
            "smartLayer, "
            "header"
            " FROM ";
    appendTableNameToQuery(sqlQuery);
    if (!condition.empty())
    {
        sqlQuery += " WHERE ";
        sqlQuery += condition;
    }

    return Reader(m_db, sqlQuery, get_allocator_ref());
}

SmartLayerTileTable::Reader::Reader(::zserio::SqliteConnection& db, const ::zserio::string<>& sqlQuery, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_stmt(db.prepareStatement(sqlQuery))
{
    makeStep();
}

bool SmartLayerTileTable::Reader::hasNext() const noexcept
{
    return m_lastResult == SQLITE_ROW;
}

SmartLayerTileTable::Row SmartLayerTileTable::Reader::next()
{
    if (!hasNext())
    {
        throw ::zserio::SqliteException("Table::Reader::next: next row is not available: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }

    Row row;

    // field tileId
    if (sqlite3_column_type(m_stmt.get(), 0) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 0);
        row.setTileId(static_cast<::nds::core::types::PackedTileId>(intValue));
    }

    // field smartLayer
    if (sqlite3_column_type(m_stmt.get(), 1) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 1);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 1);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::smart::tile::SmartLayerTile blob(reader, get_allocator_ref());
        row.setSmartLayer(::std::move(blob));
    }

    // field header
    if (sqlite3_column_type(m_stmt.get(), 2) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 2);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 2);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::smart::types::SmartLayerHeader blob(reader, get_allocator_ref());
        row.setHeader(::std::move(blob));
    }

    makeStep();

    return row;
}

void SmartLayerTileTable::Reader::makeStep()
{
    m_lastResult = sqlite3_step(m_stmt.get());
    if (m_lastResult != SQLITE_ROW && m_lastResult != SQLITE_DONE)
    {
        throw ::zserio::SqliteException("SmartLayerTileTable::Read: sqlite3_step() failed: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }
}

void SmartLayerTileTable::write(::zserio::Span<Row> rows)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "INSERT INTO ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            "("
            "tileId, "
            "smartLayer, "
            "header"
            ") VALUES (?, ?, ?);";

    // write rows
    const bool wasTransactionStarted = m_db.startTransaction();
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));

    for (Row& row : rows)
    {
        writeRow(row, *statement);
        int result = sqlite3_step(statement.get());
        if (result != SQLITE_DONE)
        {
            throw ::zserio::SqliteException("Write: sqlite3_step() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }

        sqlite3_clear_bindings(statement.get());
        result = sqlite3_reset(statement.get());
        if (result != SQLITE_OK)
        {
            throw ::zserio::SqliteException("Write: sqlite3_reset() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }
    }

    m_db.endTransaction(wasTransactionStarted);
}

void SmartLayerTileTable::update(Row& row, ::zserio::StringView whereCondition)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "UPDATE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            " SET"
            " tileId=?,"
            " smartLayer=?,"
            " header=?"
            " WHERE ";
    sqlQuery += whereCondition;

    // update row
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));
    writeRow(row, *statement);
    const int result = sqlite3_step(statement.get());
    if (result != SQLITE_DONE)
        throw ::zserio::SqliteException("Update: sqlite3_step() failed: ") << ::zserio::SqliteErrorCode(result);
}

void SmartLayerTileTable::writeRow(Row& row, sqlite3_stmt& statement)
{
    row.initializeChildren();

    int result = SQLITE_ERROR;

    // field tileId
    if (!row.isTileIdSet())
    {
        result = sqlite3_bind_null(&statement, 1);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(row.getTileId());
        result = sqlite3_bind_int64(&statement, 1, intValue);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerTileTable::WriteRow: sqlite3_bind() for field tileId failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field smartLayer
    if (!row.isSmartLayerSet())
    {
        result = sqlite3_bind_null(&statement, 2);
    }
    else
    {
        const ::nds::smart::tile::SmartLayerTile& blob = row.getSmartLayer();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 2, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerTileTable::WriteRow: sqlite3_bind() for field smartLayer failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field header
    if (!row.isHeaderSet())
    {
        result = sqlite3_bind_null(&statement, 3);
    }
    else
    {
        const ::nds::smart::types::SmartLayerHeader& blob = row.getHeader();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 3, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerTileTable::WriteRow: sqlite3_bind() for field header failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }
}

void SmartLayerTileTable::appendCreateTableToQuery(::zserio::string<>& sqlQuery) const
{
    sqlQuery += "CREATE TABLE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery += '(';
    sqlQuery += "tileId INTEGER";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("PRIMARY KEY NOT NULL");
    sqlQuery += ", smartLayer BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", header BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NULL");
    sqlQuery += ')';
}

void SmartLayerTileTable::appendTableNameToQuery(::zserio::string<>& sqlQuery) const
{
    if (!m_attachedDbName.empty())
    {
        sqlQuery += m_attachedDbName;
        sqlQuery += '.';
    }
    sqlQuery += m_name;
}

::nds::core::types::PackedTileId SmartLayerTileTable::Row::getTileId() const
{
    return m_tileId_.value();
}

void SmartLayerTileTable::Row::setTileId(::nds::core::types::PackedTileId tileId_)
{
    m_tileId_ = tileId_;
}

void SmartLayerTileTable::Row::resetTileId()
{
    m_tileId_.reset();
}

bool SmartLayerTileTable::Row::isTileIdSet() const
{
    return m_tileId_.hasValue();
}

::nds::smart::tile::SmartLayerTile& SmartLayerTileTable::Row::getSmartLayer()
{
    return m_smartLayer_.value();
}

const ::nds::smart::tile::SmartLayerTile& SmartLayerTileTable::Row::getSmartLayer() const
{
    return m_smartLayer_.value();
}

void SmartLayerTileTable::Row::setSmartLayer(const ::nds::smart::tile::SmartLayerTile& smartLayer_)
{
    m_smartLayer_ = smartLayer_;
}

void SmartLayerTileTable::Row::setSmartLayer(::nds::smart::tile::SmartLayerTile&& smartLayer_)
{
    m_smartLayer_ = ::std::move(smartLayer_);
}

void SmartLayerTileTable::Row::resetSmartLayer()
{
    m_smartLayer_.reset();
}

bool SmartLayerTileTable::Row::isSmartLayerSet() const
{
    return m_smartLayer_.hasValue();
}

::nds::smart::types::SmartLayerHeader& SmartLayerTileTable::Row::getHeader()
{
    return m_header_.value();
}

const ::nds::smart::types::SmartLayerHeader& SmartLayerTileTable::Row::getHeader() const
{
    return m_header_.value();
}

void SmartLayerTileTable::Row::setHeader(const ::nds::smart::types::SmartLayerHeader& header_)
{
    m_header_ = header_;
}

void SmartLayerTileTable::Row::setHeader(::nds::smart::types::SmartLayerHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

void SmartLayerTileTable::Row::resetHeader()
{
    m_header_.reset();
}

bool SmartLayerTileTable::Row::isHeaderSet() const
{
    return m_header_.hasValue();
}

void SmartLayerTileTable::Row::initializeChildren()
{
    if (m_smartLayer_)
    {
        m_smartLayer_->initializeChildren();
    }
    if (m_header_)
    {
        m_header_->initializeChildren();
    }
}

} // namespace filestore
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/CppRuntimeException.h>
#include <zserio/SqliteException.h>
#include <zserio/BitStreamReader.h>
#include <algorithm>
#include <zserio/BitFieldUtil.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/StringView.h>

#include <nds/smart/filestore/SmartLayerObjectTable.h>

namespace nds
{
namespace smart
{
namespace filestore
{

SmartLayerObjectTable::SmartLayerObjectTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        ::zserio::StringView attachedDbName, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_db(db), m_name(tableName), m_attachedDbName(attachedDbName)
{
}

SmartLayerObjectTable::SmartLayerObjectTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        const allocator_type& allocator) :
        SmartLayerObjectTable(db, tableName, ::zserio::StringView(), allocator)
{
}

void SmartLayerObjectTable::createTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    appendCreateTableToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

void SmartLayerObjectTable::deleteTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "DROP TABLE ";
    appendTableNameToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

SmartLayerObjectTable::Reader SmartLayerObjectTable::createReader(::zserio::StringView condition) const
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery +=
            "SELECT "
            "objectId, "
            "objectClass, "
            "smartLayer, "
            "header"
            " FROM ";
    appendTableNameToQuery(sqlQuery);
    if (!condition.empty())
    {
        sqlQuery += " WHERE ";
        sqlQuery += condition;
    }

    return Reader(m_db, sqlQuery, get_allocator_ref());
}

SmartLayerObjectTable::Reader::Reader(::zserio::SqliteConnection& db, const ::zserio::string<>& sqlQuery, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_stmt(db.prepareStatement(sqlQuery))
{
    makeStep();
}

bool SmartLayerObjectTable::Reader::hasNext() const noexcept
{
    return m_lastResult == SQLITE_ROW;
}

SmartLayerObjectTable::Row SmartLayerObjectTable::Reader::next()
{
    if (!hasNext())
    {
        throw ::zserio::SqliteException("Table::Reader::next: next row is not available: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }

    Row row;

    // field objectId
    if (sqlite3_column_type(m_stmt.get(), 0) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 0);
        row.setObjectId(static_cast<::nds::smart::object::SmartLayerObjectId>(intValue));
    }

    // field objectClass
    if (sqlite3_column_type(m_stmt.get(), 1) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 1);
        row.setObjectClass(static_cast<::nds::smart::object::SmartLayerObjectClass>(intValue));
    }

    // field smartLayer
    if (sqlite3_column_type(m_stmt.get(), 2) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 2);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 2);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::smart::object::SmartLayerObject blob(reader, get_allocator_ref());
        row.setSmartLayer(::std::move(blob));
    }

    // field header
    if (sqlite3_column_type(m_stmt.get(), 3) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 3);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 3);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::smart::types::SmartLayerHeader blob(reader, get_allocator_ref());
        row.setHeader(::std::move(blob));
    }

    makeStep();

    return row;
}

void SmartLayerObjectTable::Reader::makeStep()
{
    m_lastResult = sqlite3_step(m_stmt.get());
    if (m_lastResult != SQLITE_ROW && m_lastResult != SQLITE_DONE)
    {
        throw ::zserio::SqliteException("SmartLayerObjectTable::Read: sqlite3_step() failed: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }
}

void SmartLayerObjectTable::write(::zserio::Span<Row> rows)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "INSERT INTO ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            "("
            "objectId, "
            "objectClass, "
            "smartLayer, "
            "header"
            ") VALUES (?, ?, ?, ?);";

    // write rows
    const bool wasTransactionStarted = m_db.startTransaction();
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));

    for (Row& row : rows)
    {
        writeRow(row, *statement);
        int result = sqlite3_step(statement.get());
        if (result != SQLITE_DONE)
        {
            throw ::zserio::SqliteException("Write: sqlite3_step() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }

        sqlite3_clear_bindings(statement.get());
        result = sqlite3_reset(statement.get());
        if (result != SQLITE_OK)
        {
            throw ::zserio::SqliteException("Write: sqlite3_reset() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }
    }

    m_db.endTransaction(wasTransactionStarted);
}

void SmartLayerObjectTable::update(Row& row, ::zserio::StringView whereCondition)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "UPDATE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            " SET"
            " objectId=?,"
            " objectClass=?,"
            " smartLayer=?,"
            " header=?"
            " WHERE ";
    sqlQuery += whereCondition;

    // update row
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));
    writeRow(row, *statement);
    const int result = sqlite3_step(statement.get());
    if (result != SQLITE_DONE)
        throw ::zserio::SqliteException("Update: sqlite3_step() failed: ") << ::zserio::SqliteErrorCode(result);
}

void SmartLayerObjectTable::writeRow(Row& row, sqlite3_stmt& statement)
{
    row.initializeChildren();

    int result = SQLITE_ERROR;

    // field objectId
    if (!row.isObjectIdSet())
    {
        result = sqlite3_bind_null(&statement, 1);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(row.getObjectId());
        result = sqlite3_bind_int64(&statement, 1, intValue);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerObjectTable::WriteRow: sqlite3_bind() for field objectId failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field objectClass
    if (!row.isObjectClassSet())
    {
        result = sqlite3_bind_null(&statement, 2);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(row.getObjectClass());
        result = sqlite3_bind_int64(&statement, 2, intValue);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerObjectTable::WriteRow: sqlite3_bind() for field objectClass failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field smartLayer
    if (!row.isSmartLayerSet())
    {
        result = sqlite3_bind_null(&statement, 3);
    }
    else
    {
        const ::nds::smart::object::SmartLayerObject& blob = row.getSmartLayer();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 3, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerObjectTable::WriteRow: sqlite3_bind() for field smartLayer failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field header
    if (!row.isHeaderSet())
    {
        result = sqlite3_bind_null(&statement, 4);
    }
    else
    {
        const ::nds::smart::types::SmartLayerHeader& blob = row.getHeader();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 4, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("SmartLayerObjectTable::WriteRow: sqlite3_bind() for field header failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }
}

void SmartLayerObjectTable::appendCreateTableToQuery(::zserio::string<>& sqlQuery) const
{
    sqlQuery += "CREATE TABLE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery += '(';
    sqlQuery += "objectId INTEGER";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", objectClass INTEGER";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", smartLayer BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", header BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NULL");
    sqlQuery += ", ";
    sqlQuery += ::zserio::makeStringView("primary key (objectId, objectClass)");
    sqlQuery += ')';
}

void SmartLayerObjectTable::appendTableNameToQuery(::zserio::string<>& sqlQuery) const
{
    if (!m_attachedDbName.empty())
    {
        sqlQuery += m_attachedDbName;
        sqlQuery += '.';
    }
    sqlQuery += m_name;
}

::nds::smart::object::SmartLayerObjectId SmartLayerObjectTable::Row::getObjectId() const
{
    return m_objectId_.value();
}

void SmartLayerObjectTable::Row::setObjectId(::nds::smart::object::SmartLayerObjectId objectId_)
{
    m_objectId_ = objectId_;
}

void SmartLayerObjectTable::Row::resetObjectId()
{
    m_objectId_.reset();
}

bool SmartLayerObjectTable::Row::isObjectIdSet() const
{
    return m_objectId_.hasValue();
}

::nds::smart::object::SmartLayerObjectClass SmartLayerObjectTable::Row::getObjectClass() const
{
    return m_objectClass_.value();
}

void SmartLayerObjectTable::Row::setObjectClass(::nds::smart::object::SmartLayerObjectClass objectClass_)
{
    m_objectClass_ = objectClass_;
}

void SmartLayerObjectTable::Row::resetObjectClass()
{
    m_objectClass_.reset();
}

bool SmartLayerObjectTable::Row::isObjectClassSet() const
{
    return m_objectClass_.hasValue();
}

::nds::smart::object::SmartLayerObject& SmartLayerObjectTable::Row::getSmartLayer()
{
    return m_smartLayer_.value();
}

const ::nds::smart::object::SmartLayerObject& SmartLayerObjectTable::Row::getSmartLayer() const
{
    return m_smartLayer_.value();
}

void SmartLayerObjectTable::Row::setSmartLayer(const ::nds::smart::object::SmartLayerObject& smartLayer_)
{
    m_smartLayer_ = smartLayer_;
}

void SmartLayerObjectTable::Row::setSmartLayer(::nds::smart::object::SmartLayerObject&& smartLayer_)
{
    m_smartLayer_ = ::std::move(smartLayer_);
}

void SmartLayerObjectTable::Row::resetSmartLayer()
{
    m_smartLayer_.reset();
}

bool SmartLayerObjectTable::Row::isSmartLayerSet() const
{
    return m_smartLayer_.hasValue();
}

::nds::smart::types::SmartLayerHeader& SmartLayerObjectTable::Row::getHeader()
{
    return m_header_.value();
}

const ::nds::smart::types::SmartLayerHeader& SmartLayerObjectTable::Row::getHeader() const
{
    return m_header_.value();
}

void SmartLayerObjectTable::Row::setHeader(const ::nds::smart::types::SmartLayerHeader& header_)
{
    m_header_ = header_;
}

void SmartLayerObjectTable::Row::setHeader(::nds::smart::types::SmartLayerHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

void SmartLayerObjectTable::Row::resetHeader()
{
    m_header_.reset();
}

bool SmartLayerObjectTable::Row::isHeaderSet() const
{
    return m_header_.hasValue();
}

void SmartLayerObjectTable::Row::initializeChildren()
{
    if (m_smartLayer_)
    {
        m_smartLayer_->initializeChildren();
    }
    if (m_header_)
    {
        m_header_->initializeChildren();
    }
}

} // namespace filestore
} // namespace smart
} // namespace nds
