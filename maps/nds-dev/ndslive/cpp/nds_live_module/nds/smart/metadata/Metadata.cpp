/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/smart/metadata/TileServiceCapabilities.h>

namespace nds
{
namespace smart
{
namespace metadata
{

TileServiceCapabilities::TileServiceCapabilities(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

TileServiceCapabilities::TileServiceCapabilities(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void TileServiceCapabilities::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::smart::metadata::TileServiceCapabilities::underlying_type>>(m_value);
}

size_t TileServiceCapabilities::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t TileServiceCapabilities::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::smart::metadata::TileServiceCapabilities::underlying_type>>(m_value);
}

size_t TileServiceCapabilities::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t TileServiceCapabilities::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t TileServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void TileServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void TileServiceCapabilities::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::smart::metadata::TileServiceCapabilities::underlying_type>>(out, m_value);
}

::zserio::string<> TileServiceCapabilities::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & TileServiceCapabilities::Values::GET_LAYER_BY_TILE_ID) == TileServiceCapabilities::Values::GET_LAYER_BY_TILE_ID)
        result += result.empty() ? "GET_LAYER_BY_TILE_ID" : " | GET_LAYER_BY_TILE_ID";
    if ((*this & TileServiceCapabilities::Values::GET_LAYER_BY_TILE_ID_LIST) == TileServiceCapabilities::Values::GET_LAYER_BY_TILE_ID_LIST)
        result += result.empty() ? "GET_LAYER_BY_TILE_ID_LIST" : " | GET_LAYER_BY_TILE_ID_LIST";
    if ((*this & TileServiceCapabilities::Values::GET_HEADER_ONLY_BY_TILE_ID) == TileServiceCapabilities::Values::GET_HEADER_ONLY_BY_TILE_ID)
        result += result.empty() ? "GET_HEADER_ONLY_BY_TILE_ID" : " | GET_HEADER_ONLY_BY_TILE_ID";
    if ((*this & TileServiceCapabilities::Values::GET_HEADER_ONLY_BY_TILE_ID_LIST) == TileServiceCapabilities::Values::GET_HEADER_ONLY_BY_TILE_ID_LIST)
        result += result.empty() ? "GET_HEADER_ONLY_BY_TILE_ID_LIST" : " | GET_HEADER_ONLY_BY_TILE_ID_LIST";
    if ((*this & TileServiceCapabilities::Values::GET_HEADER_ONLY_LIST_IN_TILE) == TileServiceCapabilities::Values::GET_HEADER_ONLY_LIST_IN_TILE)
        result += result.empty() ? "GET_HEADER_ONLY_LIST_IN_TILE" : " | GET_HEADER_ONLY_LIST_IN_TILE";
    if ((*this & TileServiceCapabilities::Values::TOPIC_NDS_SMART_TILE_UPDATE) == TileServiceCapabilities::Values::TOPIC_NDS_SMART_TILE_UPDATE)
        result += result.empty() ? "TOPIC_NDS_SMART_TILE_UPDATE" : " | TOPIC_NDS_SMART_TILE_UPDATE";
    if ((*this & TileServiceCapabilities::Values::GET_DELTA_LAYER_BY_TILE_ID) == TileServiceCapabilities::Values::GET_DELTA_LAYER_BY_TILE_ID)
        result += result.empty() ? "GET_DELTA_LAYER_BY_TILE_ID" : " | GET_DELTA_LAYER_BY_TILE_ID";
    if ((*this & TileServiceCapabilities::Values::GET_DELTA_LAYER_BY_TILE_ID_LIST) == TileServiceCapabilities::Values::GET_DELTA_LAYER_BY_TILE_ID_LIST)
        result += result.empty() ? "GET_DELTA_LAYER_BY_TILE_ID_LIST" : " | GET_DELTA_LAYER_BY_TILE_ID_LIST";
    if ((*this & TileServiceCapabilities::Values::GET_LAYER_BY_TILE_VERSION) == TileServiceCapabilities::Values::GET_LAYER_BY_TILE_VERSION)
        result += result.empty() ? "GET_LAYER_BY_TILE_VERSION" : " | GET_LAYER_BY_TILE_VERSION";
    if ((*this & TileServiceCapabilities::Values::GET_LAYER_BY_TILE_VERSION_LIST) == TileServiceCapabilities::Values::GET_LAYER_BY_TILE_VERSION_LIST)
        result += result.empty() ? "GET_LAYER_BY_TILE_VERSION_LIST" : " | GET_LAYER_BY_TILE_VERSION_LIST";
    if ((*this & TileServiceCapabilities::Values::GET_SINGLE_DATA_LAYER_BY_TILE_ID) == TileServiceCapabilities::Values::GET_SINGLE_DATA_LAYER_BY_TILE_ID)
        result += result.empty() ? "GET_SINGLE_DATA_LAYER_BY_TILE_ID" : " | GET_SINGLE_DATA_LAYER_BY_TILE_ID";
    if ((*this & TileServiceCapabilities::Values::GET_DATA_LAYER_LIST_BY_TILE_ID_LIST) == TileServiceCapabilities::Values::GET_DATA_LAYER_LIST_BY_TILE_ID_LIST)
        result += result.empty() ? "GET_DATA_LAYER_LIST_BY_TILE_ID_LIST" : " | GET_DATA_LAYER_LIST_BY_TILE_ID_LIST";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

TileServiceCapabilities::underlying_type TileServiceCapabilities::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

TileServiceCapabilities::underlying_type TileServiceCapabilities::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::smart::metadata::TileServiceCapabilities::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/smart/metadata/ObjectServiceCapabilities.h>

namespace nds
{
namespace smart
{
namespace metadata
{

ObjectServiceCapabilities::ObjectServiceCapabilities(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

ObjectServiceCapabilities::ObjectServiceCapabilities(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void ObjectServiceCapabilities::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::smart::metadata::ObjectServiceCapabilities::underlying_type>>(m_value);
}

size_t ObjectServiceCapabilities::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t ObjectServiceCapabilities::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::smart::metadata::ObjectServiceCapabilities::underlying_type>>(m_value);
}

size_t ObjectServiceCapabilities::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t ObjectServiceCapabilities::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t ObjectServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void ObjectServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void ObjectServiceCapabilities::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::smart::metadata::ObjectServiceCapabilities::underlying_type>>(out, m_value);
}

::zserio::string<> ObjectServiceCapabilities::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & ObjectServiceCapabilities::Values::GET_OBJECT_BY_REFERENCE) == ObjectServiceCapabilities::Values::GET_OBJECT_BY_REFERENCE)
        result += result.empty() ? "GET_OBJECT_BY_REFERENCE" : " | GET_OBJECT_BY_REFERENCE";
    if ((*this & ObjectServiceCapabilities::Values::GET_OBJECTS_IN_TILE) == ObjectServiceCapabilities::Values::GET_OBJECTS_IN_TILE)
        result += result.empty() ? "GET_OBJECTS_IN_TILE" : " | GET_OBJECTS_IN_TILE";
    if ((*this & ObjectServiceCapabilities::Values::GET_HEADER_ONLY_BY_OBJECT_REFERENCE) == ObjectServiceCapabilities::Values::GET_HEADER_ONLY_BY_OBJECT_REFERENCE)
        result += result.empty() ? "GET_HEADER_ONLY_BY_OBJECT_REFERENCE" : " | GET_HEADER_ONLY_BY_OBJECT_REFERENCE";
    if ((*this & ObjectServiceCapabilities::Values::GET_HEADER_ONLY_LIST_IN_TILE) == ObjectServiceCapabilities::Values::GET_HEADER_ONLY_LIST_IN_TILE)
        result += result.empty() ? "GET_HEADER_ONLY_LIST_IN_TILE" : " | GET_HEADER_ONLY_LIST_IN_TILE";
    if ((*this & ObjectServiceCapabilities::Values::GET_LOCATION_PATH_FOR_OBJECT_REFERENCE) == ObjectServiceCapabilities::Values::GET_LOCATION_PATH_FOR_OBJECT_REFERENCE)
        result += result.empty() ? "GET_LOCATION_PATH_FOR_OBJECT_REFERENCE" : " | GET_LOCATION_PATH_FOR_OBJECT_REFERENCE";
    if ((*this & ObjectServiceCapabilities::Values::GET_LOCATION_ID_FOR_OBJECT_REFERENCE) == ObjectServiceCapabilities::Values::GET_LOCATION_ID_FOR_OBJECT_REFERENCE)
        result += result.empty() ? "GET_LOCATION_ID_FOR_OBJECT_REFERENCE" : " | GET_LOCATION_ID_FOR_OBJECT_REFERENCE";
    if ((*this & ObjectServiceCapabilities::Values::TOPIC_NDS_SMART_OBJECT_UPDATE) == ObjectServiceCapabilities::Values::TOPIC_NDS_SMART_OBJECT_UPDATE)
        result += result.empty() ? "TOPIC_NDS_SMART_OBJECT_UPDATE" : " | TOPIC_NDS_SMART_OBJECT_UPDATE";
    if ((*this & ObjectServiceCapabilities::Values::GET_SINGLE_DATA_LAYER_BY_OBJECT_REFERENCE) == ObjectServiceCapabilities::Values::GET_SINGLE_DATA_LAYER_BY_OBJECT_REFERENCE)
        result += result.empty() ? "GET_SINGLE_DATA_LAYER_BY_OBJECT_REFERENCE" : " | GET_SINGLE_DATA_LAYER_BY_OBJECT_REFERENCE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

ObjectServiceCapabilities::underlying_type ObjectServiceCapabilities::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

ObjectServiceCapabilities::underlying_type ObjectServiceCapabilities::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::smart::metadata::ObjectServiceCapabilities::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/smart/metadata/PathServiceCapabilities.h>

namespace nds
{
namespace smart
{
namespace metadata
{

PathServiceCapabilities::PathServiceCapabilities(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

PathServiceCapabilities::PathServiceCapabilities(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void PathServiceCapabilities::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::smart::metadata::PathServiceCapabilities::underlying_type>>(m_value);
}

size_t PathServiceCapabilities::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t PathServiceCapabilities::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::smart::metadata::PathServiceCapabilities::underlying_type>>(m_value);
}

size_t PathServiceCapabilities::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t PathServiceCapabilities::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t PathServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void PathServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void PathServiceCapabilities::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::smart::metadata::PathServiceCapabilities::underlying_type>>(out, m_value);
}

::zserio::string<> PathServiceCapabilities::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & PathServiceCapabilities::Values::GET_DATA_ALONG_PATH) == PathServiceCapabilities::Values::GET_DATA_ALONG_PATH)
        result += result.empty() ? "GET_DATA_ALONG_PATH" : " | GET_DATA_ALONG_PATH";
    if ((*this & PathServiceCapabilities::Values::GET_PATHS_IN_TILE) == PathServiceCapabilities::Values::GET_PATHS_IN_TILE)
        result += result.empty() ? "GET_PATHS_IN_TILE" : " | GET_PATHS_IN_TILE";
    if ((*this & PathServiceCapabilities::Values::GET_HEADER_ONLY_BY_PATH) == PathServiceCapabilities::Values::GET_HEADER_ONLY_BY_PATH)
        result += result.empty() ? "GET_HEADER_ONLY_BY_PATH" : " | GET_HEADER_ONLY_BY_PATH";
    if ((*this & PathServiceCapabilities::Values::GET_HEADER_ONLY_LIST_IN_TILE) == PathServiceCapabilities::Values::GET_HEADER_ONLY_LIST_IN_TILE)
        result += result.empty() ? "GET_HEADER_ONLY_LIST_IN_TILE" : " | GET_HEADER_ONLY_LIST_IN_TILE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

PathServiceCapabilities::underlying_type PathServiceCapabilities::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

PathServiceCapabilities::underlying_type PathServiceCapabilities::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::smart::metadata::PathServiceCapabilities::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/smart/metadata/PathHorizonServiceCapabilities.h>

namespace nds
{
namespace smart
{
namespace metadata
{

PathHorizonServiceCapabilities::PathHorizonServiceCapabilities(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

PathHorizonServiceCapabilities::PathHorizonServiceCapabilities(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void PathHorizonServiceCapabilities::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::smart::metadata::PathHorizonServiceCapabilities::underlying_type>>(m_value);
}

size_t PathHorizonServiceCapabilities::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t PathHorizonServiceCapabilities::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::smart::metadata::PathHorizonServiceCapabilities::underlying_type>>(m_value);
}

size_t PathHorizonServiceCapabilities::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t PathHorizonServiceCapabilities::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t PathHorizonServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void PathHorizonServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void PathHorizonServiceCapabilities::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::smart::metadata::PathHorizonServiceCapabilities::underlying_type>>(out, m_value);
}

::zserio::string<> PathHorizonServiceCapabilities::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & PathHorizonServiceCapabilities::Values::GET_HORIZON_DATA_FOR_PATH) == PathHorizonServiceCapabilities::Values::GET_HORIZON_DATA_FOR_PATH)
        result += result.empty() ? "GET_HORIZON_DATA_FOR_PATH" : " | GET_HORIZON_DATA_FOR_PATH";
    if ((*this & PathHorizonServiceCapabilities::Values::GET_HORIZON_DATA_FOR_POSE) == PathHorizonServiceCapabilities::Values::GET_HORIZON_DATA_FOR_POSE)
        result += result.empty() ? "GET_HORIZON_DATA_FOR_POSE" : " | GET_HORIZON_DATA_FOR_POSE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

PathHorizonServiceCapabilities::underlying_type PathHorizonServiceCapabilities::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

PathHorizonServiceCapabilities::underlying_type PathHorizonServiceCapabilities::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::smart::metadata::PathHorizonServiceCapabilities::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/smart/metadata/MeshServiceCapabilities.h>

namespace nds
{
namespace smart
{
namespace metadata
{

MeshServiceCapabilities::MeshServiceCapabilities(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

MeshServiceCapabilities::MeshServiceCapabilities(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void MeshServiceCapabilities::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::smart::metadata::MeshServiceCapabilities::underlying_type>>(m_value);
}

size_t MeshServiceCapabilities::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t MeshServiceCapabilities::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::smart::metadata::MeshServiceCapabilities::underlying_type>>(m_value);
}

size_t MeshServiceCapabilities::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t MeshServiceCapabilities::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t MeshServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void MeshServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void MeshServiceCapabilities::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::smart::metadata::MeshServiceCapabilities::underlying_type>>(out, m_value);
}

::zserio::string<> MeshServiceCapabilities::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & MeshServiceCapabilities::Values::GET_MESH_INDEX_BY_TILE_ID) == MeshServiceCapabilities::Values::GET_MESH_INDEX_BY_TILE_ID)
        result += result.empty() ? "GET_MESH_INDEX_BY_TILE_ID" : " | GET_MESH_INDEX_BY_TILE_ID";
    if ((*this & MeshServiceCapabilities::Values::GET_MESH_BY_ID) == MeshServiceCapabilities::Values::GET_MESH_BY_ID)
        result += result.empty() ? "GET_MESH_BY_ID" : " | GET_MESH_BY_ID";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

MeshServiceCapabilities::underlying_type MeshServiceCapabilities::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

MeshServiceCapabilities::underlying_type MeshServiceCapabilities::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::smart::metadata::MeshServiceCapabilities::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/smart/metadata/RasterTileServiceCapabilities.h>

namespace nds
{
namespace smart
{
namespace metadata
{

RasterTileServiceCapabilities::RasterTileServiceCapabilities(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

RasterTileServiceCapabilities::RasterTileServiceCapabilities(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void RasterTileServiceCapabilities::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::smart::metadata::RasterTileServiceCapabilities::underlying_type>>(m_value);
}

size_t RasterTileServiceCapabilities::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t RasterTileServiceCapabilities::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::smart::metadata::RasterTileServiceCapabilities::underlying_type>>(m_value);
}

size_t RasterTileServiceCapabilities::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t RasterTileServiceCapabilities::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t RasterTileServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void RasterTileServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void RasterTileServiceCapabilities::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::smart::metadata::RasterTileServiceCapabilities::underlying_type>>(out, m_value);
}

::zserio::string<> RasterTileServiceCapabilities::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & RasterTileServiceCapabilities::Values::GET_IMAGE) == RasterTileServiceCapabilities::Values::GET_IMAGE)
        result += result.empty() ? "GET_IMAGE" : " | GET_IMAGE";
    if ((*this & RasterTileServiceCapabilities::Values::GET_TILE_METADATA) == RasterTileServiceCapabilities::Values::GET_TILE_METADATA)
        result += result.empty() ? "GET_TILE_METADATA" : " | GET_TILE_METADATA";
    if ((*this & RasterTileServiceCapabilities::Values::GET_IMAGE_VERSIONED) == RasterTileServiceCapabilities::Values::GET_IMAGE_VERSIONED)
        result += result.empty() ? "GET_IMAGE_VERSIONED" : " | GET_IMAGE_VERSIONED";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

RasterTileServiceCapabilities::underlying_type RasterTileServiceCapabilities::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

RasterTileServiceCapabilities::underlying_type RasterTileServiceCapabilities::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::smart::metadata::RasterTileServiceCapabilities::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/smart/metadata/SmartLayerRegistryMetadata.h>
#include <nds/smart/types/SmartLayerType.h>

namespace nds
{
namespace smart
{
namespace metadata
{

SmartLayerRegistryMetadata::SmartLayerRegistryMetadata(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_smartLayerType_(::nds::smart::types::SmartLayerType()),
        m_smartLayerDefinition_(allocator),
        m_capabilities_(allocator),
        m_supportedLevels_(::zserio::NullOpt),
        m_meshIndexContent_(::zserio::NullOpt),
        m_objectClass_(::zserio::NullOpt)
{
}

SmartLayerRegistryMetadata::SmartLayerRegistryMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_smartLayerType_(readSmartLayerType(in)),
        m_smartLayerDefinition_(readSmartLayerDefinition(in, allocator)),
        m_capabilities_(readCapabilities(in, allocator)),
        m_supportedLevels_(readSupportedLevels(in, allocator)),
        m_meshIndexContent_(readMeshIndexContent(in, allocator)),
        m_objectClass_(readObjectClass(in))
{
}

SmartLayerRegistryMetadata::SmartLayerRegistryMetadata(SmartLayerRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_smartLayerType_(readSmartLayerType(context, in)),
        m_smartLayerDefinition_(readSmartLayerDefinition(context, in, allocator)),
        m_capabilities_(readCapabilities(context, in, allocator)),
        m_supportedLevels_(readSupportedLevels(context, in, allocator)),
        m_meshIndexContent_(readMeshIndexContent(in, allocator)),
        m_objectClass_(readObjectClass(context, in))
{
}

SmartLayerRegistryMetadata::SmartLayerRegistryMetadata(const SmartLayerRegistryMetadata& other) :
        m_smartLayerType_(other.m_smartLayerType_),
        m_smartLayerDefinition_(other.m_smartLayerDefinition_),
        m_capabilities_(other.m_capabilities_),
        m_supportedLevels_(other.m_supportedLevels_),
        m_meshIndexContent_(other.m_meshIndexContent_),
        m_objectClass_(other.m_objectClass_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

SmartLayerRegistryMetadata& SmartLayerRegistryMetadata::operator=(const SmartLayerRegistryMetadata& other)
{
    m_smartLayerType_ = other.m_smartLayerType_;
    m_smartLayerDefinition_ = other.m_smartLayerDefinition_;
    m_capabilities_ = other.m_capabilities_;
    m_supportedLevels_ = other.m_supportedLevels_;
    m_meshIndexContent_ = other.m_meshIndexContent_;
    m_objectClass_ = other.m_objectClass_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

SmartLayerRegistryMetadata::SmartLayerRegistryMetadata(SmartLayerRegistryMetadata&& other) :
        m_smartLayerType_(::std::move(other.m_smartLayerType_)),
        m_smartLayerDefinition_(::std::move(other.m_smartLayerDefinition_)),
        m_capabilities_(::std::move(other.m_capabilities_)),
        m_supportedLevels_(::std::move(other.m_supportedLevels_)),
        m_meshIndexContent_(::std::move(other.m_meshIndexContent_)),
        m_objectClass_(::std::move(other.m_objectClass_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

SmartLayerRegistryMetadata& SmartLayerRegistryMetadata::operator=(SmartLayerRegistryMetadata&& other)
{
    m_smartLayerType_ = ::std::move(other.m_smartLayerType_);
    m_smartLayerDefinition_ = ::std::move(other.m_smartLayerDefinition_);
    m_capabilities_ = ::std::move(other.m_capabilities_);
    m_supportedLevels_ = ::std::move(other.m_supportedLevels_);
    m_meshIndexContent_ = ::std::move(other.m_meshIndexContent_);
    m_objectClass_ = ::std::move(other.m_objectClass_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

SmartLayerRegistryMetadata::SmartLayerRegistryMetadata(::zserio::PropagateAllocatorT,
        const SmartLayerRegistryMetadata& other, const allocator_type& allocator) :
        m_smartLayerType_(::zserio::allocatorPropagatingCopy(other.m_smartLayerType_, allocator)),
        m_smartLayerDefinition_(::zserio::allocatorPropagatingCopy(other.m_smartLayerDefinition_, allocator)),
        m_capabilities_(::zserio::allocatorPropagatingCopy(other.m_capabilities_, allocator)),
        m_supportedLevels_(::zserio::allocatorPropagatingCopy(other.m_supportedLevels_, allocator)),
        m_meshIndexContent_(::zserio::allocatorPropagatingCopy(other.m_meshIndexContent_, allocator)),
        m_objectClass_(::zserio::allocatorPropagatingCopy(other.m_objectClass_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void SmartLayerRegistryMetadata::initializeChildren()
{
    m_capabilities_.initialize(static_cast<::nds::smart::types::SmartLayerType>(getSmartLayerType()));

    m_areChildrenInitialized = true;
}

::nds::smart::types::SmartLayerType SmartLayerRegistryMetadata::getSmartLayerType() const
{
    return m_smartLayerType_;
}

void SmartLayerRegistryMetadata::setSmartLayerType(::nds::smart::types::SmartLayerType smartLayerType_)
{
    m_smartLayerType_ = smartLayerType_;
}

::nds::smart::metadata::SmartLayerDefinition& SmartLayerRegistryMetadata::getSmartLayerDefinition()
{
    return m_smartLayerDefinition_;
}

const ::nds::smart::metadata::SmartLayerDefinition& SmartLayerRegistryMetadata::getSmartLayerDefinition() const
{
    return m_smartLayerDefinition_;
}

void SmartLayerRegistryMetadata::setSmartLayerDefinition(const ::nds::smart::metadata::SmartLayerDefinition& smartLayerDefinition_)
{
    m_smartLayerDefinition_ = smartLayerDefinition_;
}

void SmartLayerRegistryMetadata::setSmartLayerDefinition(::nds::smart::metadata::SmartLayerDefinition&& smartLayerDefinition_)
{
    m_smartLayerDefinition_ = ::std::move(smartLayerDefinition_);
}

::nds::smart::metadata::SmartLayerServiceCapabilities& SmartLayerRegistryMetadata::getCapabilities()
{
    return m_capabilities_;
}

const ::nds::smart::metadata::SmartLayerServiceCapabilities& SmartLayerRegistryMetadata::getCapabilities() const
{
    return m_capabilities_;
}

void SmartLayerRegistryMetadata::setCapabilities(const ::nds::smart::metadata::SmartLayerServiceCapabilities& capabilities_)
{
    m_capabilities_ = capabilities_;
}

void SmartLayerRegistryMetadata::setCapabilities(::nds::smart::metadata::SmartLayerServiceCapabilities&& capabilities_)
{
    m_capabilities_ = ::std::move(capabilities_);
}

::zserio::vector<uint8_t>& SmartLayerRegistryMetadata::getSupportedLevels()
{
    return m_supportedLevels_.value().getRawArray();
}

const ::zserio::vector<uint8_t>& SmartLayerRegistryMetadata::getSupportedLevels() const
{
    return m_supportedLevels_.value().getRawArray();
}

void SmartLayerRegistryMetadata::setSupportedLevels(const ::zserio::vector<uint8_t>& supportedLevels_)
{
    m_supportedLevels_ = ZserioArrayType_supportedLevels(supportedLevels_);
}

void SmartLayerRegistryMetadata::setSupportedLevels(::zserio::vector<uint8_t>&& supportedLevels_)
{
    m_supportedLevels_ = ZserioArrayType_supportedLevels(std::move(supportedLevels_));
}

bool SmartLayerRegistryMetadata::isSupportedLevelsUsed() const
{
    return (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE || getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH);
}

bool SmartLayerRegistryMetadata::isSupportedLevelsSet() const
{
    return m_supportedLevels_.hasValue();
}

void SmartLayerRegistryMetadata::resetSupportedLevels()
{
    m_supportedLevels_.reset();
}

::nds::smart::metadata::SmartLayerMeshIndexContent& SmartLayerRegistryMetadata::getMeshIndexContent()
{
    return m_meshIndexContent_.value();
}

const ::nds::smart::metadata::SmartLayerMeshIndexContent& SmartLayerRegistryMetadata::getMeshIndexContent() const
{
    return m_meshIndexContent_.value();
}

void SmartLayerRegistryMetadata::setMeshIndexContent(const ::nds::smart::metadata::SmartLayerMeshIndexContent& meshIndexContent_)
{
    m_meshIndexContent_ = meshIndexContent_;
}

void SmartLayerRegistryMetadata::setMeshIndexContent(::nds::smart::metadata::SmartLayerMeshIndexContent&& meshIndexContent_)
{
    m_meshIndexContent_ = ::std::move(meshIndexContent_);
}

bool SmartLayerRegistryMetadata::isMeshIndexContentUsed() const
{
    return (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH);
}

bool SmartLayerRegistryMetadata::isMeshIndexContentSet() const
{
    return m_meshIndexContent_.hasValue();
}

void SmartLayerRegistryMetadata::resetMeshIndexContent()
{
    m_meshIndexContent_.reset();
}

::nds::smart::object::SmartLayerObjectClass SmartLayerRegistryMetadata::getObjectClass() const
{
    return m_objectClass_.value();
}

void SmartLayerRegistryMetadata::setObjectClass(::nds::smart::object::SmartLayerObjectClass objectClass_)
{
    m_objectClass_ = objectClass_;
}

bool SmartLayerRegistryMetadata::isObjectClassUsed() const
{
    return (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT);
}

bool SmartLayerRegistryMetadata::isObjectClassSet() const
{
    return m_objectClass_.hasValue();
}

void SmartLayerRegistryMetadata::resetObjectClass()
{
    m_objectClass_.reset();
}

void SmartLayerRegistryMetadata::initPackingContext(SmartLayerRegistryMetadata::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getSmartLayerType(), m_smartLayerType_);
    m_smartLayerDefinition_.initPackingContext(context.getSmartLayerDefinition());
    m_capabilities_.initPackingContext(context.getCapabilities());
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT)
    {
        context.getObjectClass().init<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(m_objectClass_.value());
    }
}

size_t SmartLayerRegistryMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_smartLayerType_);
    endBitPosition += m_smartLayerDefinition_.bitSizeOf(endBitPosition);
    endBitPosition += m_capabilities_.bitSizeOf(endBitPosition);
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE || getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        endBitPosition += m_supportedLevels_.value().bitSizeOf(endBitPosition);
    }
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        endBitPosition += m_meshIndexContent_.value().bitSizeOf(endBitPosition);
    }
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_objectClass_.value());
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerRegistryMetadata::bitSizeOf(SmartLayerRegistryMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getSmartLayerType(), m_smartLayerType_);
    endBitPosition += m_smartLayerDefinition_.bitSizeOf(context.getSmartLayerDefinition(), endBitPosition);
    endBitPosition += m_capabilities_.bitSizeOf(context.getCapabilities(), endBitPosition);
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE || getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        endBitPosition += m_supportedLevels_.value().bitSizeOfPacked(endBitPosition);
    }
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        endBitPosition += m_meshIndexContent_.value().bitSizeOf(endBitPosition);
    }
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT)
    {
        endBitPosition += context.getObjectClass().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(m_objectClass_.value());
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerRegistryMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_smartLayerType_);
    endBitPosition = m_smartLayerDefinition_.initializeOffsets(endBitPosition);
    endBitPosition = m_capabilities_.initializeOffsets(endBitPosition);
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE || getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        endBitPosition = m_supportedLevels_.value().initializeOffsets(endBitPosition);
    }
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        endBitPosition = m_meshIndexContent_.value().initializeOffsets(endBitPosition);
    }
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_objectClass_.value());
    }

    return endBitPosition;
}

size_t SmartLayerRegistryMetadata::initializeOffsets(SmartLayerRegistryMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getSmartLayerType(), endBitPosition,
        m_smartLayerType_);
    endBitPosition = m_smartLayerDefinition_.initializeOffsets(context.getSmartLayerDefinition(), endBitPosition);
    endBitPosition = m_capabilities_.initializeOffsets(context.getCapabilities(), endBitPosition);
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE || getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        endBitPosition = m_supportedLevels_.value().initializeOffsetsPacked(endBitPosition);
    }
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        endBitPosition = m_meshIndexContent_.value().initializeOffsets(endBitPosition);
    }
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT)
    {
        endBitPosition += context.getObjectClass().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(m_objectClass_.value());
    }

    return endBitPosition;
}

bool SmartLayerRegistryMetadata::operator==(const SmartLayerRegistryMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_smartLayerType_ == other.m_smartLayerType_) &&
                (m_smartLayerDefinition_ == other.m_smartLayerDefinition_) &&
                (m_capabilities_ == other.m_capabilities_) &&
                (!isSupportedLevelsUsed() ? !other.isSupportedLevelsUsed() : (m_supportedLevels_ == other.m_supportedLevels_)) &&
                (!isMeshIndexContentUsed() ? !other.isMeshIndexContentUsed() : (m_meshIndexContent_ == other.m_meshIndexContent_)) &&
                (!isObjectClassUsed() ? !other.isObjectClassUsed() : (m_objectClass_ == other.m_objectClass_));
    }

    return true;
}

uint32_t SmartLayerRegistryMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_smartLayerType_);
    result = ::zserio::calcHashCode(result, m_smartLayerDefinition_);
    result = ::zserio::calcHashCode(result, m_capabilities_);
    if (isSupportedLevelsUsed())
        result = ::zserio::calcHashCode(result, m_supportedLevels_);
    if (isMeshIndexContentUsed())
        result = ::zserio::calcHashCode(result, m_meshIndexContent_);
    if (isObjectClassUsed())
        result = ::zserio::calcHashCode(result, m_objectClass_);

    return result;
}

void SmartLayerRegistryMetadata::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_smartLayerType_);

    m_smartLayerDefinition_.write(out);

    // check parameters
    if (m_capabilities_.getType() != static_cast<::nds::smart::types::SmartLayerType>(getSmartLayerType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field SmartLayerRegistryMetadata.capabilities: ") <<
                m_capabilities_.getType() << " != " << static_cast<::nds::smart::types::SmartLayerType>(getSmartLayerType()) << "!";
    }
    m_capabilities_.write(out);

    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE || getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        m_supportedLevels_.value().write(out);
    }

    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        m_meshIndexContent_.value().write(out);
    }

    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT)
    {
        out.writeVarUInt32(m_objectClass_.value());
    }
}

void SmartLayerRegistryMetadata::write(SmartLayerRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getSmartLayerType(), out, m_smartLayerType_);

    m_smartLayerDefinition_.write(context.getSmartLayerDefinition(), out);

    // check parameters
    if (m_capabilities_.getType() != static_cast<::nds::smart::types::SmartLayerType>(getSmartLayerType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field SmartLayerRegistryMetadata.capabilities: ") <<
                m_capabilities_.getType() << " != " << static_cast<::nds::smart::types::SmartLayerType>(getSmartLayerType()) << "!";
    }
    m_capabilities_.write(context.getCapabilities(), out);

    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE || getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        m_supportedLevels_.value().writePacked(out);
    }

    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        m_meshIndexContent_.value().write(out);
    }

    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT)
    {
        context.getObjectClass().write<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(out, m_objectClass_.value());
    }
}

::nds::smart::types::SmartLayerType SmartLayerRegistryMetadata::readSmartLayerType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::smart::types::SmartLayerType>(in);
}

::nds::smart::types::SmartLayerType SmartLayerRegistryMetadata::readSmartLayerType(SmartLayerRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::smart::types::SmartLayerType>(context.getSmartLayerType(), in);
}
::nds::smart::metadata::SmartLayerDefinition SmartLayerRegistryMetadata::readSmartLayerDefinition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::metadata::SmartLayerDefinition(in, allocator);
}

::nds::smart::metadata::SmartLayerDefinition SmartLayerRegistryMetadata::readSmartLayerDefinition(SmartLayerRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::metadata::SmartLayerDefinition(context.getSmartLayerDefinition(), in, allocator);
}
::nds::smart::metadata::SmartLayerServiceCapabilities SmartLayerRegistryMetadata::readCapabilities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::metadata::SmartLayerServiceCapabilities(in, static_cast<::nds::smart::types::SmartLayerType>(getSmartLayerType()), allocator);
}

::nds::smart::metadata::SmartLayerServiceCapabilities SmartLayerRegistryMetadata::readCapabilities(SmartLayerRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::metadata::SmartLayerServiceCapabilities(context.getCapabilities(), in, static_cast<::nds::smart::types::SmartLayerType>(getSmartLayerType()), allocator);
}
::zserio::InplaceOptionalHolder<SmartLayerRegistryMetadata::ZserioArrayType_supportedLevels> SmartLayerRegistryMetadata::readSupportedLevels(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE || getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        ZserioArrayType_supportedLevels readField(allocator);
        readField.read(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_supportedLevels>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_supportedLevels>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<SmartLayerRegistryMetadata::ZserioArrayType_supportedLevels> SmartLayerRegistryMetadata::readSupportedLevels(SmartLayerRegistryMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE || getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        ZserioArrayType_supportedLevels readField(allocator);
        readField.readPacked(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_supportedLevels>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_supportedLevels>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::smart::metadata::SmartLayerMeshIndexContent> SmartLayerRegistryMetadata::readMeshIndexContent(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH)
    {
        return ::zserio::InplaceOptionalHolder<::nds::smart::metadata::SmartLayerMeshIndexContent>(::nds::smart::metadata::SmartLayerMeshIndexContent(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::smart::metadata::SmartLayerMeshIndexContent>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::smart::object::SmartLayerObjectClass> SmartLayerRegistryMetadata::readObjectClass(::zserio::BitStreamReader& in)
{
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT)
    {
        return ::zserio::InplaceOptionalHolder<::nds::smart::object::SmartLayerObjectClass>(static_cast<::nds::smart::object::SmartLayerObjectClass>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::smart::object::SmartLayerObjectClass>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::smart::object::SmartLayerObjectClass> SmartLayerRegistryMetadata::readObjectClass(SmartLayerRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getSmartLayerType() == ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT)
    {
        return ::zserio::InplaceOptionalHolder<::nds::smart::object::SmartLayerObjectClass>(context.getObjectClass().read<::zserio::VarIntNNArrayTraits<::nds::smart::object::SmartLayerObjectClass>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::smart::object::SmartLayerObjectClass>(::zserio::NullOpt);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/smart/metadata/SmartLayerDefinition.h>

namespace nds
{
namespace smart
{
namespace metadata
{

SmartLayerDefinition::SmartLayerDefinition(const allocator_type& allocator) noexcept :
        m_dataContents_(allocator),
        m_layerDefinitions_(allocator)
{
}

SmartLayerDefinition::SmartLayerDefinition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_dataContents_(readDataContents(in, allocator)),
        m_layerDefinitions_(readLayerDefinitions(in, allocator))
{
}

SmartLayerDefinition::SmartLayerDefinition(SmartLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_dataContents_(readDataContents(context, in, allocator)),
        m_layerDefinitions_(readLayerDefinitions(context, in, allocator))
{
}

SmartLayerDefinition::SmartLayerDefinition(::zserio::PropagateAllocatorT,
        const SmartLayerDefinition& other, const allocator_type& allocator) :
        m_dataContents_(::zserio::allocatorPropagatingCopy(other.m_dataContents_, allocator)),
        m_layerDefinitions_(::zserio::allocatorPropagatingCopy(other.m_layerDefinitions_, allocator))
{
}

::nds::smart::metadata::SmartLayerContent& SmartLayerDefinition::getDataContents()
{
    return m_dataContents_;
}

const ::nds::smart::metadata::SmartLayerContent& SmartLayerDefinition::getDataContents() const
{
    return m_dataContents_;
}

void SmartLayerDefinition::setDataContents(const ::nds::smart::metadata::SmartLayerContent& dataContents_)
{
    m_dataContents_ = dataContents_;
}

void SmartLayerDefinition::setDataContents(::nds::smart::metadata::SmartLayerContent&& dataContents_)
{
    m_dataContents_ = ::std::move(dataContents_);
}

::zserio::vector<::nds::smart::types::DataLayerDefinition>& SmartLayerDefinition::getLayerDefinitions()
{
    return m_layerDefinitions_.getRawArray();
}

const ::zserio::vector<::nds::smart::types::DataLayerDefinition>& SmartLayerDefinition::getLayerDefinitions() const
{
    return m_layerDefinitions_.getRawArray();
}

void SmartLayerDefinition::setLayerDefinitions(const ::zserio::vector<::nds::smart::types::DataLayerDefinition>& layerDefinitions_)
{
    m_layerDefinitions_ = ZserioArrayType_layerDefinitions(layerDefinitions_);
}

void SmartLayerDefinition::setLayerDefinitions(::zserio::vector<::nds::smart::types::DataLayerDefinition>&& layerDefinitions_)
{
    m_layerDefinitions_ = ZserioArrayType_layerDefinitions(std::move(layerDefinitions_));
}

void SmartLayerDefinition::initPackingContext(SmartLayerDefinition::ZserioPackingContext& context) const
{
    m_dataContents_.initPackingContext(context.getDataContents());
}

size_t SmartLayerDefinition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_dataContents_.bitSizeOf(endBitPosition);
    endBitPosition += m_layerDefinitions_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerDefinition::bitSizeOf(SmartLayerDefinition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_dataContents_.bitSizeOf(context.getDataContents(), endBitPosition);
    endBitPosition += m_layerDefinitions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerDefinition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_dataContents_.initializeOffsets(endBitPosition);
    endBitPosition = m_layerDefinitions_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerDefinition::initializeOffsets(SmartLayerDefinition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_dataContents_.initializeOffsets(context.getDataContents(), endBitPosition);
    endBitPosition = m_layerDefinitions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerDefinition::operator==(const SmartLayerDefinition& other) const
{
    if (this != &other)
    {
        return
                (m_dataContents_ == other.m_dataContents_) &&
                (m_layerDefinitions_ == other.m_layerDefinitions_);
    }

    return true;
}

uint32_t SmartLayerDefinition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_dataContents_);
    result = ::zserio::calcHashCode(result, m_layerDefinitions_);

    return result;
}

void SmartLayerDefinition::write(::zserio::BitStreamWriter& out) const
{
    m_dataContents_.write(out);

    // check constraint
    if (!(getLayerDefinitions().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at SmartLayerDefinition.layerDefinitions!");
    m_layerDefinitions_.write(*this, out);
}

void SmartLayerDefinition::write(SmartLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_dataContents_.write(context.getDataContents(), out);

    // check constraint
    if (!(getLayerDefinitions().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at SmartLayerDefinition.layerDefinitions!");
    m_layerDefinitions_.writePacked(*this, out);
}

void SmartLayerDefinition::ZserioElementFactory_layerDefinitions::create(SmartLayerDefinition&        ,
        ::zserio::vector<::nds::smart::types::DataLayerDefinition>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerDefinition::ZserioElementFactory_layerDefinitions::create(SmartLayerDefinition&        ,
        ::zserio::vector<::nds::smart::types::DataLayerDefinition>& array,
        ::nds::smart::types::DataLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::smart::metadata::SmartLayerContent SmartLayerDefinition::readDataContents(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::metadata::SmartLayerContent(in, allocator);
}

::nds::smart::metadata::SmartLayerContent SmartLayerDefinition::readDataContents(SmartLayerDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::metadata::SmartLayerContent(context.getDataContents(), in, allocator);
}
SmartLayerDefinition::ZserioArrayType_layerDefinitions SmartLayerDefinition::readLayerDefinitions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_layerDefinitions readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at SmartLayerDefinition.layerDefinitions!");

    return readField;
}

SmartLayerDefinition::ZserioArrayType_layerDefinitions SmartLayerDefinition::readLayerDefinitions(SmartLayerDefinition::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_layerDefinitions readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at SmartLayerDefinition.layerDefinitions!");

    return readField;
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/SmartLayerContent.h>

namespace nds
{
namespace smart
{
namespace metadata
{

SmartLayerContent::SmartLayerContent(const allocator_type& allocator) noexcept :
        m_coveredRoadTypes_(allocator),
        m_vehicleTypes_(allocator),
        m_vehicleClass_(::zserio::NullOpt)
{
}

SmartLayerContent::SmartLayerContent(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_coveredRoadTypes_(readCoveredRoadTypes(in, allocator)),
        m_vehicleTypes_(readVehicleTypes(in, allocator)),
        m_vehicleClass_(readVehicleClass(in, allocator))
{
}

SmartLayerContent::SmartLayerContent(SmartLayerContent::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_coveredRoadTypes_(readCoveredRoadTypes(context, in, allocator)),
        m_vehicleTypes_(readVehicleTypes(context, in, allocator)),
        m_vehicleClass_(readVehicleClass(context, in, allocator))
{
}

SmartLayerContent::SmartLayerContent(::zserio::PropagateAllocatorT,
        const SmartLayerContent& other, const allocator_type& allocator) :
        m_coveredRoadTypes_(::zserio::allocatorPropagatingCopy(other.m_coveredRoadTypes_, allocator)),
        m_vehicleTypes_(::zserio::allocatorPropagatingCopy(other.m_vehicleTypes_, allocator)),
        m_vehicleClass_(::zserio::allocatorPropagatingCopy(other.m_vehicleClass_, allocator))
{
}

::zserio::vector<::nds::core::types::RoadType>& SmartLayerContent::getCoveredRoadTypes()
{
    return m_coveredRoadTypes_.getRawArray();
}

const ::zserio::vector<::nds::core::types::RoadType>& SmartLayerContent::getCoveredRoadTypes() const
{
    return m_coveredRoadTypes_.getRawArray();
}

void SmartLayerContent::setCoveredRoadTypes(const ::zserio::vector<::nds::core::types::RoadType>& coveredRoadTypes_)
{
    m_coveredRoadTypes_ = ZserioArrayType_coveredRoadTypes(coveredRoadTypes_);
}

void SmartLayerContent::setCoveredRoadTypes(::zserio::vector<::nds::core::types::RoadType>&& coveredRoadTypes_)
{
    m_coveredRoadTypes_ = ZserioArrayType_coveredRoadTypes(std::move(coveredRoadTypes_));
}

::nds::core::vehicle::VehicleTypeInformation& SmartLayerContent::getVehicleTypes()
{
    return m_vehicleTypes_;
}

const ::nds::core::vehicle::VehicleTypeInformation& SmartLayerContent::getVehicleTypes() const
{
    return m_vehicleTypes_;
}

void SmartLayerContent::setVehicleTypes(const ::nds::core::vehicle::VehicleTypeInformation& vehicleTypes_)
{
    m_vehicleTypes_ = vehicleTypes_;
}

void SmartLayerContent::setVehicleTypes(::nds::core::vehicle::VehicleTypeInformation&& vehicleTypes_)
{
    m_vehicleTypes_ = ::std::move(vehicleTypes_);
}

::nds::core::vehicle::VehicleClassSpecification& SmartLayerContent::getVehicleClass()
{
    return m_vehicleClass_.value();
}

const ::nds::core::vehicle::VehicleClassSpecification& SmartLayerContent::getVehicleClass() const
{
    return m_vehicleClass_.value();
}

void SmartLayerContent::setVehicleClass(const ::nds::core::vehicle::VehicleClassSpecification& vehicleClass_)
{
    m_vehicleClass_ = vehicleClass_;
}

void SmartLayerContent::setVehicleClass(::nds::core::vehicle::VehicleClassSpecification&& vehicleClass_)
{
    m_vehicleClass_ = ::std::move(vehicleClass_);
}

bool SmartLayerContent::isVehicleClassUsed() const
{
    return (isVehicleClassSet());
}

bool SmartLayerContent::isVehicleClassSet() const
{
    return m_vehicleClass_.hasValue();
}

void SmartLayerContent::resetVehicleClass()
{
    m_vehicleClass_.reset();
}

void SmartLayerContent::initPackingContext(SmartLayerContent::ZserioPackingContext& context) const
{
    m_vehicleTypes_.initPackingContext(context.getVehicleTypes());
    if (isVehicleClassSet())
    {
        m_vehicleClass_.value().initPackingContext(context.getVehicleClass());
    }
}

size_t SmartLayerContent::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_coveredRoadTypes_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_vehicleTypes_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isVehicleClassSet())
    {
        endBitPosition += m_vehicleClass_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerContent::bitSizeOf(SmartLayerContent::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_coveredRoadTypes_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_vehicleTypes_.bitSizeOf(context.getVehicleTypes(), endBitPosition);
    endBitPosition += 1;
    if (isVehicleClassSet())
    {
        endBitPosition += m_vehicleClass_.value().bitSizeOf(context.getVehicleClass(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerContent::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_coveredRoadTypes_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_vehicleTypes_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isVehicleClassSet())
    {
        endBitPosition = m_vehicleClass_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t SmartLayerContent::initializeOffsets(SmartLayerContent::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_coveredRoadTypes_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_vehicleTypes_.initializeOffsets(context.getVehicleTypes(), endBitPosition);
    endBitPosition += 1;
    if (isVehicleClassSet())
    {
        endBitPosition = m_vehicleClass_.value().initializeOffsets(context.getVehicleClass(), endBitPosition);
    }

    return endBitPosition;
}

bool SmartLayerContent::operator==(const SmartLayerContent& other) const
{
    if (this != &other)
    {
        return
                (m_coveredRoadTypes_ == other.m_coveredRoadTypes_) &&
                (m_vehicleTypes_ == other.m_vehicleTypes_) &&
                (!isVehicleClassUsed() ? !other.isVehicleClassUsed() : (m_vehicleClass_ == other.m_vehicleClass_));
    }

    return true;
}

uint32_t SmartLayerContent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_coveredRoadTypes_);
    result = ::zserio::calcHashCode(result, m_vehicleTypes_);
    if (isVehicleClassUsed())
        result = ::zserio::calcHashCode(result, m_vehicleClass_);

    return result;
}

void SmartLayerContent::write(::zserio::BitStreamWriter& out) const
{
    m_coveredRoadTypes_.write(*this, out);
    m_vehicleTypes_.write(out);
    if (isVehicleClassSet())
    {
        out.writeBool(true);
        m_vehicleClass_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void SmartLayerContent::write(SmartLayerContent::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_coveredRoadTypes_.writePacked(*this, out);
    m_vehicleTypes_.write(context.getVehicleTypes(), out);
    if (isVehicleClassSet())
    {
        out.writeBool(true);
        m_vehicleClass_.value().write(context.getVehicleClass(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

void SmartLayerContent::ZserioElementFactory_coveredRoadTypes::create(SmartLayerContent&        ,
        ::zserio::vector<::nds::core::types::RoadType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerContent::ZserioElementFactory_coveredRoadTypes::create(SmartLayerContent&        ,
        ::zserio::vector<::nds::core::types::RoadType>& array,
        ::nds::core::types::RoadType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

SmartLayerContent::ZserioArrayType_coveredRoadTypes SmartLayerContent::readCoveredRoadTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_coveredRoadTypes readField(allocator);
    readField.read(*this, in);

    return readField;
}

SmartLayerContent::ZserioArrayType_coveredRoadTypes SmartLayerContent::readCoveredRoadTypes(SmartLayerContent::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_coveredRoadTypes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::vehicle::VehicleTypeInformation SmartLayerContent::readVehicleTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleTypeInformation(in, allocator);
}

::nds::core::vehicle::VehicleTypeInformation SmartLayerContent::readVehicleTypes(SmartLayerContent::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleTypeInformation(context.getVehicleTypes(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleClassSpecification> SmartLayerContent::readVehicleClass(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleClassSpecification>(::nds::core::vehicle::VehicleClassSpecification(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleClassSpecification>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleClassSpecification> SmartLayerContent::readVehicleClass(SmartLayerContent::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleClassSpecification>(::nds::core::vehicle::VehicleClassSpecification(context.getVehicleClass(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleClassSpecification>(::zserio::NullOpt);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/SmartLayerMeshIndexContent.h>

namespace nds
{
namespace smart
{
namespace metadata
{

SmartLayerMeshIndexContent::SmartLayerMeshIndexContent(const allocator_type&) noexcept :
        m_hasHeaders_(bool()),
        m_hasSizes_(bool())
{
}

SmartLayerMeshIndexContent::SmartLayerMeshIndexContent(::zserio::BitStreamReader& in, const allocator_type&) :
        m_hasHeaders_(readHasHeaders(in)),
        m_hasSizes_(readHasSizes(in))
{
}

SmartLayerMeshIndexContent::SmartLayerMeshIndexContent(::zserio::PropagateAllocatorT,
        const SmartLayerMeshIndexContent& other, const allocator_type& allocator) :
        m_hasHeaders_(::zserio::allocatorPropagatingCopy(other.m_hasHeaders_, allocator)),
        m_hasSizes_(::zserio::allocatorPropagatingCopy(other.m_hasSizes_, allocator))
{
}

bool SmartLayerMeshIndexContent::getHasHeaders() const
{
    return m_hasHeaders_;
}

void SmartLayerMeshIndexContent::setHasHeaders(bool hasHeaders_)
{
    m_hasHeaders_ = hasHeaders_;
}

bool SmartLayerMeshIndexContent::getHasSizes() const
{
    return m_hasSizes_;
}

void SmartLayerMeshIndexContent::setHasSizes(bool hasSizes_)
{
    m_hasSizes_ = hasSizes_;
}

size_t SmartLayerMeshIndexContent::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t SmartLayerMeshIndexContent::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool SmartLayerMeshIndexContent::operator==(const SmartLayerMeshIndexContent& other) const
{
    if (this != &other)
    {
        return
                (m_hasHeaders_ == other.m_hasHeaders_) &&
                (m_hasSizes_ == other.m_hasSizes_);
    }

    return true;
}

uint32_t SmartLayerMeshIndexContent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_hasHeaders_);
    result = ::zserio::calcHashCode(result, m_hasSizes_);

    return result;
}

void SmartLayerMeshIndexContent::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasHeaders_);
    out.writeBool(m_hasSizes_);
}

bool SmartLayerMeshIndexContent::readHasHeaders(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool SmartLayerMeshIndexContent::readHasSizes(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/TileServiceCapabilitiesResponse.h>

namespace nds
{
namespace smart
{
namespace metadata
{

TileServiceCapabilitiesResponse::TileServiceCapabilitiesResponse(const allocator_type&) noexcept :
        m_capabilities_(::nds::smart::metadata::TileServiceCapabilities())
{
}

TileServiceCapabilitiesResponse::TileServiceCapabilitiesResponse(::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(in))
{
}

TileServiceCapabilitiesResponse::TileServiceCapabilitiesResponse(TileServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(context, in))
{
}

TileServiceCapabilitiesResponse::TileServiceCapabilitiesResponse(::zserio::PropagateAllocatorT,
        const TileServiceCapabilitiesResponse& other, const allocator_type& allocator) :
        m_capabilities_(::zserio::allocatorPropagatingCopy(other.m_capabilities_, allocator))
{
}

::nds::smart::metadata::TileServiceCapabilities TileServiceCapabilitiesResponse::getCapabilities() const
{
    return m_capabilities_;
}

void TileServiceCapabilitiesResponse::setCapabilities(::nds::smart::metadata::TileServiceCapabilities capabilities_)
{
    m_capabilities_ = capabilities_;
}

void TileServiceCapabilitiesResponse::initPackingContext(TileServiceCapabilitiesResponse::ZserioPackingContext& context) const
{
    m_capabilities_.initPackingContext(context.getCapabilities());
}

size_t TileServiceCapabilitiesResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TileServiceCapabilitiesResponse::bitSizeOf(TileServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(context.getCapabilities(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TileServiceCapabilitiesResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TileServiceCapabilitiesResponse::initializeOffsets(TileServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(context.getCapabilities(), endBitPosition);

    return endBitPosition;
}

bool TileServiceCapabilitiesResponse::operator==(const TileServiceCapabilitiesResponse& other) const
{
    if (this != &other)
    {
        return
                (m_capabilities_ == other.m_capabilities_);
    }

    return true;
}

uint32_t TileServiceCapabilitiesResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_capabilities_);

    return result;
}

void TileServiceCapabilitiesResponse::write(::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(out);
}

void TileServiceCapabilitiesResponse::write(TileServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(context.getCapabilities(), out);
}

::nds::smart::metadata::TileServiceCapabilities TileServiceCapabilitiesResponse::readCapabilities(::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::TileServiceCapabilities(in);
}

::nds::smart::metadata::TileServiceCapabilities TileServiceCapabilitiesResponse::readCapabilities(TileServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::TileServiceCapabilities(context.getCapabilities(), in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/ObjectServiceCapabilitiesResponse.h>

namespace nds
{
namespace smart
{
namespace metadata
{

ObjectServiceCapabilitiesResponse::ObjectServiceCapabilitiesResponse(const allocator_type&) noexcept :
        m_capabilities_(::nds::smart::metadata::ObjectServiceCapabilities())
{
}

ObjectServiceCapabilitiesResponse::ObjectServiceCapabilitiesResponse(::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(in))
{
}

ObjectServiceCapabilitiesResponse::ObjectServiceCapabilitiesResponse(ObjectServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(context, in))
{
}

ObjectServiceCapabilitiesResponse::ObjectServiceCapabilitiesResponse(::zserio::PropagateAllocatorT,
        const ObjectServiceCapabilitiesResponse& other, const allocator_type& allocator) :
        m_capabilities_(::zserio::allocatorPropagatingCopy(other.m_capabilities_, allocator))
{
}

::nds::smart::metadata::ObjectServiceCapabilities ObjectServiceCapabilitiesResponse::getCapabilities() const
{
    return m_capabilities_;
}

void ObjectServiceCapabilitiesResponse::setCapabilities(::nds::smart::metadata::ObjectServiceCapabilities capabilities_)
{
    m_capabilities_ = capabilities_;
}

void ObjectServiceCapabilitiesResponse::initPackingContext(ObjectServiceCapabilitiesResponse::ZserioPackingContext& context) const
{
    m_capabilities_.initPackingContext(context.getCapabilities());
}

size_t ObjectServiceCapabilitiesResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ObjectServiceCapabilitiesResponse::bitSizeOf(ObjectServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(context.getCapabilities(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ObjectServiceCapabilitiesResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ObjectServiceCapabilitiesResponse::initializeOffsets(ObjectServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(context.getCapabilities(), endBitPosition);

    return endBitPosition;
}

bool ObjectServiceCapabilitiesResponse::operator==(const ObjectServiceCapabilitiesResponse& other) const
{
    if (this != &other)
    {
        return
                (m_capabilities_ == other.m_capabilities_);
    }

    return true;
}

uint32_t ObjectServiceCapabilitiesResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_capabilities_);

    return result;
}

void ObjectServiceCapabilitiesResponse::write(::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(out);
}

void ObjectServiceCapabilitiesResponse::write(ObjectServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(context.getCapabilities(), out);
}

::nds::smart::metadata::ObjectServiceCapabilities ObjectServiceCapabilitiesResponse::readCapabilities(::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::ObjectServiceCapabilities(in);
}

::nds::smart::metadata::ObjectServiceCapabilities ObjectServiceCapabilitiesResponse::readCapabilities(ObjectServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::ObjectServiceCapabilities(context.getCapabilities(), in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/PathServiceCapabilitiesResponse.h>

namespace nds
{
namespace smart
{
namespace metadata
{

PathServiceCapabilitiesResponse::PathServiceCapabilitiesResponse(const allocator_type&) noexcept :
        m_capabilities_(::nds::smart::metadata::PathServiceCapabilities())
{
}

PathServiceCapabilitiesResponse::PathServiceCapabilitiesResponse(::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(in))
{
}

PathServiceCapabilitiesResponse::PathServiceCapabilitiesResponse(PathServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(context, in))
{
}

PathServiceCapabilitiesResponse::PathServiceCapabilitiesResponse(::zserio::PropagateAllocatorT,
        const PathServiceCapabilitiesResponse& other, const allocator_type& allocator) :
        m_capabilities_(::zserio::allocatorPropagatingCopy(other.m_capabilities_, allocator))
{
}

::nds::smart::metadata::PathServiceCapabilities PathServiceCapabilitiesResponse::getCapabilities() const
{
    return m_capabilities_;
}

void PathServiceCapabilitiesResponse::setCapabilities(::nds::smart::metadata::PathServiceCapabilities capabilities_)
{
    m_capabilities_ = capabilities_;
}

void PathServiceCapabilitiesResponse::initPackingContext(PathServiceCapabilitiesResponse::ZserioPackingContext& context) const
{
    m_capabilities_.initPackingContext(context.getCapabilities());
}

size_t PathServiceCapabilitiesResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PathServiceCapabilitiesResponse::bitSizeOf(PathServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(context.getCapabilities(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PathServiceCapabilitiesResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t PathServiceCapabilitiesResponse::initializeOffsets(PathServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(context.getCapabilities(), endBitPosition);

    return endBitPosition;
}

bool PathServiceCapabilitiesResponse::operator==(const PathServiceCapabilitiesResponse& other) const
{
    if (this != &other)
    {
        return
                (m_capabilities_ == other.m_capabilities_);
    }

    return true;
}

uint32_t PathServiceCapabilitiesResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_capabilities_);

    return result;
}

void PathServiceCapabilitiesResponse::write(::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(out);
}

void PathServiceCapabilitiesResponse::write(PathServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(context.getCapabilities(), out);
}

::nds::smart::metadata::PathServiceCapabilities PathServiceCapabilitiesResponse::readCapabilities(::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::PathServiceCapabilities(in);
}

::nds::smart::metadata::PathServiceCapabilities PathServiceCapabilitiesResponse::readCapabilities(PathServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::PathServiceCapabilities(context.getCapabilities(), in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/PathHorizonServiceCapabilitiesResponse.h>

namespace nds
{
namespace smart
{
namespace metadata
{

PathHorizonServiceCapabilitiesResponse::PathHorizonServiceCapabilitiesResponse(const allocator_type&) noexcept :
        m_capabilities_(::nds::smart::metadata::PathHorizonServiceCapabilities())
{
}

PathHorizonServiceCapabilitiesResponse::PathHorizonServiceCapabilitiesResponse(::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(in))
{
}

PathHorizonServiceCapabilitiesResponse::PathHorizonServiceCapabilitiesResponse(PathHorizonServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(context, in))
{
}

PathHorizonServiceCapabilitiesResponse::PathHorizonServiceCapabilitiesResponse(::zserio::PropagateAllocatorT,
        const PathHorizonServiceCapabilitiesResponse& other, const allocator_type& allocator) :
        m_capabilities_(::zserio::allocatorPropagatingCopy(other.m_capabilities_, allocator))
{
}

::nds::smart::metadata::PathHorizonServiceCapabilities PathHorizonServiceCapabilitiesResponse::getCapabilities() const
{
    return m_capabilities_;
}

void PathHorizonServiceCapabilitiesResponse::setCapabilities(::nds::smart::metadata::PathHorizonServiceCapabilities capabilities_)
{
    m_capabilities_ = capabilities_;
}

void PathHorizonServiceCapabilitiesResponse::initPackingContext(PathHorizonServiceCapabilitiesResponse::ZserioPackingContext& context) const
{
    m_capabilities_.initPackingContext(context.getCapabilities());
}

size_t PathHorizonServiceCapabilitiesResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PathHorizonServiceCapabilitiesResponse::bitSizeOf(PathHorizonServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(context.getCapabilities(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PathHorizonServiceCapabilitiesResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t PathHorizonServiceCapabilitiesResponse::initializeOffsets(PathHorizonServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(context.getCapabilities(), endBitPosition);

    return endBitPosition;
}

bool PathHorizonServiceCapabilitiesResponse::operator==(const PathHorizonServiceCapabilitiesResponse& other) const
{
    if (this != &other)
    {
        return
                (m_capabilities_ == other.m_capabilities_);
    }

    return true;
}

uint32_t PathHorizonServiceCapabilitiesResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_capabilities_);

    return result;
}

void PathHorizonServiceCapabilitiesResponse::write(::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(out);
}

void PathHorizonServiceCapabilitiesResponse::write(PathHorizonServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(context.getCapabilities(), out);
}

::nds::smart::metadata::PathHorizonServiceCapabilities PathHorizonServiceCapabilitiesResponse::readCapabilities(::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::PathHorizonServiceCapabilities(in);
}

::nds::smart::metadata::PathHorizonServiceCapabilities PathHorizonServiceCapabilitiesResponse::readCapabilities(PathHorizonServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::PathHorizonServiceCapabilities(context.getCapabilities(), in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/MeshServiceCapabilitiesResponse.h>

namespace nds
{
namespace smart
{
namespace metadata
{

MeshServiceCapabilitiesResponse::MeshServiceCapabilitiesResponse(const allocator_type&) noexcept :
        m_capabilities_(::nds::smart::metadata::MeshServiceCapabilities())
{
}

MeshServiceCapabilitiesResponse::MeshServiceCapabilitiesResponse(::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(in))
{
}

MeshServiceCapabilitiesResponse::MeshServiceCapabilitiesResponse(MeshServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(context, in))
{
}

MeshServiceCapabilitiesResponse::MeshServiceCapabilitiesResponse(::zserio::PropagateAllocatorT,
        const MeshServiceCapabilitiesResponse& other, const allocator_type& allocator) :
        m_capabilities_(::zserio::allocatorPropagatingCopy(other.m_capabilities_, allocator))
{
}

::nds::smart::metadata::MeshServiceCapabilities MeshServiceCapabilitiesResponse::getCapabilities() const
{
    return m_capabilities_;
}

void MeshServiceCapabilitiesResponse::setCapabilities(::nds::smart::metadata::MeshServiceCapabilities capabilities_)
{
    m_capabilities_ = capabilities_;
}

void MeshServiceCapabilitiesResponse::initPackingContext(MeshServiceCapabilitiesResponse::ZserioPackingContext& context) const
{
    m_capabilities_.initPackingContext(context.getCapabilities());
}

size_t MeshServiceCapabilitiesResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MeshServiceCapabilitiesResponse::bitSizeOf(MeshServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(context.getCapabilities(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MeshServiceCapabilitiesResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t MeshServiceCapabilitiesResponse::initializeOffsets(MeshServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(context.getCapabilities(), endBitPosition);

    return endBitPosition;
}

bool MeshServiceCapabilitiesResponse::operator==(const MeshServiceCapabilitiesResponse& other) const
{
    if (this != &other)
    {
        return
                (m_capabilities_ == other.m_capabilities_);
    }

    return true;
}

uint32_t MeshServiceCapabilitiesResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_capabilities_);

    return result;
}

void MeshServiceCapabilitiesResponse::write(::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(out);
}

void MeshServiceCapabilitiesResponse::write(MeshServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(context.getCapabilities(), out);
}

::nds::smart::metadata::MeshServiceCapabilities MeshServiceCapabilitiesResponse::readCapabilities(::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::MeshServiceCapabilities(in);
}

::nds::smart::metadata::MeshServiceCapabilities MeshServiceCapabilitiesResponse::readCapabilities(MeshServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::MeshServiceCapabilities(context.getCapabilities(), in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/SmartRasterRegistryMetadata.h>

namespace nds
{
namespace smart
{
namespace metadata
{

SmartRasterRegistryMetadata::SmartRasterRegistryMetadata(const allocator_type& allocator) noexcept :
        m_metadataExtern_(allocator)
{
}

SmartRasterRegistryMetadata::SmartRasterRegistryMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_metadataExtern_(readMetadataExtern(in, allocator))
{
}

SmartRasterRegistryMetadata::SmartRasterRegistryMetadata(::zserio::PropagateAllocatorT,
        const SmartRasterRegistryMetadata& other, const allocator_type& allocator) :
        m_metadataExtern_(::zserio::allocatorPropagatingCopy(other.m_metadataExtern_, allocator))
{
}

::nds::smart::metadata::RasterRegistryMetadataExtern& SmartRasterRegistryMetadata::getMetadataExtern()
{
    return m_metadataExtern_;
}

const ::nds::smart::metadata::RasterRegistryMetadataExtern& SmartRasterRegistryMetadata::getMetadataExtern() const
{
    return m_metadataExtern_;
}

void SmartRasterRegistryMetadata::setMetadataExtern(const ::nds::smart::metadata::RasterRegistryMetadataExtern& metadataExtern_)
{
    m_metadataExtern_ = metadataExtern_;
}

void SmartRasterRegistryMetadata::setMetadataExtern(::nds::smart::metadata::RasterRegistryMetadataExtern&& metadataExtern_)
{
    m_metadataExtern_ = ::std::move(metadataExtern_);
}

size_t SmartRasterRegistryMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_metadataExtern_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartRasterRegistryMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_metadataExtern_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

bool SmartRasterRegistryMetadata::operator==(const SmartRasterRegistryMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_metadataExtern_ == other.m_metadataExtern_);
    }

    return true;
}

uint32_t SmartRasterRegistryMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_metadataExtern_);

    return result;
}

void SmartRasterRegistryMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_metadataExtern_.write(out);
}

::nds::smart::metadata::RasterRegistryMetadataExtern SmartRasterRegistryMetadata::readMetadataExtern(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::metadata::RasterRegistryMetadataExtern(in, allocator);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/RasterTileServiceCapabilitiesResponse.h>

namespace nds
{
namespace smart
{
namespace metadata
{

RasterTileServiceCapabilitiesResponse::RasterTileServiceCapabilitiesResponse(const allocator_type&) noexcept :
        m_capabilities_(::nds::smart::metadata::RasterTileServiceCapabilities())
{
}

RasterTileServiceCapabilitiesResponse::RasterTileServiceCapabilitiesResponse(::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(in))
{
}

RasterTileServiceCapabilitiesResponse::RasterTileServiceCapabilitiesResponse(RasterTileServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(context, in))
{
}

RasterTileServiceCapabilitiesResponse::RasterTileServiceCapabilitiesResponse(::zserio::PropagateAllocatorT,
        const RasterTileServiceCapabilitiesResponse& other, const allocator_type& allocator) :
        m_capabilities_(::zserio::allocatorPropagatingCopy(other.m_capabilities_, allocator))
{
}

::nds::smart::metadata::RasterTileServiceCapabilities RasterTileServiceCapabilitiesResponse::getCapabilities() const
{
    return m_capabilities_;
}

void RasterTileServiceCapabilitiesResponse::setCapabilities(::nds::smart::metadata::RasterTileServiceCapabilities capabilities_)
{
    m_capabilities_ = capabilities_;
}

void RasterTileServiceCapabilitiesResponse::initPackingContext(RasterTileServiceCapabilitiesResponse::ZserioPackingContext& context) const
{
    m_capabilities_.initPackingContext(context.getCapabilities());
}

size_t RasterTileServiceCapabilitiesResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RasterTileServiceCapabilitiesResponse::bitSizeOf(RasterTileServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(context.getCapabilities(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RasterTileServiceCapabilitiesResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RasterTileServiceCapabilitiesResponse::initializeOffsets(RasterTileServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(context.getCapabilities(), endBitPosition);

    return endBitPosition;
}

bool RasterTileServiceCapabilitiesResponse::operator==(const RasterTileServiceCapabilitiesResponse& other) const
{
    if (this != &other)
    {
        return
                (m_capabilities_ == other.m_capabilities_);
    }

    return true;
}

uint32_t RasterTileServiceCapabilitiesResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_capabilities_);

    return result;
}

void RasterTileServiceCapabilitiesResponse::write(::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(out);
}

void RasterTileServiceCapabilitiesResponse::write(RasterTileServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(context.getCapabilities(), out);
}

::nds::smart::metadata::RasterTileServiceCapabilities RasterTileServiceCapabilitiesResponse::readCapabilities(::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::RasterTileServiceCapabilities(in);
}

::nds::smart::metadata::RasterTileServiceCapabilities RasterTileServiceCapabilitiesResponse::readCapabilities(RasterTileServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::smart::metadata::RasterTileServiceCapabilities(context.getCapabilities(), in);
}

} // namespace metadata
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/metadata/SmartLayerServiceCapabilities.h>

namespace nds
{
namespace smart
{
namespace metadata
{

SmartLayerServiceCapabilities::SmartLayerServiceCapabilities(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

SmartLayerServiceCapabilities::SmartLayerServiceCapabilities(::zserio::BitStreamReader& in,
        ::nds::smart::types::SmartLayerType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

SmartLayerServiceCapabilities::SmartLayerServiceCapabilities(SmartLayerServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::smart::types::SmartLayerType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

SmartLayerServiceCapabilities::SmartLayerServiceCapabilities(const SmartLayerServiceCapabilities& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

SmartLayerServiceCapabilities& SmartLayerServiceCapabilities::operator=(const SmartLayerServiceCapabilities& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

SmartLayerServiceCapabilities::SmartLayerServiceCapabilities(SmartLayerServiceCapabilities&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

SmartLayerServiceCapabilities& SmartLayerServiceCapabilities::operator=(SmartLayerServiceCapabilities&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

SmartLayerServiceCapabilities::SmartLayerServiceCapabilities(::zserio::PropagateAllocatorT,
        const SmartLayerServiceCapabilities& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void SmartLayerServiceCapabilities::initialize(
        ::nds::smart::types::SmartLayerType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool SmartLayerServiceCapabilities::isInitialized() const
{
    return m_isInitialized;
}

::nds::smart::types::SmartLayerType SmartLayerServiceCapabilities::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'SmartLayerServiceCapabilities' is not initialized!");

    return m_type_;
}

::nds::smart::metadata::TileServiceCapabilities SmartLayerServiceCapabilities::getTileServiceCapabilities() const
{
    return m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>();
}

void SmartLayerServiceCapabilities::setTileServiceCapabilities(::nds::smart::metadata::TileServiceCapabilities tileServiceCapabilities_)
{
    m_objectChoice = tileServiceCapabilities_;
}

::nds::smart::metadata::ObjectServiceCapabilities SmartLayerServiceCapabilities::getObjectServiceCapabilities() const
{
    return m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>();
}

void SmartLayerServiceCapabilities::setObjectServiceCapabilities(::nds::smart::metadata::ObjectServiceCapabilities objectServiceCapabilities_)
{
    m_objectChoice = objectServiceCapabilities_;
}

::nds::smart::metadata::PathServiceCapabilities SmartLayerServiceCapabilities::getPathServiceCapabilities() const
{
    return m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>();
}

void SmartLayerServiceCapabilities::setPathServiceCapabilities(::nds::smart::metadata::PathServiceCapabilities pathServiceCapabilities_)
{
    m_objectChoice = pathServiceCapabilities_;
}

::nds::smart::metadata::MeshServiceCapabilities SmartLayerServiceCapabilities::getMeshServiceCapabilities() const
{
    return m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>();
}

void SmartLayerServiceCapabilities::setMeshServiceCapabilities(::nds::smart::metadata::MeshServiceCapabilities meshServiceCapabilities_)
{
    m_objectChoice = meshServiceCapabilities_;
}

::nds::smart::metadata::PathHorizonServiceCapabilities SmartLayerServiceCapabilities::getPathHorizonServiceCapabilities() const
{
    return m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>();
}

void SmartLayerServiceCapabilities::setPathHorizonServiceCapabilities(::nds::smart::metadata::PathHorizonServiceCapabilities pathHorizonServiceCapabilities_)
{
    m_objectChoice = pathHorizonServiceCapabilities_;
}

SmartLayerServiceCapabilities::ChoiceTag SmartLayerServiceCapabilities::choiceTag() const
{
    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        return CHOICE_tileServiceCapabilities;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        return CHOICE_objectServiceCapabilities;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        return CHOICE_pathServiceCapabilities;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        return CHOICE_meshServiceCapabilities;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        return CHOICE_pathHorizonServiceCapabilities;
    default:
        return UNDEFINED_CHOICE;
    }
}

void SmartLayerServiceCapabilities::initPackingContext(SmartLayerServiceCapabilities::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>().initPackingContext(context.getTileServiceCapabilities());
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>().initPackingContext(context.getObjectServiceCapabilities());
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>().initPackingContext(context.getPathServiceCapabilities());
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>().initPackingContext(context.getMeshServiceCapabilities());
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>().initPackingContext(context.getPathHorizonServiceCapabilities());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }
}

size_t SmartLayerServiceCapabilities::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>().bitSizeOf(endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>().bitSizeOf(endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>().bitSizeOf(endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>().bitSizeOf(endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerServiceCapabilities::bitSizeOf(SmartLayerServiceCapabilities::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>().bitSizeOf(context.getTileServiceCapabilities(), endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>().bitSizeOf(context.getObjectServiceCapabilities(), endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>().bitSizeOf(context.getPathServiceCapabilities(), endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>().bitSizeOf(context.getMeshServiceCapabilities(), endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        endBitPosition += m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>().bitSizeOf(context.getPathHorizonServiceCapabilities(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }

    return endBitPosition - bitPosition;
}

size_t SmartLayerServiceCapabilities::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>().initializeOffsets(endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>().initializeOffsets(endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>().initializeOffsets(endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>().initializeOffsets(endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }

    return endBitPosition;
}

size_t SmartLayerServiceCapabilities::initializeOffsets(SmartLayerServiceCapabilities::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>().initializeOffsets(context.getTileServiceCapabilities(), endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>().initializeOffsets(context.getObjectServiceCapabilities(), endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>().initializeOffsets(context.getPathServiceCapabilities(), endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>().initializeOffsets(context.getMeshServiceCapabilities(), endBitPosition);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        endBitPosition = m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>().initializeOffsets(context.getPathHorizonServiceCapabilities(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }

    return endBitPosition;
}

bool SmartLayerServiceCapabilities::operator==(const SmartLayerServiceCapabilities& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>() == other.m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>());
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>() == other.m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>());
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>() == other.m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>());
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>() == other.m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>());
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>() == other.m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }
}

uint32_t SmartLayerServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>());
            break;
        case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>());
            break;
        case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>());
            break;
        case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>());
            break;
        case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>());
            break;
        default:
            break;
        }
    }

    return result;
}

void SmartLayerServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>().write(out);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>().write(out);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>().write(out);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>().write(out);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }
}

void SmartLayerServiceCapabilities::write(SmartLayerServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        m_objectChoice.get<::nds::smart::metadata::TileServiceCapabilities>().write(context.getTileServiceCapabilities(), out);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        m_objectChoice.get<::nds::smart::metadata::ObjectServiceCapabilities>().write(context.getObjectServiceCapabilities(), out);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        m_objectChoice.get<::nds::smart::metadata::PathServiceCapabilities>().write(context.getPathServiceCapabilities(), out);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        m_objectChoice.get<::nds::smart::metadata::MeshServiceCapabilities>().write(context.getMeshServiceCapabilities(), out);
        break;
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        m_objectChoice.get<::nds::smart::metadata::PathHorizonServiceCapabilities>().write(context.getPathHorizonServiceCapabilities(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }
}

::zserio::AnyHolder<> SmartLayerServiceCapabilities::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::TileServiceCapabilities(in), allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::ObjectServiceCapabilities(in), allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::PathServiceCapabilities(in), allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::MeshServiceCapabilities(in), allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::PathHorizonServiceCapabilities(in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }
}

::zserio::AnyHolder<> SmartLayerServiceCapabilities::readObject(SmartLayerServiceCapabilities::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::TileServiceCapabilities(context.getTileServiceCapabilities(), in), allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::ObjectServiceCapabilities(context.getObjectServiceCapabilities(), in), allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::PathServiceCapabilities(context.getPathServiceCapabilities(), in), allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::MeshServiceCapabilities(context.getMeshServiceCapabilities(), in), allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        return ::zserio::AnyHolder<>(::nds::smart::metadata::PathHorizonServiceCapabilities(context.getPathHorizonServiceCapabilities(), in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }
}

::zserio::AnyHolder<> SmartLayerServiceCapabilities::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_TILE:
        return ::zserio::allocatorPropagatingCopy<::nds::smart::metadata::TileServiceCapabilities>(m_objectChoice, allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_OBJECT:
        return ::zserio::allocatorPropagatingCopy<::nds::smart::metadata::ObjectServiceCapabilities>(m_objectChoice, allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH:
        return ::zserio::allocatorPropagatingCopy<::nds::smart::metadata::PathServiceCapabilities>(m_objectChoice, allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_MESH:
        return ::zserio::allocatorPropagatingCopy<::nds::smart::metadata::MeshServiceCapabilities>(m_objectChoice, allocator);
    case ::nds::smart::types::SmartLayerType::SMART_LAYER_PATH_HORIZON:
        return ::zserio::allocatorPropagatingCopy<::nds::smart::metadata::PathHorizonServiceCapabilities>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice SmartLayerServiceCapabilities!");
    }
}

} // namespace metadata
} // namespace smart
} // namespace nds
