/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/smart/mesh/SmartLayerMesh.h>

namespace nds
{
namespace smart
{
namespace mesh
{

SmartLayerMesh::SmartLayerMesh(const allocator_type& allocator) noexcept :
        m_meshId_(allocator),
        m_numTiles_(uint16_t()),
        m_tileList_(allocator)
{
}

SmartLayerMesh::SmartLayerMesh(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_meshId_(readMeshId(in, allocator)),
        m_numTiles_(readNumTiles(in)),
        m_tileList_(readTileList(in, allocator))
{
}

SmartLayerMesh::SmartLayerMesh(SmartLayerMesh::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_meshId_(readMeshId(context, in, allocator)),
        m_numTiles_(readNumTiles(context, in)),
        m_tileList_(readTileList(context, in, allocator))
{
}

SmartLayerMesh::SmartLayerMesh(::zserio::PropagateAllocatorT,
        const SmartLayerMesh& other, const allocator_type& allocator) :
        m_meshId_(::zserio::allocatorPropagatingCopy(other.m_meshId_, allocator)),
        m_numTiles_(::zserio::allocatorPropagatingCopy(other.m_numTiles_, allocator)),
        m_tileList_(::zserio::allocatorPropagatingCopy(other.m_tileList_, allocator))
{
}

void SmartLayerMesh::initializeChildren()
{
    m_tileList_.initializeElements(*this);
}

::nds::smart::mesh::SmartMeshId& SmartLayerMesh::getMeshId()
{
    return m_meshId_;
}

const ::nds::smart::mesh::SmartMeshId& SmartLayerMesh::getMeshId() const
{
    return m_meshId_;
}

void SmartLayerMesh::setMeshId(const ::nds::smart::mesh::SmartMeshId& meshId_)
{
    m_meshId_ = meshId_;
}

void SmartLayerMesh::setMeshId(::nds::smart::mesh::SmartMeshId&& meshId_)
{
    m_meshId_ = ::std::move(meshId_);
}

uint16_t SmartLayerMesh::getNumTiles() const
{
    return m_numTiles_;
}

void SmartLayerMesh::setNumTiles(uint16_t numTiles_)
{
    m_numTiles_ = numTiles_;
}

::zserio::vector<::nds::smart::tile::SmartLayerTile>& SmartLayerMesh::getTileList()
{
    return m_tileList_.getRawArray();
}

const ::zserio::vector<::nds::smart::tile::SmartLayerTile>& SmartLayerMesh::getTileList() const
{
    return m_tileList_.getRawArray();
}

void SmartLayerMesh::setTileList(const ::zserio::vector<::nds::smart::tile::SmartLayerTile>& tileList_)
{
    m_tileList_ = ZserioArrayType_tileList(tileList_);
}

void SmartLayerMesh::setTileList(::zserio::vector<::nds::smart::tile::SmartLayerTile>&& tileList_)
{
    m_tileList_ = ZserioArrayType_tileList(std::move(tileList_));
}

void SmartLayerMesh::initPackingContext(SmartLayerMesh::ZserioPackingContext& context) const
{
    m_meshId_.initPackingContext(context.getMeshId());
    context.getNumTiles().init<::zserio::StdIntArrayTraits<uint16_t>>(m_numTiles_);
}

size_t SmartLayerMesh::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_meshId_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(16);
    endBitPosition += m_tileList_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerMesh::bitSizeOf(SmartLayerMesh::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_meshId_.bitSizeOf(context.getMeshId(), endBitPosition);
    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_numTiles_);
    endBitPosition += m_tileList_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t SmartLayerMesh::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_meshId_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(16);
    endBitPosition = m_tileList_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t SmartLayerMesh::initializeOffsets(SmartLayerMesh::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_meshId_.initializeOffsets(context.getMeshId(), endBitPosition);
    endBitPosition += context.getNumTiles().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_numTiles_);
    endBitPosition = m_tileList_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool SmartLayerMesh::operator==(const SmartLayerMesh& other) const
{
    if (this != &other)
    {
        return
                (m_meshId_ == other.m_meshId_) &&
                (m_numTiles_ == other.m_numTiles_) &&
                (m_tileList_ == other.m_tileList_);
    }

    return true;
}

uint32_t SmartLayerMesh::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_meshId_);
    result = ::zserio::calcHashCode(result, m_numTiles_);
    result = ::zserio::calcHashCode(result, m_tileList_);

    return result;
}

void SmartLayerMesh::write(::zserio::BitStreamWriter& out) const
{
    m_meshId_.write(out);

    // check constraint
    if (!(getNumTiles() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at SmartLayerMesh.numTiles!");
    out.writeBits(m_numTiles_, UINT8_C(16));

    // check array length
    if (m_tileList_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerMesh.tileList: ") <<
                m_tileList_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileList_.write(*this, out);
}

void SmartLayerMesh::write(SmartLayerMesh::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_meshId_.write(context.getMeshId(), out);

    // check constraint
    if (!(getNumTiles() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at SmartLayerMesh.numTiles!");
    context.getNumTiles().write<::zserio::StdIntArrayTraits<uint16_t>>(out, m_numTiles_);

    // check array length
    if (m_tileList_.getRawArray().size() != static_cast<size_t>(getNumTiles()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartLayerMesh.tileList: ") <<
                m_tileList_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumTiles()) << "!";
    }
    m_tileList_.writePacked(*this, out);
}

void SmartLayerMesh::ZserioArrayExpressions_tileList::initializeElement(SmartLayerMesh&,
        ::nds::smart::tile::SmartLayerTile& element, size_t)
{
    element.initializeChildren();
}

void SmartLayerMesh::ZserioElementFactory_tileList::create(SmartLayerMesh&        ,
        ::zserio::vector<::nds::smart::tile::SmartLayerTile>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartLayerMesh::ZserioElementFactory_tileList::create(SmartLayerMesh&        ,
        ::zserio::vector<::nds::smart::tile::SmartLayerTile>& array,
        ::nds::smart::tile::SmartLayerTile::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::smart::mesh::SmartMeshId SmartLayerMesh::readMeshId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::smart::mesh::SmartMeshId(in, allocator);
}

::nds::smart::mesh::SmartMeshId SmartLayerMesh::readMeshId(SmartLayerMesh::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::smart::mesh::SmartMeshId(context.getMeshId(), in, allocator);
}
uint16_t SmartLayerMesh::readNumTiles(::zserio::BitStreamReader& in)
{
    uint16_t readField = static_cast<uint16_t>(in.readBits(UINT8_C(16)));
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at SmartLayerMesh.numTiles!");

    return readField;
}

uint16_t SmartLayerMesh::readNumTiles(SmartLayerMesh::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint16_t readField = context.getNumTiles().read<::zserio::StdIntArrayTraits<uint16_t>>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at SmartLayerMesh.numTiles!");

    return readField;
}
SmartLayerMesh::ZserioArrayType_tileList SmartLayerMesh::readTileList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_tileList readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

SmartLayerMesh::ZserioArrayType_tileList SmartLayerMesh::readTileList(SmartLayerMesh::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_tileList readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumTiles()));

    return readField;
}

} // namespace mesh
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/smart/mesh/SmartMeshIndex.h>

namespace nds
{
namespace smart
{
namespace mesh
{

SmartMeshIndex::SmartMeshIndex(const allocator_type& allocator) noexcept :
        m_hasHeaders_(bool()),
        m_hasMeshSizes_(bool()),
        m_numEntries_(uint32_t()),
        m_tileIds_(allocator),
        m_meshIds_(allocator),
        m_header_(::zserio::NullOpt),
        m_meshSize_(::zserio::NullOpt)
{
}

SmartMeshIndex::SmartMeshIndex(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_hasHeaders_(readHasHeaders(in)),
        m_hasMeshSizes_(readHasMeshSizes(in)),
        m_numEntries_(readNumEntries(in)),
        m_tileIds_(readTileIds(in, allocator)),
        m_meshIds_(readMeshIds(in, allocator)),
        m_header_(readHeader(in, allocator)),
        m_meshSize_(readMeshSize(in, allocator))
{
}

SmartMeshIndex::SmartMeshIndex(SmartMeshIndex::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_hasHeaders_(readHasHeaders(in)),
        m_hasMeshSizes_(readHasMeshSizes(in)),
        m_numEntries_(readNumEntries(context, in)),
        m_tileIds_(readTileIds(context, in, allocator)),
        m_meshIds_(readMeshIds(context, in, allocator)),
        m_header_(readHeader(context, in, allocator)),
        m_meshSize_(readMeshSize(context, in, allocator))
{
}

SmartMeshIndex::SmartMeshIndex(::zserio::PropagateAllocatorT,
        const SmartMeshIndex& other, const allocator_type& allocator) :
        m_hasHeaders_(::zserio::allocatorPropagatingCopy(other.m_hasHeaders_, allocator)),
        m_hasMeshSizes_(::zserio::allocatorPropagatingCopy(other.m_hasMeshSizes_, allocator)),
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_tileIds_(::zserio::allocatorPropagatingCopy(other.m_tileIds_, allocator)),
        m_meshIds_(::zserio::allocatorPropagatingCopy(other.m_meshIds_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_meshSize_(::zserio::allocatorPropagatingCopy(other.m_meshSize_, allocator))
{
}

void SmartMeshIndex::initializeChildren()
{
    if (getHasHeaders())
        m_header_.value().initializeElements(*this);
}

bool SmartMeshIndex::getHasHeaders() const
{
    return m_hasHeaders_;
}

void SmartMeshIndex::setHasHeaders(bool hasHeaders_)
{
    m_hasHeaders_ = hasHeaders_;
}

bool SmartMeshIndex::getHasMeshSizes() const
{
    return m_hasMeshSizes_;
}

void SmartMeshIndex::setHasMeshSizes(bool hasMeshSizes_)
{
    m_hasMeshSizes_ = hasMeshSizes_;
}

uint32_t SmartMeshIndex::getNumEntries() const
{
    return m_numEntries_;
}

void SmartMeshIndex::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::core::types::PackedTileId>& SmartMeshIndex::getTileIds()
{
    return m_tileIds_.getRawArray();
}

const ::zserio::vector<::nds::core::types::PackedTileId>& SmartMeshIndex::getTileIds() const
{
    return m_tileIds_.getRawArray();
}

void SmartMeshIndex::setTileIds(const ::zserio::vector<::nds::core::types::PackedTileId>& tileIds_)
{
    m_tileIds_ = ZserioArrayType_tileIds(tileIds_);
}

void SmartMeshIndex::setTileIds(::zserio::vector<::nds::core::types::PackedTileId>&& tileIds_)
{
    m_tileIds_ = ZserioArrayType_tileIds(std::move(tileIds_));
}

::zserio::vector<::nds::smart::mesh::SmartMeshId>& SmartMeshIndex::getMeshIds()
{
    return m_meshIds_.getRawArray();
}

const ::zserio::vector<::nds::smart::mesh::SmartMeshId>& SmartMeshIndex::getMeshIds() const
{
    return m_meshIds_.getRawArray();
}

void SmartMeshIndex::setMeshIds(const ::zserio::vector<::nds::smart::mesh::SmartMeshId>& meshIds_)
{
    m_meshIds_ = ZserioArrayType_meshIds(meshIds_);
}

void SmartMeshIndex::setMeshIds(::zserio::vector<::nds::smart::mesh::SmartMeshId>&& meshIds_)
{
    m_meshIds_ = ZserioArrayType_meshIds(std::move(meshIds_));
}

::zserio::vector<::nds::smart::types::SmartLayerHeader>& SmartMeshIndex::getHeader()
{
    return m_header_.value().getRawArray();
}

const ::zserio::vector<::nds::smart::types::SmartLayerHeader>& SmartMeshIndex::getHeader() const
{
    return m_header_.value().getRawArray();
}

void SmartMeshIndex::setHeader(const ::zserio::vector<::nds::smart::types::SmartLayerHeader>& header_)
{
    m_header_ = ZserioArrayType_header(header_);
}

void SmartMeshIndex::setHeader(::zserio::vector<::nds::smart::types::SmartLayerHeader>&& header_)
{
    m_header_ = ZserioArrayType_header(std::move(header_));
}

bool SmartMeshIndex::isHeaderUsed() const
{
    return (getHasHeaders());
}

bool SmartMeshIndex::isHeaderSet() const
{
    return m_header_.hasValue();
}

void SmartMeshIndex::resetHeader()
{
    m_header_.reset();
}

::zserio::vector<uint32_t>& SmartMeshIndex::getMeshSize()
{
    return m_meshSize_.value().getRawArray();
}

const ::zserio::vector<uint32_t>& SmartMeshIndex::getMeshSize() const
{
    return m_meshSize_.value().getRawArray();
}

void SmartMeshIndex::setMeshSize(const ::zserio::vector<uint32_t>& meshSize_)
{
    m_meshSize_ = ZserioArrayType_meshSize(meshSize_);
}

void SmartMeshIndex::setMeshSize(::zserio::vector<uint32_t>&& meshSize_)
{
    m_meshSize_ = ZserioArrayType_meshSize(std::move(meshSize_));
}

bool SmartMeshIndex::isMeshSizeUsed() const
{
    return (getHasMeshSizes());
}

bool SmartMeshIndex::isMeshSizeSet() const
{
    return m_meshSize_.hasValue();
}

void SmartMeshIndex::resetMeshSize()
{
    m_meshSize_.reset();
}

void SmartMeshIndex::initPackingContext(SmartMeshIndex::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t SmartMeshIndex::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_tileIds_.bitSizeOf(endBitPosition);
    endBitPosition += m_meshIds_.bitSizeOf(*this, endBitPosition);
    if (getHasHeaders())
    {
        endBitPosition += m_header_.value().bitSizeOf(*this, endBitPosition);
    }
    if (getHasMeshSizes())
    {
        endBitPosition += m_meshSize_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SmartMeshIndex::bitSizeOf(SmartMeshIndex::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_tileIds_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_meshIds_.bitSizeOfPacked(*this, endBitPosition);
    if (getHasHeaders())
    {
        endBitPosition += m_header_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    if (getHasMeshSizes())
    {
        endBitPosition += m_meshSize_.value().bitSizeOfPacked(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SmartMeshIndex::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_tileIds_.initializeOffsets(endBitPosition);
    endBitPosition = m_meshIds_.initializeOffsets(*this, endBitPosition);
    if (getHasHeaders())
    {
        endBitPosition = m_header_.value().initializeOffsets(*this, endBitPosition);
    }
    if (getHasMeshSizes())
    {
        endBitPosition = m_meshSize_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t SmartMeshIndex::initializeOffsets(SmartMeshIndex::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_tileIds_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_meshIds_.initializeOffsetsPacked(*this, endBitPosition);
    if (getHasHeaders())
    {
        endBitPosition = m_header_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    if (getHasMeshSizes())
    {
        endBitPosition = m_meshSize_.value().initializeOffsetsPacked(endBitPosition);
    }

    return endBitPosition;
}

bool SmartMeshIndex::operator==(const SmartMeshIndex& other) const
{
    if (this != &other)
    {
        return
                (m_hasHeaders_ == other.m_hasHeaders_) &&
                (m_hasMeshSizes_ == other.m_hasMeshSizes_) &&
                (m_numEntries_ == other.m_numEntries_) &&
                (m_tileIds_ == other.m_tileIds_) &&
                (m_meshIds_ == other.m_meshIds_) &&
                (!isHeaderUsed() ? !other.isHeaderUsed() : (m_header_ == other.m_header_)) &&
                (!isMeshSizeUsed() ? !other.isMeshSizeUsed() : (m_meshSize_ == other.m_meshSize_));
    }

    return true;
}

uint32_t SmartMeshIndex::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_hasHeaders_);
    result = ::zserio::calcHashCode(result, m_hasMeshSizes_);
    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_tileIds_);
    result = ::zserio::calcHashCode(result, m_meshIds_);
    if (isHeaderUsed())
        result = ::zserio::calcHashCode(result, m_header_);
    if (isMeshSizeUsed())
        result = ::zserio::calcHashCode(result, m_meshSize_);

    return result;
}

void SmartMeshIndex::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasHeaders_);

    out.writeBool(m_hasMeshSizes_);

    out.alignTo(8);
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_tileIds_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartMeshIndex.tileIds: ") <<
                m_tileIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_tileIds_.write(out);

    // check array length
    if (m_meshIds_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartMeshIndex.meshIds: ") <<
                m_meshIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_meshIds_.write(*this, out);

    if (getHasHeaders())
    {
        // check array length
        if (m_header_.value().getRawArray().size() != static_cast<size_t>(getNumEntries()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartMeshIndex.header: ") <<
                    m_header_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumEntries()) << "!";
        }
        m_header_.value().write(*this, out);
    }

    if (getHasMeshSizes())
    {
        // check array length
        if (m_meshSize_.value().getRawArray().size() != static_cast<size_t>(getNumEntries()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartMeshIndex.meshSize: ") <<
                    m_meshSize_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumEntries()) << "!";
        }
        m_meshSize_.value().write(out);
    }
}

void SmartMeshIndex::write(SmartMeshIndex::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasHeaders_);

    out.writeBool(m_hasMeshSizes_);

    out.alignTo(8);
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_tileIds_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartMeshIndex.tileIds: ") <<
                m_tileIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_tileIds_.writePacked(out);

    // check array length
    if (m_meshIds_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartMeshIndex.meshIds: ") <<
                m_meshIds_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_meshIds_.writePacked(*this, out);

    if (getHasHeaders())
    {
        // check array length
        if (m_header_.value().getRawArray().size() != static_cast<size_t>(getNumEntries()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartMeshIndex.header: ") <<
                    m_header_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumEntries()) << "!";
        }
        m_header_.value().writePacked(*this, out);
    }

    if (getHasMeshSizes())
    {
        // check array length
        if (m_meshSize_.value().getRawArray().size() != static_cast<size_t>(getNumEntries()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field SmartMeshIndex.meshSize: ") <<
                    m_meshSize_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumEntries()) << "!";
        }
        m_meshSize_.value().writePacked(out);
    }
}

void SmartMeshIndex::ZserioElementFactory_meshIds::create(SmartMeshIndex&        ,
        ::zserio::vector<::nds::smart::mesh::SmartMeshId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartMeshIndex::ZserioElementFactory_meshIds::create(SmartMeshIndex&        ,
        ::zserio::vector<::nds::smart::mesh::SmartMeshId>& array,
        ::nds::smart::mesh::SmartMeshId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void SmartMeshIndex::ZserioArrayExpressions_header::initializeElement(SmartMeshIndex&,
        ::nds::smart::types::SmartLayerHeader& element, size_t)
{
    element.initializeChildren();
}

void SmartMeshIndex::ZserioElementFactory_header::create(SmartMeshIndex&        ,
        ::zserio::vector<::nds::smart::types::SmartLayerHeader>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void SmartMeshIndex::ZserioElementFactory_header::create(SmartMeshIndex&        ,
        ::zserio::vector<::nds::smart::types::SmartLayerHeader>& array,
        ::nds::smart::types::SmartLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

bool SmartMeshIndex::readHasHeaders(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool SmartMeshIndex::readHasMeshSizes(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
uint32_t SmartMeshIndex::readNumEntries(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t SmartMeshIndex::readNumEntries(SmartMeshIndex::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
SmartMeshIndex::ZserioArrayType_tileIds SmartMeshIndex::readTileIds(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_tileIds readField(allocator);
    readField.read(in, static_cast<size_t>(getNumEntries()));

    return readField;
}

SmartMeshIndex::ZserioArrayType_tileIds SmartMeshIndex::readTileIds(SmartMeshIndex::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_tileIds readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumEntries()));

    return readField;
}
SmartMeshIndex::ZserioArrayType_meshIds SmartMeshIndex::readMeshIds(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_meshIds readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

SmartMeshIndex::ZserioArrayType_meshIds SmartMeshIndex::readMeshIds(SmartMeshIndex::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_meshIds readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}
::zserio::InplaceOptionalHolder<SmartMeshIndex::ZserioArrayType_header> SmartMeshIndex::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasHeaders())
    {
        ZserioArrayType_header readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumEntries()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_header>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_header>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<SmartMeshIndex::ZserioArrayType_header> SmartMeshIndex::readHeader(SmartMeshIndex::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasHeaders())
    {
        ZserioArrayType_header readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_header>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_header>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<SmartMeshIndex::ZserioArrayType_meshSize> SmartMeshIndex::readMeshSize(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasMeshSizes())
    {
        ZserioArrayType_meshSize readField(allocator);
        readField.read(in, static_cast<size_t>(getNumEntries()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_meshSize>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_meshSize>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<SmartMeshIndex::ZserioArrayType_meshSize> SmartMeshIndex::readMeshSize(SmartMeshIndex::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasMeshSizes())
    {
        ZserioArrayType_meshSize readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumEntries()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_meshSize>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_meshSize>(::zserio::NullOpt);
}

} // namespace mesh
} // namespace smart
} // namespace nds
