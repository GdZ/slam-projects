/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/smart/services/SmartLayerTileService.h>

namespace nds
{
namespace smart
{
namespace services
{

namespace SmartLayerTileService
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getServiceModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getServiceDefinitionMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getServiceNodeSystemReferenceMethod(requestData, context);
    if (methodName == methodNames()[3])
        return getServiceNodeLegalInfoMethod(requestData, context);
    if (methodName == methodNames()[4])
        return getTileServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[5])
        return getLayerByTileIdMethod(requestData, context);
    if (methodName == methodNames()[6])
        return getLayerByTileIdListMethod(requestData, context);
    if (methodName == methodNames()[7])
        return getHeaderOnlyByTileIdMethod(requestData, context);
    if (methodName == methodNames()[8])
        return getHeaderOnlyByTileIdListMethod(requestData, context);
    if (methodName == methodNames()[9])
        return getHeaderOnlyListInTileMethod(requestData, context);
    if (methodName == methodNames()[10])
        return getDeltaLayerByTileIdMethod(requestData, context);
    if (methodName == methodNames()[11])
        return getDeltaLayerByTileIdListMethod(requestData, context);
    if (methodName == methodNames()[12])
        return getLayerByTileVersionMethod(requestData, context);
    if (methodName == methodNames()[13])
        return getLayerByTileVersionListMethod(requestData, context);
    if (methodName == methodNames()[14])
        return getSingleDataLayerByTileIdMethod(requestData, context);
    if (methodName == methodNames()[15])
        return getDataLayerListByTileIdListMethod(requestData, context);
    throw ::zserio::ServiceException("nds.smart.services.SmartLayerTileService: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.smart.services.SmartLayerTileService");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 16>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 16> names =
    {
        ::zserio::makeStringView("getServiceModuleDefinition"),
        ::zserio::makeStringView("getServiceDefinition"),
        ::zserio::makeStringView("getServiceNodeSystemReference"),
        ::zserio::makeStringView("getServiceNodeLegalInfo"),
        ::zserio::makeStringView("getTileServiceCapabilities"),
        ::zserio::makeStringView("getLayerByTileId"),
        ::zserio::makeStringView("getLayerByTileIdList"),
        ::zserio::makeStringView("getHeaderOnlyByTileId"),
        ::zserio::makeStringView("getHeaderOnlyByTileIdList"),
        ::zserio::makeStringView("getHeaderOnlyListInTile"),
        ::zserio::makeStringView("getDeltaLayerByTileId"),
        ::zserio::makeStringView("getDeltaLayerByTileIdList"),
        ::zserio::makeStringView("getLayerByTileVersion"),
        ::zserio::makeStringView("getLayerByTileVersionList"),
        ::zserio::makeStringView("getSingleDataLayerByTileId"),
        ::zserio::makeStringView("getDataLayerListByTileIdList")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getServiceModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::SmartLayerDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeSystemReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsSystemToken&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeSystemReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeLegalInfoMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsNodeLegalInfo&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeLegalInfoImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getTileServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::TileServiceCapabilitiesResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getTileServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getLayerByTileIdMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::SmartLayerTile&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getLayerByTileIdImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getLayerByTileIdListMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileIdList request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::SmartLayerTileList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getLayerByTileIdListImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHeaderOnlyByTileIdMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::types::SmartLayerHeader&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHeaderOnlyByTileIdImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHeaderOnlyByTileIdListMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileIdList request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::SmartLayerTileHeaderList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHeaderOnlyByTileIdListImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHeaderOnlyListInTileMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::SmartLayerTileHeaderList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHeaderOnlyListInTileImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getDeltaLayerByTileIdMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::tile::DeltaTileInfo request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::SmartLayerTile&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getDeltaLayerByTileIdImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getDeltaLayerByTileIdListMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::tile::DeltaTileListInfo request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::SmartLayerTileList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getDeltaLayerByTileIdListImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getLayerByTileVersionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::tile::SmartLayerTileVersionRequest request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::SmartLayerTile&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getLayerByTileVersionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getLayerByTileVersionListMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::tile::SmartLayerTileVersionRequestList request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::SmartLayerTileList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getLayerByTileVersionListImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getSingleDataLayerByTileIdMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::tile::DataLayerTileVersionRequest request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::types::DataLayer&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getSingleDataLayerByTileIdImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getDataLayerListByTileIdListMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::tile::MultiDataLayerMultiTileRequest request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::MultiDataLayerMultiTileResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getDataLayerListByTileIdListImpl(request, context), get_allocator_ref());
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getServiceModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::smart::metadata::SmartLayerDefinition Client::getServiceDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::SmartLayerDefinition(reader, get_allocator_ref());
}

::nds::system::types::NdsSystemToken Client::getServiceNodeSystemReferenceMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeSystemReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsSystemToken(reader, get_allocator_ref());
}

::nds::system::types::NdsNodeLegalInfo Client::getServiceNodeLegalInfoMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeLegalInfo"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsNodeLegalInfo(reader, get_allocator_ref());
}

::nds::smart::metadata::TileServiceCapabilitiesResponse Client::getTileServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getTileServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::TileServiceCapabilitiesResponse(reader, get_allocator_ref());
}

::nds::smart::tile::SmartLayerTile Client::getLayerByTileIdMethod(const ::nds::core::types::TileId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getLayerByTileId"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::SmartLayerTile(reader, get_allocator_ref());
}

::nds::smart::tile::SmartLayerTileList Client::getLayerByTileIdListMethod(const ::nds::core::types::TileIdList& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getLayerByTileIdList"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::SmartLayerTileList(reader, get_allocator_ref());
}

::nds::smart::types::SmartLayerHeader Client::getHeaderOnlyByTileIdMethod(const ::nds::core::types::TileId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHeaderOnlyByTileId"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::types::SmartLayerHeader(reader, get_allocator_ref());
}

::nds::smart::tile::SmartLayerTileHeaderList Client::getHeaderOnlyByTileIdListMethod(const ::nds::core::types::TileIdList& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHeaderOnlyByTileIdList"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::SmartLayerTileHeaderList(reader, get_allocator_ref());
}

::nds::smart::tile::SmartLayerTileHeaderList Client::getHeaderOnlyListInTileMethod(const ::nds::core::types::TileId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHeaderOnlyListInTile"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::SmartLayerTileHeaderList(reader, get_allocator_ref());
}

::nds::smart::tile::SmartLayerTile Client::getDeltaLayerByTileIdMethod(const ::nds::smart::tile::DeltaTileInfo& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getDeltaLayerByTileId"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::SmartLayerTile(reader, get_allocator_ref());
}

::nds::smart::tile::SmartLayerTileList Client::getDeltaLayerByTileIdListMethod(const ::nds::smart::tile::DeltaTileListInfo& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getDeltaLayerByTileIdList"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::SmartLayerTileList(reader, get_allocator_ref());
}

::nds::smart::tile::SmartLayerTile Client::getLayerByTileVersionMethod(const ::nds::smart::tile::SmartLayerTileVersionRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getLayerByTileVersion"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::SmartLayerTile(reader, get_allocator_ref());
}

::nds::smart::tile::SmartLayerTileList Client::getLayerByTileVersionListMethod(const ::nds::smart::tile::SmartLayerTileVersionRequestList& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getLayerByTileVersionList"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::SmartLayerTileList(reader, get_allocator_ref());
}

::nds::smart::types::DataLayer Client::getSingleDataLayerByTileIdMethod(const ::nds::smart::tile::DataLayerTileVersionRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getSingleDataLayerByTileId"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::types::DataLayer(reader, get_allocator_ref());
}

::nds::smart::tile::MultiDataLayerMultiTileResponse Client::getDataLayerListByTileIdListMethod(const ::nds::smart::tile::MultiDataLayerMultiTileRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getDataLayerListByTileIdList"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::MultiDataLayerMultiTileResponse(reader, get_allocator_ref());
}

} // namespace SmartLayerTileService

} // namespace services
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/smart/services/SmartLayerObjectService.h>

namespace nds
{
namespace smart
{
namespace services
{

namespace SmartLayerObjectService
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getServiceModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getObjectServiceDefinitionMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getServiceNodeSystemReferenceMethod(requestData, context);
    if (methodName == methodNames()[3])
        return getServiceNodeLegalInfoMethod(requestData, context);
    if (methodName == methodNames()[4])
        return getObjectServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[5])
        return getObjectByReferenceMethod(requestData, context);
    if (methodName == methodNames()[6])
        return getReferencesInTileMethod(requestData, context);
    if (methodName == methodNames()[7])
        return getLocationPathForObjectReferenceMethod(requestData, context);
    if (methodName == methodNames()[8])
        return getLocationIdForObjectReferenceMethod(requestData, context);
    if (methodName == methodNames()[9])
        return getObjectsInTileMethod(requestData, context);
    if (methodName == methodNames()[10])
        return getHeaderOnlyByObjectReferenceMethod(requestData, context);
    if (methodName == methodNames()[11])
        return getHeaderOnlyListInTileMethod(requestData, context);
    if (methodName == methodNames()[12])
        return getSingleDataLayerByObjectReferenceMethod(requestData, context);
    throw ::zserio::ServiceException("nds.smart.services.SmartLayerObjectService: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.smart.services.SmartLayerObjectService");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 13>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 13> names =
    {
        ::zserio::makeStringView("getServiceModuleDefinition"),
        ::zserio::makeStringView("getObjectServiceDefinition"),
        ::zserio::makeStringView("getServiceNodeSystemReference"),
        ::zserio::makeStringView("getServiceNodeLegalInfo"),
        ::zserio::makeStringView("getObjectServiceCapabilities"),
        ::zserio::makeStringView("getObjectByReference"),
        ::zserio::makeStringView("getReferencesInTile"),
        ::zserio::makeStringView("getLocationPathForObjectReference"),
        ::zserio::makeStringView("getLocationIdForObjectReference"),
        ::zserio::makeStringView("getObjectsInTile"),
        ::zserio::makeStringView("getHeaderOnlyByObjectReference"),
        ::zserio::makeStringView("getHeaderOnlyListInTile"),
        ::zserio::makeStringView("getSingleDataLayerByObjectReference")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getServiceModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getObjectServiceDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::object::SmartLayerObjectDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getObjectServiceDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeSystemReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsSystemToken&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeSystemReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeLegalInfoMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsNodeLegalInfo&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeLegalInfoImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getObjectServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::ObjectServiceCapabilitiesResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getObjectServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getObjectByReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::object::SmartLayerObjectReference request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::object::SmartLayerObject&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getObjectByReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getReferencesInTileMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::object::SmartLayerObjectReferenceList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getReferencesInTileImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getLocationPathForObjectReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::object::SmartLayerObjectReference request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::core::location::RoadLocationPath&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getLocationPathForObjectReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getLocationIdForObjectReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::object::SmartLayerObjectReference request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::core::location::RoadLocationId&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getLocationIdForObjectReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getObjectsInTileMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::object::SmartLayerObjectList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getObjectsInTileImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHeaderOnlyByObjectReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::object::SmartLayerObjectReference request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::types::SmartLayerHeader&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHeaderOnlyByObjectReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHeaderOnlyListInTileMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::object::SmartLayerObjectHeaderList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHeaderOnlyListInTileImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getSingleDataLayerByObjectReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::object::DataLayerObjectVersionRequest request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::types::DataLayer&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getSingleDataLayerByObjectReferenceImpl(request, context), get_allocator_ref());
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getServiceModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::smart::object::SmartLayerObjectDefinition Client::getObjectServiceDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getObjectServiceDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::object::SmartLayerObjectDefinition(reader, get_allocator_ref());
}

::nds::system::types::NdsSystemToken Client::getServiceNodeSystemReferenceMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeSystemReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsSystemToken(reader, get_allocator_ref());
}

::nds::system::types::NdsNodeLegalInfo Client::getServiceNodeLegalInfoMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeLegalInfo"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsNodeLegalInfo(reader, get_allocator_ref());
}

::nds::smart::metadata::ObjectServiceCapabilitiesResponse Client::getObjectServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getObjectServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::ObjectServiceCapabilitiesResponse(reader, get_allocator_ref());
}

::nds::smart::object::SmartLayerObject Client::getObjectByReferenceMethod(const ::nds::smart::object::SmartLayerObjectReference& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getObjectByReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::object::SmartLayerObject(reader, get_allocator_ref());
}

::nds::smart::object::SmartLayerObjectReferenceList Client::getReferencesInTileMethod(const ::nds::core::types::TileId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getReferencesInTile"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::object::SmartLayerObjectReferenceList(reader, get_allocator_ref());
}

::nds::core::location::RoadLocationPath Client::getLocationPathForObjectReferenceMethod(const ::nds::smart::object::SmartLayerObjectReference& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getLocationPathForObjectReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::core::location::RoadLocationPath(reader, get_allocator_ref());
}

::nds::core::location::RoadLocationId Client::getLocationIdForObjectReferenceMethod(const ::nds::smart::object::SmartLayerObjectReference& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getLocationIdForObjectReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::core::location::RoadLocationId(reader, get_allocator_ref());
}

::nds::smart::object::SmartLayerObjectList Client::getObjectsInTileMethod(const ::nds::core::types::TileId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getObjectsInTile"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::object::SmartLayerObjectList(reader, get_allocator_ref());
}

::nds::smart::types::SmartLayerHeader Client::getHeaderOnlyByObjectReferenceMethod(const ::nds::smart::object::SmartLayerObjectReference& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHeaderOnlyByObjectReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::types::SmartLayerHeader(reader, get_allocator_ref());
}

::nds::smart::object::SmartLayerObjectHeaderList Client::getHeaderOnlyListInTileMethod(const ::nds::core::types::TileId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHeaderOnlyListInTile"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::object::SmartLayerObjectHeaderList(reader, get_allocator_ref());
}

::nds::smart::types::DataLayer Client::getSingleDataLayerByObjectReferenceMethod(const ::nds::smart::object::DataLayerObjectVersionRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getSingleDataLayerByObjectReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::types::DataLayer(reader, get_allocator_ref());
}

} // namespace SmartLayerObjectService

} // namespace services
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/smart/services/SmartLayerPathService.h>

namespace nds
{
namespace smart
{
namespace services
{

namespace SmartLayerPathService
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getServiceModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getServiceDefinitionMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getServiceNodeSystemReferenceMethod(requestData, context);
    if (methodName == methodNames()[3])
        return getServiceNodeLegalInfoMethod(requestData, context);
    if (methodName == methodNames()[4])
        return getPathServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[5])
        return getDataAlongPathMethod(requestData, context);
    if (methodName == methodNames()[6])
        return getDataAlongLocationIdMethod(requestData, context);
    if (methodName == methodNames()[7])
        return getPathsInTileMethod(requestData, context);
    if (methodName == methodNames()[8])
        return getHeaderOnlyByPathMethod(requestData, context);
    if (methodName == methodNames()[9])
        return getHeaderOnlyListInTileMethod(requestData, context);
    throw ::zserio::ServiceException("nds.smart.services.SmartLayerPathService: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.smart.services.SmartLayerPathService");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 10>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 10> names =
    {
        ::zserio::makeStringView("getServiceModuleDefinition"),
        ::zserio::makeStringView("getServiceDefinition"),
        ::zserio::makeStringView("getServiceNodeSystemReference"),
        ::zserio::makeStringView("getServiceNodeLegalInfo"),
        ::zserio::makeStringView("getPathServiceCapabilities"),
        ::zserio::makeStringView("getDataAlongPath"),
        ::zserio::makeStringView("getDataAlongLocationId"),
        ::zserio::makeStringView("getPathsInTile"),
        ::zserio::makeStringView("getHeaderOnlyByPath"),
        ::zserio::makeStringView("getHeaderOnlyListInTile")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getServiceModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::SmartLayerDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeSystemReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsSystemToken&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeSystemReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeLegalInfoMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsNodeLegalInfo&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeLegalInfoImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getPathServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::PathServiceCapabilitiesResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getPathServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getDataAlongPathMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::path::SmartLayerPathReference request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::path::SmartLayerPath&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getDataAlongPathImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getDataAlongLocationIdMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::location::RoadLocationId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::path::SmartLayerLocationIdPath&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getDataAlongLocationIdImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getPathsInTileMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileIdList request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::path::SmartLayerPathList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getPathsInTileImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHeaderOnlyByPathMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::path::SmartLayerPathReference request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::types::SmartLayerHeader&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHeaderOnlyByPathImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHeaderOnlyListInTileMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::tile::SmartLayerTileHeaderList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHeaderOnlyListInTileImpl(request, context), get_allocator_ref());
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getServiceModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::smart::metadata::SmartLayerDefinition Client::getServiceDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::SmartLayerDefinition(reader, get_allocator_ref());
}

::nds::system::types::NdsSystemToken Client::getServiceNodeSystemReferenceMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeSystemReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsSystemToken(reader, get_allocator_ref());
}

::nds::system::types::NdsNodeLegalInfo Client::getServiceNodeLegalInfoMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeLegalInfo"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsNodeLegalInfo(reader, get_allocator_ref());
}

::nds::smart::metadata::PathServiceCapabilitiesResponse Client::getPathServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getPathServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::PathServiceCapabilitiesResponse(reader, get_allocator_ref());
}

::nds::smart::path::SmartLayerPath Client::getDataAlongPathMethod(const ::nds::smart::path::SmartLayerPathReference& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getDataAlongPath"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::path::SmartLayerPath(reader, get_allocator_ref());
}

::nds::smart::path::SmartLayerLocationIdPath Client::getDataAlongLocationIdMethod(const ::nds::core::location::RoadLocationId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getDataAlongLocationId"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::path::SmartLayerLocationIdPath(reader, get_allocator_ref());
}

::nds::smart::path::SmartLayerPathList Client::getPathsInTileMethod(const ::nds::core::types::TileIdList& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getPathsInTile"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::path::SmartLayerPathList(reader, get_allocator_ref());
}

::nds::smart::types::SmartLayerHeader Client::getHeaderOnlyByPathMethod(const ::nds::smart::path::SmartLayerPathReference& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHeaderOnlyByPath"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::types::SmartLayerHeader(reader, get_allocator_ref());
}

::nds::smart::tile::SmartLayerTileHeaderList Client::getHeaderOnlyListInTileMethod(const ::nds::core::types::TileId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHeaderOnlyListInTile"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::tile::SmartLayerTileHeaderList(reader, get_allocator_ref());
}

} // namespace SmartLayerPathService

} // namespace services
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/smart/services/SmartLayerPathHorizonService.h>

namespace nds
{
namespace smart
{
namespace services
{

namespace SmartLayerPathHorizonService
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getServiceModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getServiceDefinitionMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getServiceNodeSystemReferenceMethod(requestData, context);
    if (methodName == methodNames()[3])
        return getServiceNodeLegalInfoMethod(requestData, context);
    if (methodName == methodNames()[4])
        return getPathHorizonServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[5])
        return getHorizonDataForPathMethod(requestData, context);
    if (methodName == methodNames()[6])
        return getHorizonDataForPoseMethod(requestData, context);
    throw ::zserio::ServiceException("nds.smart.services.SmartLayerPathHorizonService: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.smart.services.SmartLayerPathHorizonService");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 7>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 7> names =
    {
        ::zserio::makeStringView("getServiceModuleDefinition"),
        ::zserio::makeStringView("getServiceDefinition"),
        ::zserio::makeStringView("getServiceNodeSystemReference"),
        ::zserio::makeStringView("getServiceNodeLegalInfo"),
        ::zserio::makeStringView("getPathHorizonServiceCapabilities"),
        ::zserio::makeStringView("getHorizonDataForPath"),
        ::zserio::makeStringView("getHorizonDataForPose")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getServiceModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::SmartLayerDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeSystemReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsSystemToken&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeSystemReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeLegalInfoMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsNodeLegalInfo&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeLegalInfoImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getPathHorizonServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::PathHorizonServiceCapabilitiesResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getPathHorizonServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHorizonDataForPathMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::path::SmartLayerPathReference request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::path::SmartLayerPath&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHorizonDataForPathImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getHorizonDataForPoseMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::path::SmartLayerPosePathRequest request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::path::SmartLayerPath&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getHorizonDataForPoseImpl(request, context), get_allocator_ref());
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getServiceModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::smart::metadata::SmartLayerDefinition Client::getServiceDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::SmartLayerDefinition(reader, get_allocator_ref());
}

::nds::system::types::NdsSystemToken Client::getServiceNodeSystemReferenceMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeSystemReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsSystemToken(reader, get_allocator_ref());
}

::nds::system::types::NdsNodeLegalInfo Client::getServiceNodeLegalInfoMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeLegalInfo"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsNodeLegalInfo(reader, get_allocator_ref());
}

::nds::smart::metadata::PathHorizonServiceCapabilitiesResponse Client::getPathHorizonServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getPathHorizonServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::PathHorizonServiceCapabilitiesResponse(reader, get_allocator_ref());
}

::nds::smart::path::SmartLayerPath Client::getHorizonDataForPathMethod(const ::nds::smart::path::SmartLayerPathReference& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHorizonDataForPath"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::path::SmartLayerPath(reader, get_allocator_ref());
}

::nds::smart::path::SmartLayerPath Client::getHorizonDataForPoseMethod(const ::nds::smart::path::SmartLayerPosePathRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getHorizonDataForPose"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::path::SmartLayerPath(reader, get_allocator_ref());
}

} // namespace SmartLayerPathHorizonService

} // namespace services
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/smart/services/SmartLayerMeshService.h>

namespace nds
{
namespace smart
{
namespace services
{

namespace SmartLayerMeshService
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getServiceModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getServiceDefinitionMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getServiceNodeSystemReferenceMethod(requestData, context);
    if (methodName == methodNames()[3])
        return getServiceNodeLegalInfoMethod(requestData, context);
    if (methodName == methodNames()[4])
        return getMeshServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[5])
        return getMeshIndexByTileIdMethod(requestData, context);
    if (methodName == methodNames()[6])
        return getMeshByIdMethod(requestData, context);
    throw ::zserio::ServiceException("nds.smart.services.SmartLayerMeshService: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.smart.services.SmartLayerMeshService");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 7>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 7> names =
    {
        ::zserio::makeStringView("getServiceModuleDefinition"),
        ::zserio::makeStringView("getServiceDefinition"),
        ::zserio::makeStringView("getServiceNodeSystemReference"),
        ::zserio::makeStringView("getServiceNodeLegalInfo"),
        ::zserio::makeStringView("getMeshServiceCapabilities"),
        ::zserio::makeStringView("getMeshIndexByTileId"),
        ::zserio::makeStringView("getMeshById")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getServiceModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::SmartLayerDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeSystemReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsSystemToken&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeSystemReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeLegalInfoMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsNodeLegalInfo&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeLegalInfoImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getMeshServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::MeshServiceCapabilitiesResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getMeshServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getMeshIndexByTileIdMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::mesh::SmartMeshIndex&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getMeshIndexByTileIdImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getMeshByIdMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::mesh::SmartMeshId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::mesh::SmartLayerMesh&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getMeshByIdImpl(request, context), get_allocator_ref());
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getServiceModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::smart::metadata::SmartLayerDefinition Client::getServiceDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::SmartLayerDefinition(reader, get_allocator_ref());
}

::nds::system::types::NdsSystemToken Client::getServiceNodeSystemReferenceMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeSystemReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsSystemToken(reader, get_allocator_ref());
}

::nds::system::types::NdsNodeLegalInfo Client::getServiceNodeLegalInfoMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeLegalInfo"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsNodeLegalInfo(reader, get_allocator_ref());
}

::nds::smart::metadata::MeshServiceCapabilitiesResponse Client::getMeshServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getMeshServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::MeshServiceCapabilitiesResponse(reader, get_allocator_ref());
}

::nds::smart::mesh::SmartMeshIndex Client::getMeshIndexByTileIdMethod(const ::nds::core::types::TileId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getMeshIndexByTileId"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::mesh::SmartMeshIndex(reader, get_allocator_ref());
}

::nds::smart::mesh::SmartLayerMesh Client::getMeshByIdMethod(const ::nds::smart::mesh::SmartMeshId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getMeshById"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::mesh::SmartLayerMesh(reader, get_allocator_ref());
}

} // namespace SmartLayerMeshService

} // namespace services
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/smart/services/SmartRasterTileService.h>

namespace nds
{
namespace smart
{
namespace services
{

namespace SmartRasterTileService
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getServiceModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getServiceNodeSystemReferenceMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getServiceNodeLegalInfoMethod(requestData, context);
    if (methodName == methodNames()[3])
        return getRasterTileServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[4])
        return getImageMethod(requestData, context);
    if (methodName == methodNames()[5])
        return getTileMetadataMethod(requestData, context);
    if (methodName == methodNames()[6])
        return getImageVersionedMethod(requestData, context);
    throw ::zserio::ServiceException("nds.smart.services.SmartRasterTileService: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.smart.services.SmartRasterTileService");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 7>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 7> names =
    {
        ::zserio::makeStringView("getServiceModuleDefinition"),
        ::zserio::makeStringView("getServiceNodeSystemReference"),
        ::zserio::makeStringView("getServiceNodeLegalInfo"),
        ::zserio::makeStringView("getRasterTileServiceCapabilities"),
        ::zserio::makeStringView("getImage"),
        ::zserio::makeStringView("getTileMetadata"),
        ::zserio::makeStringView("getImageVersioned")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getServiceModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeSystemReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsSystemToken&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeSystemReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeLegalInfoMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsNodeLegalInfo&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeLegalInfoImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getRasterTileServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::metadata::RasterTileServiceCapabilitiesResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getRasterTileServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getImageMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::types::RasterTileImageRequest request(reader, get_allocator_ref());

    return ::std::allocate_shared<::zserio::RawServiceDataHolder>(get_allocator_ref(),
            getImageImpl(request, context));
}

::zserio::IServiceDataPtr Service::getTileMetadataMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::TileId request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::smart::types::RasterTileInfo&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getTileMetadataImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getImageVersionedMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::smart::types::RasterTileImageVersionRequest request(reader, get_allocator_ref());

    return ::std::allocate_shared<::zserio::RawServiceDataHolder>(get_allocator_ref(),
            getImageVersionedImpl(request, context));
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getServiceModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::system::types::NdsSystemToken Client::getServiceNodeSystemReferenceMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeSystemReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsSystemToken(reader, get_allocator_ref());
}

::nds::system::types::NdsNodeLegalInfo Client::getServiceNodeLegalInfoMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeLegalInfo"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsNodeLegalInfo(reader, get_allocator_ref());
}

::nds::smart::metadata::RasterTileServiceCapabilitiesResponse Client::getRasterTileServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getRasterTileServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::metadata::RasterTileServiceCapabilitiesResponse(reader, get_allocator_ref());
}

::nds::smart::types::RasterImage Client::getImageMethod(const ::nds::smart::types::RasterTileImageRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getImage"), requestData, context);
    return responseData;
}

::nds::smart::types::RasterTileInfo Client::getTileMetadataMethod(const ::nds::core::types::TileId& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getTileMetadata"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::smart::types::RasterTileInfo(reader, get_allocator_ref());
}

::nds::smart::types::RasterImage Client::getImageVersionedMethod(const ::nds::smart::types::RasterTileImageVersionRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getImageVersioned"), requestData, context);
    return responseData;
}

} // namespace SmartRasterTileService

} // namespace services
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/StringView.h>

#include <nds/smart/services/SmartLayerTileTopics.h>

namespace nds
{
namespace smart
{
namespace services
{

namespace
{

template <typename ZSERIO_MESSAGE>
class SmartLayerTileTopicsOnRaw : public ::zserio::IPubsub::OnTopicCallback
{
public:
    explicit SmartLayerTileTopicsOnRaw(const ::std::shared_ptr<SmartLayerTileTopics::SmartLayerTileTopicsCallback<ZSERIO_MESSAGE>>& callback,
            const ::std::allocator<uint8_t>& allocator) :
            m_callback(callback), m_allocator(allocator)
    {}

    void operator()(::zserio::StringView topic, ::zserio::Span<const uint8_t> data) override
    {
        ::zserio::BitStreamReader reader(data.data(), data.size());
        const ZSERIO_MESSAGE message(reader, m_allocator);

        m_callback->operator()(topic, message);
    }

private:
    ::std::shared_ptr<SmartLayerTileTopics::SmartLayerTileTopicsCallback<ZSERIO_MESSAGE>> m_callback;
    ::std::allocator<uint8_t> m_allocator;
};

} // namespace

SmartLayerTileTopics::SmartLayerTileTopics(::zserio::IPubsub& pubsub, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_pubsub(pubsub)
{
}

void SmartLayerTileTopics::publishTileID(const ::nds::core::types::TileId& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/smart/tile/update"), context);
}

::zserio::IPubsub::SubscriptionId SmartLayerTileTopics::subscribeTileID(
        const ::std::shared_ptr<SmartLayerTileTopicsCallback<::nds::core::types::TileId>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<SmartLayerTileTopicsOnRaw<::nds::core::types::TileId>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/smart/tile/update"), onRawCallback, context);
}

void SmartLayerTileTopics::unsubscribe(::zserio::IPubsub::SubscriptionId id)
{
    m_pubsub.unsubscribe(id);
}

template <typename ZSERIO_MESSAGE>
void SmartLayerTileTopics::publish(ZSERIO_MESSAGE& message, ::zserio::StringView topic, void* context)
{
    ::zserio::BitBuffer bitBuffer(message.bitSizeOf(), get_allocator_ref());
    ::zserio::BitStreamWriter writer(bitBuffer);
    message.write(writer);
    m_pubsub.publish(topic, bitBuffer.getBytes(), context);
}

} // namespace services
} // namespace smart
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/StringView.h>

#include <nds/smart/services/SmartLayerObjectTopics.h>

namespace nds
{
namespace smart
{
namespace services
{

namespace
{

template <typename ZSERIO_MESSAGE>
class SmartLayerObjectTopicsOnRaw : public ::zserio::IPubsub::OnTopicCallback
{
public:
    explicit SmartLayerObjectTopicsOnRaw(const ::std::shared_ptr<SmartLayerObjectTopics::SmartLayerObjectTopicsCallback<ZSERIO_MESSAGE>>& callback,
            const ::std::allocator<uint8_t>& allocator) :
            m_callback(callback), m_allocator(allocator)
    {}

    void operator()(::zserio::StringView topic, ::zserio::Span<const uint8_t> data) override
    {
        ::zserio::BitStreamReader reader(data.data(), data.size());
        const ZSERIO_MESSAGE message(reader, m_allocator);

        m_callback->operator()(topic, message);
    }

private:
    ::std::shared_ptr<SmartLayerObjectTopics::SmartLayerObjectTopicsCallback<ZSERIO_MESSAGE>> m_callback;
    ::std::allocator<uint8_t> m_allocator;
};

} // namespace

SmartLayerObjectTopics::SmartLayerObjectTopics(::zserio::IPubsub& pubsub, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_pubsub(pubsub)
{
}

void SmartLayerObjectTopics::publishObjectReference(const ::nds::smart::object::SmartLayerObjectReference& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/smart/object/update"), context);
}

::zserio::IPubsub::SubscriptionId SmartLayerObjectTopics::subscribeObjectReference(
        const ::std::shared_ptr<SmartLayerObjectTopicsCallback<::nds::smart::object::SmartLayerObjectReference>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<SmartLayerObjectTopicsOnRaw<::nds::smart::object::SmartLayerObjectReference>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/smart/object/update"), onRawCallback, context);
}

void SmartLayerObjectTopics::unsubscribe(::zserio::IPubsub::SubscriptionId id)
{
    m_pubsub.unsubscribe(id);
}

template <typename ZSERIO_MESSAGE>
void SmartLayerObjectTopics::publish(ZSERIO_MESSAGE& message, ::zserio::StringView topic, void* context)
{
    ::zserio::BitBuffer bitBuffer(message.bitSizeOf(), get_allocator_ref());
    ::zserio::BitStreamWriter writer(bitBuffer);
    message.write(writer);
    m_pubsub.publish(topic, bitBuffer.getBytes(), context);
}

} // namespace services
} // namespace smart
} // namespace nds
