/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/registry/services/RegistryServiceCapabilities.h>

namespace nds
{
namespace registry
{
namespace services
{

RegistryServiceCapabilities::RegistryServiceCapabilities(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

RegistryServiceCapabilities::RegistryServiceCapabilities(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void RegistryServiceCapabilities::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::registry::services::RegistryServiceCapabilities::underlying_type>>(m_value);
}

size_t RegistryServiceCapabilities::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t RegistryServiceCapabilities::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::services::RegistryServiceCapabilities::underlying_type>>(m_value);
}

size_t RegistryServiceCapabilities::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t RegistryServiceCapabilities::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t RegistryServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void RegistryServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void RegistryServiceCapabilities::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::registry::services::RegistryServiceCapabilities::underlying_type>>(out, m_value);
}

::zserio::string<> RegistryServiceCapabilities::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & RegistryServiceCapabilities::Values::GET_ALL_NODES) == RegistryServiceCapabilities::Values::GET_ALL_NODES)
        result += result.empty() ? "GET_ALL_NODES" : " | GET_ALL_NODES";
    if ((*this & RegistryServiceCapabilities::Values::SEARCH_NODES) == RegistryServiceCapabilities::Values::SEARCH_NODES)
        result += result.empty() ? "SEARCH_NODES" : " | SEARCH_NODES";
    if ((*this & RegistryServiceCapabilities::Values::REGISTER_NODE) == RegistryServiceCapabilities::Values::REGISTER_NODE)
        result += result.empty() ? "REGISTER_NODE" : " | REGISTER_NODE";
    if ((*this & RegistryServiceCapabilities::Values::UNREGISTER_NODE) == RegistryServiceCapabilities::Values::UNREGISTER_NODE)
        result += result.empty() ? "UNREGISTER_NODE" : " | UNREGISTER_NODE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

RegistryServiceCapabilities::underlying_type RegistryServiceCapabilities::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

RegistryServiceCapabilities::underlying_type RegistryServiceCapabilities::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::registry::services::RegistryServiceCapabilities::underlying_type>>(
            in);
}

} // namespace services
} // namespace registry
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/registry/services/RegistryServiceCapabilitiesResponse.h>

namespace nds
{
namespace registry
{
namespace services
{

RegistryServiceCapabilitiesResponse::RegistryServiceCapabilitiesResponse(const allocator_type&) noexcept :
        m_capabilities_(::nds::registry::services::RegistryServiceCapabilities())
{
}

RegistryServiceCapabilitiesResponse::RegistryServiceCapabilitiesResponse(::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(in))
{
}

RegistryServiceCapabilitiesResponse::RegistryServiceCapabilitiesResponse(RegistryServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_capabilities_(readCapabilities(context, in))
{
}

RegistryServiceCapabilitiesResponse::RegistryServiceCapabilitiesResponse(::zserio::PropagateAllocatorT,
        const RegistryServiceCapabilitiesResponse& other, const allocator_type& allocator) :
        m_capabilities_(::zserio::allocatorPropagatingCopy(other.m_capabilities_, allocator))
{
}

::nds::registry::services::RegistryServiceCapabilities RegistryServiceCapabilitiesResponse::getCapabilities() const
{
    return m_capabilities_;
}

void RegistryServiceCapabilitiesResponse::setCapabilities(::nds::registry::services::RegistryServiceCapabilities capabilities_)
{
    m_capabilities_ = capabilities_;
}

void RegistryServiceCapabilitiesResponse::initPackingContext(RegistryServiceCapabilitiesResponse::ZserioPackingContext& context) const
{
    m_capabilities_.initPackingContext(context.getCapabilities());
}

size_t RegistryServiceCapabilitiesResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RegistryServiceCapabilitiesResponse::bitSizeOf(RegistryServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_capabilities_.bitSizeOf(context.getCapabilities(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RegistryServiceCapabilitiesResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RegistryServiceCapabilitiesResponse::initializeOffsets(RegistryServiceCapabilitiesResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_capabilities_.initializeOffsets(context.getCapabilities(), endBitPosition);

    return endBitPosition;
}

bool RegistryServiceCapabilitiesResponse::operator==(const RegistryServiceCapabilitiesResponse& other) const
{
    if (this != &other)
    {
        return
                (m_capabilities_ == other.m_capabilities_);
    }

    return true;
}

uint32_t RegistryServiceCapabilitiesResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_capabilities_);

    return result;
}

void RegistryServiceCapabilitiesResponse::write(::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(out);
}

void RegistryServiceCapabilitiesResponse::write(RegistryServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_capabilities_.write(context.getCapabilities(), out);
}

::nds::registry::services::RegistryServiceCapabilities RegistryServiceCapabilitiesResponse::readCapabilities(::zserio::BitStreamReader& in)
{
    return ::nds::registry::services::RegistryServiceCapabilities(in);
}

::nds::registry::services::RegistryServiceCapabilities RegistryServiceCapabilitiesResponse::readCapabilities(RegistryServiceCapabilitiesResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::registry::services::RegistryServiceCapabilities(context.getCapabilities(), in);
}

} // namespace services
} // namespace registry
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/registry/services/NdsRegistry.h>

namespace nds
{
namespace registry
{
namespace services
{

namespace NdsRegistry
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getRegistryModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getRegistryServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getAllNodesAllSystemsMethod(requestData, context);
    if (methodName == methodNames()[3])
        return getAllNodesMethod(requestData, context);
    if (methodName == methodNames()[4])
        return searchNodesMethod(requestData, context);
    if (methodName == methodNames()[5])
        return registerNodeMethod(requestData, context);
    if (methodName == methodNames()[6])
        return unregisterNodeMethod(requestData, context);
    throw ::zserio::ServiceException("nds.registry.services.NdsRegistry: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.registry.services.NdsRegistry");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 7>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 7> names =
    {
        ::zserio::makeStringView("getRegistryModuleDefinition"),
        ::zserio::makeStringView("getRegistryServiceCapabilities"),
        ::zserio::makeStringView("getAllNodesAllSystems"),
        ::zserio::makeStringView("getAllNodes"),
        ::zserio::makeStringView("searchNodes"),
        ::zserio::makeStringView("registerNode"),
        ::zserio::makeStringView("unregisterNode")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getRegistryModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getRegistryModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getRegistryServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::registry::services::RegistryServiceCapabilitiesResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getRegistryServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getAllNodesAllSystemsMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::registry::node::NodeList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getAllNodesAllSystemsImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getAllNodesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::system::types::NdsSystemToken request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::registry::node::NodeList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getAllNodesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::searchNodesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::registry::node::NodeSearchFilter request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::registry::node::NodeList&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            searchNodesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::registerNodeMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::registry::node::NodeInformation request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::core::types::Empty&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            registerNodeImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::unregisterNodeMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::system::types::NdsNodeToken request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::core::types::Empty&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            unregisterNodeImpl(request, context), get_allocator_ref());
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getRegistryModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getRegistryModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::registry::services::RegistryServiceCapabilitiesResponse Client::getRegistryServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getRegistryServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::registry::services::RegistryServiceCapabilitiesResponse(reader, get_allocator_ref());
}

::nds::registry::node::NodeList Client::getAllNodesAllSystemsMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getAllNodesAllSystems"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::registry::node::NodeList(reader, get_allocator_ref());
}

::nds::registry::node::NodeList Client::getAllNodesMethod(const ::nds::system::types::NdsSystemToken& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getAllNodes"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::registry::node::NodeList(reader, get_allocator_ref());
}

::nds::registry::node::NodeList Client::searchNodesMethod(const ::nds::registry::node::NodeSearchFilter& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("searchNodes"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::registry::node::NodeList(reader, get_allocator_ref());
}

::nds::core::types::Empty Client::registerNodeMethod(const ::nds::registry::node::NodeInformation& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("registerNode"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::core::types::Empty(reader, get_allocator_ref());
}

::nds::core::types::Empty Client::unregisterNodeMethod(const ::nds::system::types::NdsNodeToken& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("unregisterNode"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::core::types::Empty(reader, get_allocator_ref());
}

} // namespace NdsRegistry

} // namespace services
} // namespace registry
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/StringView.h>

#include <nds/registry/services/RegistryTopics.h>

namespace nds
{
namespace registry
{
namespace services
{

namespace
{

template <typename ZSERIO_MESSAGE>
class RegistryTopicsOnRaw : public ::zserio::IPubsub::OnTopicCallback
{
public:
    explicit RegistryTopicsOnRaw(const ::std::shared_ptr<RegistryTopics::RegistryTopicsCallback<ZSERIO_MESSAGE>>& callback,
            const ::std::allocator<uint8_t>& allocator) :
            m_callback(callback), m_allocator(allocator)
    {}

    void operator()(::zserio::StringView topic, ::zserio::Span<const uint8_t> data) override
    {
        ::zserio::BitStreamReader reader(data.data(), data.size());
        const ZSERIO_MESSAGE message(reader, m_allocator);

        m_callback->operator()(topic, message);
    }

private:
    ::std::shared_ptr<RegistryTopics::RegistryTopicsCallback<ZSERIO_MESSAGE>> m_callback;
    ::std::allocator<uint8_t> m_allocator;
};

} // namespace

RegistryTopics::RegistryTopics(::zserio::IPubsub& pubsub, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_pubsub(pubsub)
{
}

void RegistryTopics::publishNdsSystemToken(const ::nds::system::types::NdsSystemToken& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/registry/update/system"), context);
}

::zserio::IPubsub::SubscriptionId RegistryTopics::subscribeNdsSystemToken(
        const ::std::shared_ptr<RegistryTopicsCallback<::nds::system::types::NdsSystemToken>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<RegistryTopicsOnRaw<::nds::system::types::NdsSystemToken>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/registry/update/system"), onRawCallback, context);
}

void RegistryTopics::publishEmpty(const ::nds::core::types::Empty& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/registry/update/tier2registry"), context);
}

::zserio::IPubsub::SubscriptionId RegistryTopics::subscribeEmpty(
        const ::std::shared_ptr<RegistryTopicsCallback<::nds::core::types::Empty>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<RegistryTopicsOnRaw<::nds::core::types::Empty>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/registry/update/tier2registry"), onRawCallback, context);
}

void RegistryTopics::unsubscribe(::zserio::IPubsub::SubscriptionId id)
{
    m_pubsub.unsubscribe(id);
}

template <typename ZSERIO_MESSAGE>
void RegistryTopics::publish(ZSERIO_MESSAGE& message, ::zserio::StringView topic, void* context)
{
    ::zserio::BitBuffer bitBuffer(message.bitSizeOf(), get_allocator_ref());
    ::zserio::BitStreamWriter writer(bitBuffer);
    message.write(writer);
    m_pubsub.publish(topic, bitBuffer.getBytes(), context);
}

} // namespace services
} // namespace registry
} // namespace nds
