/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/registry/node/NodeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for NodeType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::registry::node::NodeType>::names;
constexpr ::std::array<::nds::registry::node::NodeType, 3> EnumTraits<::nds::registry::node::NodeType>::values;
constexpr const char* EnumTraits<::nds::registry::node::NodeType>::enumName;

template <>
size_t enumToOrdinal(::nds::registry::node::NodeType value)
{
    switch (value)
    {
    case ::nds::registry::node::NodeType::REGISTRY:
        return 0;
    case ::nds::registry::node::NodeType::SERVICE:
        return 1;
    case ::nds::registry::node::NodeType::TOPIC_SERVER:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NodeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::registry::node::NodeType>::type>(value) << "!";
    }
}

template <>
::nds::registry::node::NodeType valueToEnum(
        typename ::std::underlying_type<::nds::registry::node::NodeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(3):
        return static_cast<::nds::registry::node::NodeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration NodeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::registry::node::NodeType>(::nds::registry::node::NodeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::registry::node::NodeType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::registry::node::NodeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::registry::node::NodeType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::registry::node::NodeType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::registry::node::NodeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::registry::node::NodeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::registry::node::NodeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::registry::node::NodeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::registry::node::NodeType>(
            static_cast<typename ::std::underlying_type<::nds::registry::node::NodeType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::registry::node::NodeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::registry::node::NodeType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::registry::node::NodeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::registry::node::NodeType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::registry::node::NodeType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::registry::node::NodeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/registry/node/NodeList.h>

namespace nds
{
namespace registry
{
namespace node
{

NodeList::NodeList(const allocator_type& allocator) noexcept :
        m_numNodes_(uint64_t()),
        m_nodes_(allocator)
{
}

NodeList::NodeList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numNodes_(readNumNodes(in)),
        m_nodes_(readNodes(in, allocator))
{
}

NodeList::NodeList(NodeList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numNodes_(readNumNodes(context, in)),
        m_nodes_(readNodes(context, in, allocator))
{
}

NodeList::NodeList(::zserio::PropagateAllocatorT,
        const NodeList& other, const allocator_type& allocator) :
        m_numNodes_(::zserio::allocatorPropagatingCopy(other.m_numNodes_, allocator)),
        m_nodes_(::zserio::allocatorPropagatingCopy(other.m_nodes_, allocator))
{
}

void NodeList::initializeChildren()
{
    m_nodes_.initializeElements(*this);
}

uint64_t NodeList::getNumNodes() const
{
    return m_numNodes_;
}

void NodeList::setNumNodes(uint64_t numNodes_)
{
    m_numNodes_ = numNodes_;
}

::zserio::vector<::nds::registry::node::NodeInformation>& NodeList::getNodes()
{
    return m_nodes_.getRawArray();
}

const ::zserio::vector<::nds::registry::node::NodeInformation>& NodeList::getNodes() const
{
    return m_nodes_.getRawArray();
}

void NodeList::setNodes(const ::zserio::vector<::nds::registry::node::NodeInformation>& nodes_)
{
    m_nodes_ = ZserioArrayType_nodes(nodes_);
}

void NodeList::setNodes(::zserio::vector<::nds::registry::node::NodeInformation>&& nodes_)
{
    m_nodes_ = ZserioArrayType_nodes(std::move(nodes_));
}

void NodeList::initPackingContext(NodeList::ZserioPackingContext& context) const
{
    context.getNumNodes().init<::zserio::VarIntArrayTraits<uint64_t>>(m_numNodes_);
}

size_t NodeList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_numNodes_);
    endBitPosition += m_nodes_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t NodeList::bitSizeOf(NodeList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumNodes().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_numNodes_);
    endBitPosition += m_nodes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t NodeList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_numNodes_);
    endBitPosition = m_nodes_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t NodeList::initializeOffsets(NodeList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumNodes().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_numNodes_);
    endBitPosition = m_nodes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool NodeList::operator==(const NodeList& other) const
{
    if (this != &other)
    {
        return
                (m_numNodes_ == other.m_numNodes_) &&
                (m_nodes_ == other.m_nodes_);
    }

    return true;
}

uint32_t NodeList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numNodes_);
    result = ::zserio::calcHashCode(result, m_nodes_);

    return result;
}

void NodeList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt(m_numNodes_);

    // check array length
    if (m_nodes_.getRawArray().size() != static_cast<size_t>(getNumNodes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field NodeList.nodes: ") <<
                m_nodes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumNodes()) << "!";
    }
    m_nodes_.write(*this, out);
}

void NodeList::write(NodeList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumNodes().write<::zserio::VarIntArrayTraits<uint64_t>>(out, m_numNodes_);

    // check array length
    if (m_nodes_.getRawArray().size() != static_cast<size_t>(getNumNodes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field NodeList.nodes: ") <<
                m_nodes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumNodes()) << "!";
    }
    m_nodes_.writePacked(*this, out);
}

void NodeList::ZserioArrayExpressions_nodes::initializeElement(NodeList&,
        ::nds::registry::node::NodeInformation& element, size_t)
{
    element.initializeChildren();
}

void NodeList::ZserioElementFactory_nodes::create(NodeList&        ,
        ::zserio::vector<::nds::registry::node::NodeInformation>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void NodeList::ZserioElementFactory_nodes::create(NodeList&        ,
        ::zserio::vector<::nds::registry::node::NodeInformation>& array,
        ::nds::registry::node::NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint64_t NodeList::readNumNodes(::zserio::BitStreamReader& in)
{
    return static_cast<uint64_t>(in.readVarUInt());
}

uint64_t NodeList::readNumNodes(NodeList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumNodes().read<::zserio::VarIntArrayTraits<uint64_t>>(in);
}
NodeList::ZserioArrayType_nodes NodeList::readNodes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_nodes readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumNodes()));

    return readField;
}

NodeList::ZserioArrayType_nodes NodeList::readNodes(NodeList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_nodes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumNodes()));

    return readField;
}

} // namespace node
} // namespace registry
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/registry/node/NodeInformation.h>
#include <nds/registry/node/NodeType.h>

namespace nds
{
namespace registry
{
namespace node
{

NodeInformation::NodeInformation(const allocator_type& allocator) noexcept :
        m_systemId_(allocator),
        m_nodeToken_(allocator),
        m_legalInfo_(allocator),
        m_type_(::nds::registry::node::NodeType()),
        m_connectionCosts_(::nds::registry::node::ConnectionCosts()),
        m_spatialCoverage_(allocator),
        m_protocolType_(::nds::registry::node::ProtocolType()),
        m_protocolDetailsUri_(allocator),
        m_nodeName_(allocator),
        m_hostName_(allocator),
        m_port_(uint16_t()),
        m_serviceInformation_(::zserio::NullOpt),
        m_registryDefinition_(::zserio::NullOpt)
{
}

NodeInformation::NodeInformation(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_systemId_(readSystemId(in, allocator)),
        m_nodeToken_(readNodeToken(in, allocator)),
        m_legalInfo_(readLegalInfo(in, allocator)),
        m_type_(readType(in)),
        m_connectionCosts_(readConnectionCosts(in)),
        m_spatialCoverage_(readSpatialCoverage(in, allocator)),
        m_protocolType_(readProtocolType(in)),
        m_protocolDetailsUri_(readProtocolDetailsUri(in, allocator)),
        m_nodeName_(readNodeName(in, allocator)),
        m_hostName_(readHostName(in, allocator)),
        m_port_(readPort(in)),
        m_serviceInformation_(readServiceInformation(in, allocator)),
        m_registryDefinition_(readRegistryDefinition(in, allocator))
{
}

NodeInformation::NodeInformation(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_systemId_(readSystemId(context, in, allocator)),
        m_nodeToken_(readNodeToken(context, in, allocator)),
        m_legalInfo_(readLegalInfo(context, in, allocator)),
        m_type_(readType(context, in)),
        m_connectionCosts_(readConnectionCosts(context, in)),
        m_spatialCoverage_(readSpatialCoverage(context, in, allocator)),
        m_protocolType_(readProtocolType(context, in)),
        m_protocolDetailsUri_(readProtocolDetailsUri(in, allocator)),
        m_nodeName_(readNodeName(in, allocator)),
        m_hostName_(readHostName(in, allocator)),
        m_port_(readPort(context, in)),
        m_serviceInformation_(readServiceInformation(context, in, allocator)),
        m_registryDefinition_(readRegistryDefinition(in, allocator))
{
}

NodeInformation::NodeInformation(::zserio::PropagateAllocatorT,
        const NodeInformation& other, const allocator_type& allocator) :
        m_systemId_(::zserio::allocatorPropagatingCopy(other.m_systemId_, allocator)),
        m_nodeToken_(::zserio::allocatorPropagatingCopy(other.m_nodeToken_, allocator)),
        m_legalInfo_(::zserio::allocatorPropagatingCopy(other.m_legalInfo_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_connectionCosts_(::zserio::allocatorPropagatingCopy(other.m_connectionCosts_, allocator)),
        m_spatialCoverage_(::zserio::allocatorPropagatingCopy(other.m_spatialCoverage_, allocator)),
        m_protocolType_(::zserio::allocatorPropagatingCopy(other.m_protocolType_, allocator)),
        m_protocolDetailsUri_(::zserio::allocatorPropagatingCopy(other.m_protocolDetailsUri_, allocator)),
        m_nodeName_(::zserio::allocatorPropagatingCopy(other.m_nodeName_, allocator)),
        m_hostName_(::zserio::allocatorPropagatingCopy(other.m_hostName_, allocator)),
        m_port_(::zserio::allocatorPropagatingCopy(other.m_port_, allocator)),
        m_serviceInformation_(::zserio::allocatorPropagatingCopy(other.m_serviceInformation_, allocator)),
        m_registryDefinition_(::zserio::allocatorPropagatingCopy(other.m_registryDefinition_, allocator))
{
}

void NodeInformation::initializeChildren()
{
    m_spatialCoverage_.initializeChildren();
}

::nds::system::types::NdsSystemToken& NodeInformation::getSystemId()
{
    return m_systemId_;
}

const ::nds::system::types::NdsSystemToken& NodeInformation::getSystemId() const
{
    return m_systemId_;
}

void NodeInformation::setSystemId(const ::nds::system::types::NdsSystemToken& systemId_)
{
    m_systemId_ = systemId_;
}

void NodeInformation::setSystemId(::nds::system::types::NdsSystemToken&& systemId_)
{
    m_systemId_ = ::std::move(systemId_);
}

::nds::system::types::NdsNodeToken& NodeInformation::getNodeToken()
{
    return m_nodeToken_;
}

const ::nds::system::types::NdsNodeToken& NodeInformation::getNodeToken() const
{
    return m_nodeToken_;
}

void NodeInformation::setNodeToken(const ::nds::system::types::NdsNodeToken& nodeToken_)
{
    m_nodeToken_ = nodeToken_;
}

void NodeInformation::setNodeToken(::nds::system::types::NdsNodeToken&& nodeToken_)
{
    m_nodeToken_ = ::std::move(nodeToken_);
}

::nds::system::types::NdsNodeLegalInfo& NodeInformation::getLegalInfo()
{
    return m_legalInfo_;
}

const ::nds::system::types::NdsNodeLegalInfo& NodeInformation::getLegalInfo() const
{
    return m_legalInfo_;
}

void NodeInformation::setLegalInfo(const ::nds::system::types::NdsNodeLegalInfo& legalInfo_)
{
    m_legalInfo_ = legalInfo_;
}

void NodeInformation::setLegalInfo(::nds::system::types::NdsNodeLegalInfo&& legalInfo_)
{
    m_legalInfo_ = ::std::move(legalInfo_);
}

::nds::registry::node::NodeType NodeInformation::getType() const
{
    return m_type_;
}

void NodeInformation::setType(::nds::registry::node::NodeType type_)
{
    m_type_ = type_;
}

::nds::registry::node::ConnectionCosts NodeInformation::getConnectionCosts() const
{
    return m_connectionCosts_;
}

void NodeInformation::setConnectionCosts(::nds::registry::node::ConnectionCosts connectionCosts_)
{
    m_connectionCosts_ = connectionCosts_;
}

::nds::core::geometry::SpatialExtent& NodeInformation::getSpatialCoverage()
{
    return m_spatialCoverage_;
}

const ::nds::core::geometry::SpatialExtent& NodeInformation::getSpatialCoverage() const
{
    return m_spatialCoverage_;
}

void NodeInformation::setSpatialCoverage(const ::nds::core::geometry::SpatialExtent& spatialCoverage_)
{
    m_spatialCoverage_ = spatialCoverage_;
}

void NodeInformation::setSpatialCoverage(::nds::core::geometry::SpatialExtent&& spatialCoverage_)
{
    m_spatialCoverage_ = ::std::move(spatialCoverage_);
}

::nds::registry::node::ProtocolType NodeInformation::getProtocolType() const
{
    return m_protocolType_;
}

void NodeInformation::setProtocolType(::nds::registry::node::ProtocolType protocolType_)
{
    m_protocolType_ = protocolType_;
}

::zserio::string<>& NodeInformation::getProtocolDetailsUri()
{
    return m_protocolDetailsUri_;
}

const ::zserio::string<>& NodeInformation::getProtocolDetailsUri() const
{
    return m_protocolDetailsUri_;
}

void NodeInformation::setProtocolDetailsUri(const ::zserio::string<>& protocolDetailsUri_)
{
    m_protocolDetailsUri_ = protocolDetailsUri_;
}

void NodeInformation::setProtocolDetailsUri(::zserio::string<>&& protocolDetailsUri_)
{
    m_protocolDetailsUri_ = ::std::move(protocolDetailsUri_);
}

::zserio::string<>& NodeInformation::getNodeName()
{
    return m_nodeName_;
}

const ::zserio::string<>& NodeInformation::getNodeName() const
{
    return m_nodeName_;
}

void NodeInformation::setNodeName(const ::zserio::string<>& nodeName_)
{
    m_nodeName_ = nodeName_;
}

void NodeInformation::setNodeName(::zserio::string<>&& nodeName_)
{
    m_nodeName_ = ::std::move(nodeName_);
}

::zserio::string<>& NodeInformation::getHostName()
{
    return m_hostName_;
}

const ::zserio::string<>& NodeInformation::getHostName() const
{
    return m_hostName_;
}

void NodeInformation::setHostName(const ::zserio::string<>& hostName_)
{
    m_hostName_ = hostName_;
}

void NodeInformation::setHostName(::zserio::string<>&& hostName_)
{
    m_hostName_ = ::std::move(hostName_);
}

uint16_t NodeInformation::getPort() const
{
    return m_port_;
}

void NodeInformation::setPort(uint16_t port_)
{
    m_port_ = port_;
}

::nds::registry::node::ServiceInformation& NodeInformation::getServiceInformation()
{
    return m_serviceInformation_.value();
}

const ::nds::registry::node::ServiceInformation& NodeInformation::getServiceInformation() const
{
    return m_serviceInformation_.value();
}

void NodeInformation::setServiceInformation(const ::nds::registry::node::ServiceInformation& serviceInformation_)
{
    m_serviceInformation_ = serviceInformation_;
}

void NodeInformation::setServiceInformation(::nds::registry::node::ServiceInformation&& serviceInformation_)
{
    m_serviceInformation_ = ::std::move(serviceInformation_);
}

bool NodeInformation::isServiceInformationUsed() const
{
    return (getType() == ::nds::registry::node::NodeType::SERVICE);
}

bool NodeInformation::isServiceInformationSet() const
{
    return m_serviceInformation_.hasValue();
}

void NodeInformation::resetServiceInformation()
{
    m_serviceInformation_.reset();
}

::nds::system::types::ModuleDefinition& NodeInformation::getRegistryDefinition()
{
    return m_registryDefinition_.value();
}

const ::nds::system::types::ModuleDefinition& NodeInformation::getRegistryDefinition() const
{
    return m_registryDefinition_.value();
}

void NodeInformation::setRegistryDefinition(const ::nds::system::types::ModuleDefinition& registryDefinition_)
{
    m_registryDefinition_ = registryDefinition_;
}

void NodeInformation::setRegistryDefinition(::nds::system::types::ModuleDefinition&& registryDefinition_)
{
    m_registryDefinition_ = ::std::move(registryDefinition_);
}

bool NodeInformation::isRegistryDefinitionUsed() const
{
    return (getType() == ::nds::registry::node::NodeType::REGISTRY);
}

bool NodeInformation::isRegistryDefinitionSet() const
{
    return m_registryDefinition_.hasValue();
}

void NodeInformation::resetRegistryDefinition()
{
    m_registryDefinition_.reset();
}

void NodeInformation::initPackingContext(NodeInformation::ZserioPackingContext& context) const
{
    m_systemId_.initPackingContext(context.getSystemId());
    m_nodeToken_.initPackingContext(context.getNodeToken());
    m_legalInfo_.initPackingContext(context.getLegalInfo());
    ::zserio::initPackingContext(context.getType(), m_type_);
    context.getConnectionCosts().init<::zserio::StdIntArrayTraits<::nds::registry::node::ConnectionCosts>>(m_connectionCosts_);
    m_spatialCoverage_.initPackingContext(context.getSpatialCoverage());
    context.getProtocolType().init<::zserio::StdIntArrayTraits<::nds::registry::node::ProtocolType>>(m_protocolType_);
    context.getPort().init<::zserio::StdIntArrayTraits<uint16_t>>(m_port_);
    if (getType() == ::nds::registry::node::NodeType::SERVICE)
    {
        m_serviceInformation_.value().initPackingContext(context.getServiceInformation());
    }
}

size_t NodeInformation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_systemId_.bitSizeOf(endBitPosition);
    endBitPosition += m_nodeToken_.bitSizeOf(endBitPosition);
    endBitPosition += m_legalInfo_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += UINT8_C(16);
    endBitPosition += m_spatialCoverage_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(8);
    endBitPosition += ::zserio::bitSizeOfString(m_protocolDetailsUri_);
    endBitPosition += ::zserio::bitSizeOfString(m_nodeName_);
    endBitPosition += ::zserio::bitSizeOfString(m_hostName_);
    endBitPosition += UINT8_C(16);
    if (getType() == ::nds::registry::node::NodeType::SERVICE)
    {
        endBitPosition += m_serviceInformation_.value().bitSizeOf(endBitPosition);
    }
    if (getType() == ::nds::registry::node::NodeType::REGISTRY)
    {
        endBitPosition += m_registryDefinition_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t NodeInformation::bitSizeOf(NodeInformation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_systemId_.bitSizeOf(context.getSystemId(), endBitPosition);
    endBitPosition += m_nodeToken_.bitSizeOf(context.getNodeToken(), endBitPosition);
    endBitPosition += m_legalInfo_.bitSizeOf(context.getLegalInfo(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += context.getConnectionCosts().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ConnectionCosts>>(m_connectionCosts_);
    endBitPosition += m_spatialCoverage_.bitSizeOf(context.getSpatialCoverage(), endBitPosition);
    endBitPosition += context.getProtocolType().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ProtocolType>>(m_protocolType_);
    endBitPosition += ::zserio::bitSizeOfString(m_protocolDetailsUri_);
    endBitPosition += ::zserio::bitSizeOfString(m_nodeName_);
    endBitPosition += ::zserio::bitSizeOfString(m_hostName_);
    endBitPosition += context.getPort().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_port_);
    if (getType() == ::nds::registry::node::NodeType::SERVICE)
    {
        endBitPosition += m_serviceInformation_.value().bitSizeOf(context.getServiceInformation(), endBitPosition);
    }
    if (getType() == ::nds::registry::node::NodeType::REGISTRY)
    {
        endBitPosition += m_registryDefinition_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t NodeInformation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_systemId_.initializeOffsets(endBitPosition);
    endBitPosition = m_nodeToken_.initializeOffsets(endBitPosition);
    endBitPosition = m_legalInfo_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += UINT8_C(16);
    endBitPosition = m_spatialCoverage_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(8);
    endBitPosition += ::zserio::bitSizeOfString(m_protocolDetailsUri_);
    endBitPosition += ::zserio::bitSizeOfString(m_nodeName_);
    endBitPosition += ::zserio::bitSizeOfString(m_hostName_);
    endBitPosition += UINT8_C(16);
    if (getType() == ::nds::registry::node::NodeType::SERVICE)
    {
        endBitPosition = m_serviceInformation_.value().initializeOffsets(endBitPosition);
    }
    if (getType() == ::nds::registry::node::NodeType::REGISTRY)
    {
        endBitPosition = m_registryDefinition_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t NodeInformation::initializeOffsets(NodeInformation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_systemId_.initializeOffsets(context.getSystemId(), endBitPosition);
    endBitPosition = m_nodeToken_.initializeOffsets(context.getNodeToken(), endBitPosition);
    endBitPosition = m_legalInfo_.initializeOffsets(context.getLegalInfo(), endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += context.getConnectionCosts().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ConnectionCosts>>(m_connectionCosts_);
    endBitPosition = m_spatialCoverage_.initializeOffsets(context.getSpatialCoverage(), endBitPosition);
    endBitPosition += context.getProtocolType().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ProtocolType>>(m_protocolType_);
    endBitPosition += ::zserio::bitSizeOfString(m_protocolDetailsUri_);
    endBitPosition += ::zserio::bitSizeOfString(m_nodeName_);
    endBitPosition += ::zserio::bitSizeOfString(m_hostName_);
    endBitPosition += context.getPort().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_port_);
    if (getType() == ::nds::registry::node::NodeType::SERVICE)
    {
        endBitPosition = m_serviceInformation_.value().initializeOffsets(context.getServiceInformation(), endBitPosition);
    }
    if (getType() == ::nds::registry::node::NodeType::REGISTRY)
    {
        endBitPosition = m_registryDefinition_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

bool NodeInformation::operator==(const NodeInformation& other) const
{
    if (this != &other)
    {
        return
                (m_systemId_ == other.m_systemId_) &&
                (m_nodeToken_ == other.m_nodeToken_) &&
                (m_legalInfo_ == other.m_legalInfo_) &&
                (m_type_ == other.m_type_) &&
                (m_connectionCosts_ == other.m_connectionCosts_) &&
                (m_spatialCoverage_ == other.m_spatialCoverage_) &&
                (m_protocolType_ == other.m_protocolType_) &&
                (m_protocolDetailsUri_ == other.m_protocolDetailsUri_) &&
                (m_nodeName_ == other.m_nodeName_) &&
                (m_hostName_ == other.m_hostName_) &&
                (m_port_ == other.m_port_) &&
                (!isServiceInformationUsed() ? !other.isServiceInformationUsed() : (m_serviceInformation_ == other.m_serviceInformation_)) &&
                (!isRegistryDefinitionUsed() ? !other.isRegistryDefinitionUsed() : (m_registryDefinition_ == other.m_registryDefinition_));
    }

    return true;
}

uint32_t NodeInformation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_systemId_);
    result = ::zserio::calcHashCode(result, m_nodeToken_);
    result = ::zserio::calcHashCode(result, m_legalInfo_);
    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_connectionCosts_);
    result = ::zserio::calcHashCode(result, m_spatialCoverage_);
    result = ::zserio::calcHashCode(result, m_protocolType_);
    result = ::zserio::calcHashCode(result, m_protocolDetailsUri_);
    result = ::zserio::calcHashCode(result, m_nodeName_);
    result = ::zserio::calcHashCode(result, m_hostName_);
    result = ::zserio::calcHashCode(result, m_port_);
    if (isServiceInformationUsed())
        result = ::zserio::calcHashCode(result, m_serviceInformation_);
    if (isRegistryDefinitionUsed())
        result = ::zserio::calcHashCode(result, m_registryDefinition_);

    return result;
}

void NodeInformation::write(::zserio::BitStreamWriter& out) const
{
    m_systemId_.write(out);
    m_nodeToken_.write(out);
    m_legalInfo_.write(out);
    ::zserio::write(out, m_type_);
    out.writeBits(m_connectionCosts_, UINT8_C(16));
    m_spatialCoverage_.write(out);
    out.writeBits(m_protocolType_, UINT8_C(8));
    out.writeString(m_protocolDetailsUri_);
    out.writeString(m_nodeName_);
    out.writeString(m_hostName_);
    out.writeBits(m_port_, UINT8_C(16));
    if (getType() == ::nds::registry::node::NodeType::SERVICE)
    {
        m_serviceInformation_.value().write(out);
    }
    if (getType() == ::nds::registry::node::NodeType::REGISTRY)
    {
        m_registryDefinition_.value().write(out);
    }
}

void NodeInformation::write(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_systemId_.write(context.getSystemId(), out);
    m_nodeToken_.write(context.getNodeToken(), out);
    m_legalInfo_.write(context.getLegalInfo(), out);
    ::zserio::write(context.getType(), out, m_type_);
    context.getConnectionCosts().write<::zserio::StdIntArrayTraits<::nds::registry::node::ConnectionCosts>>(out, m_connectionCosts_);
    m_spatialCoverage_.write(context.getSpatialCoverage(), out);
    context.getProtocolType().write<::zserio::StdIntArrayTraits<::nds::registry::node::ProtocolType>>(out, m_protocolType_);
    out.writeString(m_protocolDetailsUri_);
    out.writeString(m_nodeName_);
    out.writeString(m_hostName_);
    context.getPort().write<::zserio::StdIntArrayTraits<uint16_t>>(out, m_port_);
    if (getType() == ::nds::registry::node::NodeType::SERVICE)
    {
        m_serviceInformation_.value().write(context.getServiceInformation(), out);
    }
    if (getType() == ::nds::registry::node::NodeType::REGISTRY)
    {
        m_registryDefinition_.value().write(out);
    }
}

::nds::system::types::NdsSystemToken NodeInformation::readSystemId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::NdsSystemToken(in, allocator);
}

::nds::system::types::NdsSystemToken NodeInformation::readSystemId(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::system::types::NdsSystemToken(context.getSystemId(), in, allocator);
}
::nds::system::types::NdsNodeToken NodeInformation::readNodeToken(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::NdsNodeToken(in, allocator);
}

::nds::system::types::NdsNodeToken NodeInformation::readNodeToken(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::system::types::NdsNodeToken(context.getNodeToken(), in, allocator);
}
::nds::system::types::NdsNodeLegalInfo NodeInformation::readLegalInfo(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::NdsNodeLegalInfo(in, allocator);
}

::nds::system::types::NdsNodeLegalInfo NodeInformation::readLegalInfo(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::system::types::NdsNodeLegalInfo(context.getLegalInfo(), in, allocator);
}
::nds::registry::node::NodeType NodeInformation::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::registry::node::NodeType>(in);
}

::nds::registry::node::NodeType NodeInformation::readType(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::registry::node::NodeType>(context.getType(), in);
}
::nds::registry::node::ConnectionCosts NodeInformation::readConnectionCosts(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::registry::node::ConnectionCosts>(in.readBits(UINT8_C(16)));
}

::nds::registry::node::ConnectionCosts NodeInformation::readConnectionCosts(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getConnectionCosts().read<::zserio::StdIntArrayTraits<::nds::registry::node::ConnectionCosts>>(in);
}
::nds::core::geometry::SpatialExtent NodeInformation::readSpatialCoverage(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::SpatialExtent(in, allocator);
}

::nds::core::geometry::SpatialExtent NodeInformation::readSpatialCoverage(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::SpatialExtent(context.getSpatialCoverage(), in, allocator);
}
::nds::registry::node::ProtocolType NodeInformation::readProtocolType(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::registry::node::ProtocolType>(in.readBits(UINT8_C(8)));
}

::nds::registry::node::ProtocolType NodeInformation::readProtocolType(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getProtocolType().read<::zserio::StdIntArrayTraits<::nds::registry::node::ProtocolType>>(in);
}
::zserio::string<> NodeInformation::readProtocolDetailsUri(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> NodeInformation::readNodeName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> NodeInformation::readHostName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
uint16_t NodeInformation::readPort(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readBits(UINT8_C(16)));
}

uint16_t NodeInformation::readPort(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getPort().read<::zserio::StdIntArrayTraits<uint16_t>>(in);
}
::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformation> NodeInformation::readServiceInformation(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::registry::node::NodeType::SERVICE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformation>(::nds::registry::node::ServiceInformation(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformation>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformation> NodeInformation::readServiceInformation(NodeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::registry::node::NodeType::SERVICE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformation>(::nds::registry::node::ServiceInformation(context.getServiceInformation(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformation>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::system::types::ModuleDefinition> NodeInformation::readRegistryDefinition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::registry::node::NodeType::REGISTRY)
    {
        return ::zserio::InplaceOptionalHolder<::nds::system::types::ModuleDefinition>(::nds::system::types::ModuleDefinition(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::system::types::ModuleDefinition>(::zserio::NullOpt);
}

} // namespace node
} // namespace registry
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/registry/node/ServiceInformation.h>

namespace nds
{
namespace registry
{
namespace node
{

ServiceInformation::ServiceInformation(const allocator_type& allocator) noexcept :
        m_moduleDefinition_(allocator),
        m_moduleService_(allocator),
        m_servicePriority_(::nds::registry::node::ServicePriority()),
        m_serviceMetadata_(::zserio::NullOpt),
        m_serviceCertificationMetadata_(allocator)
{
}

ServiceInformation::ServiceInformation(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_moduleDefinition_(readModuleDefinition(in, allocator)),
        m_moduleService_(readModuleService(in, allocator)),
        m_servicePriority_(readServicePriority(in)),
        m_serviceMetadata_(readServiceMetadata(in, allocator)),
        m_serviceCertificationMetadata_(readServiceCertificationMetadata(in, allocator))
{
}

ServiceInformation::ServiceInformation(ServiceInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_moduleDefinition_(readModuleDefinition(in, allocator)),
        m_moduleService_(readModuleService(in, allocator)),
        m_servicePriority_(readServicePriority(context, in)),
        m_serviceMetadata_(readServiceMetadata(in, allocator)),
        m_serviceCertificationMetadata_(readServiceCertificationMetadata(in, allocator))
{
}

ServiceInformation::ServiceInformation(::zserio::PropagateAllocatorT,
        const ServiceInformation& other, const allocator_type& allocator) :
        m_moduleDefinition_(::zserio::allocatorPropagatingCopy(other.m_moduleDefinition_, allocator)),
        m_moduleService_(::zserio::allocatorPropagatingCopy(other.m_moduleService_, allocator)),
        m_servicePriority_(::zserio::allocatorPropagatingCopy(other.m_servicePriority_, allocator)),
        m_serviceMetadata_(::zserio::allocatorPropagatingCopy(other.m_serviceMetadata_, allocator)),
        m_serviceCertificationMetadata_(::zserio::allocatorPropagatingCopy(other.m_serviceCertificationMetadata_, allocator))
{
}

::nds::system::types::ModuleDefinition& ServiceInformation::getModuleDefinition()
{
    return m_moduleDefinition_;
}

const ::nds::system::types::ModuleDefinition& ServiceInformation::getModuleDefinition() const
{
    return m_moduleDefinition_;
}

void ServiceInformation::setModuleDefinition(const ::nds::system::types::ModuleDefinition& moduleDefinition_)
{
    m_moduleDefinition_ = moduleDefinition_;
}

void ServiceInformation::setModuleDefinition(::nds::system::types::ModuleDefinition&& moduleDefinition_)
{
    m_moduleDefinition_ = ::std::move(moduleDefinition_);
}

::nds::system::types::ModuleService& ServiceInformation::getModuleService()
{
    return m_moduleService_;
}

const ::nds::system::types::ModuleService& ServiceInformation::getModuleService() const
{
    return m_moduleService_;
}

void ServiceInformation::setModuleService(const ::nds::system::types::ModuleService& moduleService_)
{
    m_moduleService_ = moduleService_;
}

void ServiceInformation::setModuleService(::nds::system::types::ModuleService&& moduleService_)
{
    m_moduleService_ = ::std::move(moduleService_);
}

::nds::registry::node::ServicePriority ServiceInformation::getServicePriority() const
{
    return m_servicePriority_;
}

void ServiceInformation::setServicePriority(::nds::registry::node::ServicePriority servicePriority_)
{
    m_servicePriority_ = servicePriority_;
}

::nds::system::types::ExternData& ServiceInformation::getServiceMetadata()
{
    return m_serviceMetadata_.value();
}

const ::nds::system::types::ExternData& ServiceInformation::getServiceMetadata() const
{
    return m_serviceMetadata_.value();
}

void ServiceInformation::setServiceMetadata(const ::nds::system::types::ExternData& serviceMetadata_)
{
    m_serviceMetadata_ = serviceMetadata_;
}

void ServiceInformation::setServiceMetadata(::nds::system::types::ExternData&& serviceMetadata_)
{
    m_serviceMetadata_ = ::std::move(serviceMetadata_);
}

bool ServiceInformation::isServiceMetadataUsed() const
{
    return (isServiceMetadataSet());
}

bool ServiceInformation::isServiceMetadataSet() const
{
    return m_serviceMetadata_.hasValue();
}

void ServiceInformation::resetServiceMetadata()
{
    m_serviceMetadata_.reset();
}

::zserio::BitBuffer& ServiceInformation::getServiceCertificationMetadata()
{
    return m_serviceCertificationMetadata_;
}

const ::zserio::BitBuffer& ServiceInformation::getServiceCertificationMetadata() const
{
    return m_serviceCertificationMetadata_;
}

void ServiceInformation::setServiceCertificationMetadata(const ::zserio::BitBuffer& serviceCertificationMetadata_)
{
    m_serviceCertificationMetadata_ = serviceCertificationMetadata_;
}

void ServiceInformation::setServiceCertificationMetadata(::zserio::BitBuffer&& serviceCertificationMetadata_)
{
    m_serviceCertificationMetadata_ = ::std::move(serviceCertificationMetadata_);
}

void ServiceInformation::initPackingContext(ServiceInformation::ZserioPackingContext& context) const
{
    context.getServicePriority().init<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(m_servicePriority_);
}

size_t ServiceInformation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_moduleDefinition_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleService_);
    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isServiceMetadataSet())
    {
        endBitPosition += m_serviceMetadata_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_serviceCertificationMetadata_);

    return endBitPosition - bitPosition;
}

size_t ServiceInformation::bitSizeOf(ServiceInformation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_moduleDefinition_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleService_);
    endBitPosition += context.getServicePriority().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(m_servicePriority_);
    endBitPosition += 1;
    if (isServiceMetadataSet())
    {
        endBitPosition += m_serviceMetadata_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_serviceCertificationMetadata_);

    return endBitPosition - bitPosition;
}

size_t ServiceInformation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_moduleDefinition_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleService_);
    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isServiceMetadataSet())
    {
        endBitPosition = m_serviceMetadata_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_serviceCertificationMetadata_);

    return endBitPosition;
}

size_t ServiceInformation::initializeOffsets(ServiceInformation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_moduleDefinition_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleService_);
    endBitPosition += context.getServicePriority().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(m_servicePriority_);
    endBitPosition += 1;
    if (isServiceMetadataSet())
    {
        endBitPosition = m_serviceMetadata_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_serviceCertificationMetadata_);

    return endBitPosition;
}

bool ServiceInformation::operator==(const ServiceInformation& other) const
{
    if (this != &other)
    {
        return
                (m_moduleDefinition_ == other.m_moduleDefinition_) &&
                (m_moduleService_ == other.m_moduleService_) &&
                (m_servicePriority_ == other.m_servicePriority_) &&
                (!isServiceMetadataUsed() ? !other.isServiceMetadataUsed() : (m_serviceMetadata_ == other.m_serviceMetadata_)) &&
                (m_serviceCertificationMetadata_ == other.m_serviceCertificationMetadata_);
    }

    return true;
}

uint32_t ServiceInformation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_moduleDefinition_);
    result = ::zserio::calcHashCode(result, m_moduleService_);
    result = ::zserio::calcHashCode(result, m_servicePriority_);
    if (isServiceMetadataUsed())
        result = ::zserio::calcHashCode(result, m_serviceMetadata_);
    result = ::zserio::calcHashCode(result, m_serviceCertificationMetadata_);

    return result;
}

void ServiceInformation::write(::zserio::BitStreamWriter& out) const
{
    m_moduleDefinition_.write(out);
    out.writeString(m_moduleService_);
    out.writeBits(m_servicePriority_, UINT8_C(8));
    if (isServiceMetadataSet())
    {
        out.writeBool(true);
        m_serviceMetadata_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    out.alignTo(8);
    out.writeBitBuffer(m_serviceCertificationMetadata_);
}

void ServiceInformation::write(ServiceInformation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_moduleDefinition_.write(out);
    out.writeString(m_moduleService_);
    context.getServicePriority().write<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(out, m_servicePriority_);
    if (isServiceMetadataSet())
    {
        out.writeBool(true);
        m_serviceMetadata_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    out.alignTo(8);
    out.writeBitBuffer(m_serviceCertificationMetadata_);
}

::nds::system::types::ModuleDefinition ServiceInformation::readModuleDefinition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::ModuleDefinition(in, allocator);
}
::nds::system::types::ModuleService ServiceInformation::readModuleService(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleService>(in.readString(allocator));
}
::nds::registry::node::ServicePriority ServiceInformation::readServicePriority(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::registry::node::ServicePriority>(in.readBits(UINT8_C(8)));
}

::nds::registry::node::ServicePriority ServiceInformation::readServicePriority(ServiceInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getServicePriority().read<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(in);
}
::zserio::InplaceOptionalHolder<::nds::system::types::ExternData> ServiceInformation::readServiceMetadata(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::system::types::ExternData>(::nds::system::types::ExternData(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::system::types::ExternData>(::zserio::NullOpt);
}
::zserio::BitBuffer ServiceInformation::readServiceCertificationMetadata(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    return static_cast<::zserio::BitBuffer>(in.readBitBuffer(allocator));
}

} // namespace node
} // namespace registry
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/registry/node/NodeSearchFilter.h>
#include <nds/registry/node/NodeType.h>

namespace nds
{
namespace registry
{
namespace node
{

NodeSearchFilter::NodeSearchFilter(const allocator_type& allocator) noexcept :
        m_systemId_(allocator),
        m_nodeType_(::nds::registry::node::NodeType()),
        m_serviceInfoFilter_(::zserio::NullOpt)
{
}

NodeSearchFilter::NodeSearchFilter(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_systemId_(readSystemId(in, allocator)),
        m_nodeType_(readNodeType(in)),
        m_serviceInfoFilter_(readServiceInfoFilter(in, allocator))
{
}

NodeSearchFilter::NodeSearchFilter(NodeSearchFilter::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_systemId_(readSystemId(context, in, allocator)),
        m_nodeType_(readNodeType(context, in)),
        m_serviceInfoFilter_(readServiceInfoFilter(context, in, allocator))
{
}

NodeSearchFilter::NodeSearchFilter(::zserio::PropagateAllocatorT,
        const NodeSearchFilter& other, const allocator_type& allocator) :
        m_systemId_(::zserio::allocatorPropagatingCopy(other.m_systemId_, allocator)),
        m_nodeType_(::zserio::allocatorPropagatingCopy(other.m_nodeType_, allocator)),
        m_serviceInfoFilter_(::zserio::allocatorPropagatingCopy(other.m_serviceInfoFilter_, allocator))
{
}

::nds::system::types::NdsSystemToken& NodeSearchFilter::getSystemId()
{
    return m_systemId_;
}

const ::nds::system::types::NdsSystemToken& NodeSearchFilter::getSystemId() const
{
    return m_systemId_;
}

void NodeSearchFilter::setSystemId(const ::nds::system::types::NdsSystemToken& systemId_)
{
    m_systemId_ = systemId_;
}

void NodeSearchFilter::setSystemId(::nds::system::types::NdsSystemToken&& systemId_)
{
    m_systemId_ = ::std::move(systemId_);
}

::nds::registry::node::NodeType NodeSearchFilter::getNodeType() const
{
    return m_nodeType_;
}

void NodeSearchFilter::setNodeType(::nds::registry::node::NodeType nodeType_)
{
    m_nodeType_ = nodeType_;
}

::nds::registry::node::ServiceInformationFilter& NodeSearchFilter::getServiceInfoFilter()
{
    return m_serviceInfoFilter_.value();
}

const ::nds::registry::node::ServiceInformationFilter& NodeSearchFilter::getServiceInfoFilter() const
{
    return m_serviceInfoFilter_.value();
}

void NodeSearchFilter::setServiceInfoFilter(const ::nds::registry::node::ServiceInformationFilter& serviceInfoFilter_)
{
    m_serviceInfoFilter_ = serviceInfoFilter_;
}

void NodeSearchFilter::setServiceInfoFilter(::nds::registry::node::ServiceInformationFilter&& serviceInfoFilter_)
{
    m_serviceInfoFilter_ = ::std::move(serviceInfoFilter_);
}

bool NodeSearchFilter::isServiceInfoFilterUsed() const
{
    return (getNodeType() == ::nds::registry::node::NodeType::SERVICE);
}

bool NodeSearchFilter::isServiceInfoFilterSet() const
{
    return m_serviceInfoFilter_.hasValue();
}

void NodeSearchFilter::resetServiceInfoFilter()
{
    m_serviceInfoFilter_.reset();
}

void NodeSearchFilter::initPackingContext(NodeSearchFilter::ZserioPackingContext& context) const
{
    m_systemId_.initPackingContext(context.getSystemId());
    ::zserio::initPackingContext(context.getNodeType(), m_nodeType_);
    if (getNodeType() == ::nds::registry::node::NodeType::SERVICE)
    {
        m_serviceInfoFilter_.value().initPackingContext(context.getServiceInfoFilter());
    }
}

size_t NodeSearchFilter::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_systemId_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_nodeType_);
    if (getNodeType() == ::nds::registry::node::NodeType::SERVICE)
    {
        endBitPosition += m_serviceInfoFilter_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t NodeSearchFilter::bitSizeOf(NodeSearchFilter::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_systemId_.bitSizeOf(context.getSystemId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(context.getNodeType(), m_nodeType_);
    if (getNodeType() == ::nds::registry::node::NodeType::SERVICE)
    {
        endBitPosition += m_serviceInfoFilter_.value().bitSizeOf(context.getServiceInfoFilter(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t NodeSearchFilter::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_systemId_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_nodeType_);
    if (getNodeType() == ::nds::registry::node::NodeType::SERVICE)
    {
        endBitPosition = m_serviceInfoFilter_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t NodeSearchFilter::initializeOffsets(NodeSearchFilter::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_systemId_.initializeOffsets(context.getSystemId(), endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(context.getNodeType(), endBitPosition,
        m_nodeType_);
    if (getNodeType() == ::nds::registry::node::NodeType::SERVICE)
    {
        endBitPosition = m_serviceInfoFilter_.value().initializeOffsets(context.getServiceInfoFilter(), endBitPosition);
    }

    return endBitPosition;
}

bool NodeSearchFilter::operator==(const NodeSearchFilter& other) const
{
    if (this != &other)
    {
        return
                (m_systemId_ == other.m_systemId_) &&
                (m_nodeType_ == other.m_nodeType_) &&
                (!isServiceInfoFilterUsed() ? !other.isServiceInfoFilterUsed() : (m_serviceInfoFilter_ == other.m_serviceInfoFilter_));
    }

    return true;
}

uint32_t NodeSearchFilter::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_systemId_);
    result = ::zserio::calcHashCode(result, m_nodeType_);
    if (isServiceInfoFilterUsed())
        result = ::zserio::calcHashCode(result, m_serviceInfoFilter_);

    return result;
}

void NodeSearchFilter::write(::zserio::BitStreamWriter& out) const
{
    m_systemId_.write(out);
    ::zserio::write(out, m_nodeType_);
    if (getNodeType() == ::nds::registry::node::NodeType::SERVICE)
    {
        m_serviceInfoFilter_.value().write(out);
    }
}

void NodeSearchFilter::write(NodeSearchFilter::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_systemId_.write(context.getSystemId(), out);
    ::zserio::write(context.getNodeType(), out, m_nodeType_);
    if (getNodeType() == ::nds::registry::node::NodeType::SERVICE)
    {
        m_serviceInfoFilter_.value().write(context.getServiceInfoFilter(), out);
    }
}

::nds::system::types::NdsSystemToken NodeSearchFilter::readSystemId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::NdsSystemToken(in, allocator);
}

::nds::system::types::NdsSystemToken NodeSearchFilter::readSystemId(NodeSearchFilter::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::system::types::NdsSystemToken(context.getSystemId(), in, allocator);
}
::nds::registry::node::NodeType NodeSearchFilter::readNodeType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::registry::node::NodeType>(in);
}

::nds::registry::node::NodeType NodeSearchFilter::readNodeType(NodeSearchFilter::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::registry::node::NodeType>(context.getNodeType(), in);
}
::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformationFilter> NodeSearchFilter::readServiceInfoFilter(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getNodeType() == ::nds::registry::node::NodeType::SERVICE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformationFilter>(::nds::registry::node::ServiceInformationFilter(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformationFilter>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformationFilter> NodeSearchFilter::readServiceInfoFilter(NodeSearchFilter::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getNodeType() == ::nds::registry::node::NodeType::SERVICE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformationFilter>(::nds::registry::node::ServiceInformationFilter(context.getServiceInfoFilter(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::registry::node::ServiceInformationFilter>(::zserio::NullOpt);
}

} // namespace node
} // namespace registry
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/registry/node/ServiceInformationFilter.h>

namespace nds
{
namespace registry
{
namespace node
{

ServiceInformationFilter::ServiceInformationFilter(const allocator_type& allocator) noexcept :
        m_moduleDefinition_(allocator),
        m_moduleService_(allocator),
        m_minServicePriority_(::nds::registry::node::ServicePriority()),
        m_maxServicePriority_(::nds::registry::node::ServicePriority())
{
}

ServiceInformationFilter::ServiceInformationFilter(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_moduleDefinition_(readModuleDefinition(in, allocator)),
        m_moduleService_(readModuleService(in, allocator)),
        m_minServicePriority_(readMinServicePriority(in)),
        m_maxServicePriority_(readMaxServicePriority(in))
{
}

ServiceInformationFilter::ServiceInformationFilter(ServiceInformationFilter::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_moduleDefinition_(readModuleDefinition(in, allocator)),
        m_moduleService_(readModuleService(in, allocator)),
        m_minServicePriority_(readMinServicePriority(context, in)),
        m_maxServicePriority_(readMaxServicePriority(context, in))
{
}

ServiceInformationFilter::ServiceInformationFilter(::zserio::PropagateAllocatorT,
        const ServiceInformationFilter& other, const allocator_type& allocator) :
        m_moduleDefinition_(::zserio::allocatorPropagatingCopy(other.m_moduleDefinition_, allocator)),
        m_moduleService_(::zserio::allocatorPropagatingCopy(other.m_moduleService_, allocator)),
        m_minServicePriority_(::zserio::allocatorPropagatingCopy(other.m_minServicePriority_, allocator)),
        m_maxServicePriority_(::zserio::allocatorPropagatingCopy(other.m_maxServicePriority_, allocator))
{
}

::nds::system::types::ModuleDefinition& ServiceInformationFilter::getModuleDefinition()
{
    return m_moduleDefinition_;
}

const ::nds::system::types::ModuleDefinition& ServiceInformationFilter::getModuleDefinition() const
{
    return m_moduleDefinition_;
}

void ServiceInformationFilter::setModuleDefinition(const ::nds::system::types::ModuleDefinition& moduleDefinition_)
{
    m_moduleDefinition_ = moduleDefinition_;
}

void ServiceInformationFilter::setModuleDefinition(::nds::system::types::ModuleDefinition&& moduleDefinition_)
{
    m_moduleDefinition_ = ::std::move(moduleDefinition_);
}

::nds::system::types::ModuleService& ServiceInformationFilter::getModuleService()
{
    return m_moduleService_;
}

const ::nds::system::types::ModuleService& ServiceInformationFilter::getModuleService() const
{
    return m_moduleService_;
}

void ServiceInformationFilter::setModuleService(const ::nds::system::types::ModuleService& moduleService_)
{
    m_moduleService_ = moduleService_;
}

void ServiceInformationFilter::setModuleService(::nds::system::types::ModuleService&& moduleService_)
{
    m_moduleService_ = ::std::move(moduleService_);
}

::nds::registry::node::ServicePriority ServiceInformationFilter::getMinServicePriority() const
{
    return m_minServicePriority_;
}

void ServiceInformationFilter::setMinServicePriority(::nds::registry::node::ServicePriority minServicePriority_)
{
    m_minServicePriority_ = minServicePriority_;
}

::nds::registry::node::ServicePriority ServiceInformationFilter::getMaxServicePriority() const
{
    return m_maxServicePriority_;
}

void ServiceInformationFilter::setMaxServicePriority(::nds::registry::node::ServicePriority maxServicePriority_)
{
    m_maxServicePriority_ = maxServicePriority_;
}

void ServiceInformationFilter::initPackingContext(ServiceInformationFilter::ZserioPackingContext& context) const
{
    context.getMinServicePriority().init<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(m_minServicePriority_);
    context.getMaxServicePriority().init<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(m_maxServicePriority_);
}

size_t ServiceInformationFilter::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_moduleDefinition_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleService_);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t ServiceInformationFilter::bitSizeOf(ServiceInformationFilter::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_moduleDefinition_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleService_);
    endBitPosition += context.getMinServicePriority().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(m_minServicePriority_);
    endBitPosition += context.getMaxServicePriority().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(m_maxServicePriority_);

    return endBitPosition - bitPosition;
}

size_t ServiceInformationFilter::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_moduleDefinition_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleService_);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t ServiceInformationFilter::initializeOffsets(ServiceInformationFilter::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_moduleDefinition_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleService_);
    endBitPosition += context.getMinServicePriority().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(m_minServicePriority_);
    endBitPosition += context.getMaxServicePriority().bitSizeOf<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(m_maxServicePriority_);

    return endBitPosition;
}

bool ServiceInformationFilter::operator==(const ServiceInformationFilter& other) const
{
    if (this != &other)
    {
        return
                (m_moduleDefinition_ == other.m_moduleDefinition_) &&
                (m_moduleService_ == other.m_moduleService_) &&
                (m_minServicePriority_ == other.m_minServicePriority_) &&
                (m_maxServicePriority_ == other.m_maxServicePriority_);
    }

    return true;
}

uint32_t ServiceInformationFilter::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_moduleDefinition_);
    result = ::zserio::calcHashCode(result, m_moduleService_);
    result = ::zserio::calcHashCode(result, m_minServicePriority_);
    result = ::zserio::calcHashCode(result, m_maxServicePriority_);

    return result;
}

void ServiceInformationFilter::write(::zserio::BitStreamWriter& out) const
{
    m_moduleDefinition_.write(out);
    out.writeString(m_moduleService_);
    out.writeBits(m_minServicePriority_, UINT8_C(8));
    out.writeBits(m_maxServicePriority_, UINT8_C(8));
}

void ServiceInformationFilter::write(ServiceInformationFilter::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_moduleDefinition_.write(out);
    out.writeString(m_moduleService_);
    context.getMinServicePriority().write<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(out, m_minServicePriority_);
    context.getMaxServicePriority().write<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(out, m_maxServicePriority_);
}

::nds::system::types::ModuleDefinition ServiceInformationFilter::readModuleDefinition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::system::types::ModuleDefinition(in, allocator);
}
::nds::system::types::ModuleService ServiceInformationFilter::readModuleService(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleService>(in.readString(allocator));
}
::nds::registry::node::ServicePriority ServiceInformationFilter::readMinServicePriority(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::registry::node::ServicePriority>(in.readBits(UINT8_C(8)));
}

::nds::registry::node::ServicePriority ServiceInformationFilter::readMinServicePriority(ServiceInformationFilter::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getMinServicePriority().read<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(in);
}
::nds::registry::node::ServicePriority ServiceInformationFilter::readMaxServicePriority(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::registry::node::ServicePriority>(in.readBits(UINT8_C(8)));
}

::nds::registry::node::ServicePriority ServiceInformationFilter::readMaxServicePriority(ServiceInformationFilter::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getMaxServicePriority().read<::zserio::StdIntArrayTraits<::nds::registry::node::ServicePriority>>(in);
}

} // namespace node
} // namespace registry
} // namespace nds
