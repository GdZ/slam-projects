/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/SqliteException.h>

#include <nds/registry/filestore/RegistryStore.h>

namespace nds
{
namespace registry
{
namespace filestore
{

RegistryStore::RegistryStore(const ::zserio::string<>& dbFileName, const TRelocationMap& tableToDbFileNameRelocationMap,
        const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_tableToAttachedDbNameRelocationMap(allocator)
{
    sqlite3 *internalConnection = nullptr;
    const int sqliteOpenMode = SQLITE_OPEN_URI | SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE;
    const int result = sqlite3_open_v2(dbFileName.c_str(), &internalConnection, sqliteOpenMode, nullptr);
    m_db.reset(internalConnection, ::zserio::SqliteConnection::INTERNAL_CONNECTION);
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryStore::open(): can't open DB ") << dbFileName.c_str() << ": " <<
                ::zserio::SqliteErrorCode(result);
    }

    ::std::map<::zserio::StringView, ::zserio::string<>> dbFileNameToAttachedDbNameMap(
            get_allocator_ref());
    for (const auto& relocation : tableToDbFileNameRelocationMap)
    {
        const ::zserio::string<>& tableName = relocation.first;
        const ::zserio::string<>& fileName = relocation.second;
        auto attachedDbIt = dbFileNameToAttachedDbNameMap.find(fileName);
        if (attachedDbIt == dbFileNameToAttachedDbNameMap.end())
        {
            ::zserio::string<> attachedDbName =
                    ::zserio::stringViewToString(databaseName(), get_allocator_ref()) + "_" + tableName;
            attachDatabase(fileName, attachedDbName);
            attachedDbIt = dbFileNameToAttachedDbNameMap.emplace(fileName, ::std::move(attachedDbName)).first;
        }
        m_tableToAttachedDbNameRelocationMap.emplace(
                ::zserio::string<>(tableName, get_allocator_ref()),
                ::zserio::string<>(attachedDbIt->second, get_allocator_ref()));
    }

    initTables();
}

RegistryStore::RegistryStore(const ::zserio::string<>& dbFileName, const allocator_type& allocator) :
        RegistryStore(dbFileName, TRelocationMap(allocator), allocator)
{}

RegistryStore::RegistryStore(sqlite3* externalConnection, const TRelocationMap& tableToAttachedDbNameRelocationMap,
        const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_tableToAttachedDbNameRelocationMap(tableToAttachedDbNameRelocationMap, allocator)
{
    m_db.reset(externalConnection, ::zserio::SqliteConnection::EXTERNAL_CONNECTION);
    initTables();
}

RegistryStore::RegistryStore(sqlite3* externalConnection, const allocator_type& allocator) :
        RegistryStore(externalConnection, TRelocationMap(allocator), allocator)
{}

RegistryStore::~RegistryStore()
{
    detachDatabases();
}

::zserio::SqliteConnection& RegistryStore::connection() noexcept
{
    return m_db;
}

::nds::registry::filestore::RegistryNodeTable& RegistryStore::getNodeTable() noexcept
{
    return *m_nodeTable_;
}

void RegistryStore::createSchema()
{
    const bool wasTransactionStarted = m_db.startTransaction();

    m_nodeTable_->createTable();

    m_db.endTransaction(wasTransactionStarted);
}

void RegistryStore::createSchema(const ::std::set<::zserio::string<>>&)
{
    createSchema();
}

void RegistryStore::deleteSchema()
{
    const bool wasTransactionStarted = m_db.startTransaction();

    m_nodeTable_->deleteTable();

    m_db.endTransaction(wasTransactionStarted);
}

::zserio::StringView RegistryStore::databaseName() noexcept
{
    return ::zserio::makeStringView("RegistryStore");
}

::zserio::StringView RegistryStore::tableNameNodeTable() noexcept
{
    return ::zserio::makeStringView("nodeTable");
}

const ::std::array<::zserio::StringView, 1>& RegistryStore::tableNames() noexcept
{
    static const ::std::array<::zserio::StringView, 1> names =
    {
        tableNameNodeTable()
    };

    return names;
}

void RegistryStore::initTables()
{
    static ::zserio::StringView EMPTY_STR = ::zserio::StringView();
    auto relocationIt = m_tableToAttachedDbNameRelocationMap.find(
            ::zserio::stringViewToString(tableNameNodeTable(), get_allocator_ref()));
    m_nodeTable_ = ::zserio::allocate_unique<::nds::registry::filestore::RegistryNodeTable>(
            get_allocator_ref(), this->m_db, tableNameNodeTable(),
            relocationIt != m_tableToAttachedDbNameRelocationMap.end() ? relocationIt->second : EMPTY_STR,
            get_allocator_ref());
}

void RegistryStore::attachDatabase(::zserio::StringView fileName, ::zserio::StringView attachedDbName)
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "ATTACH DATABASE '";
    sqlQuery += fileName;
    sqlQuery += "' AS ";
    sqlQuery += attachedDbName;

    m_db.executeUpdate(sqlQuery);

    m_attachedDbList.push_back(::zserio::stringViewToString(attachedDbName, get_allocator_ref()));
}

void RegistryStore::detachDatabases()
{
    for (const auto& attachedDb : m_attachedDbList)
    {
        try
        {
            ::zserio::string<> sqlQuery(get_allocator_ref());
            sqlQuery += "DETACH DATABASE ";
            sqlQuery += attachedDb;
            m_db.executeUpdate(sqlQuery);
        }
        catch (const ::zserio::SqliteException&)
        {
            // ignore since we have no logging sub-system and we need to prevent exception in SQLDatabase destructor
        }
    }
    m_attachedDbList.clear();
}

} // namespace filestore
} // namespace registry
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/CppRuntimeException.h>
#include <zserio/SqliteException.h>
#include <zserio/BitStreamReader.h>
#include <algorithm>
#include <zserio/BitFieldUtil.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/ArrayTraits.h>
#include <zserio/StringView.h>
#include <zserio/Types.h>

#include <nds/registry/filestore/RegistryNodeTable.h>

namespace nds
{
namespace registry
{
namespace filestore
{

RegistryNodeTable::RegistryNodeTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        ::zserio::StringView attachedDbName, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_db(db), m_name(tableName), m_attachedDbName(attachedDbName)
{
}

RegistryNodeTable::RegistryNodeTable(::zserio::SqliteConnection& db, ::zserio::StringView tableName,
        const allocator_type& allocator) :
        RegistryNodeTable(db, tableName, ::zserio::StringView(), allocator)
{
}

void RegistryNodeTable::createTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    appendCreateTableToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

void RegistryNodeTable::deleteTable()
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "DROP TABLE ";
    appendTableNameToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery);
}

RegistryNodeTable::Reader RegistryNodeTable::createReader(::zserio::StringView condition) const
{
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery +=
            "SELECT "
            "systemId, "
            "nodeToken, "
            "legalInfo, "
            "type, "
            "connectionCosts, "
            "spatialCoverage, "
            "protocolType, "
            "protocolDetailsUri, "
            "nodeName, "
            "hostName, "
            "port, "
            "serviceInformation, "
            "registryDefinition"
            " FROM ";
    appendTableNameToQuery(sqlQuery);
    if (!condition.empty())
    {
        sqlQuery += " WHERE ";
        sqlQuery += condition;
    }

    return Reader(m_db, sqlQuery, get_allocator_ref());
}

RegistryNodeTable::Reader::Reader(::zserio::SqliteConnection& db, const ::zserio::string<>& sqlQuery, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_stmt(db.prepareStatement(sqlQuery))
{
    makeStep();
}

bool RegistryNodeTable::Reader::hasNext() const noexcept
{
    return m_lastResult == SQLITE_ROW;
}

RegistryNodeTable::Row RegistryNodeTable::Reader::next()
{
    if (!hasNext())
    {
        throw ::zserio::SqliteException("Table::Reader::next: next row is not available: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }

    Row row;

    // field systemId
    if (sqlite3_column_type(m_stmt.get(), 0) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 0);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 0);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::system::types::NdsSystemToken blob(reader, get_allocator_ref());
        row.setSystemId(::std::move(blob));
    }

    // field nodeToken
    if (sqlite3_column_type(m_stmt.get(), 1) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 1);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 1);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::system::types::NdsNodeToken blob(reader, get_allocator_ref());
        row.setNodeToken(::std::move(blob));
    }

    // field legalInfo
    if (sqlite3_column_type(m_stmt.get(), 2) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 2);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 2);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::system::types::NdsNodeLegalInfo blob(reader, get_allocator_ref());
        row.setLegalInfo(::std::move(blob));
    }

    // field type
    if (sqlite3_column_type(m_stmt.get(), 3) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 3);
        const ::nds::registry::node::NodeType enumValue = ::zserio::valueToEnum<::nds::registry::node::NodeType>(static_cast<uint8_t>(intValue));
        row.setType(enumValue);
    }

    // field connectionCosts
    if (sqlite3_column_type(m_stmt.get(), 4) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 4);
        row.setConnectionCosts(static_cast<::nds::registry::node::ConnectionCosts>(intValue));
    }

    // field spatialCoverage
    if (sqlite3_column_type(m_stmt.get(), 5) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 5);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 5);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::core::geometry::SpatialExtent blob(reader, get_allocator_ref());
        row.setSpatialCoverage(::std::move(blob));
    }

    // field protocolType
    if (sqlite3_column_type(m_stmt.get(), 6) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 6);
        row.setProtocolType(static_cast<::nds::registry::node::ProtocolType>(intValue));
    }

    // field protocolDetailsUri
    if (sqlite3_column_type(m_stmt.get(), 7) != SQLITE_NULL)
    {
        const unsigned char* textValue = sqlite3_column_text(m_stmt.get(), 7);
        row.setProtocolDetailsUri(::zserio::string<>(
                reinterpret_cast<const char*>(textValue), get_allocator_ref()));
    }

    // field nodeName
    if (sqlite3_column_type(m_stmt.get(), 8) != SQLITE_NULL)
    {
        const unsigned char* textValue = sqlite3_column_text(m_stmt.get(), 8);
        row.setNodeName(::zserio::string<>(
                reinterpret_cast<const char*>(textValue), get_allocator_ref()));
    }

    // field hostName
    if (sqlite3_column_type(m_stmt.get(), 9) != SQLITE_NULL)
    {
        const unsigned char* textValue = sqlite3_column_text(m_stmt.get(), 9);
        row.setHostName(::zserio::string<>(
                reinterpret_cast<const char*>(textValue), get_allocator_ref()));
    }

    // field port
    if (sqlite3_column_type(m_stmt.get(), 10) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 10);
        row.setPort(static_cast<uint16_t>(intValue));
    }

    // field serviceInformation
    if (sqlite3_column_type(m_stmt.get(), 11) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 11);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 11);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::registry::node::ServiceInformation blob(reader, get_allocator_ref());
        row.setServiceInformation(::std::move(blob));
    }

    // field registryDefinition
    if (sqlite3_column_type(m_stmt.get(), 12) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 12);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 12);
        ::zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        ::nds::system::types::ModuleDefinition blob(reader, get_allocator_ref());
        row.setRegistryDefinition(::std::move(blob));
    }

    makeStep();

    return row;
}

void RegistryNodeTable::Reader::makeStep()
{
    m_lastResult = sqlite3_step(m_stmt.get());
    if (m_lastResult != SQLITE_ROW && m_lastResult != SQLITE_DONE)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::Read: sqlite3_step() failed: ") <<
                ::zserio::SqliteErrorCode(m_lastResult);
    }
}

void RegistryNodeTable::write(::zserio::Span<Row> rows)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "INSERT INTO ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            "("
            "systemId, "
            "nodeToken, "
            "legalInfo, "
            "type, "
            "connectionCosts, "
            "spatialCoverage, "
            "protocolType, "
            "protocolDetailsUri, "
            "nodeName, "
            "hostName, "
            "port, "
            "serviceInformation, "
            "registryDefinition"
            ") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";

    // write rows
    const bool wasTransactionStarted = m_db.startTransaction();
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));

    for (Row& row : rows)
    {
        writeRow(row, *statement);
        int result = sqlite3_step(statement.get());
        if (result != SQLITE_DONE)
        {
            throw ::zserio::SqliteException("Write: sqlite3_step() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }

        sqlite3_clear_bindings(statement.get());
        result = sqlite3_reset(statement.get());
        if (result != SQLITE_OK)
        {
            throw ::zserio::SqliteException("Write: sqlite3_reset() failed: ") <<
                    ::zserio::SqliteErrorCode(result);
        }
    }

    m_db.endTransaction(wasTransactionStarted);
}

void RegistryNodeTable::update(Row& row, ::zserio::StringView whereCondition)
{
    // assemble sql query
    ::zserio::string<> sqlQuery(get_allocator_ref());
    sqlQuery += "UPDATE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            " SET"
            " systemId=?,"
            " nodeToken=?,"
            " legalInfo=?,"
            " type=?,"
            " connectionCosts=?,"
            " spatialCoverage=?,"
            " protocolType=?,"
            " protocolDetailsUri=?,"
            " nodeName=?,"
            " hostName=?,"
            " port=?,"
            " serviceInformation=?,"
            " registryDefinition=?"
            " WHERE ";
    sqlQuery += whereCondition;

    // update row
    ::std::unique_ptr<sqlite3_stmt, ::zserio::SqliteFinalizer> statement(m_db.prepareStatement(sqlQuery));
    writeRow(row, *statement);
    const int result = sqlite3_step(statement.get());
    if (result != SQLITE_DONE)
        throw ::zserio::SqliteException("Update: sqlite3_step() failed: ") << ::zserio::SqliteErrorCode(result);
}

void RegistryNodeTable::writeRow(Row& row, sqlite3_stmt& statement)
{
    row.initializeChildren();

    int result = SQLITE_ERROR;

    // field systemId
    if (!row.isSystemIdSet())
    {
        result = sqlite3_bind_null(&statement, 1);
    }
    else
    {
        const ::nds::system::types::NdsSystemToken& blob = row.getSystemId();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 1, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field systemId failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field nodeToken
    if (!row.isNodeTokenSet())
    {
        result = sqlite3_bind_null(&statement, 2);
    }
    else
    {
        const ::nds::system::types::NdsNodeToken& blob = row.getNodeToken();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 2, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field nodeToken failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field legalInfo
    if (!row.isLegalInfoSet())
    {
        result = sqlite3_bind_null(&statement, 3);
    }
    else
    {
        const ::nds::system::types::NdsNodeLegalInfo& blob = row.getLegalInfo();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 3, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field legalInfo failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field type
    if (!row.isTypeSet())
    {
        result = sqlite3_bind_null(&statement, 4);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(row.getType());
        result = sqlite3_bind_int64(&statement, 4, intValue);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field type failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field connectionCosts
    if (!row.isConnectionCostsSet())
    {
        result = sqlite3_bind_null(&statement, 5);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(row.getConnectionCosts());
        result = sqlite3_bind_int64(&statement, 5, intValue);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field connectionCosts failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field spatialCoverage
    if (!row.isSpatialCoverageSet())
    {
        result = sqlite3_bind_null(&statement, 6);
    }
    else
    {
        const ::nds::core::geometry::SpatialExtent& blob = row.getSpatialCoverage();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 6, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field spatialCoverage failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field protocolType
    if (!row.isProtocolTypeSet())
    {
        result = sqlite3_bind_null(&statement, 7);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(row.getProtocolType());
        result = sqlite3_bind_int64(&statement, 7, intValue);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field protocolType failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field protocolDetailsUri
    if (!row.isProtocolDetailsUriSet())
    {
        result = sqlite3_bind_null(&statement, 8);
    }
    else
    {
        const ::zserio::string<>& stringValue = row.getProtocolDetailsUri();
        result = sqlite3_bind_text(&statement, 8, stringValue.c_str(), -1, SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field protocolDetailsUri failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field nodeName
    if (!row.isNodeNameSet())
    {
        result = sqlite3_bind_null(&statement, 9);
    }
    else
    {
        const ::zserio::string<>& stringValue = row.getNodeName();
        result = sqlite3_bind_text(&statement, 9, stringValue.c_str(), -1, SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field nodeName failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field hostName
    if (!row.isHostNameSet())
    {
        result = sqlite3_bind_null(&statement, 10);
    }
    else
    {
        const ::zserio::string<>& stringValue = row.getHostName();
        result = sqlite3_bind_text(&statement, 10, stringValue.c_str(), -1, SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field hostName failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field port
    if (!row.isPortSet())
    {
        result = sqlite3_bind_null(&statement, 11);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(row.getPort());
        result = sqlite3_bind_int64(&statement, 11, intValue);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field port failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field serviceInformation
    if (!row.isServiceInformationSet())
    {
        result = sqlite3_bind_null(&statement, 12);
    }
    else
    {
        const ::nds::registry::node::ServiceInformation& blob = row.getServiceInformation();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 12, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field serviceInformation failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }

    // field registryDefinition
    if (!row.isRegistryDefinitionSet())
    {
        result = sqlite3_bind_null(&statement, 13);
    }
    else
    {
        const ::nds::system::types::ModuleDefinition& blob = row.getRegistryDefinition();
        ::zserio::BitBuffer bitBuffer(blob.bitSizeOf(), get_allocator_ref());
        ::zserio::BitStreamWriter writer(bitBuffer);
        blob.write(writer);
        result = sqlite3_bind_blob(&statement, 13, bitBuffer.getBuffer(),
                static_cast<int>(bitBuffer.getByteSize()), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
    {
        throw ::zserio::SqliteException("RegistryNodeTable::WriteRow: sqlite3_bind() for field registryDefinition failed: ") <<
                ::zserio::SqliteErrorCode(result);
    }
}

void RegistryNodeTable::appendCreateTableToQuery(::zserio::string<>& sqlQuery) const
{
    sqlQuery += "CREATE TABLE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery += '(';
    sqlQuery += "systemId BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", nodeToken BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", legalInfo BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", type INTEGER";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", connectionCosts INTEGER";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", spatialCoverage BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", protocolType INTEGER";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", protocolDetailsUri TEXT";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", nodeName TEXT";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", hostName TEXT";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", port INTEGER";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NOT NULL");
    sqlQuery += ", serviceInformation BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NULL");
    sqlQuery += ", registryDefinition BLOB";
    sqlQuery += ' ';
    sqlQuery += ::zserio::makeStringView("NULL");
    sqlQuery += ", ";
    sqlQuery += ::zserio::makeStringView("primary key (systemId, nodeToken)");
    sqlQuery += ')';
}

void RegistryNodeTable::appendTableNameToQuery(::zserio::string<>& sqlQuery) const
{
    if (!m_attachedDbName.empty())
    {
        sqlQuery += m_attachedDbName;
        sqlQuery += '.';
    }
    sqlQuery += m_name;
}

::nds::system::types::NdsSystemToken& RegistryNodeTable::Row::getSystemId()
{
    return m_systemId_.value();
}

const ::nds::system::types::NdsSystemToken& RegistryNodeTable::Row::getSystemId() const
{
    return m_systemId_.value();
}

void RegistryNodeTable::Row::setSystemId(const ::nds::system::types::NdsSystemToken& systemId_)
{
    m_systemId_ = systemId_;
}

void RegistryNodeTable::Row::setSystemId(::nds::system::types::NdsSystemToken&& systemId_)
{
    m_systemId_ = ::std::move(systemId_);
}

void RegistryNodeTable::Row::resetSystemId()
{
    m_systemId_.reset();
}

bool RegistryNodeTable::Row::isSystemIdSet() const
{
    return m_systemId_.hasValue();
}

::nds::system::types::NdsNodeToken& RegistryNodeTable::Row::getNodeToken()
{
    return m_nodeToken_.value();
}

const ::nds::system::types::NdsNodeToken& RegistryNodeTable::Row::getNodeToken() const
{
    return m_nodeToken_.value();
}

void RegistryNodeTable::Row::setNodeToken(const ::nds::system::types::NdsNodeToken& nodeToken_)
{
    m_nodeToken_ = nodeToken_;
}

void RegistryNodeTable::Row::setNodeToken(::nds::system::types::NdsNodeToken&& nodeToken_)
{
    m_nodeToken_ = ::std::move(nodeToken_);
}

void RegistryNodeTable::Row::resetNodeToken()
{
    m_nodeToken_.reset();
}

bool RegistryNodeTable::Row::isNodeTokenSet() const
{
    return m_nodeToken_.hasValue();
}

::nds::system::types::NdsNodeLegalInfo& RegistryNodeTable::Row::getLegalInfo()
{
    return m_legalInfo_.value();
}

const ::nds::system::types::NdsNodeLegalInfo& RegistryNodeTable::Row::getLegalInfo() const
{
    return m_legalInfo_.value();
}

void RegistryNodeTable::Row::setLegalInfo(const ::nds::system::types::NdsNodeLegalInfo& legalInfo_)
{
    m_legalInfo_ = legalInfo_;
}

void RegistryNodeTable::Row::setLegalInfo(::nds::system::types::NdsNodeLegalInfo&& legalInfo_)
{
    m_legalInfo_ = ::std::move(legalInfo_);
}

void RegistryNodeTable::Row::resetLegalInfo()
{
    m_legalInfo_.reset();
}

bool RegistryNodeTable::Row::isLegalInfoSet() const
{
    return m_legalInfo_.hasValue();
}

::nds::registry::node::NodeType RegistryNodeTable::Row::getType() const
{
    return m_type_.value();
}

void RegistryNodeTable::Row::setType(::nds::registry::node::NodeType type_)
{
    m_type_ = type_;
}

void RegistryNodeTable::Row::resetType()
{
    m_type_.reset();
}

bool RegistryNodeTable::Row::isTypeSet() const
{
    return m_type_.hasValue();
}

::nds::registry::node::ConnectionCosts RegistryNodeTable::Row::getConnectionCosts() const
{
    return m_connectionCosts_.value();
}

void RegistryNodeTable::Row::setConnectionCosts(::nds::registry::node::ConnectionCosts connectionCosts_)
{
    m_connectionCosts_ = connectionCosts_;
}

void RegistryNodeTable::Row::resetConnectionCosts()
{
    m_connectionCosts_.reset();
}

bool RegistryNodeTable::Row::isConnectionCostsSet() const
{
    return m_connectionCosts_.hasValue();
}

::nds::core::geometry::SpatialExtent& RegistryNodeTable::Row::getSpatialCoverage()
{
    return m_spatialCoverage_.value();
}

const ::nds::core::geometry::SpatialExtent& RegistryNodeTable::Row::getSpatialCoverage() const
{
    return m_spatialCoverage_.value();
}

void RegistryNodeTable::Row::setSpatialCoverage(const ::nds::core::geometry::SpatialExtent& spatialCoverage_)
{
    m_spatialCoverage_ = spatialCoverage_;
}

void RegistryNodeTable::Row::setSpatialCoverage(::nds::core::geometry::SpatialExtent&& spatialCoverage_)
{
    m_spatialCoverage_ = ::std::move(spatialCoverage_);
}

void RegistryNodeTable::Row::resetSpatialCoverage()
{
    m_spatialCoverage_.reset();
}

bool RegistryNodeTable::Row::isSpatialCoverageSet() const
{
    return m_spatialCoverage_.hasValue();
}

::nds::registry::node::ProtocolType RegistryNodeTable::Row::getProtocolType() const
{
    return m_protocolType_.value();
}

void RegistryNodeTable::Row::setProtocolType(::nds::registry::node::ProtocolType protocolType_)
{
    m_protocolType_ = protocolType_;
}

void RegistryNodeTable::Row::resetProtocolType()
{
    m_protocolType_.reset();
}

bool RegistryNodeTable::Row::isProtocolTypeSet() const
{
    return m_protocolType_.hasValue();
}

::zserio::string<>& RegistryNodeTable::Row::getProtocolDetailsUri()
{
    return m_protocolDetailsUri_.value();
}

const ::zserio::string<>& RegistryNodeTable::Row::getProtocolDetailsUri() const
{
    return m_protocolDetailsUri_.value();
}

void RegistryNodeTable::Row::setProtocolDetailsUri(const ::zserio::string<>& protocolDetailsUri_)
{
    m_protocolDetailsUri_ = protocolDetailsUri_;
}

void RegistryNodeTable::Row::setProtocolDetailsUri(::zserio::string<>&& protocolDetailsUri_)
{
    m_protocolDetailsUri_ = ::std::move(protocolDetailsUri_);
}

void RegistryNodeTable::Row::resetProtocolDetailsUri()
{
    m_protocolDetailsUri_.reset();
}

bool RegistryNodeTable::Row::isProtocolDetailsUriSet() const
{
    return m_protocolDetailsUri_.hasValue();
}

::zserio::string<>& RegistryNodeTable::Row::getNodeName()
{
    return m_nodeName_.value();
}

const ::zserio::string<>& RegistryNodeTable::Row::getNodeName() const
{
    return m_nodeName_.value();
}

void RegistryNodeTable::Row::setNodeName(const ::zserio::string<>& nodeName_)
{
    m_nodeName_ = nodeName_;
}

void RegistryNodeTable::Row::setNodeName(::zserio::string<>&& nodeName_)
{
    m_nodeName_ = ::std::move(nodeName_);
}

void RegistryNodeTable::Row::resetNodeName()
{
    m_nodeName_.reset();
}

bool RegistryNodeTable::Row::isNodeNameSet() const
{
    return m_nodeName_.hasValue();
}

::zserio::string<>& RegistryNodeTable::Row::getHostName()
{
    return m_hostName_.value();
}

const ::zserio::string<>& RegistryNodeTable::Row::getHostName() const
{
    return m_hostName_.value();
}

void RegistryNodeTable::Row::setHostName(const ::zserio::string<>& hostName_)
{
    m_hostName_ = hostName_;
}

void RegistryNodeTable::Row::setHostName(::zserio::string<>&& hostName_)
{
    m_hostName_ = ::std::move(hostName_);
}

void RegistryNodeTable::Row::resetHostName()
{
    m_hostName_.reset();
}

bool RegistryNodeTable::Row::isHostNameSet() const
{
    return m_hostName_.hasValue();
}

uint16_t RegistryNodeTable::Row::getPort() const
{
    return m_port_.value();
}

void RegistryNodeTable::Row::setPort(uint16_t port_)
{
    m_port_ = port_;
}

void RegistryNodeTable::Row::resetPort()
{
    m_port_.reset();
}

bool RegistryNodeTable::Row::isPortSet() const
{
    return m_port_.hasValue();
}

::nds::registry::node::ServiceInformation& RegistryNodeTable::Row::getServiceInformation()
{
    return m_serviceInformation_.value();
}

const ::nds::registry::node::ServiceInformation& RegistryNodeTable::Row::getServiceInformation() const
{
    return m_serviceInformation_.value();
}

void RegistryNodeTable::Row::setServiceInformation(const ::nds::registry::node::ServiceInformation& serviceInformation_)
{
    m_serviceInformation_ = serviceInformation_;
}

void RegistryNodeTable::Row::setServiceInformation(::nds::registry::node::ServiceInformation&& serviceInformation_)
{
    m_serviceInformation_ = ::std::move(serviceInformation_);
}

void RegistryNodeTable::Row::resetServiceInformation()
{
    m_serviceInformation_.reset();
}

bool RegistryNodeTable::Row::isServiceInformationSet() const
{
    return m_serviceInformation_.hasValue();
}

::nds::system::types::ModuleDefinition& RegistryNodeTable::Row::getRegistryDefinition()
{
    return m_registryDefinition_.value();
}

const ::nds::system::types::ModuleDefinition& RegistryNodeTable::Row::getRegistryDefinition() const
{
    return m_registryDefinition_.value();
}

void RegistryNodeTable::Row::setRegistryDefinition(const ::nds::system::types::ModuleDefinition& registryDefinition_)
{
    m_registryDefinition_ = registryDefinition_;
}

void RegistryNodeTable::Row::setRegistryDefinition(::nds::system::types::ModuleDefinition&& registryDefinition_)
{
    m_registryDefinition_ = ::std::move(registryDefinition_);
}

void RegistryNodeTable::Row::resetRegistryDefinition()
{
    m_registryDefinition_.reset();
}

bool RegistryNodeTable::Row::isRegistryDefinitionSet() const
{
    return m_registryDefinition_.hasValue();
}

void RegistryNodeTable::Row::initializeChildren()
{
    if (m_spatialCoverage_)
    {
        m_spatialCoverage_->initializeChildren();
    }
}

} // namespace filestore
} // namespace registry
} // namespace nds
