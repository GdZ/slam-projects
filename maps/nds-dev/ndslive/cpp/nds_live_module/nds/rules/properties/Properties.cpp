/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/properties/PropertyType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PropertyType enumeration.
constexpr ::std::array<const char*, 10> EnumTraits<::nds::rules::properties::PropertyType>::names;
constexpr ::std::array<::nds::rules::properties::PropertyType, 10> EnumTraits<::nds::rules::properties::PropertyType>::values;
constexpr const char* EnumTraits<::nds::rules::properties::PropertyType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::properties::PropertyType value)
{
    switch (value)
    {
    case ::nds::rules::properties::PropertyType::CORE:
        return 0;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        return 1;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        return 2;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        return 3;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        return 4;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        return 5;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        return 6;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        return 7;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        return 8;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        return 9;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PropertyType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::properties::PropertyType>::type>(value) << "!";
    }
}

template <>
::nds::rules::properties::PropertyType valueToEnum(
        typename ::std::underlying_type<::nds::rules::properties::PropertyType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
        return static_cast<::nds::rules::properties::PropertyType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PropertyType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::properties::PropertyType>(::nds::rules::properties::PropertyType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::properties::PropertyType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::properties::PropertyType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::properties::PropertyType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::properties::PropertyType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::properties::PropertyType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::properties::PropertyType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::properties::PropertyType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::properties::PropertyType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::properties::PropertyType>(
            static_cast<typename ::std::underlying_type<::nds::rules::properties::PropertyType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::properties::PropertyType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::properties::PropertyType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::properties::PropertyType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::properties::PropertyType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::properties::PropertyType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::properties::PropertyType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/rules/properties/RulesPropertyType.h>
#include <nds/rules/properties/PropertyType.h>

namespace nds
{
namespace rules
{
namespace properties
{

RulesPropertyType::RulesPropertyType(const allocator_type&) noexcept :
        m_type_(::nds::rules::properties::PropertyType()),
        m_coreType_(::zserio::NullOpt)
{
}

RulesPropertyType::RulesPropertyType(::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(in)),
        m_coreType_(readCoreType(in))
{
}

RulesPropertyType::RulesPropertyType(RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(context, in)),
        m_coreType_(readCoreType(context, in))
{
}

RulesPropertyType::RulesPropertyType(::zserio::PropagateAllocatorT,
        const RulesPropertyType& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_coreType_(::zserio::allocatorPropagatingCopy(other.m_coreType_, allocator))
{
}

::nds::rules::properties::PropertyType RulesPropertyType::getType() const
{
    return m_type_;
}

void RulesPropertyType::setType(::nds::rules::properties::PropertyType type_)
{
    m_type_ = type_;
}

::nds::core::properties::CorePropertyType RulesPropertyType::getCoreType() const
{
    return m_coreType_.value();
}

void RulesPropertyType::setCoreType(::nds::core::properties::CorePropertyType coreType_)
{
    m_coreType_ = coreType_;
}

bool RulesPropertyType::isCoreTypeUsed() const
{
    return (getType() == ::nds::rules::properties::PropertyType::CORE);
}

bool RulesPropertyType::isCoreTypeSet() const
{
    return m_coreType_.hasValue();
}

void RulesPropertyType::resetCoreType()
{
    m_coreType_.reset();
}

void RulesPropertyType::initPackingContext(RulesPropertyType::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        ::zserio::initPackingContext(context.getCoreType(), m_coreType_.value());
    }
}

size_t RulesPropertyType::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition += ::zserio::bitSizeOf(m_coreType_.value());
    }

    return endBitPosition - bitPosition;
}

size_t RulesPropertyType::bitSizeOf(RulesPropertyType::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition += ::zserio::bitSizeOf(context.getCoreType(), m_coreType_.value());
    }

    return endBitPosition - bitPosition;
}

size_t RulesPropertyType::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_coreType_.value());
    }

    return endBitPosition;
}

size_t RulesPropertyType::initializeOffsets(RulesPropertyType::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition = ::zserio::initializeOffsets(context.getCoreType(), endBitPosition,
        m_coreType_.value());
    }

    return endBitPosition;
}

bool RulesPropertyType::operator==(const RulesPropertyType& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isCoreTypeUsed() ? !other.isCoreTypeUsed() : (m_coreType_ == other.m_coreType_));
    }

    return true;
}

uint32_t RulesPropertyType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isCoreTypeUsed())
        result = ::zserio::calcHashCode(result, m_coreType_);

    return result;
}

void RulesPropertyType::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    if (getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        ::zserio::write(out, m_coreType_.value());
    }
}

void RulesPropertyType::write(RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    if (getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        ::zserio::write(context.getCoreType(), out, m_coreType_.value());
    }
}

::nds::rules::properties::PropertyType RulesPropertyType::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::properties::PropertyType>(in);
}

::nds::rules::properties::PropertyType RulesPropertyType::readType(RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::properties::PropertyType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyType> RulesPropertyType::readCoreType(::zserio::BitStreamReader& in)
{
    if (getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyType>(::zserio::read<::nds::core::properties::CorePropertyType>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyType>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyType> RulesPropertyType::readCoreType(RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyType>(::zserio::read<::nds::core::properties::CorePropertyType>(context.getCoreType(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyType>(::zserio::NullOpt);
}

} // namespace properties
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/rules/properties/RulesPropertyValue.h>
#include <nds/rules/properties/PropertyType.h>

namespace nds
{
namespace rules
{
namespace properties
{

RulesPropertyValue::RulesPropertyValue(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_value_(::zserio::NullOpt),
        m_coreValue_(::zserio::NullOpt)
{
}

RulesPropertyValue::RulesPropertyValue(::zserio::BitStreamReader& in,
        ::nds::rules::properties::RulesPropertyType& type_, const allocator_type& allocator) :
        m_type_(&type_),
        m_isInitialized(true),
        m_value_(readValue(in, allocator)),
        m_coreValue_(readCoreValue(in, allocator))
{
}

RulesPropertyValue::RulesPropertyValue(RulesPropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::properties::RulesPropertyType& type_, const allocator_type& allocator) :
        m_type_(&type_),
        m_isInitialized(true),
        m_value_(readValue(context, in, allocator)),
        m_coreValue_(readCoreValue(context, in, allocator))
{
}

RulesPropertyValue::RulesPropertyValue(const RulesPropertyValue& other) :
        m_value_(other.m_value_),
        m_coreValue_(other.m_coreValue_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_type_));
    else
        m_isInitialized = false;
}

RulesPropertyValue& RulesPropertyValue::operator=(const RulesPropertyValue& other)
{
    m_value_ = other.m_value_;
    m_coreValue_ = other.m_coreValue_;
    if (other.m_isInitialized)
        initialize(*(other.m_type_));
    else
        m_isInitialized = false;

    return *this;
}

RulesPropertyValue::RulesPropertyValue(RulesPropertyValue&& other) :
        m_value_(::std::move(other.m_value_)),
        m_coreValue_(::std::move(other.m_coreValue_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_type_));
    else
        m_isInitialized = false;
}

RulesPropertyValue& RulesPropertyValue::operator=(RulesPropertyValue&& other)
{
    m_value_ = ::std::move(other.m_value_);
    m_coreValue_ = ::std::move(other.m_coreValue_);
    if (other.m_isInitialized)
        initialize(*(other.m_type_));
    else
        m_isInitialized = false;

    return *this;
}

RulesPropertyValue::RulesPropertyValue(::zserio::PropagateAllocatorT,
        const RulesPropertyValue& other, const allocator_type& allocator) :
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator)),
        m_coreValue_(::zserio::allocatorPropagatingCopy(other.m_coreValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_type_));
    else
        m_isInitialized = false;
}

void RulesPropertyValue::initialize(
        ::nds::rules::properties::RulesPropertyType& type_)
{
    m_type_ = &type_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesPropertyValue::isInitialized() const
{
    return m_isInitialized;
}

void RulesPropertyValue::initializeChildren()
{
    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
        m_value_.value().initialize(static_cast<::nds::rules::properties::PropertyType>(getType().getType()));
    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
        m_coreValue_.value().initialize(static_cast<::nds::core::properties::CorePropertyType>(getType().getCoreType()));
}

::nds::rules::properties::RulesPropertyType& RulesPropertyValue::getType()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesPropertyValue' is not initialized!");

    return *m_type_;
}

const ::nds::rules::properties::RulesPropertyType& RulesPropertyValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesPropertyValue' is not initialized!");

    return *m_type_;
}

::nds::rules::properties::PropertyValue& RulesPropertyValue::getValue()
{
    return m_value_.value();
}

const ::nds::rules::properties::PropertyValue& RulesPropertyValue::getValue() const
{
    return m_value_.value();
}

void RulesPropertyValue::setValue(const ::nds::rules::properties::PropertyValue& value_)
{
    m_value_ = value_;
}

void RulesPropertyValue::setValue(::nds::rules::properties::PropertyValue&& value_)
{
    m_value_ = ::std::move(value_);
}

bool RulesPropertyValue::isValueUsed() const
{
    return (getType().getType() != ::nds::rules::properties::PropertyType::CORE);
}

bool RulesPropertyValue::isValueSet() const
{
    return m_value_.hasValue();
}

void RulesPropertyValue::resetValue()
{
    m_value_.reset();
}

::nds::core::properties::CorePropertyValue& RulesPropertyValue::getCoreValue()
{
    return m_coreValue_.value();
}

const ::nds::core::properties::CorePropertyValue& RulesPropertyValue::getCoreValue() const
{
    return m_coreValue_.value();
}

void RulesPropertyValue::setCoreValue(const ::nds::core::properties::CorePropertyValue& coreValue_)
{
    m_coreValue_ = coreValue_;
}

void RulesPropertyValue::setCoreValue(::nds::core::properties::CorePropertyValue&& coreValue_)
{
    m_coreValue_ = ::std::move(coreValue_);
}

bool RulesPropertyValue::isCoreValueUsed() const
{
    return (getType().getType() == ::nds::rules::properties::PropertyType::CORE);
}

bool RulesPropertyValue::isCoreValueSet() const
{
    return m_coreValue_.hasValue();
}

void RulesPropertyValue::resetCoreValue()
{
    m_coreValue_.reset();
}

void RulesPropertyValue::initPackingContext(RulesPropertyValue::ZserioPackingContext& context) const
{
    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
    {
        m_value_.value().initPackingContext(context.getValue());
    }
    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        m_coreValue_.value().initPackingContext(context.getCoreValue());
    }
}

size_t RulesPropertyValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition += m_value_.value().bitSizeOf(endBitPosition);
    }
    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition += m_coreValue_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesPropertyValue::bitSizeOf(RulesPropertyValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition += m_value_.value().bitSizeOf(context.getValue(), endBitPosition);
    }
    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition += m_coreValue_.value().bitSizeOf(context.getCoreValue(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesPropertyValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition = m_value_.value().initializeOffsets(endBitPosition);
    }
    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition = m_coreValue_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesPropertyValue::initializeOffsets(RulesPropertyValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition = m_value_.value().initializeOffsets(context.getValue(), endBitPosition);
    }
    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        endBitPosition = m_coreValue_.value().initializeOffsets(context.getCoreValue(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesPropertyValue::operator==(const RulesPropertyValue& other) const
{
    if (this != &other)
    {
        return
                (getType() == other.getType()) &&
                (!isValueUsed() ? !other.isValueUsed() : (m_value_ == other.m_value_)) &&
                (!isCoreValueUsed() ? !other.isCoreValueUsed() : (m_coreValue_ == other.m_coreValue_));
    }

    return true;
}

uint32_t RulesPropertyValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (isValueUsed())
        result = ::zserio::calcHashCode(result, m_value_);
    if (isCoreValueUsed())
        result = ::zserio::calcHashCode(result, m_coreValue_);

    return result;
}

void RulesPropertyValue::write(::zserio::BitStreamWriter& out) const
{
    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
    {
        // check parameters
        if (m_value_.value().getType() != static_cast<::nds::rules::properties::PropertyType>(getType().getType()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesPropertyValue.value: ") <<
                    m_value_.value().getType() << " != " << static_cast<::nds::rules::properties::PropertyType>(getType().getType()) << "!";
        }
        m_value_.value().write(out);
    }

    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        // check parameters
        if (m_coreValue_.value().getType() != static_cast<::nds::core::properties::CorePropertyType>(getType().getCoreType()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesPropertyValue.coreValue: ") <<
                    m_coreValue_.value().getType() << " != " << static_cast<::nds::core::properties::CorePropertyType>(getType().getCoreType()) << "!";
        }
        m_coreValue_.value().write(out);
    }
}

void RulesPropertyValue::write(RulesPropertyValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
    {
        // check parameters
        if (m_value_.value().getType() != static_cast<::nds::rules::properties::PropertyType>(getType().getType()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesPropertyValue.value: ") <<
                    m_value_.value().getType() << " != " << static_cast<::nds::rules::properties::PropertyType>(getType().getType()) << "!";
        }
        m_value_.value().write(context.getValue(), out);
    }

    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        // check parameters
        if (m_coreValue_.value().getType() != static_cast<::nds::core::properties::CorePropertyType>(getType().getCoreType()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesPropertyValue.coreValue: ") <<
                    m_coreValue_.value().getType() << " != " << static_cast<::nds::core::properties::CorePropertyType>(getType().getCoreType()) << "!";
        }
        m_coreValue_.value().write(context.getCoreValue(), out);
    }
}

::zserio::InplaceOptionalHolder<::nds::rules::properties::PropertyValue> RulesPropertyValue::readValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::properties::PropertyValue>(::nds::rules::properties::PropertyValue(in, static_cast<::nds::rules::properties::PropertyType>(getType().getType()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::properties::PropertyValue>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::properties::PropertyValue> RulesPropertyValue::readValue(RulesPropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType().getType() != ::nds::rules::properties::PropertyType::CORE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::properties::PropertyValue>(::nds::rules::properties::PropertyValue(context.getValue(), in, static_cast<::nds::rules::properties::PropertyType>(getType().getType()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::properties::PropertyValue>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyValue> RulesPropertyValue::readCoreValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyValue>(::nds::core::properties::CorePropertyValue(in, static_cast<::nds::core::properties::CorePropertyType>(getType().getCoreType()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyValue>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyValue> RulesPropertyValue::readCoreValue(RulesPropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType().getType() == ::nds::rules::properties::PropertyType::CORE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyValue>(::nds::core::properties::CorePropertyValue(context.getCoreValue(), in, static_cast<::nds::core::properties::CorePropertyType>(getType().getCoreType()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::properties::CorePropertyValue>(::zserio::NullOpt);
}

} // namespace properties
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/properties/PropertyValue.h>

namespace nds
{
namespace rules
{
namespace properties
{

PropertyValue::PropertyValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

PropertyValue::PropertyValue(::zserio::BitStreamReader& in,
        ::nds::rules::properties::PropertyType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

PropertyValue::PropertyValue(PropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::properties::PropertyType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

PropertyValue::PropertyValue(const PropertyValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

PropertyValue& PropertyValue::operator=(const PropertyValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

PropertyValue::PropertyValue(PropertyValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

PropertyValue& PropertyValue::operator=(PropertyValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

PropertyValue::PropertyValue(::zserio::PropagateAllocatorT,
        const PropertyValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void PropertyValue::initialize(
        ::nds::rules::properties::PropertyType type_)
{
    m_type_ = type_;
    m_isInitialized = true;

    initializeChildren();
}

bool PropertyValue::isInitialized() const
{
    return m_isInitialized;
}

void PropertyValue::initializeChildren()
{
    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        // empty
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        break;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        break;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>().initializeChildren();
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        m_objectChoice.get<::nds::rules::types::TrafficLightCycle>().initializeChildren();
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }
}

::nds::rules::properties::PropertyType PropertyValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'PropertyValue' is not initialized!");

    return m_type_;
}

::nds::signs::warning::SupplementaryWarningSign PropertyValue::getSupplementaryWarningSign() const
{
    return m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>();
}

void PropertyValue::setSupplementaryWarningSign(::nds::signs::warning::SupplementaryWarningSign supplementaryWarningSign_)
{
    m_objectChoice = supplementaryWarningSign_;
}

::nds::signs::warning::VariableWarningSignProperties PropertyValue::getVariableWarningSignProperties() const
{
    return m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>();
}

void PropertyValue::setVariableWarningSignProperties(::nds::signs::warning::VariableWarningSignProperties variableWarningSignProperties_)
{
    m_objectChoice = variableWarningSignProperties_;
}

::nds::rules::types::RoadworksType PropertyValue::getRoadworksType() const
{
    return m_objectChoice.get<::nds::rules::types::RoadworksType>();
}

void PropertyValue::setRoadworksType(::nds::rules::types::RoadworksType roadworksType_)
{
    m_objectChoice = roadworksType_;
}

::nds::rules::types::TrafficLightLayout& PropertyValue::getTrafficLightLayout()
{
    return m_objectChoice.get<::nds::rules::types::TrafficLightLayout>();
}

const ::nds::rules::types::TrafficLightLayout& PropertyValue::getTrafficLightLayout() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficLightLayout>();
}

void PropertyValue::setTrafficLightLayout(const ::nds::rules::types::TrafficLightLayout& trafficLightLayout_)
{
    m_objectChoice = trafficLightLayout_;
}

void PropertyValue::setTrafficLightLayout(::nds::rules::types::TrafficLightLayout&& trafficLightLayout_)
{
    m_objectChoice = ::std::move(trafficLightLayout_);
}

::nds::rules::types::TrafficLightFaceList& PropertyValue::getTrafficLightFaces()
{
    return m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>();
}

const ::nds::rules::types::TrafficLightFaceList& PropertyValue::getTrafficLightFaces() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>();
}

void PropertyValue::setTrafficLightFaces(const ::nds::rules::types::TrafficLightFaceList& trafficLightFaces_)
{
    m_objectChoice = trafficLightFaces_;
}

void PropertyValue::setTrafficLightFaces(::nds::rules::types::TrafficLightFaceList&& trafficLightFaces_)
{
    m_objectChoice = ::std::move(trafficLightFaces_);
}

::nds::rules::types::TrafficLightUsageType PropertyValue::getTrafficLightUsageType() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>();
}

void PropertyValue::setTrafficLightUsageType(::nds::rules::types::TrafficLightUsageType trafficLightUsageType_)
{
    m_objectChoice = trafficLightUsageType_;
}

::nds::rules::types::TrafficLightTargetGroup PropertyValue::getTrafficLightTargetGroup() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>();
}

void PropertyValue::setTrafficLightTargetGroup(::nds::rules::types::TrafficLightTargetGroup trafficLightTargetGroup_)
{
    m_objectChoice = trafficLightTargetGroup_;
}

::nds::rules::types::TrafficLightCycle& PropertyValue::getTrafficLightCycle()
{
    return m_objectChoice.get<::nds::rules::types::TrafficLightCycle>();
}

const ::nds::rules::types::TrafficLightCycle& PropertyValue::getTrafficLightCycle() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficLightCycle>();
}

void PropertyValue::setTrafficLightCycle(const ::nds::rules::types::TrafficLightCycle& trafficLightCycle_)
{
    m_objectChoice = trafficLightCycle_;
}

void PropertyValue::setTrafficLightCycle(::nds::rules::types::TrafficLightCycle&& trafficLightCycle_)
{
    m_objectChoice = ::std::move(trafficLightCycle_);
}

::nds::rules::types::SupplementaryWarningSignText& PropertyValue::getSupplementaryWarningSignText()
{
    return m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>();
}

const ::nds::rules::types::SupplementaryWarningSignText& PropertyValue::getSupplementaryWarningSignText() const
{
    return m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>();
}

void PropertyValue::setSupplementaryWarningSignText(const ::nds::rules::types::SupplementaryWarningSignText& supplementaryWarningSignText_)
{
    m_objectChoice = supplementaryWarningSignText_;
}

void PropertyValue::setSupplementaryWarningSignText(::nds::rules::types::SupplementaryWarningSignText&& supplementaryWarningSignText_)
{
    m_objectChoice = ::std::move(supplementaryWarningSignText_);
}

PropertyValue::ChoiceTag PropertyValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        return UNDEFINED_CHOICE;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        return CHOICE_supplementaryWarningSign;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        return CHOICE_variableWarningSignProperties;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        return CHOICE_roadworksType;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        return CHOICE_trafficLightLayout;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        return CHOICE_trafficLightFaces;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        return CHOICE_trafficLightUsageType;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        return CHOICE_trafficLightTargetGroup;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        return CHOICE_trafficLightCycle;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        return CHOICE_supplementaryWarningSignText;
    default:
        return UNDEFINED_CHOICE;
    }
}

void PropertyValue::initPackingContext(PropertyValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        // empty
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        ::zserio::initPackingContext(context.getSupplementaryWarningSign(), m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>());
        break;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        ::zserio::initPackingContext(context.getVariableWarningSignProperties(), m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>());
        break;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        ::zserio::initPackingContext(context.getRoadworksType(), m_objectChoice.get<::nds::rules::types::RoadworksType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        m_objectChoice.get<::nds::rules::types::TrafficLightLayout>().initPackingContext(context.getTrafficLightLayout());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>().initPackingContext(context.getTrafficLightFaces());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        ::zserio::initPackingContext(context.getTrafficLightUsageType(), m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>().initPackingContext(context.getTrafficLightTargetGroup());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        m_objectChoice.get<::nds::rules::types::TrafficLightCycle>().initPackingContext(context.getTrafficLightCycle());
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>().initPackingContext(context.getSupplementaryWarningSignText());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }
}

size_t PropertyValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        // empty
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>());
        break;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>());
        break;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::RoadworksType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLightLayout>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLightCycle>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }

    return endBitPosition - bitPosition;
}

size_t PropertyValue::bitSizeOf(PropertyValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        // empty
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(context.getSupplementaryWarningSign(), m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>());
        break;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        endBitPosition += ::zserio::bitSizeOf(context.getVariableWarningSignProperties(), m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>());
        break;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        endBitPosition += ::zserio::bitSizeOf(context.getRoadworksType(), m_objectChoice.get<::nds::rules::types::RoadworksType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLightLayout>().bitSizeOf(context.getTrafficLightLayout(), endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>().bitSizeOf(context.getTrafficLightFaces(), endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficLightUsageType(), m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>().bitSizeOf(context.getTrafficLightTargetGroup(), endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLightCycle>().bitSizeOf(context.getTrafficLightCycle(), endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>().bitSizeOf(context.getSupplementaryWarningSignText(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }

    return endBitPosition - bitPosition;
}

size_t PropertyValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        // empty
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>());
        break;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>());
        break;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::RoadworksType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLightLayout>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLightCycle>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }

    return endBitPosition;
}

size_t PropertyValue::initializeOffsets(PropertyValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        // empty
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(context.getSupplementaryWarningSign(), endBitPosition,
        m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>());
        break;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        endBitPosition = ::zserio::initializeOffsets(context.getVariableWarningSignProperties(), endBitPosition,
        m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>());
        break;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        endBitPosition = ::zserio::initializeOffsets(context.getRoadworksType(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::RoadworksType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLightLayout>().initializeOffsets(context.getTrafficLightLayout(), endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>().initializeOffsets(context.getTrafficLightFaces(), endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficLightUsageType(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>().initializeOffsets(context.getTrafficLightTargetGroup(), endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLightCycle>().initializeOffsets(context.getTrafficLightCycle(), endBitPosition);
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>().initializeOffsets(context.getSupplementaryWarningSignText(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }

    return endBitPosition;
}

bool PropertyValue::operator==(const PropertyValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        return true; // empty
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>() == other.m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>());
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>() == other.m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>());
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::RoadworksType>() == other.m_objectChoice.get<::nds::rules::types::RoadworksType>());
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficLightLayout>() == other.m_objectChoice.get<::nds::rules::types::TrafficLightLayout>());
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>() == other.m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>());
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>() == other.m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>());
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>() == other.m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>());
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficLightCycle>() == other.m_objectChoice.get<::nds::rules::types::TrafficLightCycle>());
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>() == other.m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }
}

uint32_t PropertyValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::properties::PropertyType::CORE:
            // empty
            break;
        case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>());
            break;
        case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>());
            break;
        case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::RoadworksType>());
            break;
        case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficLightLayout>());
            break;
        case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>());
            break;
        case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>());
            break;
        case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>());
            break;
        case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficLightCycle>());
            break;
        case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>());
            break;
        default:
            break;
        }
    }

    return result;
}

void PropertyValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        // empty
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        ::zserio::write(out, m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>());
        break;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        ::zserio::write(out, m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>());
        break;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::RoadworksType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        m_objectChoice.get<::nds::rules::types::TrafficLightLayout>().write(out);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>().write(out);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>().write(out);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        m_objectChoice.get<::nds::rules::types::TrafficLightCycle>().write(out);
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }
}

void PropertyValue::write(PropertyValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        // empty
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        ::zserio::write(context.getSupplementaryWarningSign(), out, m_objectChoice.get<::nds::signs::warning::SupplementaryWarningSign>());
        break;
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        ::zserio::write(context.getVariableWarningSignProperties(), out, m_objectChoice.get<::nds::signs::warning::VariableWarningSignProperties>());
        break;
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        ::zserio::write(context.getRoadworksType(), out, m_objectChoice.get<::nds::rules::types::RoadworksType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        m_objectChoice.get<::nds::rules::types::TrafficLightLayout>().write(context.getTrafficLightLayout(), out);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        m_objectChoice.get<::nds::rules::types::TrafficLightFaceList>().write(context.getTrafficLightFaces(), out);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        ::zserio::write(context.getTrafficLightUsageType(), out, m_objectChoice.get<::nds::rules::types::TrafficLightUsageType>());
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        m_objectChoice.get<::nds::rules::types::TrafficLightTargetGroup>().write(context.getTrafficLightTargetGroup(), out);
        break;
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        m_objectChoice.get<::nds::rules::types::TrafficLightCycle>().write(context.getTrafficLightCycle(), out);
        break;
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        m_objectChoice.get<::nds::rules::types::SupplementaryWarningSignText>().write(context.getSupplementaryWarningSignText(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }
}

::zserio::AnyHolder<> PropertyValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::SupplementaryWarningSign>(in), allocator);
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::VariableWarningSignProperties>(in), allocator);
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::RoadworksType>(in), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLightLayout(in, allocator), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLightFaceList(in, allocator), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficLightUsageType>(in), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLightTargetGroup(in), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLightCycle(in, allocator), allocator);
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        return ::zserio::AnyHolder<>(::nds::rules::types::SupplementaryWarningSignText(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }
}

::zserio::AnyHolder<> PropertyValue::readObject(PropertyValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::SupplementaryWarningSign>(context.getSupplementaryWarningSign(), in), allocator);
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::VariableWarningSignProperties>(context.getVariableWarningSignProperties(), in), allocator);
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::RoadworksType>(context.getRoadworksType(), in), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLightLayout(context.getTrafficLightLayout(), in, allocator), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLightFaceList(context.getTrafficLightFaces(), in, allocator), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficLightUsageType>(context.getTrafficLightUsageType(), in), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLightTargetGroup(context.getTrafficLightTargetGroup(), in), allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLightCycle(context.getTrafficLightCycle(), in, allocator), allocator);
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        return ::zserio::AnyHolder<>(::nds::rules::types::SupplementaryWarningSignText(context.getSupplementaryWarningSignText(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }
}

::zserio::AnyHolder<> PropertyValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::properties::PropertyType::CORE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN:
        return ::zserio::allocatorPropagatingCopy<::nds::signs::warning::SupplementaryWarningSign>(m_objectChoice, allocator);
    case ::nds::rules::properties::PropertyType::VARIABLE_WARNING_SIGN_PROPERTIES:
        return ::zserio::allocatorPropagatingCopy<::nds::signs::warning::VariableWarningSignProperties>(m_objectChoice, allocator);
    case ::nds::rules::properties::PropertyType::ROADWORKS_TYPE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::RoadworksType>(m_objectChoice, allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_LAYOUT:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficLightLayout>(m_objectChoice, allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_FACES:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficLightFaceList>(m_objectChoice, allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_USAGE_TYPE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficLightUsageType>(m_objectChoice, allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_TARGET_GROUP:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficLightTargetGroup>(m_objectChoice, allocator);
    case ::nds::rules::properties::PropertyType::TRAFFIC_LIGHTS_CYCLE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficLightCycle>(m_objectChoice, allocator);
    case ::nds::rules::properties::PropertyType::SUPPLEMENTARY_WARNING_SIGN_TEXT:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SupplementaryWarningSignText>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice PropertyValue!");
    }
}

} // namespace properties
} // namespace rules
} // namespace nds
