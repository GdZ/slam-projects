/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/attributes/RulesRegionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RulesRegionAttributeType enumeration.
constexpr ::std::array<const char*, 28> EnumTraits<::nds::rules::attributes::RulesRegionAttributeType>::names;
constexpr ::std::array<::nds::rules::attributes::RulesRegionAttributeType, 28> EnumTraits<::nds::rules::attributes::RulesRegionAttributeType>::values;
constexpr const char* EnumTraits<::nds::rules::attributes::RulesRegionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::attributes::RulesRegionAttributeType value)
{
    switch (value)
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        return 0;
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        return 1;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        return 2;
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        return 3;
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        return 4;
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        return 5;
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        return 6;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        return 7;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        return 8;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        return 9;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        return 10;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        return 11;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        return 12;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        return 13;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        return 14;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        return 15;
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        return 16;
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        return 17;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        return 18;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        return 19;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        return 20;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        return 21;
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        return 22;
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        return 23;
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        return 24;
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        return 25;
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        return 26;
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        return 27;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesRegionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesRegionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::rules::attributes::RulesRegionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::rules::attributes::RulesRegionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
    case UINT16_C(18):
    case UINT16_C(19):
    case UINT16_C(20):
    case UINT16_C(21):
    case UINT16_C(22):
    case UINT16_C(23):
    case UINT16_C(24):
    case UINT16_C(25):
    case UINT16_C(26):
    case UINT16_C(27):
        return static_cast<::nds::rules::attributes::RulesRegionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesRegionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::attributes::RulesRegionAttributeType>(::nds::rules::attributes::RulesRegionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesRegionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRegionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::attributes::RulesRegionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesRegionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRegionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::attributes::RulesRegionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::attributes::RulesRegionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::attributes::RulesRegionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesRegionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesRegionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::attributes::RulesRegionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesRegionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRegionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesRegionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesRegionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRegionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/attributes/RulesTransitionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RulesTransitionAttributeType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::rules::attributes::RulesTransitionAttributeType>::names;
constexpr ::std::array<::nds::rules::attributes::RulesTransitionAttributeType, 5> EnumTraits<::nds::rules::attributes::RulesTransitionAttributeType>::values;
constexpr const char* EnumTraits<::nds::rules::attributes::RulesTransitionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::attributes::RulesTransitionAttributeType value)
{
    switch (value)
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        return 0;
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return 1;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        return 2;
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return 3;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesTransitionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesTransitionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::rules::attributes::RulesTransitionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::rules::attributes::RulesTransitionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
        return static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesTransitionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::attributes::RulesTransitionAttributeType>(::nds::rules::attributes::RulesTransitionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesTransitionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::attributes::RulesTransitionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesTransitionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::attributes::RulesTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::attributes::RulesTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::attributes::RulesTransitionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesTransitionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesTransitionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::attributes::RulesTransitionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesTransitionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesTransitionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesTransitionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesTransitionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesTransitionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/attributes/RulesLaneTransitionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RulesLaneTransitionAttributeType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::rules::attributes::RulesLaneTransitionAttributeType>::names;
constexpr ::std::array<::nds::rules::attributes::RulesLaneTransitionAttributeType, 3> EnumTraits<::nds::rules::attributes::RulesLaneTransitionAttributeType>::values;
constexpr const char* EnumTraits<::nds::rules::attributes::RulesLaneTransitionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::attributes::RulesLaneTransitionAttributeType value)
{
    switch (value)
    {
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return 0;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PROHIBITED_TRANSITION:
        return 1;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PREFERRED_U_TURN:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesLaneTransitionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneTransitionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::rules::attributes::RulesLaneTransitionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::rules::attributes::RulesLaneTransitionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
        return static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesLaneTransitionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::attributes::RulesLaneTransitionAttributeType>(::nds::rules::attributes::RulesLaneTransitionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesLaneTransitionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::attributes::RulesLaneTransitionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesLaneTransitionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneTransitionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::attributes::RulesLaneTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::attributes::RulesLaneTransitionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::attributes::RulesLaneTransitionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesLaneTransitionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneTransitionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::attributes::RulesLaneTransitionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesLaneTransitionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneTransitionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesLaneTransitionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesLaneTransitionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneTransitionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/attributes/RulesRoadRangeAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RulesRoadRangeAttributeType enumeration.
constexpr ::std::array<const char*, 19> EnumTraits<::nds::rules::attributes::RulesRoadRangeAttributeType>::names;
constexpr ::std::array<::nds::rules::attributes::RulesRoadRangeAttributeType, 19> EnumTraits<::nds::rules::attributes::RulesRoadRangeAttributeType>::values;
constexpr const char* EnumTraits<::nds::rules::attributes::RulesRoadRangeAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::attributes::RulesRoadRangeAttributeType value)
{
    switch (value)
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        return 0;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        return 1;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        return 2;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return 3;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        return 4;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return 5;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return 6;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return 7;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return 8;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return 9;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        return 10;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return 11;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return 12;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        return 13;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        return 14;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        return 15;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        return 16;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return 17;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        return 18;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesRoadRangeAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadRangeAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::rules::attributes::RulesRoadRangeAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::rules::attributes::RulesRoadRangeAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
    case UINT16_C(18):
        return static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesRoadRangeAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::attributes::RulesRoadRangeAttributeType>(::nds::rules::attributes::RulesRoadRangeAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesRoadRangeAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::attributes::RulesRoadRangeAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesRoadRangeAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::attributes::RulesRoadRangeAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::attributes::RulesRoadRangeAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::attributes::RulesRoadRangeAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesRoadRangeAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadRangeAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::attributes::RulesRoadRangeAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesRoadRangeAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadRangeAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesRoadRangeAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesRoadRangeAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadRangeAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/attributes/RulesRoadPositionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RulesRoadPositionAttributeType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::rules::attributes::RulesRoadPositionAttributeType>::names;
constexpr ::std::array<::nds::rules::attributes::RulesRoadPositionAttributeType, 4> EnumTraits<::nds::rules::attributes::RulesRoadPositionAttributeType>::values;
constexpr const char* EnumTraits<::nds::rules::attributes::RulesRoadPositionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::attributes::RulesRoadPositionAttributeType value)
{
    switch (value)
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        return 0;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return 1;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        return 2;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesRoadPositionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadPositionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::rules::attributes::RulesRoadPositionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::rules::attributes::RulesRoadPositionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
        return static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesRoadPositionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::attributes::RulesRoadPositionAttributeType>(::nds::rules::attributes::RulesRoadPositionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesRoadPositionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadPositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::attributes::RulesRoadPositionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesRoadPositionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadPositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::attributes::RulesRoadPositionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::attributes::RulesRoadPositionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::attributes::RulesRoadPositionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesRoadPositionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadPositionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::attributes::RulesRoadPositionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesRoadPositionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadPositionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesRoadPositionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesRoadPositionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesRoadPositionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/attributes/RulesLaneRangeAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RulesLaneRangeAttributeType enumeration.
constexpr ::std::array<const char*, 18> EnumTraits<::nds::rules::attributes::RulesLaneRangeAttributeType>::names;
constexpr ::std::array<::nds::rules::attributes::RulesLaneRangeAttributeType, 18> EnumTraits<::nds::rules::attributes::RulesLaneRangeAttributeType>::values;
constexpr const char* EnumTraits<::nds::rules::attributes::RulesLaneRangeAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::attributes::RulesLaneRangeAttributeType value)
{
    switch (value)
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        return 0;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        return 1;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        return 2;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return 3;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        return 4;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return 5;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return 6;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return 7;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return 8;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        return 9;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        return 10;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        return 11;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        return 12;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        return 13;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return 14;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        return 15;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        return 16;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        return 17;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesLaneRangeAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneRangeAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::rules::attributes::RulesLaneRangeAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::rules::attributes::RulesLaneRangeAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
        return static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesLaneRangeAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::attributes::RulesLaneRangeAttributeType>(::nds::rules::attributes::RulesLaneRangeAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesLaneRangeAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::attributes::RulesLaneRangeAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesLaneRangeAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::attributes::RulesLaneRangeAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::attributes::RulesLaneRangeAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::attributes::RulesLaneRangeAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesLaneRangeAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneRangeAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::attributes::RulesLaneRangeAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesLaneRangeAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneRangeAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesLaneRangeAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesLaneRangeAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLaneRangeAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/attributes/RulesLanePositionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RulesLanePositionAttributeType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::rules::attributes::RulesLanePositionAttributeType>::names;
constexpr ::std::array<::nds::rules::attributes::RulesLanePositionAttributeType, 5> EnumTraits<::nds::rules::attributes::RulesLanePositionAttributeType>::values;
constexpr const char* EnumTraits<::nds::rules::attributes::RulesLanePositionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::attributes::RulesLanePositionAttributeType value)
{
    switch (value)
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        return 0;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return 1;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        return 2;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        return 3;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesLanePositionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesLanePositionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::rules::attributes::RulesLanePositionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::rules::attributes::RulesLanePositionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
        return static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesLanePositionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::attributes::RulesLanePositionAttributeType>(::nds::rules::attributes::RulesLanePositionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesLanePositionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLanePositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::attributes::RulesLanePositionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesLanePositionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLanePositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::attributes::RulesLanePositionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::attributes::RulesLanePositionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::attributes::RulesLanePositionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesLanePositionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesLanePositionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::attributes::RulesLanePositionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesLanePositionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLanePositionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesLanePositionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesLanePositionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesLanePositionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/attributes/RulesDisplayLineRangeAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RulesDisplayLineRangeAttributeType enumeration.
constexpr ::std::array<const char*, 19> EnumTraits<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::names;
constexpr ::std::array<::nds::rules::attributes::RulesDisplayLineRangeAttributeType, 19> EnumTraits<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::values;
constexpr const char* EnumTraits<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::attributes::RulesDisplayLineRangeAttributeType value)
{
    switch (value)
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        return 0;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        return 1;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        return 2;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return 3;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        return 4;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return 5;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return 6;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return 7;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return 8;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return 9;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        return 10;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return 11;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return 12;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        return 13;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        return 14;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        return 15;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        return 16;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return 17;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        return 18;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesDisplayLineRangeAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::rules::attributes::RulesDisplayLineRangeAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
    case UINT16_C(18):
        return static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesDisplayLineRangeAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(::nds::rules::attributes::RulesDisplayLineRangeAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesDisplayLineRangeAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::attributes::RulesDisplayLineRangeAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesDisplayLineRangeAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::attributes::RulesDisplayLineRangeAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::attributes::RulesDisplayLineRangeAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::attributes::RulesDisplayLineRangeAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::attributes::RulesDisplayLineRangeAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesDisplayLineRangeAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesDisplayLineRangeAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/attributes/RulesDisplayLinePositionAttributeType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RulesDisplayLinePositionAttributeType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::names;
constexpr ::std::array<::nds::rules::attributes::RulesDisplayLinePositionAttributeType, 4> EnumTraits<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::values;
constexpr const char* EnumTraits<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::attributes::RulesDisplayLinePositionAttributeType value)
{
    switch (value)
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        return 0;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return 1;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        return 2;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesDisplayLinePositionAttributeType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::type>(value) << "!";
    }
}

template <>
::nds::rules::attributes::RulesDisplayLinePositionAttributeType valueToEnum(
        typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
        return static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RulesDisplayLinePositionAttributeType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(::nds::rules::attributes::RulesDisplayLinePositionAttributeType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesDisplayLinePositionAttributeType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::attributes::RulesDisplayLinePositionAttributeType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::attributes::RulesDisplayLinePositionAttributeType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::attributes::RulesDisplayLinePositionAttributeType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::attributes::RulesDisplayLinePositionAttributeType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::attributes::RulesDisplayLinePositionAttributeType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(
            static_cast<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::rules::attributes::RulesDisplayLinePositionAttributeType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesDisplayLinePositionAttributeType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::attributes::RulesDisplayLinePositionAttributeType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/attributes/RulesRegionAttributeValue.h>

namespace nds
{
namespace rules
{
namespace attributes
{

RulesRegionAttributeValue::RulesRegionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RulesRegionAttributeValue::RulesRegionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRegionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RulesRegionAttributeValue::RulesRegionAttributeValue(RulesRegionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRegionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RulesRegionAttributeValue::RulesRegionAttributeValue(const RulesRegionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeValue& RulesRegionAttributeValue::operator=(const RulesRegionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeValue::RulesRegionAttributeValue(RulesRegionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeValue& RulesRegionAttributeValue::operator=(RulesRegionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeValue::RulesRegionAttributeValue(::zserio::PropagateAllocatorT,
        const RulesRegionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RulesRegionAttributeValue::initialize(
        ::nds::rules::attributes::RulesRegionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RulesRegionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::attributes::RulesRegionAttributeType RulesRegionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesRegionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::rules::types::BloodAlcoholContentLimit RulesRegionAttributeValue::getBloodAlcoholContentLimit() const
{
    return m_objectChoice.get<::nds::rules::types::BloodAlcoholContentLimit>();
}

void RulesRegionAttributeValue::setBloodAlcoholContentLimit(::nds::rules::types::BloodAlcoholContentLimit bloodAlcoholContentLimit_)
{
    m_objectChoice = bloodAlcoholContentLimit_;
}

::nds::rules::types::WarningTriangleRequired& RulesRegionAttributeValue::getWarningTriangleRequired()
{
    return m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>();
}

const ::nds::rules::types::WarningTriangleRequired& RulesRegionAttributeValue::getWarningTriangleRequired() const
{
    return m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>();
}

void RulesRegionAttributeValue::setWarningTriangleRequired(const ::nds::rules::types::WarningTriangleRequired& warningTriangleRequired_)
{
    m_objectChoice = warningTriangleRequired_;
}

void RulesRegionAttributeValue::setWarningTriangleRequired(::nds::rules::types::WarningTriangleRequired&& warningTriangleRequired_)
{
    m_objectChoice = ::std::move(warningTriangleRequired_);
}

::nds::rules::types::FirstAidKitRequired& RulesRegionAttributeValue::getFirstAidKitRequired()
{
    return m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>();
}

const ::nds::rules::types::FirstAidKitRequired& RulesRegionAttributeValue::getFirstAidKitRequired() const
{
    return m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>();
}

void RulesRegionAttributeValue::setFirstAidKitRequired(const ::nds::rules::types::FirstAidKitRequired& firstAidKitRequired_)
{
    m_objectChoice = firstAidKitRequired_;
}

void RulesRegionAttributeValue::setFirstAidKitRequired(::nds::rules::types::FirstAidKitRequired&& firstAidKitRequired_)
{
    m_objectChoice = ::std::move(firstAidKitRequired_);
}

::nds::rules::types::SafetyVestsRequired& RulesRegionAttributeValue::getSafetyVestsRequired()
{
    return m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>();
}

const ::nds::rules::types::SafetyVestsRequired& RulesRegionAttributeValue::getSafetyVestsRequired() const
{
    return m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>();
}

void RulesRegionAttributeValue::setSafetyVestsRequired(const ::nds::rules::types::SafetyVestsRequired& safetyVestsRequired_)
{
    m_objectChoice = safetyVestsRequired_;
}

void RulesRegionAttributeValue::setSafetyVestsRequired(::nds::rules::types::SafetyVestsRequired&& safetyVestsRequired_)
{
    m_objectChoice = ::std::move(safetyVestsRequired_);
}

::nds::rules::types::BreathalizerRequired& RulesRegionAttributeValue::getBreathalizerRequired()
{
    return m_objectChoice.get<::nds::rules::types::BreathalizerRequired>();
}

const ::nds::rules::types::BreathalizerRequired& RulesRegionAttributeValue::getBreathalizerRequired() const
{
    return m_objectChoice.get<::nds::rules::types::BreathalizerRequired>();
}

void RulesRegionAttributeValue::setBreathalizerRequired(const ::nds::rules::types::BreathalizerRequired& breathalizerRequired_)
{
    m_objectChoice = breathalizerRequired_;
}

void RulesRegionAttributeValue::setBreathalizerRequired(::nds::rules::types::BreathalizerRequired&& breathalizerRequired_)
{
    m_objectChoice = ::std::move(breathalizerRequired_);
}

::nds::rules::types::TurnOnRedAllowed RulesRegionAttributeValue::getTurnOnRedAllowed() const
{
    return m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>();
}

void RulesRegionAttributeValue::setTurnOnRedAllowed(::nds::rules::types::TurnOnRedAllowed turnOnRedAllowed_)
{
    m_objectChoice = turnOnRedAllowed_;
}

::nds::rules::types::DaytimeRunningLight RulesRegionAttributeValue::getDaytimeRunningLight() const
{
    return m_objectChoice.get<::nds::rules::types::DaytimeRunningLight>();
}

void RulesRegionAttributeValue::setDaytimeRunningLight(::nds::rules::types::DaytimeRunningLight daytimeRunningLight_)
{
    m_objectChoice = daytimeRunningLight_;
}

::nds::rules::types::AdminSpeedLimitKmh RulesRegionAttributeValue::getAdminSpeedLimitKmh() const
{
    return m_objectChoice.get<::nds::rules::types::AdminSpeedLimitKmh>();
}

void RulesRegionAttributeValue::setAdminSpeedLimitKmh(::nds::rules::types::AdminSpeedLimitKmh adminSpeedLimitKmh_)
{
    m_objectChoice = adminSpeedLimitKmh_;
}

::nds::rules::types::AdminSpeedLimitMph RulesRegionAttributeValue::getAdminSpeedLimitMph() const
{
    return m_objectChoice.get<::nds::rules::types::AdminSpeedLimitMph>();
}

void RulesRegionAttributeValue::setAdminSpeedLimitMph(::nds::rules::types::AdminSpeedLimitMph adminSpeedLimitMph_)
{
    m_objectChoice = adminSpeedLimitMph_;
}

::nds::rules::types::AdminMinimumSpeedKmh RulesRegionAttributeValue::getAdminMinimumSpeedKmh() const
{
    return m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedKmh>();
}

void RulesRegionAttributeValue::setAdminMinimumSpeedKmh(::nds::rules::types::AdminMinimumSpeedKmh adminMinimumSpeedKmh_)
{
    m_objectChoice = adminMinimumSpeedKmh_;
}

::nds::rules::types::AdminMinimumSpeedMph RulesRegionAttributeValue::getAdminMinimumSpeedMph() const
{
    return m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedMph>();
}

void RulesRegionAttributeValue::setAdminMinimumSpeedMph(::nds::rules::types::AdminMinimumSpeedMph adminMinimumSpeedMph_)
{
    m_objectChoice = adminMinimumSpeedMph_;
}

::nds::rules::types::AdminAdvisorySpeedLimitKmh RulesRegionAttributeValue::getAdminAdvisorySpeedLimitKmh() const
{
    return m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitKmh>();
}

void RulesRegionAttributeValue::setAdminAdvisorySpeedLimitKmh(::nds::rules::types::AdminAdvisorySpeedLimitKmh adminAdvisorySpeedLimitKmh_)
{
    m_objectChoice = adminAdvisorySpeedLimitKmh_;
}

::nds::rules::types::AdminAdvisorySpeedLimitMph RulesRegionAttributeValue::getAdminAdvisorySpeedLimitMph() const
{
    return m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitMph>();
}

void RulesRegionAttributeValue::setAdminAdvisorySpeedLimitMph(::nds::rules::types::AdminAdvisorySpeedLimitMph adminAdvisorySpeedLimitMph_)
{
    m_objectChoice = adminAdvisorySpeedLimitMph_;
}

::nds::rules::types::TollVignetteInfo& RulesRegionAttributeValue::getTollVignetteInfo()
{
    return m_objectChoice.get<::nds::rules::types::TollVignetteInfo>();
}

const ::nds::rules::types::TollVignetteInfo& RulesRegionAttributeValue::getTollVignetteInfo() const
{
    return m_objectChoice.get<::nds::rules::types::TollVignetteInfo>();
}

void RulesRegionAttributeValue::setTollVignetteInfo(const ::nds::rules::types::TollVignetteInfo& tollVignetteInfo_)
{
    m_objectChoice = tollVignetteInfo_;
}

void RulesRegionAttributeValue::setTollVignetteInfo(::nds::rules::types::TollVignetteInfo&& tollVignetteInfo_)
{
    m_objectChoice = ::std::move(tollVignetteInfo_);
}

::nds::rules::types::RegionCurrencies& RulesRegionAttributeValue::getRegionCurrencies()
{
    return m_objectChoice.get<::nds::rules::types::RegionCurrencies>();
}

const ::nds::rules::types::RegionCurrencies& RulesRegionAttributeValue::getRegionCurrencies() const
{
    return m_objectChoice.get<::nds::rules::types::RegionCurrencies>();
}

void RulesRegionAttributeValue::setRegionCurrencies(const ::nds::rules::types::RegionCurrencies& regionCurrencies_)
{
    m_objectChoice = regionCurrencies_;
}

void RulesRegionAttributeValue::setRegionCurrencies(::nds::rules::types::RegionCurrencies&& regionCurrencies_)
{
    m_objectChoice = ::std::move(regionCurrencies_);
}

::nds::rules::types::RegionDrivingRules& RulesRegionAttributeValue::getRegionDrivingRules()
{
    return m_objectChoice.get<::nds::rules::types::RegionDrivingRules>();
}

const ::nds::rules::types::RegionDrivingRules& RulesRegionAttributeValue::getRegionDrivingRules() const
{
    return m_objectChoice.get<::nds::rules::types::RegionDrivingRules>();
}

void RulesRegionAttributeValue::setRegionDrivingRules(const ::nds::rules::types::RegionDrivingRules& regionDrivingRules_)
{
    m_objectChoice = regionDrivingRules_;
}

void RulesRegionAttributeValue::setRegionDrivingRules(::nds::rules::types::RegionDrivingRules&& regionDrivingRules_)
{
    m_objectChoice = ::std::move(regionDrivingRules_);
}

::nds::rules::types::VehicleLightConditions& RulesRegionAttributeValue::getVehicleLightConditions()
{
    return m_objectChoice.get<::nds::rules::types::VehicleLightConditions>();
}

const ::nds::rules::types::VehicleLightConditions& RulesRegionAttributeValue::getVehicleLightConditions() const
{
    return m_objectChoice.get<::nds::rules::types::VehicleLightConditions>();
}

void RulesRegionAttributeValue::setVehicleLightConditions(const ::nds::rules::types::VehicleLightConditions& vehicleLightConditions_)
{
    m_objectChoice = vehicleLightConditions_;
}

void RulesRegionAttributeValue::setVehicleLightConditions(::nds::rules::types::VehicleLightConditions&& vehicleLightConditions_)
{
    m_objectChoice = ::std::move(vehicleLightConditions_);
}

::nds::rules::types::RequiresTollRegistration& RulesRegionAttributeValue::getRequiresTollRegistration()
{
    return m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>();
}

const ::nds::rules::types::RequiresTollRegistration& RulesRegionAttributeValue::getRequiresTollRegistration() const
{
    return m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>();
}

void RulesRegionAttributeValue::setRequiresTollRegistration(const ::nds::rules::types::RequiresTollRegistration& requiresTollRegistration_)
{
    m_objectChoice = requiresTollRegistration_;
}

void RulesRegionAttributeValue::setRequiresTollRegistration(::nds::rules::types::RequiresTollRegistration&& requiresTollRegistration_)
{
    m_objectChoice = ::std::move(requiresTollRegistration_);
}

::nds::rules::types::WinterSeason& RulesRegionAttributeValue::getWinterSeason()
{
    return m_objectChoice.get<::nds::rules::types::WinterSeason>();
}

const ::nds::rules::types::WinterSeason& RulesRegionAttributeValue::getWinterSeason() const
{
    return m_objectChoice.get<::nds::rules::types::WinterSeason>();
}

void RulesRegionAttributeValue::setWinterSeason(const ::nds::rules::types::WinterSeason& winterSeason_)
{
    m_objectChoice = winterSeason_;
}

void RulesRegionAttributeValue::setWinterSeason(::nds::rules::types::WinterSeason&& winterSeason_)
{
    m_objectChoice = ::std::move(winterSeason_);
}

::nds::rules::types::WinterTiresRequired& RulesRegionAttributeValue::getWinterTiresRequired()
{
    return m_objectChoice.get<::nds::rules::types::WinterTiresRequired>();
}

const ::nds::rules::types::WinterTiresRequired& RulesRegionAttributeValue::getWinterTiresRequired() const
{
    return m_objectChoice.get<::nds::rules::types::WinterTiresRequired>();
}

void RulesRegionAttributeValue::setWinterTiresRequired(const ::nds::rules::types::WinterTiresRequired& winterTiresRequired_)
{
    m_objectChoice = winterTiresRequired_;
}

void RulesRegionAttributeValue::setWinterTiresRequired(::nds::rules::types::WinterTiresRequired&& winterTiresRequired_)
{
    m_objectChoice = ::std::move(winterTiresRequired_);
}

::nds::rules::types::FireExtinguisherRequired& RulesRegionAttributeValue::getFireExtinguisherRequired()
{
    return m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>();
}

const ::nds::rules::types::FireExtinguisherRequired& RulesRegionAttributeValue::getFireExtinguisherRequired() const
{
    return m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>();
}

void RulesRegionAttributeValue::setFireExtinguisherRequired(const ::nds::rules::types::FireExtinguisherRequired& fireExtinguisherRequired_)
{
    m_objectChoice = fireExtinguisherRequired_;
}

void RulesRegionAttributeValue::setFireExtinguisherRequired(::nds::rules::types::FireExtinguisherRequired&& fireExtinguisherRequired_)
{
    m_objectChoice = ::std::move(fireExtinguisherRequired_);
}

::nds::rules::types::TowRopeRequired& RulesRegionAttributeValue::getTowRopeRequired()
{
    return m_objectChoice.get<::nds::rules::types::TowRopeRequired>();
}

const ::nds::rules::types::TowRopeRequired& RulesRegionAttributeValue::getTowRopeRequired() const
{
    return m_objectChoice.get<::nds::rules::types::TowRopeRequired>();
}

void RulesRegionAttributeValue::setTowRopeRequired(const ::nds::rules::types::TowRopeRequired& towRopeRequired_)
{
    m_objectChoice = towRopeRequired_;
}

void RulesRegionAttributeValue::setTowRopeRequired(::nds::rules::types::TowRopeRequired&& towRopeRequired_)
{
    m_objectChoice = ::std::move(towRopeRequired_);
}

::nds::rules::types::IsoDetails& RulesRegionAttributeValue::getIsoDetails()
{
    return m_objectChoice.get<::nds::rules::types::IsoDetails>();
}

const ::nds::rules::types::IsoDetails& RulesRegionAttributeValue::getIsoDetails() const
{
    return m_objectChoice.get<::nds::rules::types::IsoDetails>();
}

void RulesRegionAttributeValue::setIsoDetails(const ::nds::rules::types::IsoDetails& IsoDetails_)
{
    m_objectChoice = IsoDetails_;
}

void RulesRegionAttributeValue::setIsoDetails(::nds::rules::types::IsoDetails&& IsoDetails_)
{
    m_objectChoice = ::std::move(IsoDetails_);
}

::nds::rules::types::RightHandTraffic RulesRegionAttributeValue::getRightHandTraffic() const
{
    return m_objectChoice.get<::nds::rules::types::RightHandTraffic>();
}

void RulesRegionAttributeValue::setRightHandTraffic(::nds::rules::types::RightHandTraffic rightHandTraffic_)
{
    m_objectChoice = rightHandTraffic_;
}

::nds::rules::types::SystemOfMeasurement RulesRegionAttributeValue::getSystemOfMeasurement() const
{
    return m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>();
}

void RulesRegionAttributeValue::setSystemOfMeasurement(::nds::rules::types::SystemOfMeasurement systemOfMeasurement_)
{
    m_objectChoice = systemOfMeasurement_;
}

::nds::rules::types::ProhibitedPassage& RulesRegionAttributeValue::getProhibitedPassage()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedPassage>();
}

const ::nds::rules::types::ProhibitedPassage& RulesRegionAttributeValue::getProhibitedPassage() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedPassage>();
}

void RulesRegionAttributeValue::setProhibitedPassage(const ::nds::rules::types::ProhibitedPassage& prohibitedPassage_)
{
    m_objectChoice = prohibitedPassage_;
}

void RulesRegionAttributeValue::setProhibitedPassage(::nds::rules::types::ProhibitedPassage&& prohibitedPassage_)
{
    m_objectChoice = ::std::move(prohibitedPassage_);
}

::nds::rules::types::TimeZone& RulesRegionAttributeValue::getTimeZone()
{
    return m_objectChoice.get<::nds::rules::types::TimeZone>();
}

const ::nds::rules::types::TimeZone& RulesRegionAttributeValue::getTimeZone() const
{
    return m_objectChoice.get<::nds::rules::types::TimeZone>();
}

void RulesRegionAttributeValue::setTimeZone(const ::nds::rules::types::TimeZone& timeZone_)
{
    m_objectChoice = timeZone_;
}

void RulesRegionAttributeValue::setTimeZone(::nds::rules::types::TimeZone&& timeZone_)
{
    m_objectChoice = ::std::move(timeZone_);
}

::nds::rules::types::OfficialLanguages& RulesRegionAttributeValue::getOfficialLanguages()
{
    return m_objectChoice.get<::nds::rules::types::OfficialLanguages>();
}

const ::nds::rules::types::OfficialLanguages& RulesRegionAttributeValue::getOfficialLanguages() const
{
    return m_objectChoice.get<::nds::rules::types::OfficialLanguages>();
}

void RulesRegionAttributeValue::setOfficialLanguages(const ::nds::rules::types::OfficialLanguages& officialLanguages_)
{
    m_objectChoice = officialLanguages_;
}

void RulesRegionAttributeValue::setOfficialLanguages(::nds::rules::types::OfficialLanguages&& officialLanguages_)
{
    m_objectChoice = ::std::move(officialLanguages_);
}

RulesRegionAttributeValue::ChoiceTag RulesRegionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        return CHOICE_bloodAlcoholContentLimit;
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        return CHOICE_warningTriangleRequired;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        return CHOICE_firstAidKitRequired;
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        return CHOICE_safetyVestsRequired;
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        return CHOICE_breathalizerRequired;
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        return CHOICE_turnOnRedAllowed;
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        return CHOICE_daytimeRunningLight;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        return CHOICE_adminSpeedLimitKmh;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        return CHOICE_adminSpeedLimitMph;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        return CHOICE_adminMinimumSpeedKmh;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        return CHOICE_adminMinimumSpeedMph;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        return CHOICE_adminAdvisorySpeedLimitKmh;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        return CHOICE_adminAdvisorySpeedLimitMph;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        return CHOICE_tollVignetteInfo;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        return CHOICE_regionCurrencies;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        return CHOICE_regionDrivingRules;
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        return CHOICE_vehicleLightConditions;
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        return CHOICE_requiresTollRegistration;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        return CHOICE_winterSeason;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        return CHOICE_winterTiresRequired;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        return CHOICE_fireExtinguisherRequired;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        return CHOICE_towRopeRequired;
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        return CHOICE_IsoDetails;
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        return CHOICE_rightHandTraffic;
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        return CHOICE_systemOfMeasurement;
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        return CHOICE_prohibitedPassage;
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        return CHOICE_timeZone;
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        return CHOICE_officialLanguages;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RulesRegionAttributeValue::initPackingContext(RulesRegionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        context.getBloodAlcoholContentLimit().init<::zserio::StdIntArrayTraits<::nds::rules::types::BloodAlcoholContentLimit>>(m_objectChoice.get<::nds::rules::types::BloodAlcoholContentLimit>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        context.getAdminSpeedLimitKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdminSpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        context.getAdminSpeedLimitMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdminSpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        context.getAdminMinimumSpeedKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        context.getAdminMinimumSpeedMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        context.getAdminAdvisorySpeedLimitKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        context.getAdminAdvisorySpeedLimitMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        m_objectChoice.get<::nds::rules::types::RegionCurrencies>().initPackingContext(context.getRegionCurrencies());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        m_objectChoice.get<::nds::rules::types::RegionDrivingRules>().initPackingContext(context.getRegionDrivingRules());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        m_objectChoice.get<::nds::rules::types::WinterSeason>().initPackingContext(context.getWinterSeason());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        ::zserio::initPackingContext(context.getSystemOfMeasurement(), m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        m_objectChoice.get<::nds::rules::types::TimeZone>().initPackingContext(context.getTimeZone());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        m_objectChoice.get<::nds::rules::types::OfficialLanguages>().initPackingContext(context.getOfficialLanguages());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }
}

size_t RulesRegionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::BreathalizerRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TollVignetteInfo>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        endBitPosition += m_objectChoice.get<::nds::rules::types::RegionCurrencies>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        endBitPosition += m_objectChoice.get<::nds::rules::types::RegionDrivingRules>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::VehicleLightConditions>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        endBitPosition += m_objectChoice.get<::nds::rules::types::WinterSeason>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::WinterTiresRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TowRopeRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::IsoDetails>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TimeZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        endBitPosition += m_objectChoice.get<::nds::rules::types::OfficialLanguages>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeValue::bitSizeOf(RulesRegionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        endBitPosition += context.getBloodAlcoholContentLimit().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::BloodAlcoholContentLimit>>(m_objectChoice.get<::nds::rules::types::BloodAlcoholContentLimit>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::BreathalizerRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdminSpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdminSpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdminSpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdminSpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        endBitPosition += context.getAdminMinimumSpeedKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        endBitPosition += context.getAdminMinimumSpeedMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdminAdvisorySpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdminAdvisorySpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TollVignetteInfo>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        endBitPosition += m_objectChoice.get<::nds::rules::types::RegionCurrencies>().bitSizeOf(context.getRegionCurrencies(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        endBitPosition += m_objectChoice.get<::nds::rules::types::RegionDrivingRules>().bitSizeOf(context.getRegionDrivingRules(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::VehicleLightConditions>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        endBitPosition += m_objectChoice.get<::nds::rules::types::WinterSeason>().bitSizeOf(context.getWinterSeason(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::WinterTiresRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TowRopeRequired>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::IsoDetails>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        endBitPosition += ::zserio::bitSizeOf(context.getSystemOfMeasurement(), m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TimeZone>().bitSizeOf(context.getTimeZone(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        endBitPosition += m_objectChoice.get<::nds::rules::types::OfficialLanguages>().bitSizeOf(context.getOfficialLanguages(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::BreathalizerRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TollVignetteInfo>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        endBitPosition = m_objectChoice.get<::nds::rules::types::RegionCurrencies>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        endBitPosition = m_objectChoice.get<::nds::rules::types::RegionDrivingRules>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::VehicleLightConditions>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        endBitPosition = m_objectChoice.get<::nds::rules::types::WinterSeason>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::WinterTiresRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TowRopeRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::IsoDetails>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TimeZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        endBitPosition = m_objectChoice.get<::nds::rules::types::OfficialLanguages>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }

    return endBitPosition;
}

size_t RulesRegionAttributeValue::initializeOffsets(RulesRegionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        endBitPosition += context.getBloodAlcoholContentLimit().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::BloodAlcoholContentLimit>>(m_objectChoice.get<::nds::rules::types::BloodAlcoholContentLimit>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::BreathalizerRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdminSpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdminSpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdminSpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdminSpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        endBitPosition += context.getAdminMinimumSpeedKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        endBitPosition += context.getAdminMinimumSpeedMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdminAdvisorySpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdminAdvisorySpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TollVignetteInfo>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        endBitPosition = m_objectChoice.get<::nds::rules::types::RegionCurrencies>().initializeOffsets(context.getRegionCurrencies(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        endBitPosition = m_objectChoice.get<::nds::rules::types::RegionDrivingRules>().initializeOffsets(context.getRegionDrivingRules(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::VehicleLightConditions>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        endBitPosition = m_objectChoice.get<::nds::rules::types::WinterSeason>().initializeOffsets(context.getWinterSeason(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::WinterTiresRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TowRopeRequired>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::IsoDetails>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        endBitPosition = ::zserio::initializeOffsets(context.getSystemOfMeasurement(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TimeZone>().initializeOffsets(context.getTimeZone(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        endBitPosition = m_objectChoice.get<::nds::rules::types::OfficialLanguages>().initializeOffsets(context.getOfficialLanguages(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }

    return endBitPosition;
}

bool RulesRegionAttributeValue::operator==(const RulesRegionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::BloodAlcoholContentLimit>() == other.m_objectChoice.get<::nds::rules::types::BloodAlcoholContentLimit>());
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>() == other.m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>());
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>() == other.m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>());
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>() == other.m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>());
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::BreathalizerRequired>() == other.m_objectChoice.get<::nds::rules::types::BreathalizerRequired>());
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>() == other.m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::DaytimeRunningLight>() == other.m_objectChoice.get<::nds::rules::types::DaytimeRunningLight>());
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdminSpeedLimitKmh>() == other.m_objectChoice.get<::nds::rules::types::AdminSpeedLimitKmh>());
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdminSpeedLimitMph>() == other.m_objectChoice.get<::nds::rules::types::AdminSpeedLimitMph>());
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedKmh>() == other.m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedKmh>());
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedMph>() == other.m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedMph>());
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitKmh>() == other.m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitKmh>());
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitMph>() == other.m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitMph>());
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TollVignetteInfo>() == other.m_objectChoice.get<::nds::rules::types::TollVignetteInfo>());
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::RegionCurrencies>() == other.m_objectChoice.get<::nds::rules::types::RegionCurrencies>());
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::RegionDrivingRules>() == other.m_objectChoice.get<::nds::rules::types::RegionDrivingRules>());
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::VehicleLightConditions>() == other.m_objectChoice.get<::nds::rules::types::VehicleLightConditions>());
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>() == other.m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>());
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::WinterSeason>() == other.m_objectChoice.get<::nds::rules::types::WinterSeason>());
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::WinterTiresRequired>() == other.m_objectChoice.get<::nds::rules::types::WinterTiresRequired>());
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>() == other.m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>());
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TowRopeRequired>() == other.m_objectChoice.get<::nds::rules::types::TowRopeRequired>());
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::IsoDetails>() == other.m_objectChoice.get<::nds::rules::types::IsoDetails>());
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::RightHandTraffic>() == other.m_objectChoice.get<::nds::rules::types::RightHandTraffic>());
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>() == other.m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>());
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedPassage>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedPassage>());
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TimeZone>() == other.m_objectChoice.get<::nds::rules::types::TimeZone>());
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::OfficialLanguages>() == other.m_objectChoice.get<::nds::rules::types::OfficialLanguages>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }
}

uint32_t RulesRegionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::BloodAlcoholContentLimit>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::BreathalizerRequired>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::DaytimeRunningLight>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdminSpeedLimitKmh>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdminSpeedLimitMph>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedKmh>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedMph>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitKmh>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitMph>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TollVignetteInfo>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::RegionCurrencies>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::RegionDrivingRules>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::VehicleLightConditions>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::WinterSeason>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::WinterTiresRequired>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TowRopeRequired>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::IsoDetails>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::RightHandTraffic>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedPassage>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TimeZone>());
            break;
        case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::OfficialLanguages>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RulesRegionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        out.writeBits(m_objectChoice.get<::nds::rules::types::BloodAlcoholContentLimit>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        m_objectChoice.get<::nds::rules::types::BreathalizerRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        out.writeBool(m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        out.writeBool(m_objectChoice.get<::nds::rules::types::DaytimeRunningLight>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdminSpeedLimitKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdminSpeedLimitMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        m_objectChoice.get<::nds::rules::types::TollVignetteInfo>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        m_objectChoice.get<::nds::rules::types::RegionCurrencies>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        m_objectChoice.get<::nds::rules::types::RegionDrivingRules>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        m_objectChoice.get<::nds::rules::types::VehicleLightConditions>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        m_objectChoice.get<::nds::rules::types::WinterSeason>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        m_objectChoice.get<::nds::rules::types::WinterTiresRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        m_objectChoice.get<::nds::rules::types::TowRopeRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        m_objectChoice.get<::nds::rules::types::IsoDetails>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        out.writeBool(m_objectChoice.get<::nds::rules::types::RightHandTraffic>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        m_objectChoice.get<::nds::rules::types::TimeZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        m_objectChoice.get<::nds::rules::types::OfficialLanguages>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }
}

void RulesRegionAttributeValue::write(RulesRegionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        context.getBloodAlcoholContentLimit().write<::zserio::StdIntArrayTraits<::nds::rules::types::BloodAlcoholContentLimit>>(out, m_objectChoice.get<::nds::rules::types::BloodAlcoholContentLimit>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        m_objectChoice.get<::nds::rules::types::WarningTriangleRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        m_objectChoice.get<::nds::rules::types::FirstAidKitRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        m_objectChoice.get<::nds::rules::types::SafetyVestsRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        m_objectChoice.get<::nds::rules::types::BreathalizerRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        out.writeBool(m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        out.writeBool(m_objectChoice.get<::nds::rules::types::DaytimeRunningLight>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        context.getAdminSpeedLimitKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitKmh>>(out, m_objectChoice.get<::nds::rules::types::AdminSpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        context.getAdminSpeedLimitMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitMph>>(out, m_objectChoice.get<::nds::rules::types::AdminSpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        context.getAdminMinimumSpeedKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedKmh>>(out, m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        context.getAdminMinimumSpeedMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedMph>>(out, m_objectChoice.get<::nds::rules::types::AdminMinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        context.getAdminAdvisorySpeedLimitKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitKmh>>(out, m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        context.getAdminAdvisorySpeedLimitMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitMph>>(out, m_objectChoice.get<::nds::rules::types::AdminAdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        m_objectChoice.get<::nds::rules::types::TollVignetteInfo>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        m_objectChoice.get<::nds::rules::types::RegionCurrencies>().write(context.getRegionCurrencies(), out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        m_objectChoice.get<::nds::rules::types::RegionDrivingRules>().write(context.getRegionDrivingRules(), out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        m_objectChoice.get<::nds::rules::types::VehicleLightConditions>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        m_objectChoice.get<::nds::rules::types::RequiresTollRegistration>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        m_objectChoice.get<::nds::rules::types::WinterSeason>().write(context.getWinterSeason(), out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        m_objectChoice.get<::nds::rules::types::WinterTiresRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        m_objectChoice.get<::nds::rules::types::FireExtinguisherRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        m_objectChoice.get<::nds::rules::types::TowRopeRequired>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        m_objectChoice.get<::nds::rules::types::IsoDetails>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        out.writeBool(m_objectChoice.get<::nds::rules::types::RightHandTraffic>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        ::zserio::write(context.getSystemOfMeasurement(), out, m_objectChoice.get<::nds::rules::types::SystemOfMeasurement>());
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().write(out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        m_objectChoice.get<::nds::rules::types::TimeZone>().write(context.getTimeZone(), out);
        break;
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        m_objectChoice.get<::nds::rules::types::OfficialLanguages>().write(context.getOfficialLanguages(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesRegionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::BloodAlcoholContentLimit>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::WarningTriangleRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::FirstAidKitRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::SafetyVestsRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::BreathalizerRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::TurnOnRedAllowed>(in.readBool()), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::DaytimeRunningLight>(in.readBool()), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdminSpeedLimitKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdminSpeedLimitMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdminMinimumSpeedKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdminMinimumSpeedMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdminAdvisorySpeedLimitKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdminAdvisorySpeedLimitMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        return ::zserio::AnyHolder<>(::nds::rules::types::TollVignetteInfo(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        return ::zserio::AnyHolder<>(::nds::rules::types::RegionCurrencies(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        return ::zserio::AnyHolder<>(::nds::rules::types::RegionDrivingRules(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        return ::zserio::AnyHolder<>(::nds::rules::types::VehicleLightConditions(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        return ::zserio::AnyHolder<>(::nds::rules::types::RequiresTollRegistration(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        return ::zserio::AnyHolder<>(::nds::rules::types::WinterSeason(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::WinterTiresRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::FireExtinguisherRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::TowRopeRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        return ::zserio::AnyHolder<>(::nds::rules::types::IsoDetails(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::RightHandTraffic>(in.readBool()), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::SystemOfMeasurement>(in), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedPassage(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TimeZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        return ::zserio::AnyHolder<>(::nds::rules::types::OfficialLanguages(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesRegionAttributeValue::readObject(RulesRegionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        return ::zserio::AnyHolder<>(context.getBloodAlcoholContentLimit().read<::zserio::StdIntArrayTraits<::nds::rules::types::BloodAlcoholContentLimit>>(in), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::WarningTriangleRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::FirstAidKitRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::SafetyVestsRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::BreathalizerRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::TurnOnRedAllowed>(in.readBool()), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::DaytimeRunningLight>(in.readBool()), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(context.getAdminSpeedLimitKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getAdminSpeedLimitMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdminSpeedLimitMph>>(in), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        return ::zserio::AnyHolder<>(context.getAdminMinimumSpeedKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getAdminMinimumSpeedMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdminMinimumSpeedMph>>(in), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(context.getAdminAdvisorySpeedLimitKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getAdminAdvisorySpeedLimitMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdminAdvisorySpeedLimitMph>>(in), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        return ::zserio::AnyHolder<>(::nds::rules::types::TollVignetteInfo(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        return ::zserio::AnyHolder<>(::nds::rules::types::RegionCurrencies(context.getRegionCurrencies(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        return ::zserio::AnyHolder<>(::nds::rules::types::RegionDrivingRules(context.getRegionDrivingRules(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        return ::zserio::AnyHolder<>(::nds::rules::types::VehicleLightConditions(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        return ::zserio::AnyHolder<>(::nds::rules::types::RequiresTollRegistration(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        return ::zserio::AnyHolder<>(::nds::rules::types::WinterSeason(context.getWinterSeason(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::WinterTiresRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::FireExtinguisherRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        return ::zserio::AnyHolder<>(::nds::rules::types::TowRopeRequired(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        return ::zserio::AnyHolder<>(::nds::rules::types::IsoDetails(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::RightHandTraffic>(in.readBool()), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::SystemOfMeasurement>(context.getSystemOfMeasurement(), in), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedPassage(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TimeZone(context.getTimeZone(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        return ::zserio::AnyHolder<>(::nds::rules::types::OfficialLanguages(context.getOfficialLanguages(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesRegionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRegionAttributeType::BLOOD_ALCOHOL_CONTENT_LIMIT:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::BloodAlcoholContentLimit>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::WARNING_TRIANGLE_REQUIRED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::WarningTriangleRequired>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRST_AID_KIT_REQUIRED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::FirstAidKitRequired>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::SAFETY_VESTS_REQUIRED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SafetyVestsRequired>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::BREATHALIZER_REQUIRED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::BreathalizerRequired>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TURN_ON_RED_ALLOWED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TurnOnRedAllowed>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::DAYTIME_RUNNING_LIGHT:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::DaytimeRunningLight>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdminSpeedLimitKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_SPEED_LIMIT_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdminSpeedLimitMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdminMinimumSpeedKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_MINIMUM_SPEED_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdminMinimumSpeedMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdminAdvisorySpeedLimitKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ADMIN_ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdminAdvisorySpeedLimitMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TOLL_VIGNETTE_INFO:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TollVignetteInfo>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_CURRENCIES:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::RegionCurrencies>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::REGION_DRIVING_RULES:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::RegionDrivingRules>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::LIGHT_CONDITIONS:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::VehicleLightConditions>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::REQUIRES_TOLL_REGISTRATION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::RequiresTollRegistration>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_SEASON:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::WinterSeason>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::WINTER_TIRES_REQUIRED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::WinterTiresRequired>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::FIRE_EXTINGUISHER_REQUIRED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::FireExtinguisherRequired>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TOW_ROPE_REQUIRED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TowRopeRequired>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::ISO_DETAILS:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::IsoDetails>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::RIGHT_HAND_TRAFFIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::RightHandTraffic>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::SYSTEM_OF_MEASUREMENT:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SystemOfMeasurement>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedPassage>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::TIME_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TimeZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRegionAttributeType::OFFICIAL_LANGUAGES:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::OfficialLanguages>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRegionAttributeValue!");
    }
}

} // namespace attributes
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/attributes/RulesTransitionAttributeValue.h>

namespace nds
{
namespace rules
{
namespace attributes
{

RulesTransitionAttributeValue::RulesTransitionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RulesTransitionAttributeValue::RulesTransitionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RulesTransitionAttributeValue::RulesTransitionAttributeValue(RulesTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RulesTransitionAttributeValue::RulesTransitionAttributeValue(const RulesTransitionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeValue& RulesTransitionAttributeValue::operator=(const RulesTransitionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeValue::RulesTransitionAttributeValue(RulesTransitionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeValue& RulesTransitionAttributeValue::operator=(RulesTransitionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeValue::RulesTransitionAttributeValue(::zserio::PropagateAllocatorT,
        const RulesTransitionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RulesTransitionAttributeValue::initialize(
        ::nds::rules::attributes::RulesTransitionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RulesTransitionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::attributes::RulesTransitionAttributeType RulesTransitionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesTransitionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::rules::types::RightOfWayType RulesTransitionAttributeValue::getRightOfWayType() const
{
    return m_objectChoice.get<::nds::rules::types::RightOfWayType>();
}

void RulesTransitionAttributeValue::setRightOfWayType(::nds::rules::types::RightOfWayType rightOfWayType_)
{
    m_objectChoice = rightOfWayType_;
}

::nds::rules::types::TurnOnRedAllowed RulesTransitionAttributeValue::getTurnOnRedAllowed() const
{
    return m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>();
}

void RulesTransitionAttributeValue::setTurnOnRedAllowed(::nds::rules::types::TurnOnRedAllowed turnOnRedAllowed_)
{
    m_objectChoice = turnOnRedAllowed_;
}

::nds::rules::types::ProhibitedTransition& RulesTransitionAttributeValue::getProhibitedTransition()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedTransition>();
}

const ::nds::rules::types::ProhibitedTransition& RulesTransitionAttributeValue::getProhibitedTransition() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedTransition>();
}

void RulesTransitionAttributeValue::setProhibitedTransition(const ::nds::rules::types::ProhibitedTransition& prohibitedTransition_)
{
    m_objectChoice = prohibitedTransition_;
}

void RulesTransitionAttributeValue::setProhibitedTransition(::nds::rules::types::ProhibitedTransition&& prohibitedTransition_)
{
    m_objectChoice = ::std::move(prohibitedTransition_);
}

::nds::rules::types::AutomatedDrivingClearance RulesTransitionAttributeValue::getAutomatedDrivingClearance() const
{
    return m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>();
}

void RulesTransitionAttributeValue::setAutomatedDrivingClearance(::nds::rules::types::AutomatedDrivingClearance automatedDrivingClearance_)
{
    m_objectChoice = automatedDrivingClearance_;
}

::nds::rules::types::PreferredUTurn& RulesTransitionAttributeValue::getPreferredUTurn()
{
    return m_objectChoice.get<::nds::rules::types::PreferredUTurn>();
}

const ::nds::rules::types::PreferredUTurn& RulesTransitionAttributeValue::getPreferredUTurn() const
{
    return m_objectChoice.get<::nds::rules::types::PreferredUTurn>();
}

void RulesTransitionAttributeValue::setPreferredUTurn(const ::nds::rules::types::PreferredUTurn& preferredUTurn_)
{
    m_objectChoice = preferredUTurn_;
}

void RulesTransitionAttributeValue::setPreferredUTurn(::nds::rules::types::PreferredUTurn&& preferredUTurn_)
{
    m_objectChoice = ::std::move(preferredUTurn_);
}

RulesTransitionAttributeValue::ChoiceTag RulesTransitionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        return CHOICE_rightOfWayType;
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return CHOICE_turnOnRedAllowed;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        return CHOICE_prohibitedTransition;
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return CHOICE_automatedDrivingClearance;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        return CHOICE_preferredUTurn;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RulesTransitionAttributeValue::initPackingContext(RulesTransitionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        ::zserio::initPackingContext(context.getRightOfWayType(), m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::initPackingContext(context.getAutomatedDrivingClearance(), m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }
}

size_t RulesTransitionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedTransition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        endBitPosition += m_objectChoice.get<::nds::rules::types::PreferredUTurn>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeValue::bitSizeOf(RulesTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        endBitPosition += ::zserio::bitSizeOf(context.getRightOfWayType(), m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedTransition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition += ::zserio::bitSizeOf(context.getAutomatedDrivingClearance(), m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        endBitPosition += m_objectChoice.get<::nds::rules::types::PreferredUTurn>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedTransition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        endBitPosition = m_objectChoice.get<::nds::rules::types::PreferredUTurn>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }

    return endBitPosition;
}

size_t RulesTransitionAttributeValue::initializeOffsets(RulesTransitionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        endBitPosition = ::zserio::initializeOffsets(context.getRightOfWayType(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedTransition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition = ::zserio::initializeOffsets(context.getAutomatedDrivingClearance(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        endBitPosition = m_objectChoice.get<::nds::rules::types::PreferredUTurn>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }

    return endBitPosition;
}

bool RulesTransitionAttributeValue::operator==(const RulesTransitionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::RightOfWayType>() == other.m_objectChoice.get<::nds::rules::types::RightOfWayType>());
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>() == other.m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedTransition>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedTransition>());
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>() == other.m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::PreferredUTurn>() == other.m_objectChoice.get<::nds::rules::types::PreferredUTurn>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }
}

uint32_t RulesTransitionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::RightOfWayType>());
            break;
        case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
            break;
        case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedTransition>());
            break;
        case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
            break;
        case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::PreferredUTurn>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RulesTransitionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        out.writeBool(m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        m_objectChoice.get<::nds::rules::types::ProhibitedTransition>().write(out);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        m_objectChoice.get<::nds::rules::types::PreferredUTurn>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }
}

void RulesTransitionAttributeValue::write(RulesTransitionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        ::zserio::write(context.getRightOfWayType(), out, m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        out.writeBool(m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        m_objectChoice.get<::nds::rules::types::ProhibitedTransition>().write(out);
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::write(context.getAutomatedDrivingClearance(), out, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        m_objectChoice.get<::nds::rules::types::PreferredUTurn>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesTransitionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::RightOfWayType>(in), allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::TurnOnRedAllowed>(in.readBool()), allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedTransition(in, allocator), allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AutomatedDrivingClearance>(in), allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        return ::zserio::AnyHolder<>(::nds::rules::types::PreferredUTurn(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesTransitionAttributeValue::readObject(RulesTransitionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::RightOfWayType>(context.getRightOfWayType(), in), allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::TurnOnRedAllowed>(in.readBool()), allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedTransition(in, allocator), allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AutomatedDrivingClearance>(context.getAutomatedDrivingClearance(), in), allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        return ::zserio::AnyHolder<>(::nds::rules::types::PreferredUTurn(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesTransitionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesTransitionAttributeType::RIGHT_OF_WAY_REGULATION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::RightOfWayType>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TurnOnRedAllowed>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::PROHIBITED_TRANSITION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedTransition>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AutomatedDrivingClearance>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesTransitionAttributeType::PREFERRED_U_TURN:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::PreferredUTurn>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesTransitionAttributeValue!");
    }
}

} // namespace attributes
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/attributes/RulesLaneTransitionAttributeValue.h>

namespace nds
{
namespace rules
{
namespace attributes
{

RulesLaneTransitionAttributeValue::RulesLaneTransitionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RulesLaneTransitionAttributeValue::RulesLaneTransitionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLaneTransitionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RulesLaneTransitionAttributeValue::RulesLaneTransitionAttributeValue(const RulesLaneTransitionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeValue& RulesLaneTransitionAttributeValue::operator=(const RulesLaneTransitionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeValue::RulesLaneTransitionAttributeValue(RulesLaneTransitionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeValue& RulesLaneTransitionAttributeValue::operator=(RulesLaneTransitionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeValue::RulesLaneTransitionAttributeValue(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RulesLaneTransitionAttributeValue::initialize(
        ::nds::rules::attributes::RulesLaneTransitionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RulesLaneTransitionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::attributes::RulesLaneTransitionAttributeType RulesLaneTransitionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesLaneTransitionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::rules::types::TurnOnRedAllowed RulesLaneTransitionAttributeValue::getTurnOnRedAllowed() const
{
    return m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>();
}

void RulesLaneTransitionAttributeValue::setTurnOnRedAllowed(::nds::rules::types::TurnOnRedAllowed turnOnRedAllowed_)
{
    m_objectChoice = turnOnRedAllowed_;
}

::nds::rules::types::ProhibitedTransition& RulesLaneTransitionAttributeValue::getProhibitedTransition()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedTransition>();
}

const ::nds::rules::types::ProhibitedTransition& RulesLaneTransitionAttributeValue::getProhibitedTransition() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedTransition>();
}

void RulesLaneTransitionAttributeValue::setProhibitedTransition(const ::nds::rules::types::ProhibitedTransition& prohibitedTransition_)
{
    m_objectChoice = prohibitedTransition_;
}

void RulesLaneTransitionAttributeValue::setProhibitedTransition(::nds::rules::types::ProhibitedTransition&& prohibitedTransition_)
{
    m_objectChoice = ::std::move(prohibitedTransition_);
}

::nds::rules::types::PreferredUTurn& RulesLaneTransitionAttributeValue::getPreferredUTurn()
{
    return m_objectChoice.get<::nds::rules::types::PreferredUTurn>();
}

const ::nds::rules::types::PreferredUTurn& RulesLaneTransitionAttributeValue::getPreferredUTurn() const
{
    return m_objectChoice.get<::nds::rules::types::PreferredUTurn>();
}

void RulesLaneTransitionAttributeValue::setPreferredUTurn(const ::nds::rules::types::PreferredUTurn& preferredUTurn_)
{
    m_objectChoice = preferredUTurn_;
}

void RulesLaneTransitionAttributeValue::setPreferredUTurn(::nds::rules::types::PreferredUTurn&& preferredUTurn_)
{
    m_objectChoice = ::std::move(preferredUTurn_);
}

RulesLaneTransitionAttributeValue::ChoiceTag RulesLaneTransitionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return CHOICE_turnOnRedAllowed;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PROHIBITED_TRANSITION:
        return CHOICE_prohibitedTransition;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PREFERRED_U_TURN:
        return CHOICE_preferredUTurn;
    default:
        return UNDEFINED_CHOICE;
    }
}

size_t RulesLaneTransitionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PROHIBITED_TRANSITION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedTransition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PREFERRED_U_TURN:
        endBitPosition += m_objectChoice.get<::nds::rules::types::PreferredUTurn>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneTransitionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::TURN_ON_RED_ALLOWED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PROHIBITED_TRANSITION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedTransition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PREFERRED_U_TURN:
        endBitPosition = m_objectChoice.get<::nds::rules::types::PreferredUTurn>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneTransitionAttributeValue!");
    }

    return endBitPosition;
}

bool RulesLaneTransitionAttributeValue::operator==(const RulesLaneTransitionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>() == other.m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PROHIBITED_TRANSITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedTransition>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedTransition>());
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PREFERRED_U_TURN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::PreferredUTurn>() == other.m_objectChoice.get<::nds::rules::types::PreferredUTurn>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneTransitionAttributeValue!");
    }
}

uint32_t RulesLaneTransitionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::attributes::RulesLaneTransitionAttributeType::TURN_ON_RED_ALLOWED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
            break;
        case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PROHIBITED_TRANSITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedTransition>());
            break;
        case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PREFERRED_U_TURN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::PreferredUTurn>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RulesLaneTransitionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::TURN_ON_RED_ALLOWED:
        out.writeBool(m_objectChoice.get<::nds::rules::types::TurnOnRedAllowed>());
        break;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PROHIBITED_TRANSITION:
        m_objectChoice.get<::nds::rules::types::ProhibitedTransition>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PREFERRED_U_TURN:
        m_objectChoice.get<::nds::rules::types::PreferredUTurn>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesLaneTransitionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::TurnOnRedAllowed>(in.readBool()), allocator);
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PROHIBITED_TRANSITION:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedTransition(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PREFERRED_U_TURN:
        return ::zserio::AnyHolder<>(::nds::rules::types::PreferredUTurn(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneTransitionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesLaneTransitionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::TURN_ON_RED_ALLOWED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TurnOnRedAllowed>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PROHIBITED_TRANSITION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedTransition>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneTransitionAttributeType::PREFERRED_U_TURN:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::PreferredUTurn>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneTransitionAttributeValue!");
    }
}

} // namespace attributes
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/attributes/RulesRoadRangeAttributeValue.h>

namespace nds
{
namespace rules
{
namespace attributes
{

RulesRoadRangeAttributeValue::RulesRoadRangeAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RulesRoadRangeAttributeValue::RulesRoadRangeAttributeValue(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRoadRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RulesRoadRangeAttributeValue::RulesRoadRangeAttributeValue(RulesRoadRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRoadRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RulesRoadRangeAttributeValue::RulesRoadRangeAttributeValue(const RulesRoadRangeAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeValue& RulesRoadRangeAttributeValue::operator=(const RulesRoadRangeAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeValue::RulesRoadRangeAttributeValue(RulesRoadRangeAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeValue& RulesRoadRangeAttributeValue::operator=(RulesRoadRangeAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeValue::RulesRoadRangeAttributeValue(::zserio::PropagateAllocatorT,
        const RulesRoadRangeAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RulesRoadRangeAttributeValue::initialize(
        ::nds::rules::attributes::RulesRoadRangeAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RulesRoadRangeAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadRangeAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesRoadRangeAttributeValue' is not initialized!");

    return m_type_;
}

::nds::rules::types::ProhibitedPassage& RulesRoadRangeAttributeValue::getProhibitedPassage()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedPassage>();
}

const ::nds::rules::types::ProhibitedPassage& RulesRoadRangeAttributeValue::getProhibitedPassage() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedPassage>();
}

void RulesRoadRangeAttributeValue::setProhibitedPassage(const ::nds::rules::types::ProhibitedPassage& prohibitedPassage_)
{
    m_objectChoice = prohibitedPassage_;
}

void RulesRoadRangeAttributeValue::setProhibitedPassage(::nds::rules::types::ProhibitedPassage&& prohibitedPassage_)
{
    m_objectChoice = ::std::move(prohibitedPassage_);
}

::nds::rules::types::OvertakingProhibition& RulesRoadRangeAttributeValue::getOvertakingProhibition()
{
    return m_objectChoice.get<::nds::rules::types::OvertakingProhibition>();
}

const ::nds::rules::types::OvertakingProhibition& RulesRoadRangeAttributeValue::getOvertakingProhibition() const
{
    return m_objectChoice.get<::nds::rules::types::OvertakingProhibition>();
}

void RulesRoadRangeAttributeValue::setOvertakingProhibition(const ::nds::rules::types::OvertakingProhibition& overtakingProhibition_)
{
    m_objectChoice = overtakingProhibition_;
}

void RulesRoadRangeAttributeValue::setOvertakingProhibition(::nds::rules::types::OvertakingProhibition&& overtakingProhibition_)
{
    m_objectChoice = ::std::move(overtakingProhibition_);
}

::nds::rules::types::SpeedLimitKmh RulesRoadRangeAttributeValue::getSpeedLimitKmh() const
{
    return m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>();
}

void RulesRoadRangeAttributeValue::setSpeedLimitKmh(::nds::rules::types::SpeedLimitKmh speedLimitKmh_)
{
    m_objectChoice = speedLimitKmh_;
}

::nds::rules::types::SpeedLimitMph RulesRoadRangeAttributeValue::getSpeedLimitMph() const
{
    return m_objectChoice.get<::nds::rules::types::SpeedLimitMph>();
}

void RulesRoadRangeAttributeValue::setSpeedLimitMph(::nds::rules::types::SpeedLimitMph speedLimitMph_)
{
    m_objectChoice = speedLimitMph_;
}

::nds::rules::types::MinimumSpeedKmh RulesRoadRangeAttributeValue::getMinimumSpeedKmh() const
{
    return m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>();
}

void RulesRoadRangeAttributeValue::setMinimumSpeedKmh(::nds::rules::types::MinimumSpeedKmh minimumSpeedKmh_)
{
    m_objectChoice = minimumSpeedKmh_;
}

::nds::rules::types::MinimumSpeedMph RulesRoadRangeAttributeValue::getMinimumSpeedMph() const
{
    return m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>();
}

void RulesRoadRangeAttributeValue::setMinimumSpeedMph(::nds::rules::types::MinimumSpeedMph minimumSpeedMph_)
{
    m_objectChoice = minimumSpeedMph_;
}

::nds::rules::types::AdvisorySpeedLimitKmh RulesRoadRangeAttributeValue::getAdvisorySpeedLimitKmh() const
{
    return m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>();
}

void RulesRoadRangeAttributeValue::setAdvisorySpeedLimitKmh(::nds::rules::types::AdvisorySpeedLimitKmh advisorySpeedLimitKmh_)
{
    m_objectChoice = advisorySpeedLimitKmh_;
}

::nds::rules::types::AdvisorySpeedLimitMph RulesRoadRangeAttributeValue::getAdvisorySpeedLimitMph() const
{
    return m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>();
}

void RulesRoadRangeAttributeValue::setAdvisorySpeedLimitMph(::nds::rules::types::AdvisorySpeedLimitMph advisorySpeedLimitMph_)
{
    m_objectChoice = advisorySpeedLimitMph_;
}

::nds::rules::types::TrafficEnforcementZone& RulesRoadRangeAttributeValue::getTrafficEnforcementZone()
{
    return m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>();
}

const ::nds::rules::types::TrafficEnforcementZone& RulesRoadRangeAttributeValue::getTrafficEnforcementZone() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>();
}

void RulesRoadRangeAttributeValue::setTrafficEnforcementZone(const ::nds::rules::types::TrafficEnforcementZone& trafficEnforcementZone_)
{
    m_objectChoice = trafficEnforcementZone_;
}

void RulesRoadRangeAttributeValue::setTrafficEnforcementZone(::nds::rules::types::TrafficEnforcementZone&& trafficEnforcementZone_)
{
    m_objectChoice = ::std::move(trafficEnforcementZone_);
}

::nds::rules::types::NonDefaultDrivingSide& RulesRoadRangeAttributeValue::getNonDefaultDrivingSide()
{
    return m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>();
}

const ::nds::rules::types::NonDefaultDrivingSide& RulesRoadRangeAttributeValue::getNonDefaultDrivingSide() const
{
    return m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>();
}

void RulesRoadRangeAttributeValue::setNonDefaultDrivingSide(const ::nds::rules::types::NonDefaultDrivingSide& nonDefaultDrivingSide_)
{
    m_objectChoice = nonDefaultDrivingSide_;
}

void RulesRoadRangeAttributeValue::setNonDefaultDrivingSide(::nds::rules::types::NonDefaultDrivingSide&& nonDefaultDrivingSide_)
{
    m_objectChoice = ::std::move(nonDefaultDrivingSide_);
}

::nds::rules::types::TrafficZone RulesRoadRangeAttributeValue::getTrafficZone() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficZone>();
}

void RulesRoadRangeAttributeValue::setTrafficZone(::nds::rules::types::TrafficZone trafficZone_)
{
    m_objectChoice = trafficZone_;
}

::nds::rules::types::AdrTunnelCategory RulesRoadRangeAttributeValue::getAdrTunnelCategory() const
{
    return m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>();
}

void RulesRoadRangeAttributeValue::setAdrTunnelCategory(::nds::rules::types::AdrTunnelCategory adrTunnelCategory_)
{
    m_objectChoice = adrTunnelCategory_;
}

::nds::rules::types::LicensePlateRestriction& RulesRoadRangeAttributeValue::getLicensePlateRestriction()
{
    return m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>();
}

const ::nds::rules::types::LicensePlateRestriction& RulesRoadRangeAttributeValue::getLicensePlateRestriction() const
{
    return m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>();
}

void RulesRoadRangeAttributeValue::setLicensePlateRestriction(const ::nds::rules::types::LicensePlateRestriction& licensePlateRestriction_)
{
    m_objectChoice = licensePlateRestriction_;
}

void RulesRoadRangeAttributeValue::setLicensePlateRestriction(::nds::rules::types::LicensePlateRestriction&& licensePlateRestriction_)
{
    m_objectChoice = ::std::move(licensePlateRestriction_);
}

::nds::rules::types::SeasonalClosed& RulesRoadRangeAttributeValue::getSeasonalClosed()
{
    return m_objectChoice.get<::nds::rules::types::SeasonalClosed>();
}

const ::nds::rules::types::SeasonalClosed& RulesRoadRangeAttributeValue::getSeasonalClosed() const
{
    return m_objectChoice.get<::nds::rules::types::SeasonalClosed>();
}

void RulesRoadRangeAttributeValue::setSeasonalClosed(const ::nds::rules::types::SeasonalClosed& seasonalClosed_)
{
    m_objectChoice = seasonalClosed_;
}

void RulesRoadRangeAttributeValue::setSeasonalClosed(::nds::rules::types::SeasonalClosed&& seasonalClosed_)
{
    m_objectChoice = ::std::move(seasonalClosed_);
}

::nds::rules::types::ProhibitedParking& RulesRoadRangeAttributeValue::getProhibitedParking()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedParking>();
}

const ::nds::rules::types::ProhibitedParking& RulesRoadRangeAttributeValue::getProhibitedParking() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedParking>();
}

void RulesRoadRangeAttributeValue::setProhibitedParking(const ::nds::rules::types::ProhibitedParking& prohibitedParking_)
{
    m_objectChoice = prohibitedParking_;
}

void RulesRoadRangeAttributeValue::setProhibitedParking(::nds::rules::types::ProhibitedParking&& prohibitedParking_)
{
    m_objectChoice = ::std::move(prohibitedParking_);
}

::nds::rules::types::ProhibitedStopping& RulesRoadRangeAttributeValue::getProhibitedStopping()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedStopping>();
}

const ::nds::rules::types::ProhibitedStopping& RulesRoadRangeAttributeValue::getProhibitedStopping() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedStopping>();
}

void RulesRoadRangeAttributeValue::setProhibitedStopping(const ::nds::rules::types::ProhibitedStopping& prohibitedStopping_)
{
    m_objectChoice = prohibitedStopping_;
}

void RulesRoadRangeAttributeValue::setProhibitedStopping(::nds::rules::types::ProhibitedStopping&& prohibitedStopping_)
{
    m_objectChoice = ::std::move(prohibitedStopping_);
}

::nds::rules::types::DontStopZone& RulesRoadRangeAttributeValue::getDontStopZone()
{
    return m_objectChoice.get<::nds::rules::types::DontStopZone>();
}

const ::nds::rules::types::DontStopZone& RulesRoadRangeAttributeValue::getDontStopZone() const
{
    return m_objectChoice.get<::nds::rules::types::DontStopZone>();
}

void RulesRoadRangeAttributeValue::setDontStopZone(const ::nds::rules::types::DontStopZone& dontStopZone_)
{
    m_objectChoice = dontStopZone_;
}

void RulesRoadRangeAttributeValue::setDontStopZone(::nds::rules::types::DontStopZone&& dontStopZone_)
{
    m_objectChoice = ::std::move(dontStopZone_);
}

::nds::rules::types::AutomatedDrivingClearance RulesRoadRangeAttributeValue::getAutomatedDrivingClearance() const
{
    return m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>();
}

void RulesRoadRangeAttributeValue::setAutomatedDrivingClearance(::nds::rules::types::AutomatedDrivingClearance automatedDrivingClearance_)
{
    m_objectChoice = automatedDrivingClearance_;
}

::nds::rules::types::Roadworks& RulesRoadRangeAttributeValue::getRoadworks()
{
    return m_objectChoice.get<::nds::rules::types::Roadworks>();
}

const ::nds::rules::types::Roadworks& RulesRoadRangeAttributeValue::getRoadworks() const
{
    return m_objectChoice.get<::nds::rules::types::Roadworks>();
}

void RulesRoadRangeAttributeValue::setRoadworks(const ::nds::rules::types::Roadworks& roadworks_)
{
    m_objectChoice = roadworks_;
}

void RulesRoadRangeAttributeValue::setRoadworks(::nds::rules::types::Roadworks&& roadworks_)
{
    m_objectChoice = ::std::move(roadworks_);
}

RulesRoadRangeAttributeValue::ChoiceTag RulesRoadRangeAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        return CHOICE_prohibitedPassage;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        return CHOICE_overtakingProhibition;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        return CHOICE_speedLimitKmh;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return CHOICE_speedLimitMph;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        return CHOICE_minimumSpeedKmh;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return CHOICE_minimumSpeedMph;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return CHOICE_advisorySpeedLimitKmh;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return CHOICE_advisorySpeedLimitMph;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return CHOICE_trafficEnforcementZone;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return CHOICE_nonDefaultDrivingSide;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        return CHOICE_trafficZone;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return CHOICE_adrTunnelCategory;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return CHOICE_licensePlateRestriction;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        return CHOICE_seasonalClosed;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        return CHOICE_prohibitedParking;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        return CHOICE_prohibitedStopping;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        return CHOICE_dontStopZone;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return CHOICE_automatedDrivingClearance;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        return CHOICE_roadworks;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RulesRoadRangeAttributeValue::initPackingContext(RulesRoadRangeAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        context.getSpeedLimitKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        context.getSpeedLimitMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        context.getMinimumSpeedKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        context.getMinimumSpeedMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        context.getAdvisorySpeedLimitKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        context.getAdvisorySpeedLimitMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().initPackingContext(context.getTrafficEnforcementZone());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        ::zserio::initPackingContext(context.getTrafficZone(), m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        ::zserio::initPackingContext(context.getAdrTunnelCategory(), m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().initPackingContext(context.getLicensePlateRestriction());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::initPackingContext(context.getAutomatedDrivingClearance(), m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }
}

size_t RulesRoadRangeAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SeasonalClosed>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedParking>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::DontStopZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::Roadworks>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeValue::bitSizeOf(RulesRoadRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += context.getSpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getSpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += context.getMinimumSpeedKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += context.getMinimumSpeedMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdvisorySpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdvisorySpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().bitSizeOf(context.getTrafficEnforcementZone(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficZone(), m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        endBitPosition += ::zserio::bitSizeOf(context.getAdrTunnelCategory(), m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().bitSizeOf(context.getLicensePlateRestriction(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SeasonalClosed>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedParking>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::DontStopZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition += ::zserio::bitSizeOf(context.getAutomatedDrivingClearance(), m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::Roadworks>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SeasonalClosed>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedParking>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::DontStopZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::Roadworks>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }

    return endBitPosition;
}

size_t RulesRoadRangeAttributeValue::initializeOffsets(RulesRoadRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += context.getSpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getSpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += context.getMinimumSpeedKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += context.getMinimumSpeedMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdvisorySpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdvisorySpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().initializeOffsets(context.getTrafficEnforcementZone(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficZone(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        endBitPosition = ::zserio::initializeOffsets(context.getAdrTunnelCategory(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().initializeOffsets(context.getLicensePlateRestriction(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SeasonalClosed>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedParking>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::DontStopZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition = ::zserio::initializeOffsets(context.getAutomatedDrivingClearance(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::Roadworks>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }

    return endBitPosition;
}

bool RulesRoadRangeAttributeValue::operator==(const RulesRoadRangeAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedPassage>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedPassage>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::OvertakingProhibition>() == other.m_objectChoice.get<::nds::rules::types::OvertakingProhibition>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>() == other.m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SpeedLimitMph>() == other.m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>() == other.m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>() == other.m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>() == other.m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>() == other.m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>() == other.m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>() == other.m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficZone>() == other.m_objectChoice.get<::nds::rules::types::TrafficZone>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>() == other.m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>() == other.m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SeasonalClosed>() == other.m_objectChoice.get<::nds::rules::types::SeasonalClosed>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedParking>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedParking>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedStopping>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedStopping>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::DontStopZone>() == other.m_objectChoice.get<::nds::rules::types::DontStopZone>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>() == other.m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::Roadworks>() == other.m_objectChoice.get<::nds::rules::types::Roadworks>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }
}

uint32_t RulesRoadRangeAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedPassage>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::OvertakingProhibition>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficZone>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SeasonalClosed>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedParking>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedStopping>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::DontStopZone>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
            break;
        case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::Roadworks>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RulesRoadRangeAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        m_objectChoice.get<::nds::rules::types::SeasonalClosed>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        m_objectChoice.get<::nds::rules::types::ProhibitedParking>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        m_objectChoice.get<::nds::rules::types::DontStopZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        m_objectChoice.get<::nds::rules::types::Roadworks>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }
}

void RulesRoadRangeAttributeValue::write(RulesRoadRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        context.getSpeedLimitKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(out, m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        context.getSpeedLimitMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(out, m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        context.getMinimumSpeedKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(out, m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        context.getMinimumSpeedMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(out, m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        context.getAdvisorySpeedLimitKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(out, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        context.getAdvisorySpeedLimitMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(out, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().write(context.getTrafficEnforcementZone(), out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        ::zserio::write(context.getTrafficZone(), out, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        ::zserio::write(context.getAdrTunnelCategory(), out, m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().write(context.getLicensePlateRestriction(), out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        m_objectChoice.get<::nds::rules::types::SeasonalClosed>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        m_objectChoice.get<::nds::rules::types::ProhibitedParking>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        m_objectChoice.get<::nds::rules::types::DontStopZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::write(context.getAutomatedDrivingClearance(), out, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        m_objectChoice.get<::nds::rules::types::Roadworks>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesRoadRangeAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedPassage(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        return ::zserio::AnyHolder<>(::nds::rules::types::OvertakingProhibition(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::SpeedLimitKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::SpeedLimitMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::MinimumSpeedKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::MinimumSpeedMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdvisorySpeedLimitKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdvisorySpeedLimitMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficEnforcementZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return ::zserio::AnyHolder<>(::nds::rules::types::NonDefaultDrivingSide(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficZone>(in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AdrTunnelCategory>(in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return ::zserio::AnyHolder<>(::nds::rules::types::LicensePlateRestriction(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        return ::zserio::AnyHolder<>(::nds::rules::types::SeasonalClosed(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedParking(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedStopping(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::DontStopZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AutomatedDrivingClearance>(in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        return ::zserio::AnyHolder<>(::nds::rules::types::Roadworks(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesRoadRangeAttributeValue::readObject(RulesRoadRangeAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedPassage(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        return ::zserio::AnyHolder<>(::nds::rules::types::OvertakingProhibition(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(context.getSpeedLimitKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getSpeedLimitMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        return ::zserio::AnyHolder<>(context.getMinimumSpeedKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getMinimumSpeedMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(context.getAdvisorySpeedLimitKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getAdvisorySpeedLimitMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficEnforcementZone(context.getTrafficEnforcementZone(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return ::zserio::AnyHolder<>(::nds::rules::types::NonDefaultDrivingSide(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficZone>(context.getTrafficZone(), in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AdrTunnelCategory>(context.getAdrTunnelCategory(), in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return ::zserio::AnyHolder<>(::nds::rules::types::LicensePlateRestriction(context.getLicensePlateRestriction(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        return ::zserio::AnyHolder<>(::nds::rules::types::SeasonalClosed(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedParking(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedStopping(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::DontStopZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AutomatedDrivingClearance>(context.getAutomatedDrivingClearance(), in), allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        return ::zserio::AnyHolder<>(::nds::rules::types::Roadworks(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesRoadRangeAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedPassage>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::OVERTAKING_PROHIBITION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::OvertakingProhibition>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SpeedLimitKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SpeedLimitMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MinimumSpeedKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MinimumSpeedMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdvisorySpeedLimitKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdvisorySpeedLimitMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficEnforcementZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::NonDefaultDrivingSide>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::TRAFFIC_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdrTunnelCategory>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::LicensePlateRestriction>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::SEASONAL_CLOSED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SeasonalClosed>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_PARKING:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedParking>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::PROHIBITED_STOPPING:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedStopping>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::DONT_STOP_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::DontStopZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AutomatedDrivingClearance>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadRangeAttributeType::ROADWORKS:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::Roadworks>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadRangeAttributeValue!");
    }
}

} // namespace attributes
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/attributes/RulesRoadPositionAttributeValue.h>

namespace nds
{
namespace rules
{
namespace attributes
{

RulesRoadPositionAttributeValue::RulesRoadPositionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RulesRoadPositionAttributeValue::RulesRoadPositionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRoadPositionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RulesRoadPositionAttributeValue::RulesRoadPositionAttributeValue(RulesRoadPositionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRoadPositionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RulesRoadPositionAttributeValue::RulesRoadPositionAttributeValue(const RulesRoadPositionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeValue& RulesRoadPositionAttributeValue::operator=(const RulesRoadPositionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeValue::RulesRoadPositionAttributeValue(RulesRoadPositionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeValue& RulesRoadPositionAttributeValue::operator=(RulesRoadPositionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeValue::RulesRoadPositionAttributeValue(::zserio::PropagateAllocatorT,
        const RulesRoadPositionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RulesRoadPositionAttributeValue::initialize(
        ::nds::rules::attributes::RulesRoadPositionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RulesRoadPositionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesRoadPositionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesRoadPositionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::rules::types::TrafficLights& RulesRoadPositionAttributeValue::getTrafficLights()
{
    return m_objectChoice.get<::nds::rules::types::TrafficLights>();
}

const ::nds::rules::types::TrafficLights& RulesRoadPositionAttributeValue::getTrafficLights() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficLights>();
}

void RulesRoadPositionAttributeValue::setTrafficLights(const ::nds::rules::types::TrafficLights& trafficLights_)
{
    m_objectChoice = trafficLights_;
}

void RulesRoadPositionAttributeValue::setTrafficLights(::nds::rules::types::TrafficLights&& trafficLights_)
{
    m_objectChoice = ::std::move(trafficLights_);
}

::nds::rules::types::TrafficEnforcementCamera RulesRoadPositionAttributeValue::getTrafficEnforcementCamera() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>();
}

void RulesRoadPositionAttributeValue::setTrafficEnforcementCamera(::nds::rules::types::TrafficEnforcementCamera trafficEnforcementCamera_)
{
    m_objectChoice = trafficEnforcementCamera_;
}

::nds::rules::types::MovableWarningSign RulesRoadPositionAttributeValue::getMovableWarningSign() const
{
    return m_objectChoice.get<::nds::rules::types::MovableWarningSign>();
}

void RulesRoadPositionAttributeValue::setMovableWarningSign(::nds::rules::types::MovableWarningSign movableWarningSign_)
{
    m_objectChoice = movableWarningSign_;
}

::nds::signs::warning::WarningSign RulesRoadPositionAttributeValue::getWarningSign() const
{
    return m_objectChoice.get<::nds::signs::warning::WarningSign>();
}

void RulesRoadPositionAttributeValue::setWarningSign(::nds::signs::warning::WarningSign warningSign_)
{
    m_objectChoice = warningSign_;
}

RulesRoadPositionAttributeValue::ChoiceTag RulesRoadPositionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        return CHOICE_trafficLights;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return CHOICE_trafficEnforcementCamera;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        return CHOICE_movableWarningSign;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        return CHOICE_warningSign;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RulesRoadPositionAttributeValue::initPackingContext(RulesRoadPositionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::initPackingContext(context.getTrafficEnforcementCamera(), m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        ::zserio::initPackingContext(context.getMovableWarningSign(), m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        ::zserio::initPackingContext(context.getWarningSign(), m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }
}

size_t RulesRoadPositionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLights>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeValue::bitSizeOf(RulesRoadPositionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLights>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficEnforcementCamera(), m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(context.getMovableWarningSign(), m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(context.getWarningSign(), m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLights>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }

    return endBitPosition;
}

size_t RulesRoadPositionAttributeValue::initializeOffsets(RulesRoadPositionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLights>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficEnforcementCamera(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(context.getMovableWarningSign(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(context.getWarningSign(), endBitPosition,
        m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }

    return endBitPosition;
}

bool RulesRoadPositionAttributeValue::operator==(const RulesRoadPositionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficLights>() == other.m_objectChoice.get<::nds::rules::types::TrafficLights>());
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>() == other.m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MovableWarningSign>() == other.m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::signs::warning::WarningSign>() == other.m_objectChoice.get<::nds::signs::warning::WarningSign>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }
}

uint32_t RulesRoadPositionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficLights>());
            break;
        case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
            break;
        case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
            break;
        case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::signs::warning::WarningSign>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RulesRoadPositionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        m_objectChoice.get<::nds::rules::types::TrafficLights>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        ::zserio::write(out, m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }
}

void RulesRoadPositionAttributeValue::write(RulesRoadPositionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        m_objectChoice.get<::nds::rules::types::TrafficLights>().write(out);
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::write(context.getTrafficEnforcementCamera(), out, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        ::zserio::write(context.getMovableWarningSign(), out, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        ::zserio::write(context.getWarningSign(), out, m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesRoadPositionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLights(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficEnforcementCamera>(in), allocator);
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::MovableWarningSign>(in), allocator);
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::WarningSign>(in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesRoadPositionAttributeValue::readObject(RulesRoadPositionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLights(in, allocator), allocator);
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficEnforcementCamera>(context.getTrafficEnforcementCamera(), in), allocator);
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::MovableWarningSign>(context.getMovableWarningSign(), in), allocator);
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::WarningSign>(context.getWarningSign(), in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesRoadPositionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_LIGHTS:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficLights>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficEnforcementCamera>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::MOVABLE_WARNING_SIGN:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MovableWarningSign>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesRoadPositionAttributeType::WARNING_SIGN:
        return ::zserio::allocatorPropagatingCopy<::nds::signs::warning::WarningSign>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesRoadPositionAttributeValue!");
    }
}

} // namespace attributes
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/attributes/RulesLaneRangeAttributeValue.h>

namespace nds
{
namespace rules
{
namespace attributes
{

RulesLaneRangeAttributeValue::RulesLaneRangeAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RulesLaneRangeAttributeValue::RulesLaneRangeAttributeValue(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLaneRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RulesLaneRangeAttributeValue::RulesLaneRangeAttributeValue(RulesLaneRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLaneRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RulesLaneRangeAttributeValue::RulesLaneRangeAttributeValue(const RulesLaneRangeAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeValue& RulesLaneRangeAttributeValue::operator=(const RulesLaneRangeAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeValue::RulesLaneRangeAttributeValue(RulesLaneRangeAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeValue& RulesLaneRangeAttributeValue::operator=(RulesLaneRangeAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeValue::RulesLaneRangeAttributeValue(::zserio::PropagateAllocatorT,
        const RulesLaneRangeAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RulesLaneRangeAttributeValue::initialize(
        ::nds::rules::attributes::RulesLaneRangeAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RulesLaneRangeAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesLaneRangeAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesLaneRangeAttributeValue' is not initialized!");

    return m_type_;
}

::nds::rules::types::ProhibitedPassage& RulesLaneRangeAttributeValue::getProhibitedPassage()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedPassage>();
}

const ::nds::rules::types::ProhibitedPassage& RulesLaneRangeAttributeValue::getProhibitedPassage() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedPassage>();
}

void RulesLaneRangeAttributeValue::setProhibitedPassage(const ::nds::rules::types::ProhibitedPassage& prohibitedPassage_)
{
    m_objectChoice = prohibitedPassage_;
}

void RulesLaneRangeAttributeValue::setProhibitedPassage(::nds::rules::types::ProhibitedPassage&& prohibitedPassage_)
{
    m_objectChoice = ::std::move(prohibitedPassage_);
}

::nds::rules::types::OvertakingProhibition& RulesLaneRangeAttributeValue::getOvertakingProhibition()
{
    return m_objectChoice.get<::nds::rules::types::OvertakingProhibition>();
}

const ::nds::rules::types::OvertakingProhibition& RulesLaneRangeAttributeValue::getOvertakingProhibition() const
{
    return m_objectChoice.get<::nds::rules::types::OvertakingProhibition>();
}

void RulesLaneRangeAttributeValue::setOvertakingProhibition(const ::nds::rules::types::OvertakingProhibition& overtakingProhibition_)
{
    m_objectChoice = overtakingProhibition_;
}

void RulesLaneRangeAttributeValue::setOvertakingProhibition(::nds::rules::types::OvertakingProhibition&& overtakingProhibition_)
{
    m_objectChoice = ::std::move(overtakingProhibition_);
}

::nds::rules::types::SpeedLimitKmh RulesLaneRangeAttributeValue::getSpeedLimitKmh() const
{
    return m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>();
}

void RulesLaneRangeAttributeValue::setSpeedLimitKmh(::nds::rules::types::SpeedLimitKmh speedLimitKmh_)
{
    m_objectChoice = speedLimitKmh_;
}

::nds::rules::types::SpeedLimitMph RulesLaneRangeAttributeValue::getSpeedLimitMph() const
{
    return m_objectChoice.get<::nds::rules::types::SpeedLimitMph>();
}

void RulesLaneRangeAttributeValue::setSpeedLimitMph(::nds::rules::types::SpeedLimitMph speedLimitMph_)
{
    m_objectChoice = speedLimitMph_;
}

::nds::rules::types::MinimumSpeedKmh RulesLaneRangeAttributeValue::getMinimumSpeedKmh() const
{
    return m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>();
}

void RulesLaneRangeAttributeValue::setMinimumSpeedKmh(::nds::rules::types::MinimumSpeedKmh minimumSpeedKmh_)
{
    m_objectChoice = minimumSpeedKmh_;
}

::nds::rules::types::MinimumSpeedMph RulesLaneRangeAttributeValue::getMinimumSpeedMph() const
{
    return m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>();
}

void RulesLaneRangeAttributeValue::setMinimumSpeedMph(::nds::rules::types::MinimumSpeedMph minimumSpeedMph_)
{
    m_objectChoice = minimumSpeedMph_;
}

::nds::rules::types::AdvisorySpeedLimitKmh RulesLaneRangeAttributeValue::getAdvisorySpeedLimitKmh() const
{
    return m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>();
}

void RulesLaneRangeAttributeValue::setAdvisorySpeedLimitKmh(::nds::rules::types::AdvisorySpeedLimitKmh advisorySpeedLimitKmh_)
{
    m_objectChoice = advisorySpeedLimitKmh_;
}

::nds::rules::types::AdvisorySpeedLimitMph RulesLaneRangeAttributeValue::getAdvisorySpeedLimitMph() const
{
    return m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>();
}

void RulesLaneRangeAttributeValue::setAdvisorySpeedLimitMph(::nds::rules::types::AdvisorySpeedLimitMph advisorySpeedLimitMph_)
{
    m_objectChoice = advisorySpeedLimitMph_;
}

::nds::rules::types::TrafficEnforcementZone& RulesLaneRangeAttributeValue::getTrafficEnforcementZone()
{
    return m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>();
}

const ::nds::rules::types::TrafficEnforcementZone& RulesLaneRangeAttributeValue::getTrafficEnforcementZone() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>();
}

void RulesLaneRangeAttributeValue::setTrafficEnforcementZone(const ::nds::rules::types::TrafficEnforcementZone& trafficEnforcementZone_)
{
    m_objectChoice = trafficEnforcementZone_;
}

void RulesLaneRangeAttributeValue::setTrafficEnforcementZone(::nds::rules::types::TrafficEnforcementZone&& trafficEnforcementZone_)
{
    m_objectChoice = ::std::move(trafficEnforcementZone_);
}

::nds::rules::types::TrafficZone RulesLaneRangeAttributeValue::getTrafficZone() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficZone>();
}

void RulesLaneRangeAttributeValue::setTrafficZone(::nds::rules::types::TrafficZone trafficZone_)
{
    m_objectChoice = trafficZone_;
}

::nds::rules::types::SeasonalClosed& RulesLaneRangeAttributeValue::getSeasonalClosed()
{
    return m_objectChoice.get<::nds::rules::types::SeasonalClosed>();
}

const ::nds::rules::types::SeasonalClosed& RulesLaneRangeAttributeValue::getSeasonalClosed() const
{
    return m_objectChoice.get<::nds::rules::types::SeasonalClosed>();
}

void RulesLaneRangeAttributeValue::setSeasonalClosed(const ::nds::rules::types::SeasonalClosed& seasonalClosed_)
{
    m_objectChoice = seasonalClosed_;
}

void RulesLaneRangeAttributeValue::setSeasonalClosed(::nds::rules::types::SeasonalClosed&& seasonalClosed_)
{
    m_objectChoice = ::std::move(seasonalClosed_);
}

::nds::rules::types::DontStopZone& RulesLaneRangeAttributeValue::getDontStopZone()
{
    return m_objectChoice.get<::nds::rules::types::DontStopZone>();
}

const ::nds::rules::types::DontStopZone& RulesLaneRangeAttributeValue::getDontStopZone() const
{
    return m_objectChoice.get<::nds::rules::types::DontStopZone>();
}

void RulesLaneRangeAttributeValue::setDontStopZone(const ::nds::rules::types::DontStopZone& dontStopZone_)
{
    m_objectChoice = dontStopZone_;
}

void RulesLaneRangeAttributeValue::setDontStopZone(::nds::rules::types::DontStopZone&& dontStopZone_)
{
    m_objectChoice = ::std::move(dontStopZone_);
}

::nds::rules::types::ProhibitedParking& RulesLaneRangeAttributeValue::getProhibitedParking()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedParking>();
}

const ::nds::rules::types::ProhibitedParking& RulesLaneRangeAttributeValue::getProhibitedParking() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedParking>();
}

void RulesLaneRangeAttributeValue::setProhibitedParking(const ::nds::rules::types::ProhibitedParking& prohibitedParking_)
{
    m_objectChoice = prohibitedParking_;
}

void RulesLaneRangeAttributeValue::setProhibitedParking(::nds::rules::types::ProhibitedParking&& prohibitedParking_)
{
    m_objectChoice = ::std::move(prohibitedParking_);
}

::nds::rules::types::ProhibitedStopping& RulesLaneRangeAttributeValue::getProhibitedStopping()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedStopping>();
}

const ::nds::rules::types::ProhibitedStopping& RulesLaneRangeAttributeValue::getProhibitedStopping() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedStopping>();
}

void RulesLaneRangeAttributeValue::setProhibitedStopping(const ::nds::rules::types::ProhibitedStopping& prohibitedStopping_)
{
    m_objectChoice = prohibitedStopping_;
}

void RulesLaneRangeAttributeValue::setProhibitedStopping(::nds::rules::types::ProhibitedStopping&& prohibitedStopping_)
{
    m_objectChoice = ::std::move(prohibitedStopping_);
}

::nds::rules::types::AutomatedDrivingClearance RulesLaneRangeAttributeValue::getAutomatedDrivingClearance() const
{
    return m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>();
}

void RulesLaneRangeAttributeValue::setAutomatedDrivingClearance(::nds::rules::types::AutomatedDrivingClearance automatedDrivingClearance_)
{
    m_objectChoice = automatedDrivingClearance_;
}

::nds::rules::types::Roadworks& RulesLaneRangeAttributeValue::getRoadworks()
{
    return m_objectChoice.get<::nds::rules::types::Roadworks>();
}

const ::nds::rules::types::Roadworks& RulesLaneRangeAttributeValue::getRoadworks() const
{
    return m_objectChoice.get<::nds::rules::types::Roadworks>();
}

void RulesLaneRangeAttributeValue::setRoadworks(const ::nds::rules::types::Roadworks& roadworks_)
{
    m_objectChoice = roadworks_;
}

void RulesLaneRangeAttributeValue::setRoadworks(::nds::rules::types::Roadworks&& roadworks_)
{
    m_objectChoice = ::std::move(roadworks_);
}

::nds::rules::types::LaneRightOfWayRegulation& RulesLaneRangeAttributeValue::getLaneRightOfWayRegulation()
{
    return m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>();
}

const ::nds::rules::types::LaneRightOfWayRegulation& RulesLaneRangeAttributeValue::getLaneRightOfWayRegulation() const
{
    return m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>();
}

void RulesLaneRangeAttributeValue::setLaneRightOfWayRegulation(const ::nds::rules::types::LaneRightOfWayRegulation& laneRightOfWayRegulation_)
{
    m_objectChoice = laneRightOfWayRegulation_;
}

void RulesLaneRangeAttributeValue::setLaneRightOfWayRegulation(::nds::rules::types::LaneRightOfWayRegulation&& laneRightOfWayRegulation_)
{
    m_objectChoice = ::std::move(laneRightOfWayRegulation_);
}

::nds::rules::types::LaneTrafficPriority& RulesLaneRangeAttributeValue::getLaneTrafficPriority()
{
    return m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>();
}

const ::nds::rules::types::LaneTrafficPriority& RulesLaneRangeAttributeValue::getLaneTrafficPriority() const
{
    return m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>();
}

void RulesLaneRangeAttributeValue::setLaneTrafficPriority(const ::nds::rules::types::LaneTrafficPriority& laneTrafficPriority_)
{
    m_objectChoice = laneTrafficPriority_;
}

void RulesLaneRangeAttributeValue::setLaneTrafficPriority(::nds::rules::types::LaneTrafficPriority&& laneTrafficPriority_)
{
    m_objectChoice = ::std::move(laneTrafficPriority_);
}

RulesLaneRangeAttributeValue::ChoiceTag RulesLaneRangeAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        return CHOICE_prohibitedPassage;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        return CHOICE_overtakingProhibition;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        return CHOICE_speedLimitKmh;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return CHOICE_speedLimitMph;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        return CHOICE_minimumSpeedKmh;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return CHOICE_minimumSpeedMph;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return CHOICE_advisorySpeedLimitKmh;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return CHOICE_advisorySpeedLimitMph;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return CHOICE_trafficEnforcementZone;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        return CHOICE_trafficZone;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        return CHOICE_seasonalClosed;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        return CHOICE_dontStopZone;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        return CHOICE_prohibitedParking;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        return CHOICE_prohibitedStopping;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return CHOICE_automatedDrivingClearance;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        return CHOICE_roadworks;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        return CHOICE_laneRightOfWayRegulation;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        return CHOICE_laneTrafficPriority;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RulesLaneRangeAttributeValue::initPackingContext(RulesLaneRangeAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        context.getSpeedLimitKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        context.getSpeedLimitMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        context.getMinimumSpeedKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        context.getMinimumSpeedMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        context.getAdvisorySpeedLimitKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        context.getAdvisorySpeedLimitMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().initPackingContext(context.getTrafficEnforcementZone());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        ::zserio::initPackingContext(context.getTrafficZone(), m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::initPackingContext(context.getAutomatedDrivingClearance(), m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>().initPackingContext(context.getLaneRightOfWayRegulation());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>().initPackingContext(context.getLaneTrafficPriority());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }
}

size_t RulesLaneRangeAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SeasonalClosed>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::DontStopZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedParking>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::Roadworks>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        endBitPosition += m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeValue::bitSizeOf(RulesLaneRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += context.getSpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getSpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += context.getMinimumSpeedKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += context.getMinimumSpeedMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdvisorySpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdvisorySpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().bitSizeOf(context.getTrafficEnforcementZone(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficZone(), m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SeasonalClosed>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::DontStopZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedParking>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition += ::zserio::bitSizeOf(context.getAutomatedDrivingClearance(), m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::Roadworks>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>().bitSizeOf(context.getLaneRightOfWayRegulation(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        endBitPosition += m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>().bitSizeOf(context.getLaneTrafficPriority(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SeasonalClosed>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::DontStopZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedParking>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::Roadworks>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        endBitPosition = m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }

    return endBitPosition;
}

size_t RulesLaneRangeAttributeValue::initializeOffsets(RulesLaneRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += context.getSpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getSpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += context.getMinimumSpeedKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += context.getMinimumSpeedMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdvisorySpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdvisorySpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().initializeOffsets(context.getTrafficEnforcementZone(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficZone(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SeasonalClosed>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::DontStopZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedParking>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition = ::zserio::initializeOffsets(context.getAutomatedDrivingClearance(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::Roadworks>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>().initializeOffsets(context.getLaneRightOfWayRegulation(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        endBitPosition = m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>().initializeOffsets(context.getLaneTrafficPriority(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }

    return endBitPosition;
}

bool RulesLaneRangeAttributeValue::operator==(const RulesLaneRangeAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedPassage>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedPassage>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::OvertakingProhibition>() == other.m_objectChoice.get<::nds::rules::types::OvertakingProhibition>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>() == other.m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SpeedLimitMph>() == other.m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>() == other.m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>() == other.m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>() == other.m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>() == other.m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>() == other.m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficZone>() == other.m_objectChoice.get<::nds::rules::types::TrafficZone>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SeasonalClosed>() == other.m_objectChoice.get<::nds::rules::types::SeasonalClosed>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::DontStopZone>() == other.m_objectChoice.get<::nds::rules::types::DontStopZone>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedParking>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedParking>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedStopping>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedStopping>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>() == other.m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::Roadworks>() == other.m_objectChoice.get<::nds::rules::types::Roadworks>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>() == other.m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>());
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>() == other.m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }
}

uint32_t RulesLaneRangeAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedPassage>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::OvertakingProhibition>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficZone>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SeasonalClosed>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::DontStopZone>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedParking>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedStopping>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::Roadworks>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>());
            break;
        case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RulesLaneRangeAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        m_objectChoice.get<::nds::rules::types::SeasonalClosed>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        m_objectChoice.get<::nds::rules::types::DontStopZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        m_objectChoice.get<::nds::rules::types::ProhibitedParking>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        m_objectChoice.get<::nds::rules::types::Roadworks>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }
}

void RulesLaneRangeAttributeValue::write(RulesLaneRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        context.getSpeedLimitKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(out, m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        context.getSpeedLimitMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(out, m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        context.getMinimumSpeedKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(out, m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        context.getMinimumSpeedMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(out, m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        context.getAdvisorySpeedLimitKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(out, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        context.getAdvisorySpeedLimitMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(out, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().write(context.getTrafficEnforcementZone(), out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        ::zserio::write(context.getTrafficZone(), out, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        m_objectChoice.get<::nds::rules::types::SeasonalClosed>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        m_objectChoice.get<::nds::rules::types::DontStopZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        m_objectChoice.get<::nds::rules::types::ProhibitedParking>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::write(context.getAutomatedDrivingClearance(), out, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        m_objectChoice.get<::nds::rules::types::Roadworks>().write(out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        m_objectChoice.get<::nds::rules::types::LaneRightOfWayRegulation>().write(context.getLaneRightOfWayRegulation(), out);
        break;
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        m_objectChoice.get<::nds::rules::types::LaneTrafficPriority>().write(context.getLaneTrafficPriority(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesLaneRangeAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedPassage(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        return ::zserio::AnyHolder<>(::nds::rules::types::OvertakingProhibition(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::SpeedLimitKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::SpeedLimitMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::MinimumSpeedKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::MinimumSpeedMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdvisorySpeedLimitKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdvisorySpeedLimitMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficEnforcementZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficZone>(in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        return ::zserio::AnyHolder<>(::nds::rules::types::SeasonalClosed(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::DontStopZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedParking(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedStopping(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AutomatedDrivingClearance>(in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        return ::zserio::AnyHolder<>(::nds::rules::types::Roadworks(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        return ::zserio::AnyHolder<>(::nds::rules::types::LaneRightOfWayRegulation(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        return ::zserio::AnyHolder<>(::nds::rules::types::LaneTrafficPriority(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesLaneRangeAttributeValue::readObject(RulesLaneRangeAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedPassage(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        return ::zserio::AnyHolder<>(::nds::rules::types::OvertakingProhibition(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(context.getSpeedLimitKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getSpeedLimitMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        return ::zserio::AnyHolder<>(context.getMinimumSpeedKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getMinimumSpeedMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(context.getAdvisorySpeedLimitKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getAdvisorySpeedLimitMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficEnforcementZone(context.getTrafficEnforcementZone(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficZone>(context.getTrafficZone(), in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        return ::zserio::AnyHolder<>(::nds::rules::types::SeasonalClosed(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::DontStopZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedParking(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedStopping(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AutomatedDrivingClearance>(context.getAutomatedDrivingClearance(), in), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        return ::zserio::AnyHolder<>(::nds::rules::types::Roadworks(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        return ::zserio::AnyHolder<>(::nds::rules::types::LaneRightOfWayRegulation(context.getLaneRightOfWayRegulation(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        return ::zserio::AnyHolder<>(::nds::rules::types::LaneTrafficPriority(context.getLaneTrafficPriority(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesLaneRangeAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedPassage>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::OVERTAKING_PROHIBITION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::OvertakingProhibition>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SpeedLimitKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SpeedLimitMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MinimumSpeedKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MinimumSpeedMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdvisorySpeedLimitKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdvisorySpeedLimitMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficEnforcementZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::TRAFFIC_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::SEASONAL_CLOSED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SeasonalClosed>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::DONT_STOP_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::DontStopZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_PARKING:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedParking>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::PROHIBITED_STOPPING:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedStopping>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AutomatedDrivingClearance>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::ROADWORKS:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::Roadworks>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_RIGHT_OF_WAY_REGULATION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::LaneRightOfWayRegulation>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLaneRangeAttributeType::LANE_TRAFFIC_PRIORITY:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::LaneTrafficPriority>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLaneRangeAttributeValue!");
    }
}

} // namespace attributes
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/attributes/RulesLanePositionAttributeValue.h>

namespace nds
{
namespace rules
{
namespace attributes
{

RulesLanePositionAttributeValue::RulesLanePositionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RulesLanePositionAttributeValue::RulesLanePositionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLanePositionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RulesLanePositionAttributeValue::RulesLanePositionAttributeValue(RulesLanePositionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLanePositionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RulesLanePositionAttributeValue::RulesLanePositionAttributeValue(const RulesLanePositionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeValue& RulesLanePositionAttributeValue::operator=(const RulesLanePositionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeValue::RulesLanePositionAttributeValue(RulesLanePositionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeValue& RulesLanePositionAttributeValue::operator=(RulesLanePositionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeValue::RulesLanePositionAttributeValue(::zserio::PropagateAllocatorT,
        const RulesLanePositionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RulesLanePositionAttributeValue::initialize(
        ::nds::rules::attributes::RulesLanePositionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RulesLanePositionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesLanePositionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesLanePositionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::rules::types::TrafficLights& RulesLanePositionAttributeValue::getTrafficLights()
{
    return m_objectChoice.get<::nds::rules::types::TrafficLights>();
}

const ::nds::rules::types::TrafficLights& RulesLanePositionAttributeValue::getTrafficLights() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficLights>();
}

void RulesLanePositionAttributeValue::setTrafficLights(const ::nds::rules::types::TrafficLights& trafficLights_)
{
    m_objectChoice = trafficLights_;
}

void RulesLanePositionAttributeValue::setTrafficLights(::nds::rules::types::TrafficLights&& trafficLights_)
{
    m_objectChoice = ::std::move(trafficLights_);
}

::nds::rules::types::TrafficEnforcementCamera RulesLanePositionAttributeValue::getTrafficEnforcementCamera() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>();
}

void RulesLanePositionAttributeValue::setTrafficEnforcementCamera(::nds::rules::types::TrafficEnforcementCamera trafficEnforcementCamera_)
{
    m_objectChoice = trafficEnforcementCamera_;
}

::nds::signs::warning::WarningSign RulesLanePositionAttributeValue::getWarningSign() const
{
    return m_objectChoice.get<::nds::signs::warning::WarningSign>();
}

void RulesLanePositionAttributeValue::setWarningSign(::nds::signs::warning::WarningSign warningSign_)
{
    m_objectChoice = warningSign_;
}

::nds::rules::types::MovableWarningSign RulesLanePositionAttributeValue::getMovableWarningSign() const
{
    return m_objectChoice.get<::nds::rules::types::MovableWarningSign>();
}

void RulesLanePositionAttributeValue::setMovableWarningSign(::nds::rules::types::MovableWarningSign movableWarningSign_)
{
    m_objectChoice = movableWarningSign_;
}

::nds::rules::types::RightOfWayType RulesLanePositionAttributeValue::getRightOfWayType() const
{
    return m_objectChoice.get<::nds::rules::types::RightOfWayType>();
}

void RulesLanePositionAttributeValue::setRightOfWayType(::nds::rules::types::RightOfWayType rightOfWayType_)
{
    m_objectChoice = rightOfWayType_;
}

RulesLanePositionAttributeValue::ChoiceTag RulesLanePositionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        return CHOICE_trafficLights;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return CHOICE_trafficEnforcementCamera;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        return CHOICE_warningSign;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        return CHOICE_movableWarningSign;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        return CHOICE_rightOfWayType;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RulesLanePositionAttributeValue::initPackingContext(RulesLanePositionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::initPackingContext(context.getTrafficEnforcementCamera(), m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        ::zserio::initPackingContext(context.getWarningSign(), m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        ::zserio::initPackingContext(context.getMovableWarningSign(), m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        ::zserio::initPackingContext(context.getRightOfWayType(), m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }
}

size_t RulesLanePositionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLights>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeValue::bitSizeOf(RulesLanePositionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLights>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficEnforcementCamera(), m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(context.getWarningSign(), m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(context.getMovableWarningSign(), m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        endBitPosition += ::zserio::bitSizeOf(context.getRightOfWayType(), m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLights>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }

    return endBitPosition;
}

size_t RulesLanePositionAttributeValue::initializeOffsets(RulesLanePositionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLights>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficEnforcementCamera(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(context.getWarningSign(), endBitPosition,
        m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(context.getMovableWarningSign(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        endBitPosition = ::zserio::initializeOffsets(context.getRightOfWayType(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }

    return endBitPosition;
}

bool RulesLanePositionAttributeValue::operator==(const RulesLanePositionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficLights>() == other.m_objectChoice.get<::nds::rules::types::TrafficLights>());
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>() == other.m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::signs::warning::WarningSign>() == other.m_objectChoice.get<::nds::signs::warning::WarningSign>());
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MovableWarningSign>() == other.m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::RightOfWayType>() == other.m_objectChoice.get<::nds::rules::types::RightOfWayType>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }
}

uint32_t RulesLanePositionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficLights>());
            break;
        case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
            break;
        case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::signs::warning::WarningSign>());
            break;
        case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
            break;
        case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::RightOfWayType>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RulesLanePositionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        m_objectChoice.get<::nds::rules::types::TrafficLights>().write(out);
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        ::zserio::write(out, m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }
}

void RulesLanePositionAttributeValue::write(RulesLanePositionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        m_objectChoice.get<::nds::rules::types::TrafficLights>().write(out);
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::write(context.getTrafficEnforcementCamera(), out, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        ::zserio::write(context.getWarningSign(), out, m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        ::zserio::write(context.getMovableWarningSign(), out, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        ::zserio::write(context.getRightOfWayType(), out, m_objectChoice.get<::nds::rules::types::RightOfWayType>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesLanePositionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLights(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficEnforcementCamera>(in), allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::WarningSign>(in), allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::MovableWarningSign>(in), allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::RightOfWayType>(in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesLanePositionAttributeValue::readObject(RulesLanePositionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLights(in, allocator), allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficEnforcementCamera>(context.getTrafficEnforcementCamera(), in), allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::WarningSign>(context.getWarningSign(), in), allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::MovableWarningSign>(context.getMovableWarningSign(), in), allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::RightOfWayType>(context.getRightOfWayType(), in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesLanePositionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_LIGHTS:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficLights>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficEnforcementCamera>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::WARNING_SIGN:
        return ::zserio::allocatorPropagatingCopy<::nds::signs::warning::WarningSign>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::MOVABLE_WARNING_SIGN:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MovableWarningSign>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesLanePositionAttributeType::RIGHT_OF_WAY_REGULATION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::RightOfWayType>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesLanePositionAttributeValue!");
    }
}

} // namespace attributes
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/attributes/RulesDisplayLineRangeAttributeValue.h>

namespace nds
{
namespace rules
{
namespace attributes
{

RulesDisplayLineRangeAttributeValue::RulesDisplayLineRangeAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RulesDisplayLineRangeAttributeValue::RulesDisplayLineRangeAttributeValue(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesDisplayLineRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RulesDisplayLineRangeAttributeValue::RulesDisplayLineRangeAttributeValue(RulesDisplayLineRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesDisplayLineRangeAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RulesDisplayLineRangeAttributeValue::RulesDisplayLineRangeAttributeValue(const RulesDisplayLineRangeAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeValue& RulesDisplayLineRangeAttributeValue::operator=(const RulesDisplayLineRangeAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeValue::RulesDisplayLineRangeAttributeValue(RulesDisplayLineRangeAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeValue& RulesDisplayLineRangeAttributeValue::operator=(RulesDisplayLineRangeAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeValue::RulesDisplayLineRangeAttributeValue(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RulesDisplayLineRangeAttributeValue::initialize(
        ::nds::rules::attributes::RulesDisplayLineRangeAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RulesDisplayLineRangeAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeType RulesDisplayLineRangeAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesDisplayLineRangeAttributeValue' is not initialized!");

    return m_type_;
}

::nds::rules::types::ProhibitedPassage& RulesDisplayLineRangeAttributeValue::getProhibitedPassage()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedPassage>();
}

const ::nds::rules::types::ProhibitedPassage& RulesDisplayLineRangeAttributeValue::getProhibitedPassage() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedPassage>();
}

void RulesDisplayLineRangeAttributeValue::setProhibitedPassage(const ::nds::rules::types::ProhibitedPassage& prohibitedPassage_)
{
    m_objectChoice = prohibitedPassage_;
}

void RulesDisplayLineRangeAttributeValue::setProhibitedPassage(::nds::rules::types::ProhibitedPassage&& prohibitedPassage_)
{
    m_objectChoice = ::std::move(prohibitedPassage_);
}

::nds::rules::types::OvertakingProhibition& RulesDisplayLineRangeAttributeValue::getOvertakingProhibition()
{
    return m_objectChoice.get<::nds::rules::types::OvertakingProhibition>();
}

const ::nds::rules::types::OvertakingProhibition& RulesDisplayLineRangeAttributeValue::getOvertakingProhibition() const
{
    return m_objectChoice.get<::nds::rules::types::OvertakingProhibition>();
}

void RulesDisplayLineRangeAttributeValue::setOvertakingProhibition(const ::nds::rules::types::OvertakingProhibition& overtakingProhibition_)
{
    m_objectChoice = overtakingProhibition_;
}

void RulesDisplayLineRangeAttributeValue::setOvertakingProhibition(::nds::rules::types::OvertakingProhibition&& overtakingProhibition_)
{
    m_objectChoice = ::std::move(overtakingProhibition_);
}

::nds::rules::types::SpeedLimitKmh RulesDisplayLineRangeAttributeValue::getSpeedLimitKmh() const
{
    return m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>();
}

void RulesDisplayLineRangeAttributeValue::setSpeedLimitKmh(::nds::rules::types::SpeedLimitKmh speedLimitKmh_)
{
    m_objectChoice = speedLimitKmh_;
}

::nds::rules::types::SpeedLimitMph RulesDisplayLineRangeAttributeValue::getSpeedLimitMph() const
{
    return m_objectChoice.get<::nds::rules::types::SpeedLimitMph>();
}

void RulesDisplayLineRangeAttributeValue::setSpeedLimitMph(::nds::rules::types::SpeedLimitMph speedLimitMph_)
{
    m_objectChoice = speedLimitMph_;
}

::nds::rules::types::MinimumSpeedKmh RulesDisplayLineRangeAttributeValue::getMinimumSpeedKmh() const
{
    return m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>();
}

void RulesDisplayLineRangeAttributeValue::setMinimumSpeedKmh(::nds::rules::types::MinimumSpeedKmh minimumSpeedKmh_)
{
    m_objectChoice = minimumSpeedKmh_;
}

::nds::rules::types::MinimumSpeedMph RulesDisplayLineRangeAttributeValue::getMinimumSpeedMph() const
{
    return m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>();
}

void RulesDisplayLineRangeAttributeValue::setMinimumSpeedMph(::nds::rules::types::MinimumSpeedMph minimumSpeedMph_)
{
    m_objectChoice = minimumSpeedMph_;
}

::nds::rules::types::AdvisorySpeedLimitKmh RulesDisplayLineRangeAttributeValue::getAdvisorySpeedLimitKmh() const
{
    return m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>();
}

void RulesDisplayLineRangeAttributeValue::setAdvisorySpeedLimitKmh(::nds::rules::types::AdvisorySpeedLimitKmh advisorySpeedLimitKmh_)
{
    m_objectChoice = advisorySpeedLimitKmh_;
}

::nds::rules::types::AdvisorySpeedLimitMph RulesDisplayLineRangeAttributeValue::getAdvisorySpeedLimitMph() const
{
    return m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>();
}

void RulesDisplayLineRangeAttributeValue::setAdvisorySpeedLimitMph(::nds::rules::types::AdvisorySpeedLimitMph advisorySpeedLimitMph_)
{
    m_objectChoice = advisorySpeedLimitMph_;
}

::nds::rules::types::TrafficEnforcementZone& RulesDisplayLineRangeAttributeValue::getTrafficEnforcementZone()
{
    return m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>();
}

const ::nds::rules::types::TrafficEnforcementZone& RulesDisplayLineRangeAttributeValue::getTrafficEnforcementZone() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>();
}

void RulesDisplayLineRangeAttributeValue::setTrafficEnforcementZone(const ::nds::rules::types::TrafficEnforcementZone& trafficEnforcementZone_)
{
    m_objectChoice = trafficEnforcementZone_;
}

void RulesDisplayLineRangeAttributeValue::setTrafficEnforcementZone(::nds::rules::types::TrafficEnforcementZone&& trafficEnforcementZone_)
{
    m_objectChoice = ::std::move(trafficEnforcementZone_);
}

::nds::rules::types::NonDefaultDrivingSide& RulesDisplayLineRangeAttributeValue::getNonDefaultDrivingSide()
{
    return m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>();
}

const ::nds::rules::types::NonDefaultDrivingSide& RulesDisplayLineRangeAttributeValue::getNonDefaultDrivingSide() const
{
    return m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>();
}

void RulesDisplayLineRangeAttributeValue::setNonDefaultDrivingSide(const ::nds::rules::types::NonDefaultDrivingSide& nonDefaultDrivingSide_)
{
    m_objectChoice = nonDefaultDrivingSide_;
}

void RulesDisplayLineRangeAttributeValue::setNonDefaultDrivingSide(::nds::rules::types::NonDefaultDrivingSide&& nonDefaultDrivingSide_)
{
    m_objectChoice = ::std::move(nonDefaultDrivingSide_);
}

::nds::rules::types::TrafficZone RulesDisplayLineRangeAttributeValue::getTrafficZone() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficZone>();
}

void RulesDisplayLineRangeAttributeValue::setTrafficZone(::nds::rules::types::TrafficZone trafficZone_)
{
    m_objectChoice = trafficZone_;
}

::nds::rules::types::AdrTunnelCategory RulesDisplayLineRangeAttributeValue::getAdrTunnelCategory() const
{
    return m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>();
}

void RulesDisplayLineRangeAttributeValue::setAdrTunnelCategory(::nds::rules::types::AdrTunnelCategory adrTunnelCategory_)
{
    m_objectChoice = adrTunnelCategory_;
}

::nds::rules::types::LicensePlateRestriction& RulesDisplayLineRangeAttributeValue::getLicensePlateRestriction()
{
    return m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>();
}

const ::nds::rules::types::LicensePlateRestriction& RulesDisplayLineRangeAttributeValue::getLicensePlateRestriction() const
{
    return m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>();
}

void RulesDisplayLineRangeAttributeValue::setLicensePlateRestriction(const ::nds::rules::types::LicensePlateRestriction& licensePlateRestriction_)
{
    m_objectChoice = licensePlateRestriction_;
}

void RulesDisplayLineRangeAttributeValue::setLicensePlateRestriction(::nds::rules::types::LicensePlateRestriction&& licensePlateRestriction_)
{
    m_objectChoice = ::std::move(licensePlateRestriction_);
}

::nds::rules::types::SeasonalClosed& RulesDisplayLineRangeAttributeValue::getSeasonalClosed()
{
    return m_objectChoice.get<::nds::rules::types::SeasonalClosed>();
}

const ::nds::rules::types::SeasonalClosed& RulesDisplayLineRangeAttributeValue::getSeasonalClosed() const
{
    return m_objectChoice.get<::nds::rules::types::SeasonalClosed>();
}

void RulesDisplayLineRangeAttributeValue::setSeasonalClosed(const ::nds::rules::types::SeasonalClosed& seasonalClosed_)
{
    m_objectChoice = seasonalClosed_;
}

void RulesDisplayLineRangeAttributeValue::setSeasonalClosed(::nds::rules::types::SeasonalClosed&& seasonalClosed_)
{
    m_objectChoice = ::std::move(seasonalClosed_);
}

::nds::rules::types::ProhibitedParking& RulesDisplayLineRangeAttributeValue::getProhibitedParking()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedParking>();
}

const ::nds::rules::types::ProhibitedParking& RulesDisplayLineRangeAttributeValue::getProhibitedParking() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedParking>();
}

void RulesDisplayLineRangeAttributeValue::setProhibitedParking(const ::nds::rules::types::ProhibitedParking& prohibitedParking_)
{
    m_objectChoice = prohibitedParking_;
}

void RulesDisplayLineRangeAttributeValue::setProhibitedParking(::nds::rules::types::ProhibitedParking&& prohibitedParking_)
{
    m_objectChoice = ::std::move(prohibitedParking_);
}

::nds::rules::types::ProhibitedStopping& RulesDisplayLineRangeAttributeValue::getProhibitedStopping()
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedStopping>();
}

const ::nds::rules::types::ProhibitedStopping& RulesDisplayLineRangeAttributeValue::getProhibitedStopping() const
{
    return m_objectChoice.get<::nds::rules::types::ProhibitedStopping>();
}

void RulesDisplayLineRangeAttributeValue::setProhibitedStopping(const ::nds::rules::types::ProhibitedStopping& prohibitedStopping_)
{
    m_objectChoice = prohibitedStopping_;
}

void RulesDisplayLineRangeAttributeValue::setProhibitedStopping(::nds::rules::types::ProhibitedStopping&& prohibitedStopping_)
{
    m_objectChoice = ::std::move(prohibitedStopping_);
}

::nds::rules::types::DontStopZone& RulesDisplayLineRangeAttributeValue::getDontStopZone()
{
    return m_objectChoice.get<::nds::rules::types::DontStopZone>();
}

const ::nds::rules::types::DontStopZone& RulesDisplayLineRangeAttributeValue::getDontStopZone() const
{
    return m_objectChoice.get<::nds::rules::types::DontStopZone>();
}

void RulesDisplayLineRangeAttributeValue::setDontStopZone(const ::nds::rules::types::DontStopZone& dontStopZone_)
{
    m_objectChoice = dontStopZone_;
}

void RulesDisplayLineRangeAttributeValue::setDontStopZone(::nds::rules::types::DontStopZone&& dontStopZone_)
{
    m_objectChoice = ::std::move(dontStopZone_);
}

::nds::rules::types::AutomatedDrivingClearance RulesDisplayLineRangeAttributeValue::getAutomatedDrivingClearance() const
{
    return m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>();
}

void RulesDisplayLineRangeAttributeValue::setAutomatedDrivingClearance(::nds::rules::types::AutomatedDrivingClearance automatedDrivingClearance_)
{
    m_objectChoice = automatedDrivingClearance_;
}

::nds::rules::types::Roadworks& RulesDisplayLineRangeAttributeValue::getRoadworks()
{
    return m_objectChoice.get<::nds::rules::types::Roadworks>();
}

const ::nds::rules::types::Roadworks& RulesDisplayLineRangeAttributeValue::getRoadworks() const
{
    return m_objectChoice.get<::nds::rules::types::Roadworks>();
}

void RulesDisplayLineRangeAttributeValue::setRoadworks(const ::nds::rules::types::Roadworks& roadworks_)
{
    m_objectChoice = roadworks_;
}

void RulesDisplayLineRangeAttributeValue::setRoadworks(::nds::rules::types::Roadworks&& roadworks_)
{
    m_objectChoice = ::std::move(roadworks_);
}

RulesDisplayLineRangeAttributeValue::ChoiceTag RulesDisplayLineRangeAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        return CHOICE_prohibitedPassage;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        return CHOICE_overtakingProhibition;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        return CHOICE_speedLimitKmh;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return CHOICE_speedLimitMph;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        return CHOICE_minimumSpeedKmh;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return CHOICE_minimumSpeedMph;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return CHOICE_advisorySpeedLimitKmh;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return CHOICE_advisorySpeedLimitMph;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return CHOICE_trafficEnforcementZone;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return CHOICE_nonDefaultDrivingSide;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        return CHOICE_trafficZone;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return CHOICE_adrTunnelCategory;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return CHOICE_licensePlateRestriction;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        return CHOICE_seasonalClosed;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        return CHOICE_prohibitedParking;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        return CHOICE_prohibitedStopping;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        return CHOICE_dontStopZone;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return CHOICE_automatedDrivingClearance;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        return CHOICE_roadworks;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RulesDisplayLineRangeAttributeValue::initPackingContext(RulesDisplayLineRangeAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        context.getSpeedLimitKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        context.getSpeedLimitMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        context.getMinimumSpeedKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        context.getMinimumSpeedMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        context.getAdvisorySpeedLimitKmh().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        context.getAdvisorySpeedLimitMph().init<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().initPackingContext(context.getTrafficEnforcementZone());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        ::zserio::initPackingContext(context.getTrafficZone(), m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        ::zserio::initPackingContext(context.getAdrTunnelCategory(), m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().initPackingContext(context.getLicensePlateRestriction());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::initPackingContext(context.getAutomatedDrivingClearance(), m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }
}

size_t RulesDisplayLineRangeAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SeasonalClosed>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedParking>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::DontStopZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::Roadworks>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeValue::bitSizeOf(RulesDisplayLineRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += context.getSpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getSpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += context.getMinimumSpeedKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += context.getMinimumSpeedMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdvisorySpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdvisorySpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().bitSizeOf(context.getTrafficEnforcementZone(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficZone(), m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        endBitPosition += ::zserio::bitSizeOf(context.getAdrTunnelCategory(), m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        endBitPosition += m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().bitSizeOf(context.getLicensePlateRestriction(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition += m_objectChoice.get<::nds::rules::types::SeasonalClosed>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedParking>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition += m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition += m_objectChoice.get<::nds::rules::types::DontStopZone>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition += ::zserio::bitSizeOf(context.getAutomatedDrivingClearance(), m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::Roadworks>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SeasonalClosed>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedParking>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::DontStopZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::Roadworks>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }

    return endBitPosition;
}

size_t RulesDisplayLineRangeAttributeValue::initializeOffsets(RulesDisplayLineRangeAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        endBitPosition += context.getSpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getSpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        endBitPosition += context.getMinimumSpeedKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        endBitPosition += context.getMinimumSpeedMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        endBitPosition += context.getAdvisorySpeedLimitKmh().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        endBitPosition += context.getAdvisorySpeedLimitMph().bitSizeOf<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().initializeOffsets(context.getTrafficEnforcementZone(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficZone(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        endBitPosition = ::zserio::initializeOffsets(context.getAdrTunnelCategory(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        endBitPosition = m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().initializeOffsets(context.getLicensePlateRestriction(), endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        endBitPosition = m_objectChoice.get<::nds::rules::types::SeasonalClosed>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedParking>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        endBitPosition = m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        endBitPosition = m_objectChoice.get<::nds::rules::types::DontStopZone>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        endBitPosition = ::zserio::initializeOffsets(context.getAutomatedDrivingClearance(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::Roadworks>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }

    return endBitPosition;
}

bool RulesDisplayLineRangeAttributeValue::operator==(const RulesDisplayLineRangeAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedPassage>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedPassage>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::OvertakingProhibition>() == other.m_objectChoice.get<::nds::rules::types::OvertakingProhibition>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>() == other.m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SpeedLimitMph>() == other.m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>() == other.m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>() == other.m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>() == other.m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>() == other.m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>() == other.m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>() == other.m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficZone>() == other.m_objectChoice.get<::nds::rules::types::TrafficZone>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>() == other.m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>() == other.m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::SeasonalClosed>() == other.m_objectChoice.get<::nds::rules::types::SeasonalClosed>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedParking>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedParking>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::ProhibitedStopping>() == other.m_objectChoice.get<::nds::rules::types::ProhibitedStopping>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::DontStopZone>() == other.m_objectChoice.get<::nds::rules::types::DontStopZone>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>() == other.m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::Roadworks>() == other.m_objectChoice.get<::nds::rules::types::Roadworks>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }
}

uint32_t RulesDisplayLineRangeAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedPassage>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::OvertakingProhibition>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficZone>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::SeasonalClosed>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedParking>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::ProhibitedStopping>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::DontStopZone>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
            break;
        case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::Roadworks>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RulesDisplayLineRangeAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::SpeedLimitMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        out.writeBits(m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>(), UINT8_C(8));
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        m_objectChoice.get<::nds::rules::types::SeasonalClosed>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        m_objectChoice.get<::nds::rules::types::ProhibitedParking>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        m_objectChoice.get<::nds::rules::types::DontStopZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        m_objectChoice.get<::nds::rules::types::Roadworks>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }
}

void RulesDisplayLineRangeAttributeValue::write(RulesDisplayLineRangeAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        m_objectChoice.get<::nds::rules::types::ProhibitedPassage>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        m_objectChoice.get<::nds::rules::types::OvertakingProhibition>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        context.getSpeedLimitKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(out, m_objectChoice.get<::nds::rules::types::SpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        context.getSpeedLimitMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(out, m_objectChoice.get<::nds::rules::types::SpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        context.getMinimumSpeedKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(out, m_objectChoice.get<::nds::rules::types::MinimumSpeedKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        context.getMinimumSpeedMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(out, m_objectChoice.get<::nds::rules::types::MinimumSpeedMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        context.getAdvisorySpeedLimitKmh().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(out, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitKmh>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        context.getAdvisorySpeedLimitMph().write<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(out, m_objectChoice.get<::nds::rules::types::AdvisorySpeedLimitMph>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementZone>().write(context.getTrafficEnforcementZone(), out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        m_objectChoice.get<::nds::rules::types::NonDefaultDrivingSide>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        ::zserio::write(context.getTrafficZone(), out, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        ::zserio::write(context.getAdrTunnelCategory(), out, m_objectChoice.get<::nds::rules::types::AdrTunnelCategory>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        m_objectChoice.get<::nds::rules::types::LicensePlateRestriction>().write(context.getLicensePlateRestriction(), out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        m_objectChoice.get<::nds::rules::types::SeasonalClosed>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        m_objectChoice.get<::nds::rules::types::ProhibitedParking>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        m_objectChoice.get<::nds::rules::types::ProhibitedStopping>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        m_objectChoice.get<::nds::rules::types::DontStopZone>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        ::zserio::write(context.getAutomatedDrivingClearance(), out, m_objectChoice.get<::nds::rules::types::AutomatedDrivingClearance>());
        break;
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        m_objectChoice.get<::nds::rules::types::Roadworks>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesDisplayLineRangeAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedPassage(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        return ::zserio::AnyHolder<>(::nds::rules::types::OvertakingProhibition(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::SpeedLimitKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::SpeedLimitMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::MinimumSpeedKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::MinimumSpeedMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdvisorySpeedLimitKmh>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::AdvisorySpeedLimitMph>(in.readBits(UINT8_C(8))), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficEnforcementZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return ::zserio::AnyHolder<>(::nds::rules::types::NonDefaultDrivingSide(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficZone>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AdrTunnelCategory>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return ::zserio::AnyHolder<>(::nds::rules::types::LicensePlateRestriction(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        return ::zserio::AnyHolder<>(::nds::rules::types::SeasonalClosed(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedParking(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedStopping(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::DontStopZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AutomatedDrivingClearance>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        return ::zserio::AnyHolder<>(::nds::rules::types::Roadworks(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesDisplayLineRangeAttributeValue::readObject(RulesDisplayLineRangeAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedPassage(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        return ::zserio::AnyHolder<>(::nds::rules::types::OvertakingProhibition(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(context.getSpeedLimitKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getSpeedLimitMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::SpeedLimitMph>>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        return ::zserio::AnyHolder<>(context.getMinimumSpeedKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getMinimumSpeedMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::MinimumSpeedMph>>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::AnyHolder<>(context.getAdvisorySpeedLimitKmh().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitKmh>>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::AnyHolder<>(context.getAdvisorySpeedLimitMph().read<::zserio::StdIntArrayTraits<::nds::rules::types::AdvisorySpeedLimitMph>>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficEnforcementZone(context.getTrafficEnforcementZone(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return ::zserio::AnyHolder<>(::nds::rules::types::NonDefaultDrivingSide(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficZone>(context.getTrafficZone(), in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AdrTunnelCategory>(context.getAdrTunnelCategory(), in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return ::zserio::AnyHolder<>(::nds::rules::types::LicensePlateRestriction(context.getLicensePlateRestriction(), in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        return ::zserio::AnyHolder<>(::nds::rules::types::SeasonalClosed(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedParking(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        return ::zserio::AnyHolder<>(::nds::rules::types::ProhibitedStopping(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        return ::zserio::AnyHolder<>(::nds::rules::types::DontStopZone(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::AutomatedDrivingClearance>(context.getAutomatedDrivingClearance(), in), allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        return ::zserio::AnyHolder<>(::nds::rules::types::Roadworks(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesDisplayLineRangeAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PASSAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedPassage>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::OVERTAKING_PROHIBITION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::OvertakingProhibition>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SpeedLimitKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SPEED_LIMIT_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SpeedLimitMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MinimumSpeedKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::MINIMUM_SPEED_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MinimumSpeedMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_METRIC:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdvisorySpeedLimitKmh>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADVISORY_SPEED_LIMIT_IMPERIAL:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdvisorySpeedLimitMph>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficEnforcementZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::NON_DEFAULT_DRIVING_SIDE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::NonDefaultDrivingSide>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::TRAFFIC_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ADR_TUNNEL_CATEGORY:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AdrTunnelCategory>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::LICENSE_PLATE_RESTRICTION:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::LicensePlateRestriction>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::SEASONAL_CLOSED:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::SeasonalClosed>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_PARKING:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedParking>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::PROHIBITED_STOPPING:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::ProhibitedStopping>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::DONT_STOP_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::DontStopZone>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::AUTOMATED_DRIVING_CLEARANCE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::AutomatedDrivingClearance>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLineRangeAttributeType::ROADWORKS:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::Roadworks>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLineRangeAttributeValue!");
    }
}

} // namespace attributes
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/attributes/RulesDisplayLinePositionAttributeValue.h>

namespace nds
{
namespace rules
{
namespace attributes
{

RulesDisplayLinePositionAttributeValue::RulesDisplayLinePositionAttributeValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RulesDisplayLinePositionAttributeValue::RulesDisplayLinePositionAttributeValue(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesDisplayLinePositionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RulesDisplayLinePositionAttributeValue::RulesDisplayLinePositionAttributeValue(RulesDisplayLinePositionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesDisplayLinePositionAttributeType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RulesDisplayLinePositionAttributeValue::RulesDisplayLinePositionAttributeValue(const RulesDisplayLinePositionAttributeValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeValue& RulesDisplayLinePositionAttributeValue::operator=(const RulesDisplayLinePositionAttributeValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeValue::RulesDisplayLinePositionAttributeValue(RulesDisplayLinePositionAttributeValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeValue& RulesDisplayLinePositionAttributeValue::operator=(RulesDisplayLinePositionAttributeValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeValue::RulesDisplayLinePositionAttributeValue(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionAttributeValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RulesDisplayLinePositionAttributeValue::initialize(
        ::nds::rules::attributes::RulesDisplayLinePositionAttributeType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RulesDisplayLinePositionAttributeValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeType RulesDisplayLinePositionAttributeValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RulesDisplayLinePositionAttributeValue' is not initialized!");

    return m_type_;
}

::nds::rules::types::TrafficLights& RulesDisplayLinePositionAttributeValue::getTrafficLights()
{
    return m_objectChoice.get<::nds::rules::types::TrafficLights>();
}

const ::nds::rules::types::TrafficLights& RulesDisplayLinePositionAttributeValue::getTrafficLights() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficLights>();
}

void RulesDisplayLinePositionAttributeValue::setTrafficLights(const ::nds::rules::types::TrafficLights& trafficLights_)
{
    m_objectChoice = trafficLights_;
}

void RulesDisplayLinePositionAttributeValue::setTrafficLights(::nds::rules::types::TrafficLights&& trafficLights_)
{
    m_objectChoice = ::std::move(trafficLights_);
}

::nds::rules::types::TrafficEnforcementCamera RulesDisplayLinePositionAttributeValue::getTrafficEnforcementCamera() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>();
}

void RulesDisplayLinePositionAttributeValue::setTrafficEnforcementCamera(::nds::rules::types::TrafficEnforcementCamera trafficEnforcementCamera_)
{
    m_objectChoice = trafficEnforcementCamera_;
}

::nds::rules::types::MovableWarningSign RulesDisplayLinePositionAttributeValue::getMovableWarningSign() const
{
    return m_objectChoice.get<::nds::rules::types::MovableWarningSign>();
}

void RulesDisplayLinePositionAttributeValue::setMovableWarningSign(::nds::rules::types::MovableWarningSign movableWarningSign_)
{
    m_objectChoice = movableWarningSign_;
}

::nds::signs::warning::WarningSign RulesDisplayLinePositionAttributeValue::getWarningSign() const
{
    return m_objectChoice.get<::nds::signs::warning::WarningSign>();
}

void RulesDisplayLinePositionAttributeValue::setWarningSign(::nds::signs::warning::WarningSign warningSign_)
{
    m_objectChoice = warningSign_;
}

RulesDisplayLinePositionAttributeValue::ChoiceTag RulesDisplayLinePositionAttributeValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        return CHOICE_trafficLights;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return CHOICE_trafficEnforcementCamera;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        return CHOICE_movableWarningSign;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        return CHOICE_warningSign;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RulesDisplayLinePositionAttributeValue::initPackingContext(RulesDisplayLinePositionAttributeValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::initPackingContext(context.getTrafficEnforcementCamera(), m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        ::zserio::initPackingContext(context.getMovableWarningSign(), m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        ::zserio::initPackingContext(context.getWarningSign(), m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }
}

size_t RulesDisplayLinePositionAttributeValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLights>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeValue::bitSizeOf(RulesDisplayLinePositionAttributeValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition += m_objectChoice.get<::nds::rules::types::TrafficLights>().bitSizeOf(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficEnforcementCamera(), m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(context.getMovableWarningSign(), m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        endBitPosition += ::zserio::bitSizeOf(context.getWarningSign(), m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLights>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }

    return endBitPosition;
}

size_t RulesDisplayLinePositionAttributeValue::initializeOffsets(RulesDisplayLinePositionAttributeValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        endBitPosition = m_objectChoice.get<::nds::rules::types::TrafficLights>().initializeOffsets(endBitPosition);
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficEnforcementCamera(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(context.getMovableWarningSign(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        endBitPosition = ::zserio::initializeOffsets(context.getWarningSign(), endBitPosition,
        m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }

    return endBitPosition;
}

bool RulesDisplayLinePositionAttributeValue::operator==(const RulesDisplayLinePositionAttributeValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficLights>() == other.m_objectChoice.get<::nds::rules::types::TrafficLights>());
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>() == other.m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MovableWarningSign>() == other.m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::signs::warning::WarningSign>() == other.m_objectChoice.get<::nds::signs::warning::WarningSign>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }
}

uint32_t RulesDisplayLinePositionAttributeValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficLights>());
            break;
        case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
            break;
        case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
            break;
        case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::signs::warning::WarningSign>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RulesDisplayLinePositionAttributeValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        m_objectChoice.get<::nds::rules::types::TrafficLights>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        ::zserio::write(out, m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }
}

void RulesDisplayLinePositionAttributeValue::write(RulesDisplayLinePositionAttributeValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        m_objectChoice.get<::nds::rules::types::TrafficLights>().write(out);
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::write(context.getTrafficEnforcementCamera(), out, m_objectChoice.get<::nds::rules::types::TrafficEnforcementCamera>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        ::zserio::write(context.getMovableWarningSign(), out, m_objectChoice.get<::nds::rules::types::MovableWarningSign>());
        break;
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        ::zserio::write(context.getWarningSign(), out, m_objectChoice.get<::nds::signs::warning::WarningSign>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesDisplayLinePositionAttributeValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLights(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficEnforcementCamera>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::MovableWarningSign>(in), allocator);
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::WarningSign>(in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesDisplayLinePositionAttributeValue::readObject(RulesDisplayLinePositionAttributeValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        return ::zserio::AnyHolder<>(::nds::rules::types::TrafficLights(in, allocator), allocator);
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficEnforcementCamera>(context.getTrafficEnforcementCamera(), in), allocator);
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::MovableWarningSign>(context.getMovableWarningSign(), in), allocator);
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::signs::warning::WarningSign>(context.getWarningSign(), in), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }
}

::zserio::AnyHolder<> RulesDisplayLinePositionAttributeValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_LIGHTS:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficLights>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficEnforcementCamera>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::MOVABLE_WARNING_SIGN:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MovableWarningSign>(m_objectChoice, allocator);
    case ::nds::rules::attributes::RulesDisplayLinePositionAttributeType::WARNING_SIGN:
        return ::zserio::allocatorPropagatingCopy<::nds::signs::warning::WarningSign>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RulesDisplayLinePositionAttributeValue!");
    }
}

} // namespace attributes
} // namespace rules
} // namespace nds
