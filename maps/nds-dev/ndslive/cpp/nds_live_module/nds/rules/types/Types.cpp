/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/SystemOfMeasurement.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for SystemOfMeasurement enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::rules::types::SystemOfMeasurement>::names;
constexpr ::std::array<::nds::rules::types::SystemOfMeasurement, 2> EnumTraits<::nds::rules::types::SystemOfMeasurement>::values;
constexpr const char* EnumTraits<::nds::rules::types::SystemOfMeasurement>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::SystemOfMeasurement value)
{
    switch (value)
    {
    case ::nds::rules::types::SystemOfMeasurement::IMPERIAL:
        return 0;
    case ::nds::rules::types::SystemOfMeasurement::METRIC:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration SystemOfMeasurement: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::SystemOfMeasurement>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::SystemOfMeasurement valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::SystemOfMeasurement>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::rules::types::SystemOfMeasurement>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration SystemOfMeasurement: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::SystemOfMeasurement>(::nds::rules::types::SystemOfMeasurement value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::SystemOfMeasurement value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::SystemOfMeasurement>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::SystemOfMeasurement)
{
    return UINT8_C(1);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::SystemOfMeasurement value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::SystemOfMeasurement>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::SystemOfMeasurement value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::SystemOfMeasurement value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::SystemOfMeasurement read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::SystemOfMeasurement>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::SystemOfMeasurement>::type>(
                    in.readBits(UINT8_C(1))));
}

template <>
::nds::rules::types::SystemOfMeasurement read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::SystemOfMeasurement>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::SystemOfMeasurement>::type, UINT8_C(1)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::SystemOfMeasurement value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(1));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::SystemOfMeasurement value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::SystemOfMeasurement>::type, UINT8_C(1)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/RightOfWayType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RightOfWayType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::rules::types::RightOfWayType>::names;
constexpr ::std::array<::nds::rules::types::RightOfWayType, 5> EnumTraits<::nds::rules::types::RightOfWayType>::values;
constexpr const char* EnumTraits<::nds::rules::types::RightOfWayType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::RightOfWayType value)
{
    switch (value)
    {
    case ::nds::rules::types::RightOfWayType::NO_SIGN:
        return 0;
    case ::nds::rules::types::RightOfWayType::RIGHT_OF_WAY:
        return 1;
    case ::nds::rules::types::RightOfWayType::GIVE_WAY:
        return 2;
    case ::nds::rules::types::RightOfWayType::STOP_GIVE_WAY:
        return 3;
    case ::nds::rules::types::RightOfWayType::ALL_WAY_STOP:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RightOfWayType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::RightOfWayType>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::RightOfWayType valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::RightOfWayType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::rules::types::RightOfWayType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RightOfWayType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::RightOfWayType>(::nds::rules::types::RightOfWayType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::RightOfWayType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RightOfWayType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::RightOfWayType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::RightOfWayType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RightOfWayType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::RightOfWayType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::RightOfWayType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::RightOfWayType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::RightOfWayType>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::RightOfWayType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::rules::types::RightOfWayType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::RightOfWayType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RightOfWayType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::RightOfWayType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::RightOfWayType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RightOfWayType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/LaneTrafficPriorityReason.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneTrafficPriorityReason enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::rules::types::LaneTrafficPriorityReason>::names;
constexpr ::std::array<::nds::rules::types::LaneTrafficPriorityReason, 3> EnumTraits<::nds::rules::types::LaneTrafficPriorityReason>::values;
constexpr const char* EnumTraits<::nds::rules::types::LaneTrafficPriorityReason>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::LaneTrafficPriorityReason value)
{
    switch (value)
    {
    case ::nds::rules::types::LaneTrafficPriorityReason::UNPROTECTED_GREEN:
        return 0;
    case ::nds::rules::types::LaneTrafficPriorityReason::TRAFFIC_RULE:
        return 1;
    case ::nds::rules::types::LaneTrafficPriorityReason::OPPOSING_LEFT_TURN:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneTrafficPriorityReason: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::LaneTrafficPriorityReason>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::LaneTrafficPriorityReason valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::LaneTrafficPriorityReason>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::rules::types::LaneTrafficPriorityReason>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneTrafficPriorityReason: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::LaneTrafficPriorityReason>(::nds::rules::types::LaneTrafficPriorityReason value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::LaneTrafficPriorityReason value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::LaneTrafficPriorityReason>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::LaneTrafficPriorityReason)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::LaneTrafficPriorityReason value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::LaneTrafficPriorityReason>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::LaneTrafficPriorityReason value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::LaneTrafficPriorityReason value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::LaneTrafficPriorityReason read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::LaneTrafficPriorityReason>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::LaneTrafficPriorityReason>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::rules::types::LaneTrafficPriorityReason read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::LaneTrafficPriorityReason>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::LaneTrafficPriorityReason>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::LaneTrafficPriorityReason value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::LaneTrafficPriorityReason value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::LaneTrafficPriorityReason>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/TrafficZone.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficZone enumeration.
constexpr ::std::array<const char*, 16> EnumTraits<::nds::rules::types::TrafficZone>::names;
constexpr ::std::array<::nds::rules::types::TrafficZone, 16> EnumTraits<::nds::rules::types::TrafficZone>::values;
constexpr const char* EnumTraits<::nds::rules::types::TrafficZone>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::TrafficZone value)
{
    switch (value)
    {
    case ::nds::rules::types::TrafficZone::OTHER:
        return 0;
    case ::nds::rules::types::TrafficZone::ENVIRONMENT_ZONE:
        return 1;
    case ::nds::rules::types::TrafficZone::TOLL_ZONE:
        return 2;
    case ::nds::rules::types::TrafficZone::LIVING_STREET:
        return 3;
    case ::nds::rules::types::TrafficZone::SPEED_LIMIT_ZONE:
        return 4;
    case ::nds::rules::types::TrafficZone::SCHOOL_ZONE:
        return 5;
    case ::nds::rules::types::TrafficZone::LOW_EMISSION_ZONE:
        return 6;
    case ::nds::rules::types::TrafficZone::CONGESTION_ZONE:
        return 7;
    case ::nds::rules::types::TrafficZone::AUTONOMOUS_DRIVING_ZONE:
        return 8;
    case ::nds::rules::types::TrafficZone::NON_AUTONOMOUS_DRIVING_ZONE:
        return 9;
    case ::nds::rules::types::TrafficZone::RESIDENTIAL_AREA:
        return 10;
    case ::nds::rules::types::TrafficZone::GATED_AREA:
        return 11;
    case ::nds::rules::types::TrafficZone::CYCLIST_ROAD:
        return 12;
    case ::nds::rules::types::TrafficZone::RESTRICTED_PARKING_ZONE:
        return 13;
    case ::nds::rules::types::TrafficZone::NO_STOPPING_ZONE:
        return 14;
    case ::nds::rules::types::TrafficZone::NO_BOUNDARY_MARKINGS_ZONE:
        return 15;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficZone: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficZone>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::TrafficZone valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::TrafficZone>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
        return static_cast<::nds::rules::types::TrafficZone>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficZone: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::TrafficZone>(::nds::rules::types::TrafficZone value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::TrafficZone value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficZone>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::TrafficZone)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::TrafficZone value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficZone>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::TrafficZone value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::TrafficZone value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::TrafficZone read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficZone>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficZone>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::rules::types::TrafficZone read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficZone>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficZone>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficZone value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficZone value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficZone>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/AdrTunnelCategory.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AdrTunnelCategory enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::rules::types::AdrTunnelCategory>::names;
constexpr ::std::array<::nds::rules::types::AdrTunnelCategory, 5> EnumTraits<::nds::rules::types::AdrTunnelCategory>::values;
constexpr const char* EnumTraits<::nds::rules::types::AdrTunnelCategory>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::AdrTunnelCategory value)
{
    switch (value)
    {
    case ::nds::rules::types::AdrTunnelCategory::A:
        return 0;
    case ::nds::rules::types::AdrTunnelCategory::B:
        return 1;
    case ::nds::rules::types::AdrTunnelCategory::C:
        return 2;
    case ::nds::rules::types::AdrTunnelCategory::D:
        return 3;
    case ::nds::rules::types::AdrTunnelCategory::E:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdrTunnelCategory: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::AdrTunnelCategory>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::AdrTunnelCategory valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::AdrTunnelCategory>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::rules::types::AdrTunnelCategory>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdrTunnelCategory: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::AdrTunnelCategory>(::nds::rules::types::AdrTunnelCategory value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::AdrTunnelCategory value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::AdrTunnelCategory>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::AdrTunnelCategory)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::AdrTunnelCategory value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::AdrTunnelCategory>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::AdrTunnelCategory value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::AdrTunnelCategory value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::AdrTunnelCategory read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::AdrTunnelCategory>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::AdrTunnelCategory>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::rules::types::AdrTunnelCategory read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::AdrTunnelCategory>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::AdrTunnelCategory>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::AdrTunnelCategory value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::AdrTunnelCategory value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::AdrTunnelCategory>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/LicensePlateRestrictionType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LicensePlateRestrictionType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::rules::types::LicensePlateRestrictionType>::names;
constexpr ::std::array<::nds::rules::types::LicensePlateRestrictionType, 2> EnumTraits<::nds::rules::types::LicensePlateRestrictionType>::values;
constexpr const char* EnumTraits<::nds::rules::types::LicensePlateRestrictionType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::LicensePlateRestrictionType value)
{
    switch (value)
    {
    case ::nds::rules::types::LicensePlateRestrictionType::AREA:
        return 0;
    case ::nds::rules::types::LicensePlateRestrictionType::ROAD:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LicensePlateRestrictionType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::LicensePlateRestrictionType>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::LicensePlateRestrictionType valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::LicensePlateRestrictionType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::rules::types::LicensePlateRestrictionType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LicensePlateRestrictionType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::LicensePlateRestrictionType>(::nds::rules::types::LicensePlateRestrictionType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::LicensePlateRestrictionType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::LicensePlateRestrictionType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::LicensePlateRestrictionType)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::LicensePlateRestrictionType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::LicensePlateRestrictionType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::LicensePlateRestrictionType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::LicensePlateRestrictionType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::LicensePlateRestrictionType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::LicensePlateRestrictionType>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::LicensePlateRestrictionType>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::rules::types::LicensePlateRestrictionType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::LicensePlateRestrictionType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::LicensePlateRestrictionType>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::LicensePlateRestrictionType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::LicensePlateRestrictionType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::LicensePlateRestrictionType>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/LicensePlateDigitRuleType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LicensePlateDigitRuleType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::rules::types::LicensePlateDigitRuleType>::names;
constexpr ::std::array<::nds::rules::types::LicensePlateDigitRuleType, 3> EnumTraits<::nds::rules::types::LicensePlateDigitRuleType>::values;
constexpr const char* EnumTraits<::nds::rules::types::LicensePlateDigitRuleType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::LicensePlateDigitRuleType value)
{
    switch (value)
    {
    case ::nds::rules::types::LicensePlateDigitRuleType::ODD_NUMBER:
        return 0;
    case ::nds::rules::types::LicensePlateDigitRuleType::EVEN_NUMBER:
        return 1;
    case ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LicensePlateDigitRuleType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::LicensePlateDigitRuleType>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::LicensePlateDigitRuleType valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::LicensePlateDigitRuleType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::rules::types::LicensePlateDigitRuleType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LicensePlateDigitRuleType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::LicensePlateDigitRuleType>(::nds::rules::types::LicensePlateDigitRuleType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::LicensePlateDigitRuleType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::LicensePlateDigitRuleType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::LicensePlateDigitRuleType)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::LicensePlateDigitRuleType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::LicensePlateDigitRuleType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::LicensePlateDigitRuleType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::LicensePlateDigitRuleType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::LicensePlateDigitRuleType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::LicensePlateDigitRuleType>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::LicensePlateDigitRuleType>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::rules::types::LicensePlateDigitRuleType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::LicensePlateDigitRuleType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::LicensePlateDigitRuleType>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::LicensePlateDigitRuleType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::LicensePlateDigitRuleType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::LicensePlateDigitRuleType>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/RegionValidityType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RegionValidityType enumeration.
constexpr ::std::array<const char*, 12> EnumTraits<::nds::rules::types::RegionValidityType>::names;
constexpr ::std::array<::nds::rules::types::RegionValidityType, 12> EnumTraits<::nds::rules::types::RegionValidityType>::values;
constexpr const char* EnumTraits<::nds::rules::types::RegionValidityType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::RegionValidityType value)
{
    switch (value)
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        return 0;
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        return 1;
    case ::nds::rules::types::RegionValidityType::PAVED:
        return 2;
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        return 3;
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        return 4;
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        return 5;
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        return 6;
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        return 7;
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        return 8;
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        return 9;
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        return 10;
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        return 11;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RegionValidityType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::RegionValidityType>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::RegionValidityType valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::RegionValidityType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
        return static_cast<::nds::rules::types::RegionValidityType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RegionValidityType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::RegionValidityType>(::nds::rules::types::RegionValidityType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::RegionValidityType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RegionValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::RegionValidityType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::RegionValidityType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RegionValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::RegionValidityType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::RegionValidityType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::RegionValidityType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::RegionValidityType>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::RegionValidityType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::rules::types::RegionValidityType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::RegionValidityType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RegionValidityType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::RegionValidityType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::RegionValidityType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RegionValidityType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/AutomatedDrivingClearance.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AutomatedDrivingClearance enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::rules::types::AutomatedDrivingClearance>::names;
constexpr ::std::array<::nds::rules::types::AutomatedDrivingClearance, 5> EnumTraits<::nds::rules::types::AutomatedDrivingClearance>::values;
constexpr const char* EnumTraits<::nds::rules::types::AutomatedDrivingClearance>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::AutomatedDrivingClearance value)
{
    switch (value)
    {
    case ::nds::rules::types::AutomatedDrivingClearance::SAE_LEVEL_1:
        return 0;
    case ::nds::rules::types::AutomatedDrivingClearance::SAE_LEVEL_2:
        return 1;
    case ::nds::rules::types::AutomatedDrivingClearance::SAE_LEVEL_3:
        return 2;
    case ::nds::rules::types::AutomatedDrivingClearance::SAE_LEVEL_4:
        return 3;
    case ::nds::rules::types::AutomatedDrivingClearance::SAE_LEVEL_5:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AutomatedDrivingClearance: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::AutomatedDrivingClearance>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::AutomatedDrivingClearance valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::AutomatedDrivingClearance>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::rules::types::AutomatedDrivingClearance>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AutomatedDrivingClearance: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::AutomatedDrivingClearance>(::nds::rules::types::AutomatedDrivingClearance value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::AutomatedDrivingClearance value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::AutomatedDrivingClearance>::type, UINT8_C(3)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::AutomatedDrivingClearance)
{
    return UINT8_C(3);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::AutomatedDrivingClearance value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::AutomatedDrivingClearance>::type, UINT8_C(3)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::AutomatedDrivingClearance value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::AutomatedDrivingClearance value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::AutomatedDrivingClearance read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::AutomatedDrivingClearance>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::AutomatedDrivingClearance>::type>(
                    in.readBits(UINT8_C(3))));
}

template <>
::nds::rules::types::AutomatedDrivingClearance read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::AutomatedDrivingClearance>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::AutomatedDrivingClearance>::type, UINT8_C(3)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::AutomatedDrivingClearance value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(3));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::AutomatedDrivingClearance value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::AutomatedDrivingClearance>::type, UINT8_C(3)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/RoadworksType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadworksType enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::rules::types::RoadworksType>::names;
constexpr ::std::array<::nds::rules::types::RoadworksType, 7> EnumTraits<::nds::rules::types::RoadworksType>::values;
constexpr const char* EnumTraits<::nds::rules::types::RoadworksType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::RoadworksType value)
{
    switch (value)
    {
    case ::nds::rules::types::RoadworksType::LONG_TERM_ROADWORKS:
        return 0;
    case ::nds::rules::types::RoadworksType::CONSTRUCTION_WORK:
        return 1;
    case ::nds::rules::types::RoadworksType::BRIDGE_MAINTENANCE_WORK:
        return 2;
    case ::nds::rules::types::RoadworksType::RESURFACING_WORK:
        return 3;
    case ::nds::rules::types::RoadworksType::MAJOR_ROADWORKS:
        return 4;
    case ::nds::rules::types::RoadworksType::MAINTENANCE_ROADWORKS:
        return 5;
    case ::nds::rules::types::RoadworksType::ROADWORKS_SINGLE_LINE_TRAFFIC_ALTERNATE_DIRECTIONS:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadworksType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::RoadworksType>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::RoadworksType valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::RoadworksType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::rules::types::RoadworksType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadworksType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::RoadworksType>(::nds::rules::types::RoadworksType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::RoadworksType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RoadworksType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::RoadworksType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::RoadworksType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RoadworksType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::RoadworksType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::RoadworksType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::RoadworksType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::RoadworksType>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::RoadworksType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::rules::types::RoadworksType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::RoadworksType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RoadworksType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::RoadworksType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::RoadworksType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::RoadworksType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/TrafficLightLensColor.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficLightLensColor enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::rules::types::TrafficLightLensColor>::names;
constexpr ::std::array<::nds::rules::types::TrafficLightLensColor, 7> EnumTraits<::nds::rules::types::TrafficLightLensColor>::values;
constexpr const char* EnumTraits<::nds::rules::types::TrafficLightLensColor>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::TrafficLightLensColor value)
{
    switch (value)
    {
    case ::nds::rules::types::TrafficLightLensColor::UNKNOWN:
        return 0;
    case ::nds::rules::types::TrafficLightLensColor::RED:
        return 1;
    case ::nds::rules::types::TrafficLightLensColor::AMBER:
        return 2;
    case ::nds::rules::types::TrafficLightLensColor::GREEN:
        return 3;
    case ::nds::rules::types::TrafficLightLensColor::WHITE:
        return 4;
    case ::nds::rules::types::TrafficLightLensColor::BLUE:
        return 5;
    case ::nds::rules::types::TrafficLightLensColor::OTHER_COLOR:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightLensColor: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensColor>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::TrafficLightLensColor valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::TrafficLightLensColor>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::rules::types::TrafficLightLensColor>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightLensColor: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::TrafficLightLensColor>(::nds::rules::types::TrafficLightLensColor value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightLensColor value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensColor>::type, UINT8_C(3)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::TrafficLightLensColor)
{
    return UINT8_C(3);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightLensColor value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensColor>::type, UINT8_C(3)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::TrafficLightLensColor value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::TrafficLightLensColor value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::TrafficLightLensColor read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightLensColor>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensColor>::type>(
                    in.readBits(UINT8_C(3))));
}

template <>
::nds::rules::types::TrafficLightLensColor read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightLensColor>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensColor>::type, UINT8_C(3)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightLensColor value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(3));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightLensColor value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensColor>::type, UINT8_C(3)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/TrafficLightInlayType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficLightInlayType enumeration.
constexpr ::std::array<const char*, 37> EnumTraits<::nds::rules::types::TrafficLightInlayType>::names;
constexpr ::std::array<::nds::rules::types::TrafficLightInlayType, 37> EnumTraits<::nds::rules::types::TrafficLightInlayType>::values;
constexpr const char* EnumTraits<::nds::rules::types::TrafficLightInlayType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::TrafficLightInlayType value)
{
    switch (value)
    {
    case ::nds::rules::types::TrafficLightInlayType::UNKNOWN:
        return 0;
    case ::nds::rules::types::TrafficLightInlayType::NONE:
        return 1;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_UP:
        return 2;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_DOWN:
        return 3;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_LEFT:
        return 4;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_UP_LEFT:
        return 5;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_DOWN_LEFT:
        return 6;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_RIGHT:
        return 7;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_UP_RIGHT:
        return 8;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_DOWN_RIGHT:
        return 9;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_U_TURN:
        return 10;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_LEFT_RIGHT:
        return 11;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_STRAIGHT_LEFT:
        return 12;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_STRAIGHT_RIGHT:
        return 13;
    case ::nds::rules::types::TrafficLightInlayType::ARROW_STRAIGHT_LEFT_RIGHT:
        return 14;
    case ::nds::rules::types::TrafficLightInlayType::PEDESTRIAN:
        return 15;
    case ::nds::rules::types::TrafficLightInlayType::BICYCLE:
        return 16;
    case ::nds::rules::types::TrafficLightInlayType::PEDESTRIAN_BICYCLE:
        return 17;
    case ::nds::rules::types::TrafficLightInlayType::HAND:
        return 18;
    case ::nds::rules::types::TrafficLightInlayType::TRAM:
        return 19;
    case ::nds::rules::types::TrafficLightInlayType::BUS:
        return 20;
    case ::nds::rules::types::TrafficLightInlayType::COUNTDOWN:
        return 21;
    case ::nds::rules::types::TrafficLightInlayType::BAR_HORIZONTAL:
        return 22;
    case ::nds::rules::types::TrafficLightInlayType::BAR_STRAIGHT:
        return 23;
    case ::nds::rules::types::TrafficLightInlayType::BAR_LEFT:
        return 24;
    case ::nds::rules::types::TrafficLightInlayType::BAR_RIGHT:
        return 25;
    case ::nds::rules::types::TrafficLightInlayType::BAR_DOUBLE_STRAIGHT:
        return 26;
    case ::nds::rules::types::TrafficLightInlayType::TRIANGLE:
        return 27;
    case ::nds::rules::types::TrafficLightInlayType::CIRCLE:
        return 28;
    case ::nds::rules::types::TrafficLightInlayType::PLUS:
        return 29;
    case ::nds::rules::types::TrafficLightInlayType::CROSS:
        return 30;
    case ::nds::rules::types::TrafficLightInlayType::CIRCLE_RING:
        return 31;
    case ::nds::rules::types::TrafficLightInlayType::CIRCLE_MATRIX:
        return 32;
    case ::nds::rules::types::TrafficLightInlayType::LETTER:
        return 33;
    case ::nds::rules::types::TrafficLightInlayType::TEXT:
        return 34;
    case ::nds::rules::types::TrafficLightInlayType::NUMBERS:
        return 35;
    case ::nds::rules::types::TrafficLightInlayType::OTHER:
        return 36;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightInlayType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightInlayType>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::TrafficLightInlayType valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::TrafficLightInlayType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
    case UINT8_C(17):
    case UINT8_C(18):
    case UINT8_C(19):
    case UINT8_C(20):
    case UINT8_C(21):
    case UINT8_C(22):
    case UINT8_C(23):
    case UINT8_C(24):
    case UINT8_C(25):
    case UINT8_C(26):
    case UINT8_C(27):
    case UINT8_C(28):
    case UINT8_C(29):
    case UINT8_C(30):
    case UINT8_C(31):
    case UINT8_C(32):
    case UINT8_C(33):
    case UINT8_C(34):
    case UINT8_C(35):
    case UINT8_C(36):
        return static_cast<::nds::rules::types::TrafficLightInlayType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightInlayType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::TrafficLightInlayType>(::nds::rules::types::TrafficLightInlayType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightInlayType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightInlayType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::TrafficLightInlayType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightInlayType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightInlayType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::TrafficLightInlayType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::TrafficLightInlayType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::TrafficLightInlayType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightInlayType>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightInlayType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::rules::types::TrafficLightInlayType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightInlayType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightInlayType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightInlayType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightInlayType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightInlayType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/TrafficLightLensType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficLightLensType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::rules::types::TrafficLightLensType>::names;
constexpr ::std::array<::nds::rules::types::TrafficLightLensType, 4> EnumTraits<::nds::rules::types::TrafficLightLensType>::values;
constexpr const char* EnumTraits<::nds::rules::types::TrafficLightLensType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::TrafficLightLensType value)
{
    switch (value)
    {
    case ::nds::rules::types::TrafficLightLensType::SIMPLE:
        return 0;
    case ::nds::rules::types::TrafficLightLensType::DOGHOUSE_SHARED:
        return 1;
    case ::nds::rules::types::TrafficLightLensType::ANIMATED:
        return 2;
    case ::nds::rules::types::TrafficLightLensType::MIXED:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightLensType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensType>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::TrafficLightLensType valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::TrafficLightLensType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::rules::types::TrafficLightLensType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightLensType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::TrafficLightLensType>(::nds::rules::types::TrafficLightLensType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightLensType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensType>::type, UINT8_C(3)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::TrafficLightLensType)
{
    return UINT8_C(3);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightLensType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensType>::type, UINT8_C(3)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::TrafficLightLensType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::TrafficLightLensType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::TrafficLightLensType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightLensType>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensType>::type>(
                    in.readBits(UINT8_C(3))));
}

template <>
::nds::rules::types::TrafficLightLensType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightLensType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensType>::type, UINT8_C(3)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightLensType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(3));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightLensType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightLensType>::type, UINT8_C(3)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/TrafficLightConstructionType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficLightConstructionType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::rules::types::TrafficLightConstructionType>::names;
constexpr ::std::array<::nds::rules::types::TrafficLightConstructionType, 4> EnumTraits<::nds::rules::types::TrafficLightConstructionType>::values;
constexpr const char* EnumTraits<::nds::rules::types::TrafficLightConstructionType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::TrafficLightConstructionType value)
{
    switch (value)
    {
    case ::nds::rules::types::TrafficLightConstructionType::HORIZONTAL:
        return 0;
    case ::nds::rules::types::TrafficLightConstructionType::VERTICAL:
        return 1;
    case ::nds::rules::types::TrafficLightConstructionType::DOGHOUSE_HORIZONTAL:
        return 2;
    case ::nds::rules::types::TrafficLightConstructionType::DOGHOUSE_VERTICAL:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightConstructionType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightConstructionType>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::TrafficLightConstructionType valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::TrafficLightConstructionType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::rules::types::TrafficLightConstructionType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightConstructionType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::TrafficLightConstructionType>(::nds::rules::types::TrafficLightConstructionType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightConstructionType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightConstructionType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::TrafficLightConstructionType)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightConstructionType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightConstructionType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::TrafficLightConstructionType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::TrafficLightConstructionType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::TrafficLightConstructionType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightConstructionType>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightConstructionType>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::rules::types::TrafficLightConstructionType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightConstructionType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightConstructionType>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightConstructionType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightConstructionType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightConstructionType>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/TrafficLightUsageType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficLightUsageType enumeration.
constexpr ::std::array<const char*, 14> EnumTraits<::nds::rules::types::TrafficLightUsageType>::names;
constexpr ::std::array<::nds::rules::types::TrafficLightUsageType, 14> EnumTraits<::nds::rules::types::TrafficLightUsageType>::values;
constexpr const char* EnumTraits<::nds::rules::types::TrafficLightUsageType>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::TrafficLightUsageType value)
{
    switch (value)
    {
    case ::nds::rules::types::TrafficLightUsageType::INTERSECTION:
        return 0;
    case ::nds::rules::types::TrafficLightUsageType::RAMP_METER:
        return 1;
    case ::nds::rules::types::TrafficLightUsageType::TOLL_BOOTH:
        return 2;
    case ::nds::rules::types::TrafficLightUsageType::PEDESTRIAN_CROSSING:
        return 3;
    case ::nds::rules::types::TrafficLightUsageType::BICYCLE_CROSSING:
        return 4;
    case ::nds::rules::types::TrafficLightUsageType::TUNNEL:
        return 5;
    case ::nds::rules::types::TrafficLightUsageType::BRIDGE:
        return 6;
    case ::nds::rules::types::TrafficLightUsageType::LANE_CONTROL:
        return 7;
    case ::nds::rules::types::TrafficLightUsageType::RAILWAY_CROSSING:
        return 8;
    case ::nds::rules::types::TrafficLightUsageType::TRAM_CROSSING:
        return 9;
    case ::nds::rules::types::TrafficLightUsageType::SPEED_SIGN:
        return 10;
    case ::nds::rules::types::TrafficLightUsageType::WARNING_LIGHT:
        return 11;
    case ::nds::rules::types::TrafficLightUsageType::ADVANCE_WARNING_LIGHT:
        return 12;
    case ::nds::rules::types::TrafficLightUsageType::PEDESTRIAN:
        return 13;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightUsageType: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightUsageType>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::TrafficLightUsageType valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::TrafficLightUsageType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
        return static_cast<::nds::rules::types::TrafficLightUsageType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightUsageType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::TrafficLightUsageType>(::nds::rules::types::TrafficLightUsageType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightUsageType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightUsageType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::TrafficLightUsageType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightUsageType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightUsageType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::TrafficLightUsageType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::TrafficLightUsageType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::TrafficLightUsageType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightUsageType>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightUsageType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::rules::types::TrafficLightUsageType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightUsageType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightUsageType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightUsageType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightUsageType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightUsageType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/TrafficLightPhaseMeaning.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficLightPhaseMeaning enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::rules::types::TrafficLightPhaseMeaning>::names;
constexpr ::std::array<::nds::rules::types::TrafficLightPhaseMeaning, 7> EnumTraits<::nds::rules::types::TrafficLightPhaseMeaning>::values;
constexpr const char* EnumTraits<::nds::rules::types::TrafficLightPhaseMeaning>::enumName;

template <>
size_t enumToOrdinal(::nds::rules::types::TrafficLightPhaseMeaning value)
{
    switch (value)
    {
    case ::nds::rules::types::TrafficLightPhaseMeaning::OFF:
        return 0;
    case ::nds::rules::types::TrafficLightPhaseMeaning::STOP_WAIT:
        return 1;
    case ::nds::rules::types::TrafficLightPhaseMeaning::GO:
        return 2;
    case ::nds::rules::types::TrafficLightPhaseMeaning::PROTECTED_GO:
        return 3;
    case ::nds::rules::types::TrafficLightPhaseMeaning::STOP_WAIT_EXPECTED:
        return 4;
    case ::nds::rules::types::TrafficLightPhaseMeaning::PREPARE_TO_GO:
        return 5;
    case ::nds::rules::types::TrafficLightPhaseMeaning::STOP_GO:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightPhaseMeaning: ") <<
                static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightPhaseMeaning>::type>(value) << "!";
    }
}

template <>
::nds::rules::types::TrafficLightPhaseMeaning valueToEnum(
        typename ::std::underlying_type<::nds::rules::types::TrafficLightPhaseMeaning>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::rules::types::TrafficLightPhaseMeaning>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficLightPhaseMeaning: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::rules::types::TrafficLightPhaseMeaning>(::nds::rules::types::TrafficLightPhaseMeaning value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightPhaseMeaning value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightPhaseMeaning>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::rules::types::TrafficLightPhaseMeaning)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::rules::types::TrafficLightPhaseMeaning value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightPhaseMeaning>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::rules::types::TrafficLightPhaseMeaning value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::rules::types::TrafficLightPhaseMeaning value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::rules::types::TrafficLightPhaseMeaning read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightPhaseMeaning>(
            static_cast<typename ::std::underlying_type<::nds::rules::types::TrafficLightPhaseMeaning>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::rules::types::TrafficLightPhaseMeaning read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::rules::types::TrafficLightPhaseMeaning>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightPhaseMeaning>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightPhaseMeaning value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::rules::types::TrafficLightPhaseMeaning value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::rules::types::TrafficLightPhaseMeaning>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/DrivingRulesContent.h>

namespace nds
{
namespace rules
{
namespace types
{

DrivingRulesContent::DrivingRulesContent(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

DrivingRulesContent::DrivingRulesContent(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

DrivingRulesContent::DrivingRulesContent(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'DrivingRulesContent' out of bounds: ") << value << "!";
}

void DrivingRulesContent::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::rules::types::DrivingRulesContent::underlying_type>>(m_value);
}

size_t DrivingRulesContent::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t DrivingRulesContent::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::rules::types::DrivingRulesContent::underlying_type>>(m_value);
}

size_t DrivingRulesContent::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t DrivingRulesContent::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t DrivingRulesContent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void DrivingRulesContent::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void DrivingRulesContent::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::rules::types::DrivingRulesContent::underlying_type>>(out, m_value);
}

::zserio::string<> DrivingRulesContent::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & DrivingRulesContent::Values::STAY_CURBSIDE) == DrivingRulesContent::Values::STAY_CURBSIDE)
        result += result.empty() ? "STAY_CURBSIDE" : " | STAY_CURBSIDE";
    if ((*this & DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
        result += result.empty() ? "TEMPORARY_LANE_MARKING_COLOR" : " | TEMPORARY_LANE_MARKING_COLOR";
    if ((*this & DrivingRulesContent::Values::CURBSIDE_PASSING) == DrivingRulesContent::Values::CURBSIDE_PASSING)
        result += result.empty() ? "CURBSIDE_PASSING" : " | CURBSIDE_PASSING";
    if ((*this & DrivingRulesContent::Values::EMERGENCY_RULES) == DrivingRulesContent::Values::EMERGENCY_RULES)
        result += result.empty() ? "EMERGENCY_RULES" : " | EMERGENCY_RULES";
    if ((*this & DrivingRulesContent::Values::YIELD_RULES) == DrivingRulesContent::Values::YIELD_RULES)
        result += result.empty() ? "YIELD_RULES" : " | YIELD_RULES";
    if ((*this & DrivingRulesContent::Values::SOLID_LINE_RULES) == DrivingRulesContent::Values::SOLID_LINE_RULES)
        result += result.empty() ? "SOLID_LINE_RULES" : " | SOLID_LINE_RULES";
    if ((*this & DrivingRulesContent::Values::ROADSIDE_PARKING_RULES) == DrivingRulesContent::Values::ROADSIDE_PARKING_RULES)
        result += result.empty() ? "ROADSIDE_PARKING_RULES" : " | ROADSIDE_PARKING_RULES";
    if ((*this & DrivingRulesContent::Values::LANE_MERGE_RULES) == DrivingRulesContent::Values::LANE_MERGE_RULES)
        result += result.empty() ? "LANE_MERGE_RULES" : " | LANE_MERGE_RULES";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

DrivingRulesContent::underlying_type DrivingRulesContent::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

DrivingRulesContent::underlying_type DrivingRulesContent::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::rules::types::DrivingRulesContent::underlying_type>>(
            in);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/rules/types/TrafficLightTargetGroup.h>

namespace nds
{
namespace rules
{
namespace types
{

TrafficLightTargetGroup::TrafficLightTargetGroup(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

TrafficLightTargetGroup::TrafficLightTargetGroup(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

TrafficLightTargetGroup::TrafficLightTargetGroup(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT16_C(32767))
        throw ::zserio::CppRuntimeException("Value for bitmask 'TrafficLightTargetGroup' out of bounds: ") << value << "!";
}

void TrafficLightTargetGroup::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::rules::types::TrafficLightTargetGroup::underlying_type>>(m_value);
}

size_t TrafficLightTargetGroup::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt16(m_value);
}

size_t TrafficLightTargetGroup::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::rules::types::TrafficLightTargetGroup::underlying_type>>(m_value);
}

size_t TrafficLightTargetGroup::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t TrafficLightTargetGroup::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t TrafficLightTargetGroup::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void TrafficLightTargetGroup::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_value);
}

void TrafficLightTargetGroup::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::rules::types::TrafficLightTargetGroup::underlying_type>>(out, m_value);
}

::zserio::string<> TrafficLightTargetGroup::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & TrafficLightTargetGroup::Values::VEHICLE) == TrafficLightTargetGroup::Values::VEHICLE)
        result += result.empty() ? "VEHICLE" : " | VEHICLE";
    if ((*this & TrafficLightTargetGroup::Values::PEDESTRIAN) == TrafficLightTargetGroup::Values::PEDESTRIAN)
        result += result.empty() ? "PEDESTRIAN" : " | PEDESTRIAN";
    if ((*this & TrafficLightTargetGroup::Values::BICYCLE) == TrafficLightTargetGroup::Values::BICYCLE)
        result += result.empty() ? "BICYCLE" : " | BICYCLE";
    if ((*this & TrafficLightTargetGroup::Values::PUBLIC_TRANSPORT) == TrafficLightTargetGroup::Values::PUBLIC_TRANSPORT)
        result += result.empty() ? "PUBLIC_TRANSPORT" : " | PUBLIC_TRANSPORT";
    if ((*this & TrafficLightTargetGroup::Values::RAILWAY) == TrafficLightTargetGroup::Values::RAILWAY)
        result += result.empty() ? "RAILWAY" : " | RAILWAY";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

TrafficLightTargetGroup::underlying_type TrafficLightTargetGroup::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt16());
}

TrafficLightTargetGroup::underlying_type TrafficLightTargetGroup::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::rules::types::TrafficLightTargetGroup::underlying_type>>(
            in);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/rules/types/RegionDrivingRules.h>
#include <nds/rules/types/DrivingRulesContent.h>

namespace nds
{
namespace rules
{
namespace types
{

RegionDrivingRules::RegionDrivingRules(const allocator_type&) noexcept :
        m_content_(::nds::rules::types::DrivingRulesContent()),
        m_stayCurbside_(::zserio::NullOpt),
        m_temporaryLaneMarkingColor_(::zserio::NullOpt),
        m_curbsidePassingAllowed_(::zserio::NullOpt),
        m_emergencyRules_(::zserio::NullOpt),
        m_yieldOncoming_(::zserio::NullOpt),
        m_yieldCurbSide_(::zserio::NullOpt),
        m_alwaysAllowed_(::zserio::NullOpt),
        m_solidLineCrossingRules_(::zserio::NullOpt),
        m_roadSideParkingRules_(::zserio::NullOpt),
        m_laneMergeRules_(::zserio::NullOpt)
{
}

RegionDrivingRules::RegionDrivingRules(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_content_(readContent(in)),
        m_stayCurbside_(readStayCurbside(in)),
        m_temporaryLaneMarkingColor_(readTemporaryLaneMarkingColor(in)),
        m_curbsidePassingAllowed_(readCurbsidePassingAllowed(in)),
        m_emergencyRules_(readEmergencyRules(in, allocator)),
        m_yieldOncoming_(readYieldOncoming(in)),
        m_yieldCurbSide_(readYieldCurbSide(in)),
        m_alwaysAllowed_(readAlwaysAllowed(in)),
        m_solidLineCrossingRules_(readSolidLineCrossingRules(in, allocator)),
        m_roadSideParkingRules_(readRoadSideParkingRules(in, allocator)),
        m_laneMergeRules_(readLaneMergeRules(in, allocator))
{
}

RegionDrivingRules::RegionDrivingRules(RegionDrivingRules::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_content_(readContent(context, in)),
        m_stayCurbside_(readStayCurbside(in)),
        m_temporaryLaneMarkingColor_(readTemporaryLaneMarkingColor(context, in)),
        m_curbsidePassingAllowed_(readCurbsidePassingAllowed(in)),
        m_emergencyRules_(readEmergencyRules(in, allocator)),
        m_yieldOncoming_(readYieldOncoming(in)),
        m_yieldCurbSide_(readYieldCurbSide(in)),
        m_alwaysAllowed_(readAlwaysAllowed(in)),
        m_solidLineCrossingRules_(readSolidLineCrossingRules(in, allocator)),
        m_roadSideParkingRules_(readRoadSideParkingRules(in, allocator)),
        m_laneMergeRules_(readLaneMergeRules(in, allocator))
{
}

RegionDrivingRules::RegionDrivingRules(::zserio::PropagateAllocatorT,
        const RegionDrivingRules& other, const allocator_type& allocator) :
        m_content_(::zserio::allocatorPropagatingCopy(other.m_content_, allocator)),
        m_stayCurbside_(::zserio::allocatorPropagatingCopy(other.m_stayCurbside_, allocator)),
        m_temporaryLaneMarkingColor_(::zserio::allocatorPropagatingCopy(other.m_temporaryLaneMarkingColor_, allocator)),
        m_curbsidePassingAllowed_(::zserio::allocatorPropagatingCopy(other.m_curbsidePassingAllowed_, allocator)),
        m_emergencyRules_(::zserio::allocatorPropagatingCopy(other.m_emergencyRules_, allocator)),
        m_yieldOncoming_(::zserio::allocatorPropagatingCopy(other.m_yieldOncoming_, allocator)),
        m_yieldCurbSide_(::zserio::allocatorPropagatingCopy(other.m_yieldCurbSide_, allocator)),
        m_alwaysAllowed_(::zserio::allocatorPropagatingCopy(other.m_alwaysAllowed_, allocator)),
        m_solidLineCrossingRules_(::zserio::allocatorPropagatingCopy(other.m_solidLineCrossingRules_, allocator)),
        m_roadSideParkingRules_(::zserio::allocatorPropagatingCopy(other.m_roadSideParkingRules_, allocator)),
        m_laneMergeRules_(::zserio::allocatorPropagatingCopy(other.m_laneMergeRules_, allocator))
{
}

::nds::rules::types::DrivingRulesContent RegionDrivingRules::getContent() const
{
    return m_content_;
}

void RegionDrivingRules::setContent(::nds::rules::types::DrivingRulesContent content_)
{
    m_content_ = content_;
}

bool RegionDrivingRules::getStayCurbside() const
{
    return m_stayCurbside_.value();
}

void RegionDrivingRules::setStayCurbside(bool stayCurbside_)
{
    m_stayCurbside_ = stayCurbside_;
}

bool RegionDrivingRules::isStayCurbsideUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE) == ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE);
}

bool RegionDrivingRules::isStayCurbsideSet() const
{
    return m_stayCurbside_.hasValue();
}

void RegionDrivingRules::resetStayCurbside()
{
    m_stayCurbside_.reset();
}

::nds::lane::reference::types::MarkingColor RegionDrivingRules::getTemporaryLaneMarkingColor() const
{
    return m_temporaryLaneMarkingColor_.value();
}

void RegionDrivingRules::setTemporaryLaneMarkingColor(::nds::lane::reference::types::MarkingColor temporaryLaneMarkingColor_)
{
    m_temporaryLaneMarkingColor_ = temporaryLaneMarkingColor_;
}

bool RegionDrivingRules::isTemporaryLaneMarkingColorUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR);
}

bool RegionDrivingRules::isTemporaryLaneMarkingColorSet() const
{
    return m_temporaryLaneMarkingColor_.hasValue();
}

void RegionDrivingRules::resetTemporaryLaneMarkingColor()
{
    m_temporaryLaneMarkingColor_.reset();
}

bool RegionDrivingRules::getCurbsidePassingAllowed() const
{
    return m_curbsidePassingAllowed_.value();
}

void RegionDrivingRules::setCurbsidePassingAllowed(bool curbsidePassingAllowed_)
{
    m_curbsidePassingAllowed_ = curbsidePassingAllowed_;
}

bool RegionDrivingRules::isCurbsidePassingAllowedUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING) == ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING);
}

bool RegionDrivingRules::isCurbsidePassingAllowedSet() const
{
    return m_curbsidePassingAllowed_.hasValue();
}

void RegionDrivingRules::resetCurbsidePassingAllowed()
{
    m_curbsidePassingAllowed_.reset();
}

::nds::rules::types::EmergencyRules& RegionDrivingRules::getEmergencyRules()
{
    return m_emergencyRules_.value();
}

const ::nds::rules::types::EmergencyRules& RegionDrivingRules::getEmergencyRules() const
{
    return m_emergencyRules_.value();
}

void RegionDrivingRules::setEmergencyRules(const ::nds::rules::types::EmergencyRules& emergencyRules_)
{
    m_emergencyRules_ = emergencyRules_;
}

void RegionDrivingRules::setEmergencyRules(::nds::rules::types::EmergencyRules&& emergencyRules_)
{
    m_emergencyRules_ = ::std::move(emergencyRules_);
}

bool RegionDrivingRules::isEmergencyRulesUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES) == ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES);
}

bool RegionDrivingRules::isEmergencyRulesSet() const
{
    return m_emergencyRules_.hasValue();
}

void RegionDrivingRules::resetEmergencyRules()
{
    m_emergencyRules_.reset();
}

bool RegionDrivingRules::getYieldOncoming() const
{
    return m_yieldOncoming_.value();
}

void RegionDrivingRules::setYieldOncoming(bool yieldOncoming_)
{
    m_yieldOncoming_ = yieldOncoming_;
}

bool RegionDrivingRules::isYieldOncomingUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES);
}

bool RegionDrivingRules::isYieldOncomingSet() const
{
    return m_yieldOncoming_.hasValue();
}

void RegionDrivingRules::resetYieldOncoming()
{
    m_yieldOncoming_.reset();
}

bool RegionDrivingRules::getYieldCurbSide() const
{
    return m_yieldCurbSide_.value();
}

void RegionDrivingRules::setYieldCurbSide(bool yieldCurbSide_)
{
    m_yieldCurbSide_ = yieldCurbSide_;
}

bool RegionDrivingRules::isYieldCurbSideUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES);
}

bool RegionDrivingRules::isYieldCurbSideSet() const
{
    return m_yieldCurbSide_.hasValue();
}

void RegionDrivingRules::resetYieldCurbSide()
{
    m_yieldCurbSide_.reset();
}

bool RegionDrivingRules::getAlwaysAllowed() const
{
    return m_alwaysAllowed_.value();
}

void RegionDrivingRules::setAlwaysAllowed(bool alwaysAllowed_)
{
    m_alwaysAllowed_ = alwaysAllowed_;
}

bool RegionDrivingRules::isAlwaysAllowedUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES);
}

bool RegionDrivingRules::isAlwaysAllowedSet() const
{
    return m_alwaysAllowed_.hasValue();
}

void RegionDrivingRules::resetAlwaysAllowed()
{
    m_alwaysAllowed_.reset();
}

::nds::rules::types::SolidLineCrossingRules& RegionDrivingRules::getSolidLineCrossingRules()
{
    return m_solidLineCrossingRules_.value();
}

const ::nds::rules::types::SolidLineCrossingRules& RegionDrivingRules::getSolidLineCrossingRules() const
{
    return m_solidLineCrossingRules_.value();
}

void RegionDrivingRules::setSolidLineCrossingRules(const ::nds::rules::types::SolidLineCrossingRules& solidLineCrossingRules_)
{
    m_solidLineCrossingRules_ = solidLineCrossingRules_;
}

void RegionDrivingRules::setSolidLineCrossingRules(::nds::rules::types::SolidLineCrossingRules&& solidLineCrossingRules_)
{
    m_solidLineCrossingRules_ = ::std::move(solidLineCrossingRules_);
}

bool RegionDrivingRules::isSolidLineCrossingRulesUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES && !getAlwaysAllowed());
}

bool RegionDrivingRules::isSolidLineCrossingRulesSet() const
{
    return m_solidLineCrossingRules_.hasValue();
}

void RegionDrivingRules::resetSolidLineCrossingRules()
{
    m_solidLineCrossingRules_.reset();
}

::nds::rules::types::RoadSideParkingRules& RegionDrivingRules::getRoadSideParkingRules()
{
    return m_roadSideParkingRules_.value();
}

const ::nds::rules::types::RoadSideParkingRules& RegionDrivingRules::getRoadSideParkingRules() const
{
    return m_roadSideParkingRules_.value();
}

void RegionDrivingRules::setRoadSideParkingRules(const ::nds::rules::types::RoadSideParkingRules& roadSideParkingRules_)
{
    m_roadSideParkingRules_ = roadSideParkingRules_;
}

void RegionDrivingRules::setRoadSideParkingRules(::nds::rules::types::RoadSideParkingRules&& roadSideParkingRules_)
{
    m_roadSideParkingRules_ = ::std::move(roadSideParkingRules_);
}

bool RegionDrivingRules::isRoadSideParkingRulesUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES) == ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES);
}

bool RegionDrivingRules::isRoadSideParkingRulesSet() const
{
    return m_roadSideParkingRules_.hasValue();
}

void RegionDrivingRules::resetRoadSideParkingRules()
{
    m_roadSideParkingRules_.reset();
}

::nds::rules::types::LaneMergeRules& RegionDrivingRules::getLaneMergeRules()
{
    return m_laneMergeRules_.value();
}

const ::nds::rules::types::LaneMergeRules& RegionDrivingRules::getLaneMergeRules() const
{
    return m_laneMergeRules_.value();
}

void RegionDrivingRules::setLaneMergeRules(const ::nds::rules::types::LaneMergeRules& laneMergeRules_)
{
    m_laneMergeRules_ = laneMergeRules_;
}

void RegionDrivingRules::setLaneMergeRules(::nds::rules::types::LaneMergeRules&& laneMergeRules_)
{
    m_laneMergeRules_ = ::std::move(laneMergeRules_);
}

bool RegionDrivingRules::isLaneMergeRulesUsed() const
{
    return ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES);
}

bool RegionDrivingRules::isLaneMergeRulesSet() const
{
    return m_laneMergeRules_.hasValue();
}

void RegionDrivingRules::resetLaneMergeRules()
{
    m_laneMergeRules_.reset();
}

void RegionDrivingRules::initPackingContext(RegionDrivingRules::ZserioPackingContext& context) const
{
    m_content_.initPackingContext(context.getContent());
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
    {
        ::zserio::initPackingContext(context.getTemporaryLaneMarkingColor(), m_temporaryLaneMarkingColor_.value());
    }
}

size_t RegionDrivingRules::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(endBitPosition);
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE) == ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
    {
        endBitPosition += ::zserio::bitSizeOf(m_temporaryLaneMarkingColor_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING) == ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES) == ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES)
    {
        endBitPosition += m_emergencyRules_.value().bitSizeOf(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES && !getAlwaysAllowed())
    {
        endBitPosition += m_solidLineCrossingRules_.value().bitSizeOf(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES) == ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES)
    {
        endBitPosition += m_roadSideParkingRules_.value().bitSizeOf(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES)
    {
        endBitPosition += m_laneMergeRules_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RegionDrivingRules::bitSizeOf(RegionDrivingRules::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(context.getContent(), endBitPosition);
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE) == ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
    {
        endBitPosition += ::zserio::bitSizeOf(context.getTemporaryLaneMarkingColor(), m_temporaryLaneMarkingColor_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING) == ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES) == ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES)
    {
        endBitPosition += m_emergencyRules_.value().bitSizeOf(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES && !getAlwaysAllowed())
    {
        endBitPosition += m_solidLineCrossingRules_.value().bitSizeOf(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES) == ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES)
    {
        endBitPosition += m_roadSideParkingRules_.value().bitSizeOf(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES)
    {
        endBitPosition += m_laneMergeRules_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RegionDrivingRules::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(endBitPosition);
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE) == ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_temporaryLaneMarkingColor_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING) == ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES) == ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES)
    {
        endBitPosition = m_emergencyRules_.value().initializeOffsets(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES && !getAlwaysAllowed())
    {
        endBitPosition = m_solidLineCrossingRules_.value().initializeOffsets(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES) == ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES)
    {
        endBitPosition = m_roadSideParkingRules_.value().initializeOffsets(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES)
    {
        endBitPosition = m_laneMergeRules_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RegionDrivingRules::initializeOffsets(RegionDrivingRules::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(context.getContent(), endBitPosition);
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE) == ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
    {
        endBitPosition = ::zserio::initializeOffsets(context.getTemporaryLaneMarkingColor(), endBitPosition,
        m_temporaryLaneMarkingColor_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING) == ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES) == ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES)
    {
        endBitPosition = m_emergencyRules_.value().initializeOffsets(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES && !getAlwaysAllowed())
    {
        endBitPosition = m_solidLineCrossingRules_.value().initializeOffsets(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES) == ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES)
    {
        endBitPosition = m_roadSideParkingRules_.value().initializeOffsets(endBitPosition);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES)
    {
        endBitPosition = m_laneMergeRules_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

bool RegionDrivingRules::operator==(const RegionDrivingRules& other) const
{
    if (this != &other)
    {
        return
                (m_content_ == other.m_content_) &&
                (!isStayCurbsideUsed() ? !other.isStayCurbsideUsed() : (m_stayCurbside_ == other.m_stayCurbside_)) &&
                (!isTemporaryLaneMarkingColorUsed() ? !other.isTemporaryLaneMarkingColorUsed() : (m_temporaryLaneMarkingColor_ == other.m_temporaryLaneMarkingColor_)) &&
                (!isCurbsidePassingAllowedUsed() ? !other.isCurbsidePassingAllowedUsed() : (m_curbsidePassingAllowed_ == other.m_curbsidePassingAllowed_)) &&
                (!isEmergencyRulesUsed() ? !other.isEmergencyRulesUsed() : (m_emergencyRules_ == other.m_emergencyRules_)) &&
                (!isYieldOncomingUsed() ? !other.isYieldOncomingUsed() : (m_yieldOncoming_ == other.m_yieldOncoming_)) &&
                (!isYieldCurbSideUsed() ? !other.isYieldCurbSideUsed() : (m_yieldCurbSide_ == other.m_yieldCurbSide_)) &&
                (!isAlwaysAllowedUsed() ? !other.isAlwaysAllowedUsed() : (m_alwaysAllowed_ == other.m_alwaysAllowed_)) &&
                (!isSolidLineCrossingRulesUsed() ? !other.isSolidLineCrossingRulesUsed() : (m_solidLineCrossingRules_ == other.m_solidLineCrossingRules_)) &&
                (!isRoadSideParkingRulesUsed() ? !other.isRoadSideParkingRulesUsed() : (m_roadSideParkingRules_ == other.m_roadSideParkingRules_)) &&
                (!isLaneMergeRulesUsed() ? !other.isLaneMergeRulesUsed() : (m_laneMergeRules_ == other.m_laneMergeRules_));
    }

    return true;
}

uint32_t RegionDrivingRules::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_content_);
    if (isStayCurbsideUsed())
        result = ::zserio::calcHashCode(result, m_stayCurbside_);
    if (isTemporaryLaneMarkingColorUsed())
        result = ::zserio::calcHashCode(result, m_temporaryLaneMarkingColor_);
    if (isCurbsidePassingAllowedUsed())
        result = ::zserio::calcHashCode(result, m_curbsidePassingAllowed_);
    if (isEmergencyRulesUsed())
        result = ::zserio::calcHashCode(result, m_emergencyRules_);
    if (isYieldOncomingUsed())
        result = ::zserio::calcHashCode(result, m_yieldOncoming_);
    if (isYieldCurbSideUsed())
        result = ::zserio::calcHashCode(result, m_yieldCurbSide_);
    if (isAlwaysAllowedUsed())
        result = ::zserio::calcHashCode(result, m_alwaysAllowed_);
    if (isSolidLineCrossingRulesUsed())
        result = ::zserio::calcHashCode(result, m_solidLineCrossingRules_);
    if (isRoadSideParkingRulesUsed())
        result = ::zserio::calcHashCode(result, m_roadSideParkingRules_);
    if (isLaneMergeRulesUsed())
        result = ::zserio::calcHashCode(result, m_laneMergeRules_);

    return result;
}

void RegionDrivingRules::write(::zserio::BitStreamWriter& out) const
{
    m_content_.write(out);
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE) == ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE)
    {
        out.writeBool(m_stayCurbside_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
    {
        ::zserio::write(out, m_temporaryLaneMarkingColor_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING) == ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING)
    {
        out.writeBool(m_curbsidePassingAllowed_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES) == ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES)
    {
        m_emergencyRules_.value().write(out);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        out.writeBool(m_yieldOncoming_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        out.writeBool(m_yieldCurbSide_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES)
    {
        out.writeBool(m_alwaysAllowed_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES && !getAlwaysAllowed())
    {
        m_solidLineCrossingRules_.value().write(out);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES) == ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES)
    {
        m_roadSideParkingRules_.value().write(out);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES)
    {
        m_laneMergeRules_.value().write(out);
    }
}

void RegionDrivingRules::write(RegionDrivingRules::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_content_.write(context.getContent(), out);
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE) == ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE)
    {
        out.writeBool(m_stayCurbside_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
    {
        ::zserio::write(context.getTemporaryLaneMarkingColor(), out, m_temporaryLaneMarkingColor_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING) == ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING)
    {
        out.writeBool(m_curbsidePassingAllowed_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES) == ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES)
    {
        m_emergencyRules_.value().write(out);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        out.writeBool(m_yieldOncoming_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        out.writeBool(m_yieldCurbSide_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES)
    {
        out.writeBool(m_alwaysAllowed_.value());
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES && !getAlwaysAllowed())
    {
        m_solidLineCrossingRules_.value().write(out);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES) == ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES)
    {
        m_roadSideParkingRules_.value().write(out);
    }
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES)
    {
        m_laneMergeRules_.value().write(out);
    }
}

::nds::rules::types::DrivingRulesContent RegionDrivingRules::readContent(::zserio::BitStreamReader& in)
{
    return ::nds::rules::types::DrivingRulesContent(in);
}

::nds::rules::types::DrivingRulesContent RegionDrivingRules::readContent(RegionDrivingRules::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::rules::types::DrivingRulesContent(context.getContent(), in);
}
::zserio::InplaceOptionalHolder<bool> RegionDrivingRules::readStayCurbside(::zserio::BitStreamReader& in)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE) == ::nds::rules::types::DrivingRulesContent::Values::STAY_CURBSIDE)
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::MarkingColor> RegionDrivingRules::readTemporaryLaneMarkingColor(::zserio::BitStreamReader& in)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::MarkingColor>(::zserio::read<::nds::lane::reference::types::MarkingColor>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::MarkingColor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::MarkingColor> RegionDrivingRules::readTemporaryLaneMarkingColor(RegionDrivingRules::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR) == ::nds::rules::types::DrivingRulesContent::Values::TEMPORARY_LANE_MARKING_COLOR)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::MarkingColor>(::zserio::read<::nds::lane::reference::types::MarkingColor>(context.getTemporaryLaneMarkingColor(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::MarkingColor>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> RegionDrivingRules::readCurbsidePassingAllowed(::zserio::BitStreamReader& in)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING) == ::nds::rules::types::DrivingRulesContent::Values::CURBSIDE_PASSING)
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::rules::types::EmergencyRules> RegionDrivingRules::readEmergencyRules(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES) == ::nds::rules::types::DrivingRulesContent::Values::EMERGENCY_RULES)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::EmergencyRules>(::nds::rules::types::EmergencyRules(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::EmergencyRules>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> RegionDrivingRules::readYieldOncoming(::zserio::BitStreamReader& in)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> RegionDrivingRules::readYieldCurbSide(::zserio::BitStreamReader& in)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES) == ::nds::rules::types::DrivingRulesContent::Values::YIELD_RULES)
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> RegionDrivingRules::readAlwaysAllowed(::zserio::BitStreamReader& in)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES)
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::rules::types::SolidLineCrossingRules> RegionDrivingRules::readSolidLineCrossingRules(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::SOLID_LINE_RULES && !getAlwaysAllowed())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::SolidLineCrossingRules>(::nds::rules::types::SolidLineCrossingRules(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::SolidLineCrossingRules>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::rules::types::RoadSideParkingRules> RegionDrivingRules::readRoadSideParkingRules(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES) == ::nds::rules::types::DrivingRulesContent::Values::ROADSIDE_PARKING_RULES)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::RoadSideParkingRules>(::nds::rules::types::RoadSideParkingRules(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::RoadSideParkingRules>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::rules::types::LaneMergeRules> RegionDrivingRules::readLaneMergeRules(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if ((getContent() & ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES) == ::nds::rules::types::DrivingRulesContent::Values::LANE_MERGE_RULES)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::LaneMergeRules>(::nds::rules::types::LaneMergeRules(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::LaneMergeRules>(::zserio::NullOpt);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/EmergencyRules.h>

namespace nds
{
namespace rules
{
namespace types
{

EmergencyRules::EmergencyRules(const allocator_type&) noexcept :
        m_buildEmergencyCorridor_(bool()),
        m_changeLanes_(bool()),
        m_slowDown_(bool())
{
}

EmergencyRules::EmergencyRules(::zserio::BitStreamReader& in, const allocator_type&) :
        m_buildEmergencyCorridor_(readBuildEmergencyCorridor(in)),
        m_changeLanes_(readChangeLanes(in)),
        m_slowDown_(readSlowDown(in))
{
}

EmergencyRules::EmergencyRules(::zserio::PropagateAllocatorT,
        const EmergencyRules& other, const allocator_type& allocator) :
        m_buildEmergencyCorridor_(::zserio::allocatorPropagatingCopy(other.m_buildEmergencyCorridor_, allocator)),
        m_changeLanes_(::zserio::allocatorPropagatingCopy(other.m_changeLanes_, allocator)),
        m_slowDown_(::zserio::allocatorPropagatingCopy(other.m_slowDown_, allocator))
{
}

bool EmergencyRules::getBuildEmergencyCorridor() const
{
    return m_buildEmergencyCorridor_;
}

void EmergencyRules::setBuildEmergencyCorridor(bool buildEmergencyCorridor_)
{
    m_buildEmergencyCorridor_ = buildEmergencyCorridor_;
}

bool EmergencyRules::getChangeLanes() const
{
    return m_changeLanes_;
}

void EmergencyRules::setChangeLanes(bool changeLanes_)
{
    m_changeLanes_ = changeLanes_;
}

bool EmergencyRules::getSlowDown() const
{
    return m_slowDown_;
}

void EmergencyRules::setSlowDown(bool slowDown_)
{
    m_slowDown_ = slowDown_;
}

size_t EmergencyRules::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t EmergencyRules::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool EmergencyRules::operator==(const EmergencyRules& other) const
{
    if (this != &other)
    {
        return
                (m_buildEmergencyCorridor_ == other.m_buildEmergencyCorridor_) &&
                (m_changeLanes_ == other.m_changeLanes_) &&
                (m_slowDown_ == other.m_slowDown_);
    }

    return true;
}

uint32_t EmergencyRules::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_buildEmergencyCorridor_);
    result = ::zserio::calcHashCode(result, m_changeLanes_);
    result = ::zserio::calcHashCode(result, m_slowDown_);

    return result;
}

void EmergencyRules::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_buildEmergencyCorridor_);
    out.writeBool(m_changeLanes_);
    out.writeBool(m_slowDown_);
}

bool EmergencyRules::readBuildEmergencyCorridor(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool EmergencyRules::readChangeLanes(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool EmergencyRules::readSlowDown(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/SolidLineCrossingRules.h>

namespace nds
{
namespace rules
{
namespace types
{

SolidLineCrossingRules::SolidLineCrossingRules(const allocator_type&) noexcept :
        m_duringEmergencies_(bool()),
        m_enterShoulderLane_(bool()),
        m_enterBusLane_(bool()),
        m_overtakeSlowTraffic_(bool()),
        m_enterPremisesOrSideRoads_(bool()),
        m_avoidObstacles_(bool())
{
}

SolidLineCrossingRules::SolidLineCrossingRules(::zserio::BitStreamReader& in, const allocator_type&) :
        m_duringEmergencies_(readDuringEmergencies(in)),
        m_enterShoulderLane_(readEnterShoulderLane(in)),
        m_enterBusLane_(readEnterBusLane(in)),
        m_overtakeSlowTraffic_(readOvertakeSlowTraffic(in)),
        m_enterPremisesOrSideRoads_(readEnterPremisesOrSideRoads(in)),
        m_avoidObstacles_(readAvoidObstacles(in))
{
}

SolidLineCrossingRules::SolidLineCrossingRules(::zserio::PropagateAllocatorT,
        const SolidLineCrossingRules& other, const allocator_type& allocator) :
        m_duringEmergencies_(::zserio::allocatorPropagatingCopy(other.m_duringEmergencies_, allocator)),
        m_enterShoulderLane_(::zserio::allocatorPropagatingCopy(other.m_enterShoulderLane_, allocator)),
        m_enterBusLane_(::zserio::allocatorPropagatingCopy(other.m_enterBusLane_, allocator)),
        m_overtakeSlowTraffic_(::zserio::allocatorPropagatingCopy(other.m_overtakeSlowTraffic_, allocator)),
        m_enterPremisesOrSideRoads_(::zserio::allocatorPropagatingCopy(other.m_enterPremisesOrSideRoads_, allocator)),
        m_avoidObstacles_(::zserio::allocatorPropagatingCopy(other.m_avoidObstacles_, allocator))
{
}

bool SolidLineCrossingRules::getDuringEmergencies() const
{
    return m_duringEmergencies_;
}

void SolidLineCrossingRules::setDuringEmergencies(bool duringEmergencies_)
{
    m_duringEmergencies_ = duringEmergencies_;
}

bool SolidLineCrossingRules::getEnterShoulderLane() const
{
    return m_enterShoulderLane_;
}

void SolidLineCrossingRules::setEnterShoulderLane(bool enterShoulderLane_)
{
    m_enterShoulderLane_ = enterShoulderLane_;
}

bool SolidLineCrossingRules::getEnterBusLane() const
{
    return m_enterBusLane_;
}

void SolidLineCrossingRules::setEnterBusLane(bool enterBusLane_)
{
    m_enterBusLane_ = enterBusLane_;
}

bool SolidLineCrossingRules::getOvertakeSlowTraffic() const
{
    return m_overtakeSlowTraffic_;
}

void SolidLineCrossingRules::setOvertakeSlowTraffic(bool overtakeSlowTraffic_)
{
    m_overtakeSlowTraffic_ = overtakeSlowTraffic_;
}

bool SolidLineCrossingRules::getEnterPremisesOrSideRoads() const
{
    return m_enterPremisesOrSideRoads_;
}

void SolidLineCrossingRules::setEnterPremisesOrSideRoads(bool enterPremisesOrSideRoads_)
{
    m_enterPremisesOrSideRoads_ = enterPremisesOrSideRoads_;
}

bool SolidLineCrossingRules::getAvoidObstacles() const
{
    return m_avoidObstacles_;
}

void SolidLineCrossingRules::setAvoidObstacles(bool avoidObstacles_)
{
    m_avoidObstacles_ = avoidObstacles_;
}

size_t SolidLineCrossingRules::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t SolidLineCrossingRules::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool SolidLineCrossingRules::operator==(const SolidLineCrossingRules& other) const
{
    if (this != &other)
    {
        return
                (m_duringEmergencies_ == other.m_duringEmergencies_) &&
                (m_enterShoulderLane_ == other.m_enterShoulderLane_) &&
                (m_enterBusLane_ == other.m_enterBusLane_) &&
                (m_overtakeSlowTraffic_ == other.m_overtakeSlowTraffic_) &&
                (m_enterPremisesOrSideRoads_ == other.m_enterPremisesOrSideRoads_) &&
                (m_avoidObstacles_ == other.m_avoidObstacles_);
    }

    return true;
}

uint32_t SolidLineCrossingRules::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_duringEmergencies_);
    result = ::zserio::calcHashCode(result, m_enterShoulderLane_);
    result = ::zserio::calcHashCode(result, m_enterBusLane_);
    result = ::zserio::calcHashCode(result, m_overtakeSlowTraffic_);
    result = ::zserio::calcHashCode(result, m_enterPremisesOrSideRoads_);
    result = ::zserio::calcHashCode(result, m_avoidObstacles_);

    return result;
}

void SolidLineCrossingRules::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_duringEmergencies_);
    out.writeBool(m_enterShoulderLane_);
    out.writeBool(m_enterBusLane_);
    out.writeBool(m_overtakeSlowTraffic_);
    out.writeBool(m_enterPremisesOrSideRoads_);
    out.writeBool(m_avoidObstacles_);
}

bool SolidLineCrossingRules::readDuringEmergencies(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool SolidLineCrossingRules::readEnterShoulderLane(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool SolidLineCrossingRules::readEnterBusLane(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool SolidLineCrossingRules::readOvertakeSlowTraffic(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool SolidLineCrossingRules::readEnterPremisesOrSideRoads(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool SolidLineCrossingRules::readAvoidObstacles(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/RoadSideParkingRules.h>

namespace nds
{
namespace rules
{
namespace types
{

RoadSideParkingRules::RoadSideParkingRules(const allocator_type&) noexcept :
        m_bothSidesOfOneWay_(bool()),
        m_oppositeDirection_(bool())
{
}

RoadSideParkingRules::RoadSideParkingRules(::zserio::BitStreamReader& in, const allocator_type&) :
        m_bothSidesOfOneWay_(readBothSidesOfOneWay(in)),
        m_oppositeDirection_(readOppositeDirection(in))
{
}

RoadSideParkingRules::RoadSideParkingRules(::zserio::PropagateAllocatorT,
        const RoadSideParkingRules& other, const allocator_type& allocator) :
        m_bothSidesOfOneWay_(::zserio::allocatorPropagatingCopy(other.m_bothSidesOfOneWay_, allocator)),
        m_oppositeDirection_(::zserio::allocatorPropagatingCopy(other.m_oppositeDirection_, allocator))
{
}

bool RoadSideParkingRules::getBothSidesOfOneWay() const
{
    return m_bothSidesOfOneWay_;
}

void RoadSideParkingRules::setBothSidesOfOneWay(bool bothSidesOfOneWay_)
{
    m_bothSidesOfOneWay_ = bothSidesOfOneWay_;
}

bool RoadSideParkingRules::getOppositeDirection() const
{
    return m_oppositeDirection_;
}

void RoadSideParkingRules::setOppositeDirection(bool oppositeDirection_)
{
    m_oppositeDirection_ = oppositeDirection_;
}

size_t RoadSideParkingRules::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t RoadSideParkingRules::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool RoadSideParkingRules::operator==(const RoadSideParkingRules& other) const
{
    if (this != &other)
    {
        return
                (m_bothSidesOfOneWay_ == other.m_bothSidesOfOneWay_) &&
                (m_oppositeDirection_ == other.m_oppositeDirection_);
    }

    return true;
}

uint32_t RoadSideParkingRules::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_bothSidesOfOneWay_);
    result = ::zserio::calcHashCode(result, m_oppositeDirection_);

    return result;
}

void RoadSideParkingRules::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_bothSidesOfOneWay_);
    out.writeBool(m_oppositeDirection_);
}

bool RoadSideParkingRules::readBothSidesOfOneWay(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool RoadSideParkingRules::readOppositeDirection(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/LaneMergeRules.h>

namespace nds
{
namespace rules
{
namespace types
{

LaneMergeRules::LaneMergeRules(const allocator_type&) noexcept :
        m_yieldToOngoingLane_(bool()),
        m_yieldToCurb_(bool()),
        m_yieldToTrafficAhead_(bool()),
        m_noDividerYieldToCurb_(bool())
{
}

LaneMergeRules::LaneMergeRules(::zserio::BitStreamReader& in, const allocator_type&) :
        m_yieldToOngoingLane_(readYieldToOngoingLane(in)),
        m_yieldToCurb_(readYieldToCurb(in)),
        m_yieldToTrafficAhead_(readYieldToTrafficAhead(in)),
        m_noDividerYieldToCurb_(readNoDividerYieldToCurb(in))
{
}

LaneMergeRules::LaneMergeRules(::zserio::PropagateAllocatorT,
        const LaneMergeRules& other, const allocator_type& allocator) :
        m_yieldToOngoingLane_(::zserio::allocatorPropagatingCopy(other.m_yieldToOngoingLane_, allocator)),
        m_yieldToCurb_(::zserio::allocatorPropagatingCopy(other.m_yieldToCurb_, allocator)),
        m_yieldToTrafficAhead_(::zserio::allocatorPropagatingCopy(other.m_yieldToTrafficAhead_, allocator)),
        m_noDividerYieldToCurb_(::zserio::allocatorPropagatingCopy(other.m_noDividerYieldToCurb_, allocator))
{
}

bool LaneMergeRules::getYieldToOngoingLane() const
{
    return m_yieldToOngoingLane_;
}

void LaneMergeRules::setYieldToOngoingLane(bool yieldToOngoingLane_)
{
    m_yieldToOngoingLane_ = yieldToOngoingLane_;
}

bool LaneMergeRules::getYieldToCurb() const
{
    return m_yieldToCurb_;
}

void LaneMergeRules::setYieldToCurb(bool yieldToCurb_)
{
    m_yieldToCurb_ = yieldToCurb_;
}

bool LaneMergeRules::getYieldToTrafficAhead() const
{
    return m_yieldToTrafficAhead_;
}

void LaneMergeRules::setYieldToTrafficAhead(bool yieldToTrafficAhead_)
{
    m_yieldToTrafficAhead_ = yieldToTrafficAhead_;
}

bool LaneMergeRules::getNoDividerYieldToCurb() const
{
    return m_noDividerYieldToCurb_;
}

void LaneMergeRules::setNoDividerYieldToCurb(bool noDividerYieldToCurb_)
{
    m_noDividerYieldToCurb_ = noDividerYieldToCurb_;
}

size_t LaneMergeRules::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t LaneMergeRules::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool LaneMergeRules::operator==(const LaneMergeRules& other) const
{
    if (this != &other)
    {
        return
                (m_yieldToOngoingLane_ == other.m_yieldToOngoingLane_) &&
                (m_yieldToCurb_ == other.m_yieldToCurb_) &&
                (m_yieldToTrafficAhead_ == other.m_yieldToTrafficAhead_) &&
                (m_noDividerYieldToCurb_ == other.m_noDividerYieldToCurb_);
    }

    return true;
}

uint32_t LaneMergeRules::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_yieldToOngoingLane_);
    result = ::zserio::calcHashCode(result, m_yieldToCurb_);
    result = ::zserio::calcHashCode(result, m_yieldToTrafficAhead_);
    result = ::zserio::calcHashCode(result, m_noDividerYieldToCurb_);

    return result;
}

void LaneMergeRules::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_yieldToOngoingLane_);
    out.writeBool(m_yieldToCurb_);
    out.writeBool(m_yieldToTrafficAhead_);
    out.writeBool(m_noDividerYieldToCurb_);
}

bool LaneMergeRules::readYieldToOngoingLane(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool LaneMergeRules::readYieldToCurb(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool LaneMergeRules::readYieldToTrafficAhead(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool LaneMergeRules::readNoDividerYieldToCurb(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/VehicleLightConditions.h>

namespace nds
{
namespace rules
{
namespace types
{

VehicleLightConditions::VehicleLightConditions(const allocator_type&) noexcept :
        m_alwaysRequired_(bool()),
        m_afterSunset_(::zserio::NullOpt),
        m_withWindshieldWipers_(::zserio::NullOpt),
        m_lowVisibility_(::zserio::NullOpt)
{
}

VehicleLightConditions::VehicleLightConditions(::zserio::BitStreamReader& in, const allocator_type&) :
        m_alwaysRequired_(readAlwaysRequired(in)),
        m_afterSunset_(readAfterSunset(in)),
        m_withWindshieldWipers_(readWithWindshieldWipers(in)),
        m_lowVisibility_(readLowVisibility(in))
{
}

VehicleLightConditions::VehicleLightConditions(::zserio::PropagateAllocatorT,
        const VehicleLightConditions& other, const allocator_type& allocator) :
        m_alwaysRequired_(::zserio::allocatorPropagatingCopy(other.m_alwaysRequired_, allocator)),
        m_afterSunset_(::zserio::allocatorPropagatingCopy(other.m_afterSunset_, allocator)),
        m_withWindshieldWipers_(::zserio::allocatorPropagatingCopy(other.m_withWindshieldWipers_, allocator)),
        m_lowVisibility_(::zserio::allocatorPropagatingCopy(other.m_lowVisibility_, allocator))
{
}

bool VehicleLightConditions::getAlwaysRequired() const
{
    return m_alwaysRequired_;
}

void VehicleLightConditions::setAlwaysRequired(bool alwaysRequired_)
{
    m_alwaysRequired_ = alwaysRequired_;
}

bool VehicleLightConditions::getAfterSunset() const
{
    return m_afterSunset_.value();
}

void VehicleLightConditions::setAfterSunset(bool afterSunset_)
{
    m_afterSunset_ = afterSunset_;
}

bool VehicleLightConditions::isAfterSunsetUsed() const
{
    return (!getAlwaysRequired());
}

bool VehicleLightConditions::isAfterSunsetSet() const
{
    return m_afterSunset_.hasValue();
}

void VehicleLightConditions::resetAfterSunset()
{
    m_afterSunset_.reset();
}

bool VehicleLightConditions::getWithWindshieldWipers() const
{
    return m_withWindshieldWipers_.value();
}

void VehicleLightConditions::setWithWindshieldWipers(bool withWindshieldWipers_)
{
    m_withWindshieldWipers_ = withWindshieldWipers_;
}

bool VehicleLightConditions::isWithWindshieldWipersUsed() const
{
    return (!getAlwaysRequired());
}

bool VehicleLightConditions::isWithWindshieldWipersSet() const
{
    return m_withWindshieldWipers_.hasValue();
}

void VehicleLightConditions::resetWithWindshieldWipers()
{
    m_withWindshieldWipers_.reset();
}

bool VehicleLightConditions::getLowVisibility() const
{
    return m_lowVisibility_.value();
}

void VehicleLightConditions::setLowVisibility(bool lowVisibility_)
{
    m_lowVisibility_ = lowVisibility_;
}

bool VehicleLightConditions::isLowVisibilityUsed() const
{
    return (!getAlwaysRequired());
}

bool VehicleLightConditions::isLowVisibilitySet() const
{
    return m_lowVisibility_.hasValue();
}

void VehicleLightConditions::resetLowVisibility()
{
    m_lowVisibility_.reset();
}

size_t VehicleLightConditions::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (!getAlwaysRequired())
    {
        endBitPosition += UINT8_C(1);
    }
    if (!getAlwaysRequired())
    {
        endBitPosition += UINT8_C(1);
    }
    if (!getAlwaysRequired())
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition - bitPosition;
}

size_t VehicleLightConditions::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (!getAlwaysRequired())
    {
        endBitPosition += UINT8_C(1);
    }
    if (!getAlwaysRequired())
    {
        endBitPosition += UINT8_C(1);
    }
    if (!getAlwaysRequired())
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition;
}

bool VehicleLightConditions::operator==(const VehicleLightConditions& other) const
{
    if (this != &other)
    {
        return
                (m_alwaysRequired_ == other.m_alwaysRequired_) &&
                (!isAfterSunsetUsed() ? !other.isAfterSunsetUsed() : (m_afterSunset_ == other.m_afterSunset_)) &&
                (!isWithWindshieldWipersUsed() ? !other.isWithWindshieldWipersUsed() : (m_withWindshieldWipers_ == other.m_withWindshieldWipers_)) &&
                (!isLowVisibilityUsed() ? !other.isLowVisibilityUsed() : (m_lowVisibility_ == other.m_lowVisibility_));
    }

    return true;
}

uint32_t VehicleLightConditions::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_alwaysRequired_);
    if (isAfterSunsetUsed())
        result = ::zserio::calcHashCode(result, m_afterSunset_);
    if (isWithWindshieldWipersUsed())
        result = ::zserio::calcHashCode(result, m_withWindshieldWipers_);
    if (isLowVisibilityUsed())
        result = ::zserio::calcHashCode(result, m_lowVisibility_);

    return result;
}

void VehicleLightConditions::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_alwaysRequired_);
    if (!getAlwaysRequired())
    {
        out.writeBool(m_afterSunset_.value());
    }
    if (!getAlwaysRequired())
    {
        out.writeBool(m_withWindshieldWipers_.value());
    }
    if (!getAlwaysRequired())
    {
        out.writeBool(m_lowVisibility_.value());
    }
}

bool VehicleLightConditions::readAlwaysRequired(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<bool> VehicleLightConditions::readAfterSunset(::zserio::BitStreamReader& in)
{
    if (!getAlwaysRequired())
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> VehicleLightConditions::readWithWindshieldWipers(::zserio::BitStreamReader& in)
{
    if (!getAlwaysRequired())
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> VehicleLightConditions::readLowVisibility(::zserio::BitStreamReader& in)
{
    if (!getAlwaysRequired())
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/OfficialLanguages.h>

namespace nds
{
namespace rules
{
namespace types
{

OfficialLanguages::OfficialLanguages(const allocator_type& allocator) noexcept :
        m_officialLanguages_(allocator)
{
}

OfficialLanguages::OfficialLanguages(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_officialLanguages_(readOfficialLanguages(in, allocator))
{
}

OfficialLanguages::OfficialLanguages(OfficialLanguages::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_officialLanguages_(readOfficialLanguages(context, in, allocator))
{
}

OfficialLanguages::OfficialLanguages(::zserio::PropagateAllocatorT,
        const OfficialLanguages& other, const allocator_type& allocator) :
        m_officialLanguages_(::zserio::allocatorPropagatingCopy(other.m_officialLanguages_, allocator))
{
}

::zserio::vector<::nds::core::types::LanguageCode>& OfficialLanguages::getOfficialLanguages()
{
    return m_officialLanguages_.getRawArray();
}

const ::zserio::vector<::nds::core::types::LanguageCode>& OfficialLanguages::getOfficialLanguages() const
{
    return m_officialLanguages_.getRawArray();
}

void OfficialLanguages::setOfficialLanguages(const ::zserio::vector<::nds::core::types::LanguageCode>& officialLanguages_)
{
    m_officialLanguages_ = ZserioArrayType_officialLanguages(officialLanguages_);
}

void OfficialLanguages::setOfficialLanguages(::zserio::vector<::nds::core::types::LanguageCode>&& officialLanguages_)
{
    m_officialLanguages_ = ZserioArrayType_officialLanguages(std::move(officialLanguages_));
}

void OfficialLanguages::initPackingContext(OfficialLanguages::ZserioPackingContext&) const
{
}

size_t OfficialLanguages::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_officialLanguages_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OfficialLanguages::bitSizeOf(OfficialLanguages::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_officialLanguages_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OfficialLanguages::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_officialLanguages_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t OfficialLanguages::initializeOffsets(OfficialLanguages::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_officialLanguages_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool OfficialLanguages::operator==(const OfficialLanguages& other) const
{
    if (this != &other)
    {
        return
                (m_officialLanguages_ == other.m_officialLanguages_);
    }

    return true;
}

uint32_t OfficialLanguages::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_officialLanguages_);

    return result;
}

void OfficialLanguages::write(::zserio::BitStreamWriter& out) const
{
    m_officialLanguages_.write(out);
}

void OfficialLanguages::write(OfficialLanguages::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_officialLanguages_.writePacked(out);
}

OfficialLanguages::ZserioArrayType_officialLanguages OfficialLanguages::readOfficialLanguages(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_officialLanguages readField(allocator);
    readField.read(in);

    return readField;
}

OfficialLanguages::ZserioArrayType_officialLanguages OfficialLanguages::readOfficialLanguages(OfficialLanguages::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_officialLanguages readField(allocator);
    readField.readPacked(in);

    return readField;
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/LaneRightOfWayRegulation.h>

namespace nds
{
namespace rules
{
namespace types
{

LaneRightOfWayRegulation::LaneRightOfWayRegulation(const allocator_type& allocator) noexcept :
        m_otherLane_(allocator),
        m_otherLaneRange_(allocator),
        m_type_(::nds::rules::types::RightOfWayType())
{
}

LaneRightOfWayRegulation::LaneRightOfWayRegulation(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_otherLane_(readOtherLane(in, allocator)),
        m_otherLaneRange_(readOtherLaneRange(in, allocator)),
        m_type_(readType(in))
{
}

LaneRightOfWayRegulation::LaneRightOfWayRegulation(LaneRightOfWayRegulation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_otherLane_(readOtherLane(context, in, allocator)),
        m_otherLaneRange_(readOtherLaneRange(context, in, allocator)),
        m_type_(readType(context, in))
{
}

LaneRightOfWayRegulation::LaneRightOfWayRegulation(::zserio::PropagateAllocatorT,
        const LaneRightOfWayRegulation& other, const allocator_type& allocator) :
        m_otherLane_(::zserio::allocatorPropagatingCopy(other.m_otherLane_, allocator)),
        m_otherLaneRange_(::zserio::allocatorPropagatingCopy(other.m_otherLaneRange_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator))
{
}

::nds::lane::reference::types::LaneId& LaneRightOfWayRegulation::getOtherLane()
{
    return m_otherLane_;
}

const ::nds::lane::reference::types::LaneId& LaneRightOfWayRegulation::getOtherLane() const
{
    return m_otherLane_;
}

void LaneRightOfWayRegulation::setOtherLane(const ::nds::lane::reference::types::LaneId& otherLane_)
{
    m_otherLane_ = otherLane_;
}

void LaneRightOfWayRegulation::setOtherLane(::nds::lane::reference::types::LaneId&& otherLane_)
{
    m_otherLane_ = ::std::move(otherLane_);
}

::nds::lane::reference::types::LaneGeometryRange& LaneRightOfWayRegulation::getOtherLaneRange()
{
    return m_otherLaneRange_;
}

const ::nds::lane::reference::types::LaneGeometryRange& LaneRightOfWayRegulation::getOtherLaneRange() const
{
    return m_otherLaneRange_;
}

void LaneRightOfWayRegulation::setOtherLaneRange(const ::nds::lane::reference::types::LaneGeometryRange& otherLaneRange_)
{
    m_otherLaneRange_ = otherLaneRange_;
}

void LaneRightOfWayRegulation::setOtherLaneRange(::nds::lane::reference::types::LaneGeometryRange&& otherLaneRange_)
{
    m_otherLaneRange_ = ::std::move(otherLaneRange_);
}

::nds::rules::types::RightOfWayType LaneRightOfWayRegulation::getType() const
{
    return m_type_;
}

void LaneRightOfWayRegulation::setType(::nds::rules::types::RightOfWayType type_)
{
    m_type_ = type_;
}

void LaneRightOfWayRegulation::initPackingContext(LaneRightOfWayRegulation::ZserioPackingContext& context) const
{
    m_otherLane_.initPackingContext(context.getOtherLane());
    m_otherLaneRange_.initPackingContext(context.getOtherLaneRange());
    ::zserio::initPackingContext(context.getType(), m_type_);
}

size_t LaneRightOfWayRegulation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_otherLane_.bitSizeOf(endBitPosition);
    endBitPosition += m_otherLaneRange_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_type_);

    return endBitPosition - bitPosition;
}

size_t LaneRightOfWayRegulation::bitSizeOf(LaneRightOfWayRegulation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_otherLane_.bitSizeOf(context.getOtherLane(), endBitPosition);
    endBitPosition += m_otherLaneRange_.bitSizeOf(context.getOtherLaneRange(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);

    return endBitPosition - bitPosition;
}

size_t LaneRightOfWayRegulation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_otherLane_.initializeOffsets(endBitPosition);
    endBitPosition = m_otherLaneRange_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);

    return endBitPosition;
}

size_t LaneRightOfWayRegulation::initializeOffsets(LaneRightOfWayRegulation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_otherLane_.initializeOffsets(context.getOtherLane(), endBitPosition);
    endBitPosition = m_otherLaneRange_.initializeOffsets(context.getOtherLaneRange(), endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);

    return endBitPosition;
}

bool LaneRightOfWayRegulation::operator==(const LaneRightOfWayRegulation& other) const
{
    if (this != &other)
    {
        return
                (m_otherLane_ == other.m_otherLane_) &&
                (m_otherLaneRange_ == other.m_otherLaneRange_) &&
                (m_type_ == other.m_type_);
    }

    return true;
}

uint32_t LaneRightOfWayRegulation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_otherLane_);
    result = ::zserio::calcHashCode(result, m_otherLaneRange_);
    result = ::zserio::calcHashCode(result, m_type_);

    return result;
}

void LaneRightOfWayRegulation::write(::zserio::BitStreamWriter& out) const
{
    m_otherLane_.write(out);
    m_otherLaneRange_.write(out);
    ::zserio::write(out, m_type_);
}

void LaneRightOfWayRegulation::write(LaneRightOfWayRegulation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_otherLane_.write(context.getOtherLane(), out);
    m_otherLaneRange_.write(context.getOtherLaneRange(), out);
    ::zserio::write(context.getType(), out, m_type_);
}

::nds::lane::reference::types::LaneId LaneRightOfWayRegulation::readOtherLane(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneId(in, allocator);
}

::nds::lane::reference::types::LaneId LaneRightOfWayRegulation::readOtherLane(LaneRightOfWayRegulation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneId(context.getOtherLane(), in, allocator);
}
::nds::lane::reference::types::LaneGeometryRange LaneRightOfWayRegulation::readOtherLaneRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGeometryRange(in, allocator);
}

::nds::lane::reference::types::LaneGeometryRange LaneRightOfWayRegulation::readOtherLaneRange(LaneRightOfWayRegulation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGeometryRange(context.getOtherLaneRange(), in, allocator);
}
::nds::rules::types::RightOfWayType LaneRightOfWayRegulation::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::RightOfWayType>(in);
}

::nds::rules::types::RightOfWayType LaneRightOfWayRegulation::readType(LaneRightOfWayRegulation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::RightOfWayType>(context.getType(), in);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/LaneTrafficPriority.h>

namespace nds
{
namespace rules
{
namespace types
{

LaneTrafficPriority::LaneTrafficPriority(const allocator_type& allocator) noexcept :
        m_reason_(::nds::rules::types::LaneTrafficPriorityReason()),
        m_numLanes_(uint32_t()),
        m_otherLanes_(allocator),
        m_range_(allocator)
{
}

LaneTrafficPriority::LaneTrafficPriority(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_reason_(readReason(in)),
        m_numLanes_(readNumLanes(in)),
        m_otherLanes_(readOtherLanes(in, allocator)),
        m_range_(readRange(in, allocator))
{
}

LaneTrafficPriority::LaneTrafficPriority(LaneTrafficPriority::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_reason_(readReason(context, in)),
        m_numLanes_(readNumLanes(context, in)),
        m_otherLanes_(readOtherLanes(context, in, allocator)),
        m_range_(readRange(context, in, allocator))
{
}

LaneTrafficPriority::LaneTrafficPriority(::zserio::PropagateAllocatorT,
        const LaneTrafficPriority& other, const allocator_type& allocator) :
        m_reason_(::zserio::allocatorPropagatingCopy(other.m_reason_, allocator)),
        m_numLanes_(::zserio::allocatorPropagatingCopy(other.m_numLanes_, allocator)),
        m_otherLanes_(::zserio::allocatorPropagatingCopy(other.m_otherLanes_, allocator)),
        m_range_(::zserio::allocatorPropagatingCopy(other.m_range_, allocator))
{
}

::nds::rules::types::LaneTrafficPriorityReason LaneTrafficPriority::getReason() const
{
    return m_reason_;
}

void LaneTrafficPriority::setReason(::nds::rules::types::LaneTrafficPriorityReason reason_)
{
    m_reason_ = reason_;
}

uint32_t LaneTrafficPriority::getNumLanes() const
{
    return m_numLanes_;
}

void LaneTrafficPriority::setNumLanes(uint32_t numLanes_)
{
    m_numLanes_ = numLanes_;
}

::zserio::vector<::nds::lane::reference::types::LaneId>& LaneTrafficPriority::getOtherLanes()
{
    return m_otherLanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneId>& LaneTrafficPriority::getOtherLanes() const
{
    return m_otherLanes_.getRawArray();
}

void LaneTrafficPriority::setOtherLanes(const ::zserio::vector<::nds::lane::reference::types::LaneId>& otherLanes_)
{
    m_otherLanes_ = ZserioArrayType_otherLanes(otherLanes_);
}

void LaneTrafficPriority::setOtherLanes(::zserio::vector<::nds::lane::reference::types::LaneId>&& otherLanes_)
{
    m_otherLanes_ = ZserioArrayType_otherLanes(std::move(otherLanes_));
}

::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& LaneTrafficPriority::getRange()
{
    return m_range_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& LaneTrafficPriority::getRange() const
{
    return m_range_.getRawArray();
}

void LaneTrafficPriority::setRange(const ::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& range_)
{
    m_range_ = ZserioArrayType_range(range_);
}

void LaneTrafficPriority::setRange(::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>&& range_)
{
    m_range_ = ZserioArrayType_range(std::move(range_));
}

void LaneTrafficPriority::initPackingContext(LaneTrafficPriority::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getReason(), m_reason_);
    context.getNumLanes().init<::zserio::VarSizeArrayTraits>(m_numLanes_);
}

size_t LaneTrafficPriority::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_reason_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numLanes_);
    endBitPosition += m_otherLanes_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_range_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneTrafficPriority::bitSizeOf(LaneTrafficPriority::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getReason(), m_reason_);
    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numLanes_);
    endBitPosition += m_otherLanes_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_range_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneTrafficPriority::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_reason_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numLanes_);
    endBitPosition = m_otherLanes_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_range_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t LaneTrafficPriority::initializeOffsets(LaneTrafficPriority::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getReason(), endBitPosition,
        m_reason_);
    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numLanes_);
    endBitPosition = m_otherLanes_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_range_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LaneTrafficPriority::operator==(const LaneTrafficPriority& other) const
{
    if (this != &other)
    {
        return
                (m_reason_ == other.m_reason_) &&
                (m_numLanes_ == other.m_numLanes_) &&
                (m_otherLanes_ == other.m_otherLanes_) &&
                (m_range_ == other.m_range_);
    }

    return true;
}

uint32_t LaneTrafficPriority::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_reason_);
    result = ::zserio::calcHashCode(result, m_numLanes_);
    result = ::zserio::calcHashCode(result, m_otherLanes_);
    result = ::zserio::calcHashCode(result, m_range_);

    return result;
}

void LaneTrafficPriority::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_reason_);

    out.writeVarSize(m_numLanes_);

    // check array length
    if (m_otherLanes_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneTrafficPriority.otherLanes: ") <<
                m_otherLanes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_otherLanes_.write(*this, out);

    // check array length
    if (m_range_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneTrafficPriority.range: ") <<
                m_range_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_range_.write(*this, out);
}

void LaneTrafficPriority::write(LaneTrafficPriority::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getReason(), out, m_reason_);

    context.getNumLanes().write<::zserio::VarSizeArrayTraits>(out, m_numLanes_);

    // check array length
    if (m_otherLanes_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneTrafficPriority.otherLanes: ") <<
                m_otherLanes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_otherLanes_.writePacked(*this, out);

    // check array length
    if (m_range_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneTrafficPriority.range: ") <<
                m_range_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_range_.writePacked(*this, out);
}

void LaneTrafficPriority::ZserioElementFactory_otherLanes::create(LaneTrafficPriority&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneTrafficPriority::ZserioElementFactory_otherLanes::create(LaneTrafficPriority&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneId>& array,
        ::nds::lane::reference::types::LaneId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LaneTrafficPriority::ZserioElementFactory_range::create(LaneTrafficPriority&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneTrafficPriority::ZserioElementFactory_range::create(LaneTrafficPriority&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& array,
        ::nds::lane::reference::types::LaneGeometryRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::types::LaneTrafficPriorityReason LaneTrafficPriority::readReason(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::LaneTrafficPriorityReason>(in);
}

::nds::rules::types::LaneTrafficPriorityReason LaneTrafficPriority::readReason(LaneTrafficPriority::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::LaneTrafficPriorityReason>(context.getReason(), in);
}
uint32_t LaneTrafficPriority::readNumLanes(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LaneTrafficPriority::readNumLanes(LaneTrafficPriority::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumLanes().read<::zserio::VarSizeArrayTraits>(in);
}
LaneTrafficPriority::ZserioArrayType_otherLanes LaneTrafficPriority::readOtherLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_otherLanes readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumLanes()));

    return readField;
}

LaneTrafficPriority::ZserioArrayType_otherLanes LaneTrafficPriority::readOtherLanes(LaneTrafficPriority::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_otherLanes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumLanes()));

    return readField;
}
LaneTrafficPriority::ZserioArrayType_range LaneTrafficPriority::readRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_range readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumLanes()));

    return readField;
}

LaneTrafficPriority::ZserioArrayType_range LaneTrafficPriority::readRange(LaneTrafficPriority::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_range readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumLanes()));

    return readField;
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/TrafficEnforcementZone.h>

namespace nds
{
namespace rules
{
namespace types
{

TrafficEnforcementZone::TrafficEnforcementZone(const allocator_type&) noexcept :
        m_trafficEnforcementZoneType_(::nds::core::types::TrafficEnforcementZoneType()),
        m_zoneLength_(::nds::core::types::LengthMeters())
{
}

TrafficEnforcementZone::TrafficEnforcementZone(::zserio::BitStreamReader& in, const allocator_type&) :
        m_trafficEnforcementZoneType_(readTrafficEnforcementZoneType(in)),
        m_zoneLength_(readZoneLength(in))
{
}

TrafficEnforcementZone::TrafficEnforcementZone(TrafficEnforcementZone::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_trafficEnforcementZoneType_(readTrafficEnforcementZoneType(context, in)),
        m_zoneLength_(readZoneLength(context, in))
{
}

TrafficEnforcementZone::TrafficEnforcementZone(::zserio::PropagateAllocatorT,
        const TrafficEnforcementZone& other, const allocator_type& allocator) :
        m_trafficEnforcementZoneType_(::zserio::allocatorPropagatingCopy(other.m_trafficEnforcementZoneType_, allocator)),
        m_zoneLength_(::zserio::allocatorPropagatingCopy(other.m_zoneLength_, allocator))
{
}

::nds::core::types::TrafficEnforcementZoneType TrafficEnforcementZone::getTrafficEnforcementZoneType() const
{
    return m_trafficEnforcementZoneType_;
}

void TrafficEnforcementZone::setTrafficEnforcementZoneType(::nds::core::types::TrafficEnforcementZoneType trafficEnforcementZoneType_)
{
    m_trafficEnforcementZoneType_ = trafficEnforcementZoneType_;
}

::nds::core::types::LengthMeters TrafficEnforcementZone::getZoneLength() const
{
    return m_zoneLength_;
}

void TrafficEnforcementZone::setZoneLength(::nds::core::types::LengthMeters zoneLength_)
{
    m_zoneLength_ = zoneLength_;
}

void TrafficEnforcementZone::initPackingContext(TrafficEnforcementZone::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getTrafficEnforcementZoneType(), m_trafficEnforcementZoneType_);
    context.getZoneLength().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(m_zoneLength_);
}

size_t TrafficEnforcementZone::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_trafficEnforcementZoneType_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_zoneLength_);

    return endBitPosition - bitPosition;
}

size_t TrafficEnforcementZone::bitSizeOf(TrafficEnforcementZone::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getTrafficEnforcementZoneType(), m_trafficEnforcementZoneType_);
    endBitPosition += context.getZoneLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(m_zoneLength_);

    return endBitPosition - bitPosition;
}

size_t TrafficEnforcementZone::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_trafficEnforcementZoneType_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_zoneLength_);

    return endBitPosition;
}

size_t TrafficEnforcementZone::initializeOffsets(TrafficEnforcementZone::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getTrafficEnforcementZoneType(), endBitPosition,
        m_trafficEnforcementZoneType_);
    endBitPosition += context.getZoneLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(m_zoneLength_);

    return endBitPosition;
}

bool TrafficEnforcementZone::operator==(const TrafficEnforcementZone& other) const
{
    if (this != &other)
    {
        return
                (m_trafficEnforcementZoneType_ == other.m_trafficEnforcementZoneType_) &&
                (m_zoneLength_ == other.m_zoneLength_);
    }

    return true;
}

uint32_t TrafficEnforcementZone::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_trafficEnforcementZoneType_);
    result = ::zserio::calcHashCode(result, m_zoneLength_);

    return result;
}

void TrafficEnforcementZone::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_trafficEnforcementZoneType_);
    out.writeVarUInt32(m_zoneLength_);
}

void TrafficEnforcementZone::write(TrafficEnforcementZone::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getTrafficEnforcementZoneType(), out, m_trafficEnforcementZoneType_);
    context.getZoneLength().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(out, m_zoneLength_);
}

::nds::core::types::TrafficEnforcementZoneType TrafficEnforcementZone::readTrafficEnforcementZoneType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::TrafficEnforcementZoneType>(in);
}

::nds::core::types::TrafficEnforcementZoneType TrafficEnforcementZone::readTrafficEnforcementZoneType(TrafficEnforcementZone::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::TrafficEnforcementZoneType>(context.getTrafficEnforcementZoneType(), in);
}
::nds::core::types::LengthMeters TrafficEnforcementZone::readZoneLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LengthMeters>(in.readVarUInt32());
}

::nds::core::types::LengthMeters TrafficEnforcementZone::readZoneLength(TrafficEnforcementZone::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getZoneLength().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(in);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/LicensePlateRestriction.h>

namespace nds
{
namespace rules
{
namespace types
{

LicensePlateRestriction::LicensePlateRestriction(const allocator_type& allocator) noexcept :
        m_licensePlateRestrictionType_(::nds::rules::types::LicensePlateRestrictionType()),
        m_licensePlateRestrictionRule_(allocator),
        m_licensePlateRestrictionDescription_(allocator)
{
}

LicensePlateRestriction::LicensePlateRestriction(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_licensePlateRestrictionType_(readLicensePlateRestrictionType(in)),
        m_licensePlateRestrictionRule_(readLicensePlateRestrictionRule(in, allocator)),
        m_licensePlateRestrictionDescription_(readLicensePlateRestrictionDescription(in, allocator))
{
}

LicensePlateRestriction::LicensePlateRestriction(LicensePlateRestriction::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_licensePlateRestrictionType_(readLicensePlateRestrictionType(context, in)),
        m_licensePlateRestrictionRule_(readLicensePlateRestrictionRule(context, in, allocator)),
        m_licensePlateRestrictionDescription_(readLicensePlateRestrictionDescription(in, allocator))
{
}

LicensePlateRestriction::LicensePlateRestriction(::zserio::PropagateAllocatorT,
        const LicensePlateRestriction& other, const allocator_type& allocator) :
        m_licensePlateRestrictionType_(::zserio::allocatorPropagatingCopy(other.m_licensePlateRestrictionType_, allocator)),
        m_licensePlateRestrictionRule_(::zserio::allocatorPropagatingCopy(other.m_licensePlateRestrictionRule_, allocator)),
        m_licensePlateRestrictionDescription_(::zserio::allocatorPropagatingCopy(other.m_licensePlateRestrictionDescription_, allocator))
{
}

::nds::rules::types::LicensePlateRestrictionType LicensePlateRestriction::getLicensePlateRestrictionType() const
{
    return m_licensePlateRestrictionType_;
}

void LicensePlateRestriction::setLicensePlateRestrictionType(::nds::rules::types::LicensePlateRestrictionType licensePlateRestrictionType_)
{
    m_licensePlateRestrictionType_ = licensePlateRestrictionType_;
}

::nds::rules::types::LicensePlateRestrictionRule& LicensePlateRestriction::getLicensePlateRestrictionRule()
{
    return m_licensePlateRestrictionRule_;
}

const ::nds::rules::types::LicensePlateRestrictionRule& LicensePlateRestriction::getLicensePlateRestrictionRule() const
{
    return m_licensePlateRestrictionRule_;
}

void LicensePlateRestriction::setLicensePlateRestrictionRule(const ::nds::rules::types::LicensePlateRestrictionRule& licensePlateRestrictionRule_)
{
    m_licensePlateRestrictionRule_ = licensePlateRestrictionRule_;
}

void LicensePlateRestriction::setLicensePlateRestrictionRule(::nds::rules::types::LicensePlateRestrictionRule&& licensePlateRestrictionRule_)
{
    m_licensePlateRestrictionRule_ = ::std::move(licensePlateRestrictionRule_);
}

::zserio::string<>& LicensePlateRestriction::getLicensePlateRestrictionDescription()
{
    return m_licensePlateRestrictionDescription_;
}

const ::zserio::string<>& LicensePlateRestriction::getLicensePlateRestrictionDescription() const
{
    return m_licensePlateRestrictionDescription_;
}

void LicensePlateRestriction::setLicensePlateRestrictionDescription(const ::zserio::string<>& licensePlateRestrictionDescription_)
{
    m_licensePlateRestrictionDescription_ = licensePlateRestrictionDescription_;
}

void LicensePlateRestriction::setLicensePlateRestrictionDescription(::zserio::string<>&& licensePlateRestrictionDescription_)
{
    m_licensePlateRestrictionDescription_ = ::std::move(licensePlateRestrictionDescription_);
}

void LicensePlateRestriction::initPackingContext(LicensePlateRestriction::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getLicensePlateRestrictionType(), m_licensePlateRestrictionType_);
    m_licensePlateRestrictionRule_.initPackingContext(context.getLicensePlateRestrictionRule());
}

size_t LicensePlateRestriction::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_licensePlateRestrictionType_);
    endBitPosition += m_licensePlateRestrictionRule_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_licensePlateRestrictionDescription_);

    return endBitPosition - bitPosition;
}

size_t LicensePlateRestriction::bitSizeOf(LicensePlateRestriction::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getLicensePlateRestrictionType(), m_licensePlateRestrictionType_);
    endBitPosition += m_licensePlateRestrictionRule_.bitSizeOf(context.getLicensePlateRestrictionRule(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_licensePlateRestrictionDescription_);

    return endBitPosition - bitPosition;
}

size_t LicensePlateRestriction::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_licensePlateRestrictionType_);
    endBitPosition = m_licensePlateRestrictionRule_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_licensePlateRestrictionDescription_);

    return endBitPosition;
}

size_t LicensePlateRestriction::initializeOffsets(LicensePlateRestriction::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getLicensePlateRestrictionType(), endBitPosition,
        m_licensePlateRestrictionType_);
    endBitPosition = m_licensePlateRestrictionRule_.initializeOffsets(context.getLicensePlateRestrictionRule(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_licensePlateRestrictionDescription_);

    return endBitPosition;
}

bool LicensePlateRestriction::operator==(const LicensePlateRestriction& other) const
{
    if (this != &other)
    {
        return
                (m_licensePlateRestrictionType_ == other.m_licensePlateRestrictionType_) &&
                (m_licensePlateRestrictionRule_ == other.m_licensePlateRestrictionRule_) &&
                (m_licensePlateRestrictionDescription_ == other.m_licensePlateRestrictionDescription_);
    }

    return true;
}

uint32_t LicensePlateRestriction::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_licensePlateRestrictionType_);
    result = ::zserio::calcHashCode(result, m_licensePlateRestrictionRule_);
    result = ::zserio::calcHashCode(result, m_licensePlateRestrictionDescription_);

    return result;
}

void LicensePlateRestriction::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_licensePlateRestrictionType_);
    m_licensePlateRestrictionRule_.write(out);
    out.writeString(m_licensePlateRestrictionDescription_);
}

void LicensePlateRestriction::write(LicensePlateRestriction::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getLicensePlateRestrictionType(), out, m_licensePlateRestrictionType_);
    m_licensePlateRestrictionRule_.write(context.getLicensePlateRestrictionRule(), out);
    out.writeString(m_licensePlateRestrictionDescription_);
}

::nds::rules::types::LicensePlateRestrictionType LicensePlateRestriction::readLicensePlateRestrictionType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::LicensePlateRestrictionType>(in);
}

::nds::rules::types::LicensePlateRestrictionType LicensePlateRestriction::readLicensePlateRestrictionType(LicensePlateRestriction::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::LicensePlateRestrictionType>(context.getLicensePlateRestrictionType(), in);
}
::nds::rules::types::LicensePlateRestrictionRule LicensePlateRestriction::readLicensePlateRestrictionRule(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::types::LicensePlateRestrictionRule(in, allocator);
}

::nds::rules::types::LicensePlateRestrictionRule LicensePlateRestriction::readLicensePlateRestrictionRule(LicensePlateRestriction::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::types::LicensePlateRestrictionRule(context.getLicensePlateRestrictionRule(), in, allocator);
}
::zserio::string<> LicensePlateRestriction::readLicensePlateRestrictionDescription(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/rules/types/LicensePlateRestrictionRule.h>
#include <nds/rules/types/LicensePlateDigitRuleType.h>

namespace nds
{
namespace rules
{
namespace types
{

LicensePlateRestrictionRule::LicensePlateRestrictionRule(const allocator_type&) noexcept :
        m_noPermitPaper_(bool()),
        m_isSpecificPlates_(bool()),
        m_isFirstDigitRule_(bool()),
        m_isLastDigitRule_(bool()),
        m_firstDigitRuleType_(::zserio::NullOpt),
        m_numFirstSpecialDigits_(::zserio::NullOpt),
        m_firstSpecialDigit_(::zserio::NullOpt),
        m_lastDigitRuleType_(::zserio::NullOpt),
        m_numLastSpecialDigits_(::zserio::NullOpt),
        m_lastSpecialDigit_(::zserio::NullOpt),
        m_numSpecificPlates_(::zserio::NullOpt),
        m_specificPlates_(::zserio::NullOpt)
{
}

LicensePlateRestrictionRule::LicensePlateRestrictionRule(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_noPermitPaper_(readNoPermitPaper(in)),
        m_isSpecificPlates_(readIsSpecificPlates(in)),
        m_isFirstDigitRule_(readIsFirstDigitRule(in)),
        m_isLastDigitRule_(readIsLastDigitRule(in)),
        m_firstDigitRuleType_(readFirstDigitRuleType(in)),
        m_numFirstSpecialDigits_(readNumFirstSpecialDigits(in)),
        m_firstSpecialDigit_(readFirstSpecialDigit(in, allocator)),
        m_lastDigitRuleType_(readLastDigitRuleType(in)),
        m_numLastSpecialDigits_(readNumLastSpecialDigits(in)),
        m_lastSpecialDigit_(readLastSpecialDigit(in, allocator)),
        m_numSpecificPlates_(readNumSpecificPlates(in)),
        m_specificPlates_(readSpecificPlates(in, allocator))
{
}

LicensePlateRestrictionRule::LicensePlateRestrictionRule(LicensePlateRestrictionRule::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_noPermitPaper_(readNoPermitPaper(in)),
        m_isSpecificPlates_(readIsSpecificPlates(in)),
        m_isFirstDigitRule_(readIsFirstDigitRule(in)),
        m_isLastDigitRule_(readIsLastDigitRule(in)),
        m_firstDigitRuleType_(readFirstDigitRuleType(context, in)),
        m_numFirstSpecialDigits_(readNumFirstSpecialDigits(context, in)),
        m_firstSpecialDigit_(readFirstSpecialDigit(in, allocator)),
        m_lastDigitRuleType_(readLastDigitRuleType(context, in)),
        m_numLastSpecialDigits_(readNumLastSpecialDigits(context, in)),
        m_lastSpecialDigit_(readLastSpecialDigit(in, allocator)),
        m_numSpecificPlates_(readNumSpecificPlates(context, in)),
        m_specificPlates_(readSpecificPlates(in, allocator))
{
}

LicensePlateRestrictionRule::LicensePlateRestrictionRule(::zserio::PropagateAllocatorT,
        const LicensePlateRestrictionRule& other, const allocator_type& allocator) :
        m_noPermitPaper_(::zserio::allocatorPropagatingCopy(other.m_noPermitPaper_, allocator)),
        m_isSpecificPlates_(::zserio::allocatorPropagatingCopy(other.m_isSpecificPlates_, allocator)),
        m_isFirstDigitRule_(::zserio::allocatorPropagatingCopy(other.m_isFirstDigitRule_, allocator)),
        m_isLastDigitRule_(::zserio::allocatorPropagatingCopy(other.m_isLastDigitRule_, allocator)),
        m_firstDigitRuleType_(::zserio::allocatorPropagatingCopy(other.m_firstDigitRuleType_, allocator)),
        m_numFirstSpecialDigits_(::zserio::allocatorPropagatingCopy(other.m_numFirstSpecialDigits_, allocator)),
        m_firstSpecialDigit_(::zserio::allocatorPropagatingCopy(other.m_firstSpecialDigit_, allocator)),
        m_lastDigitRuleType_(::zserio::allocatorPropagatingCopy(other.m_lastDigitRuleType_, allocator)),
        m_numLastSpecialDigits_(::zserio::allocatorPropagatingCopy(other.m_numLastSpecialDigits_, allocator)),
        m_lastSpecialDigit_(::zserio::allocatorPropagatingCopy(other.m_lastSpecialDigit_, allocator)),
        m_numSpecificPlates_(::zserio::allocatorPropagatingCopy(other.m_numSpecificPlates_, allocator)),
        m_specificPlates_(::zserio::allocatorPropagatingCopy(other.m_specificPlates_, allocator))
{
}

bool LicensePlateRestrictionRule::getNoPermitPaper() const
{
    return m_noPermitPaper_;
}

void LicensePlateRestrictionRule::setNoPermitPaper(bool noPermitPaper_)
{
    m_noPermitPaper_ = noPermitPaper_;
}

bool LicensePlateRestrictionRule::getIsSpecificPlates() const
{
    return m_isSpecificPlates_;
}

void LicensePlateRestrictionRule::setIsSpecificPlates(bool isSpecificPlates_)
{
    m_isSpecificPlates_ = isSpecificPlates_;
}

bool LicensePlateRestrictionRule::getIsFirstDigitRule() const
{
    return m_isFirstDigitRule_;
}

void LicensePlateRestrictionRule::setIsFirstDigitRule(bool isFirstDigitRule_)
{
    m_isFirstDigitRule_ = isFirstDigitRule_;
}

bool LicensePlateRestrictionRule::getIsLastDigitRule() const
{
    return m_isLastDigitRule_;
}

void LicensePlateRestrictionRule::setIsLastDigitRule(bool isLastDigitRule_)
{
    m_isLastDigitRule_ = isLastDigitRule_;
}

::nds::rules::types::LicensePlateDigitRuleType LicensePlateRestrictionRule::getFirstDigitRuleType() const
{
    return m_firstDigitRuleType_.value();
}

void LicensePlateRestrictionRule::setFirstDigitRuleType(::nds::rules::types::LicensePlateDigitRuleType firstDigitRuleType_)
{
    m_firstDigitRuleType_ = firstDigitRuleType_;
}

bool LicensePlateRestrictionRule::isFirstDigitRuleTypeUsed() const
{
    return (getIsFirstDigitRule() == true);
}

bool LicensePlateRestrictionRule::isFirstDigitRuleTypeSet() const
{
    return m_firstDigitRuleType_.hasValue();
}

void LicensePlateRestrictionRule::resetFirstDigitRuleType()
{
    m_firstDigitRuleType_.reset();
}

uint8_t LicensePlateRestrictionRule::getNumFirstSpecialDigits() const
{
    return m_numFirstSpecialDigits_.value();
}

void LicensePlateRestrictionRule::setNumFirstSpecialDigits(uint8_t numFirstSpecialDigits_)
{
    m_numFirstSpecialDigits_ = numFirstSpecialDigits_;
}

bool LicensePlateRestrictionRule::isNumFirstSpecialDigitsUsed() const
{
    return (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT);
}

bool LicensePlateRestrictionRule::isNumFirstSpecialDigitsSet() const
{
    return m_numFirstSpecialDigits_.hasValue();
}

void LicensePlateRestrictionRule::resetNumFirstSpecialDigits()
{
    m_numFirstSpecialDigits_.reset();
}

::zserio::vector<::zserio::string<>>& LicensePlateRestrictionRule::getFirstSpecialDigit()
{
    return m_firstSpecialDigit_.value().getRawArray();
}

const ::zserio::vector<::zserio::string<>>& LicensePlateRestrictionRule::getFirstSpecialDigit() const
{
    return m_firstSpecialDigit_.value().getRawArray();
}

void LicensePlateRestrictionRule::setFirstSpecialDigit(const ::zserio::vector<::zserio::string<>>& firstSpecialDigit_)
{
    m_firstSpecialDigit_ = ZserioArrayType_firstSpecialDigit(firstSpecialDigit_);
}

void LicensePlateRestrictionRule::setFirstSpecialDigit(::zserio::vector<::zserio::string<>>&& firstSpecialDigit_)
{
    m_firstSpecialDigit_ = ZserioArrayType_firstSpecialDigit(std::move(firstSpecialDigit_));
}

bool LicensePlateRestrictionRule::isFirstSpecialDigitUsed() const
{
    return (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT);
}

bool LicensePlateRestrictionRule::isFirstSpecialDigitSet() const
{
    return m_firstSpecialDigit_.hasValue();
}

void LicensePlateRestrictionRule::resetFirstSpecialDigit()
{
    m_firstSpecialDigit_.reset();
}

::nds::rules::types::LicensePlateDigitRuleType LicensePlateRestrictionRule::getLastDigitRuleType() const
{
    return m_lastDigitRuleType_.value();
}

void LicensePlateRestrictionRule::setLastDigitRuleType(::nds::rules::types::LicensePlateDigitRuleType lastDigitRuleType_)
{
    m_lastDigitRuleType_ = lastDigitRuleType_;
}

bool LicensePlateRestrictionRule::isLastDigitRuleTypeUsed() const
{
    return (getIsLastDigitRule() == true);
}

bool LicensePlateRestrictionRule::isLastDigitRuleTypeSet() const
{
    return m_lastDigitRuleType_.hasValue();
}

void LicensePlateRestrictionRule::resetLastDigitRuleType()
{
    m_lastDigitRuleType_.reset();
}

uint8_t LicensePlateRestrictionRule::getNumLastSpecialDigits() const
{
    return m_numLastSpecialDigits_.value();
}

void LicensePlateRestrictionRule::setNumLastSpecialDigits(uint8_t numLastSpecialDigits_)
{
    m_numLastSpecialDigits_ = numLastSpecialDigits_;
}

bool LicensePlateRestrictionRule::isNumLastSpecialDigitsUsed() const
{
    return (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT);
}

bool LicensePlateRestrictionRule::isNumLastSpecialDigitsSet() const
{
    return m_numLastSpecialDigits_.hasValue();
}

void LicensePlateRestrictionRule::resetNumLastSpecialDigits()
{
    m_numLastSpecialDigits_.reset();
}

::zserio::vector<::zserio::string<>>& LicensePlateRestrictionRule::getLastSpecialDigit()
{
    return m_lastSpecialDigit_.value().getRawArray();
}

const ::zserio::vector<::zserio::string<>>& LicensePlateRestrictionRule::getLastSpecialDigit() const
{
    return m_lastSpecialDigit_.value().getRawArray();
}

void LicensePlateRestrictionRule::setLastSpecialDigit(const ::zserio::vector<::zserio::string<>>& lastSpecialDigit_)
{
    m_lastSpecialDigit_ = ZserioArrayType_lastSpecialDigit(lastSpecialDigit_);
}

void LicensePlateRestrictionRule::setLastSpecialDigit(::zserio::vector<::zserio::string<>>&& lastSpecialDigit_)
{
    m_lastSpecialDigit_ = ZserioArrayType_lastSpecialDigit(std::move(lastSpecialDigit_));
}

bool LicensePlateRestrictionRule::isLastSpecialDigitUsed() const
{
    return (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT);
}

bool LicensePlateRestrictionRule::isLastSpecialDigitSet() const
{
    return m_lastSpecialDigit_.hasValue();
}

void LicensePlateRestrictionRule::resetLastSpecialDigit()
{
    m_lastSpecialDigit_.reset();
}

uint8_t LicensePlateRestrictionRule::getNumSpecificPlates() const
{
    return m_numSpecificPlates_.value();
}

void LicensePlateRestrictionRule::setNumSpecificPlates(uint8_t numSpecificPlates_)
{
    m_numSpecificPlates_ = numSpecificPlates_;
}

bool LicensePlateRestrictionRule::isNumSpecificPlatesUsed() const
{
    return (getIsSpecificPlates() == true);
}

bool LicensePlateRestrictionRule::isNumSpecificPlatesSet() const
{
    return m_numSpecificPlates_.hasValue();
}

void LicensePlateRestrictionRule::resetNumSpecificPlates()
{
    m_numSpecificPlates_.reset();
}

::zserio::vector<::zserio::string<>>& LicensePlateRestrictionRule::getSpecificPlates()
{
    return m_specificPlates_.value().getRawArray();
}

const ::zserio::vector<::zserio::string<>>& LicensePlateRestrictionRule::getSpecificPlates() const
{
    return m_specificPlates_.value().getRawArray();
}

void LicensePlateRestrictionRule::setSpecificPlates(const ::zserio::vector<::zserio::string<>>& specificPlates_)
{
    m_specificPlates_ = ZserioArrayType_specificPlates(specificPlates_);
}

void LicensePlateRestrictionRule::setSpecificPlates(::zserio::vector<::zserio::string<>>&& specificPlates_)
{
    m_specificPlates_ = ZserioArrayType_specificPlates(std::move(specificPlates_));
}

bool LicensePlateRestrictionRule::isSpecificPlatesUsed() const
{
    return (getIsSpecificPlates() == true);
}

bool LicensePlateRestrictionRule::isSpecificPlatesSet() const
{
    return m_specificPlates_.hasValue();
}

void LicensePlateRestrictionRule::resetSpecificPlates()
{
    m_specificPlates_.reset();
}

void LicensePlateRestrictionRule::initPackingContext(LicensePlateRestrictionRule::ZserioPackingContext& context) const
{
    if (getIsFirstDigitRule() == true)
    {
        ::zserio::initPackingContext(context.getFirstDigitRuleType(), m_firstDigitRuleType_.value());
    }
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        context.getNumFirstSpecialDigits().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numFirstSpecialDigits_.value());
    }
    if (getIsLastDigitRule() == true)
    {
        ::zserio::initPackingContext(context.getLastDigitRuleType(), m_lastDigitRuleType_.value());
    }
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        context.getNumLastSpecialDigits().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numLastSpecialDigits_.value());
    }
    if (getIsSpecificPlates() == true)
    {
        context.getNumSpecificPlates().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numSpecificPlates_.value());
    }
}

size_t LicensePlateRestrictionRule::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getIsFirstDigitRule() == true)
    {
        endBitPosition += ::zserio::bitSizeOf(m_firstDigitRuleType_.value());
    }
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += UINT8_C(8);
    }
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += m_firstSpecialDigit_.value().bitSizeOf(endBitPosition);
    }
    if (getIsLastDigitRule() == true)
    {
        endBitPosition += ::zserio::bitSizeOf(m_lastDigitRuleType_.value());
    }
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += UINT8_C(8);
    }
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += m_lastSpecialDigit_.value().bitSizeOf(endBitPosition);
    }
    if (getIsSpecificPlates() == true)
    {
        endBitPosition += UINT8_C(8);
    }
    if (getIsSpecificPlates() == true)
    {
        endBitPosition += m_specificPlates_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LicensePlateRestrictionRule::bitSizeOf(LicensePlateRestrictionRule::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getIsFirstDigitRule() == true)
    {
        endBitPosition += ::zserio::bitSizeOf(context.getFirstDigitRuleType(), m_firstDigitRuleType_.value());
    }
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += context.getNumFirstSpecialDigits().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numFirstSpecialDigits_.value());
    }
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += m_firstSpecialDigit_.value().bitSizeOf(endBitPosition);
    }
    if (getIsLastDigitRule() == true)
    {
        endBitPosition += ::zserio::bitSizeOf(context.getLastDigitRuleType(), m_lastDigitRuleType_.value());
    }
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += context.getNumLastSpecialDigits().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numLastSpecialDigits_.value());
    }
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += m_lastSpecialDigit_.value().bitSizeOf(endBitPosition);
    }
    if (getIsSpecificPlates() == true)
    {
        endBitPosition += context.getNumSpecificPlates().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numSpecificPlates_.value());
    }
    if (getIsSpecificPlates() == true)
    {
        endBitPosition += m_specificPlates_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LicensePlateRestrictionRule::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getIsFirstDigitRule() == true)
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_firstDigitRuleType_.value());
    }
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += UINT8_C(8);
    }
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition = m_firstSpecialDigit_.value().initializeOffsets(endBitPosition);
    }
    if (getIsLastDigitRule() == true)
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_lastDigitRuleType_.value());
    }
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += UINT8_C(8);
    }
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition = m_lastSpecialDigit_.value().initializeOffsets(endBitPosition);
    }
    if (getIsSpecificPlates() == true)
    {
        endBitPosition += UINT8_C(8);
    }
    if (getIsSpecificPlates() == true)
    {
        endBitPosition = m_specificPlates_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LicensePlateRestrictionRule::initializeOffsets(LicensePlateRestrictionRule::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getIsFirstDigitRule() == true)
    {
        endBitPosition = ::zserio::initializeOffsets(context.getFirstDigitRuleType(), endBitPosition,
        m_firstDigitRuleType_.value());
    }
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += context.getNumFirstSpecialDigits().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numFirstSpecialDigits_.value());
    }
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition = m_firstSpecialDigit_.value().initializeOffsets(endBitPosition);
    }
    if (getIsLastDigitRule() == true)
    {
        endBitPosition = ::zserio::initializeOffsets(context.getLastDigitRuleType(), endBitPosition,
        m_lastDigitRuleType_.value());
    }
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition += context.getNumLastSpecialDigits().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numLastSpecialDigits_.value());
    }
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        endBitPosition = m_lastSpecialDigit_.value().initializeOffsets(endBitPosition);
    }
    if (getIsSpecificPlates() == true)
    {
        endBitPosition += context.getNumSpecificPlates().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numSpecificPlates_.value());
    }
    if (getIsSpecificPlates() == true)
    {
        endBitPosition = m_specificPlates_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

bool LicensePlateRestrictionRule::operator==(const LicensePlateRestrictionRule& other) const
{
    if (this != &other)
    {
        return
                (m_noPermitPaper_ == other.m_noPermitPaper_) &&
                (m_isSpecificPlates_ == other.m_isSpecificPlates_) &&
                (m_isFirstDigitRule_ == other.m_isFirstDigitRule_) &&
                (m_isLastDigitRule_ == other.m_isLastDigitRule_) &&
                (!isFirstDigitRuleTypeUsed() ? !other.isFirstDigitRuleTypeUsed() : (m_firstDigitRuleType_ == other.m_firstDigitRuleType_)) &&
                (!isNumFirstSpecialDigitsUsed() ? !other.isNumFirstSpecialDigitsUsed() : (m_numFirstSpecialDigits_ == other.m_numFirstSpecialDigits_)) &&
                (!isFirstSpecialDigitUsed() ? !other.isFirstSpecialDigitUsed() : (m_firstSpecialDigit_ == other.m_firstSpecialDigit_)) &&
                (!isLastDigitRuleTypeUsed() ? !other.isLastDigitRuleTypeUsed() : (m_lastDigitRuleType_ == other.m_lastDigitRuleType_)) &&
                (!isNumLastSpecialDigitsUsed() ? !other.isNumLastSpecialDigitsUsed() : (m_numLastSpecialDigits_ == other.m_numLastSpecialDigits_)) &&
                (!isLastSpecialDigitUsed() ? !other.isLastSpecialDigitUsed() : (m_lastSpecialDigit_ == other.m_lastSpecialDigit_)) &&
                (!isNumSpecificPlatesUsed() ? !other.isNumSpecificPlatesUsed() : (m_numSpecificPlates_ == other.m_numSpecificPlates_)) &&
                (!isSpecificPlatesUsed() ? !other.isSpecificPlatesUsed() : (m_specificPlates_ == other.m_specificPlates_));
    }

    return true;
}

uint32_t LicensePlateRestrictionRule::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_noPermitPaper_);
    result = ::zserio::calcHashCode(result, m_isSpecificPlates_);
    result = ::zserio::calcHashCode(result, m_isFirstDigitRule_);
    result = ::zserio::calcHashCode(result, m_isLastDigitRule_);
    if (isFirstDigitRuleTypeUsed())
        result = ::zserio::calcHashCode(result, m_firstDigitRuleType_);
    if (isNumFirstSpecialDigitsUsed())
        result = ::zserio::calcHashCode(result, m_numFirstSpecialDigits_);
    if (isFirstSpecialDigitUsed())
        result = ::zserio::calcHashCode(result, m_firstSpecialDigit_);
    if (isLastDigitRuleTypeUsed())
        result = ::zserio::calcHashCode(result, m_lastDigitRuleType_);
    if (isNumLastSpecialDigitsUsed())
        result = ::zserio::calcHashCode(result, m_numLastSpecialDigits_);
    if (isLastSpecialDigitUsed())
        result = ::zserio::calcHashCode(result, m_lastSpecialDigit_);
    if (isNumSpecificPlatesUsed())
        result = ::zserio::calcHashCode(result, m_numSpecificPlates_);
    if (isSpecificPlatesUsed())
        result = ::zserio::calcHashCode(result, m_specificPlates_);

    return result;
}

void LicensePlateRestrictionRule::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_noPermitPaper_);

    out.writeBool(m_isSpecificPlates_);

    out.writeBool(m_isFirstDigitRule_);

    out.writeBool(m_isLastDigitRule_);

    if (getIsFirstDigitRule() == true)
    {
        ::zserio::write(out, m_firstDigitRuleType_.value());
    }

    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        out.writeBits(m_numFirstSpecialDigits_.value(), UINT8_C(8));
    }

    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        // check array length
        if (m_firstSpecialDigit_.value().getRawArray().size() != static_cast<size_t>(getNumFirstSpecialDigits()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LicensePlateRestrictionRule.firstSpecialDigit: ") <<
                    m_firstSpecialDigit_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumFirstSpecialDigits()) << "!";
        }
        m_firstSpecialDigit_.value().write(out);
    }

    if (getIsLastDigitRule() == true)
    {
        ::zserio::write(out, m_lastDigitRuleType_.value());
    }

    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        out.writeBits(m_numLastSpecialDigits_.value(), UINT8_C(8));
    }

    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        // check array length
        if (m_lastSpecialDigit_.value().getRawArray().size() != static_cast<size_t>(getNumLastSpecialDigits()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LicensePlateRestrictionRule.lastSpecialDigit: ") <<
                    m_lastSpecialDigit_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLastSpecialDigits()) << "!";
        }
        m_lastSpecialDigit_.value().write(out);
    }

    if (getIsSpecificPlates() == true)
    {
        out.writeBits(m_numSpecificPlates_.value(), UINT8_C(8));
    }

    if (getIsSpecificPlates() == true)
    {
        // check array length
        if (m_specificPlates_.value().getRawArray().size() != static_cast<size_t>(getNumSpecificPlates()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LicensePlateRestrictionRule.specificPlates: ") <<
                    m_specificPlates_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumSpecificPlates()) << "!";
        }
        m_specificPlates_.value().write(out);
    }
}

void LicensePlateRestrictionRule::write(LicensePlateRestrictionRule::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_noPermitPaper_);

    out.writeBool(m_isSpecificPlates_);

    out.writeBool(m_isFirstDigitRule_);

    out.writeBool(m_isLastDigitRule_);

    if (getIsFirstDigitRule() == true)
    {
        ::zserio::write(context.getFirstDigitRuleType(), out, m_firstDigitRuleType_.value());
    }

    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        context.getNumFirstSpecialDigits().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numFirstSpecialDigits_.value());
    }

    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        // check array length
        if (m_firstSpecialDigit_.value().getRawArray().size() != static_cast<size_t>(getNumFirstSpecialDigits()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LicensePlateRestrictionRule.firstSpecialDigit: ") <<
                    m_firstSpecialDigit_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumFirstSpecialDigits()) << "!";
        }
        m_firstSpecialDigit_.value().write(out);
    }

    if (getIsLastDigitRule() == true)
    {
        ::zserio::write(context.getLastDigitRuleType(), out, m_lastDigitRuleType_.value());
    }

    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        context.getNumLastSpecialDigits().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numLastSpecialDigits_.value());
    }

    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        // check array length
        if (m_lastSpecialDigit_.value().getRawArray().size() != static_cast<size_t>(getNumLastSpecialDigits()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LicensePlateRestrictionRule.lastSpecialDigit: ") <<
                    m_lastSpecialDigit_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLastSpecialDigits()) << "!";
        }
        m_lastSpecialDigit_.value().write(out);
    }

    if (getIsSpecificPlates() == true)
    {
        context.getNumSpecificPlates().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numSpecificPlates_.value());
    }

    if (getIsSpecificPlates() == true)
    {
        // check array length
        if (m_specificPlates_.value().getRawArray().size() != static_cast<size_t>(getNumSpecificPlates()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LicensePlateRestrictionRule.specificPlates: ") <<
                    m_specificPlates_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumSpecificPlates()) << "!";
        }
        m_specificPlates_.value().write(out);
    }
}

bool LicensePlateRestrictionRule::readNoPermitPaper(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool LicensePlateRestrictionRule::readIsSpecificPlates(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool LicensePlateRestrictionRule::readIsFirstDigitRule(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool LicensePlateRestrictionRule::readIsLastDigitRule(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType> LicensePlateRestrictionRule::readFirstDigitRuleType(::zserio::BitStreamReader& in)
{
    if (getIsFirstDigitRule() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType>(::zserio::read<::nds::rules::types::LicensePlateDigitRuleType>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType> LicensePlateRestrictionRule::readFirstDigitRuleType(LicensePlateRestrictionRule::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getIsFirstDigitRule() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType>(::zserio::read<::nds::rules::types::LicensePlateDigitRuleType>(context.getFirstDigitRuleType(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint8_t> LicensePlateRestrictionRule::readNumFirstSpecialDigits(::zserio::BitStreamReader& in)
{
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(static_cast<uint8_t>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint8_t> LicensePlateRestrictionRule::readNumFirstSpecialDigits(LicensePlateRestrictionRule::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(context.getNumFirstSpecialDigits().read<::zserio::StdIntArrayTraits<uint8_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LicensePlateRestrictionRule::ZserioArrayType_firstSpecialDigit> LicensePlateRestrictionRule::readFirstSpecialDigit(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getIsFirstDigitRule() == true && getFirstDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        ZserioArrayType_firstSpecialDigit readField(allocator);
        readField.read(in, static_cast<size_t>(getNumFirstSpecialDigits()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_firstSpecialDigit>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_firstSpecialDigit>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType> LicensePlateRestrictionRule::readLastDigitRuleType(::zserio::BitStreamReader& in)
{
    if (getIsLastDigitRule() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType>(::zserio::read<::nds::rules::types::LicensePlateDigitRuleType>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType> LicensePlateRestrictionRule::readLastDigitRuleType(LicensePlateRestrictionRule::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getIsLastDigitRule() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType>(::zserio::read<::nds::rules::types::LicensePlateDigitRuleType>(context.getLastDigitRuleType(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::LicensePlateDigitRuleType>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint8_t> LicensePlateRestrictionRule::readNumLastSpecialDigits(::zserio::BitStreamReader& in)
{
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(static_cast<uint8_t>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint8_t> LicensePlateRestrictionRule::readNumLastSpecialDigits(LicensePlateRestrictionRule::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(context.getNumLastSpecialDigits().read<::zserio::StdIntArrayTraits<uint8_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LicensePlateRestrictionRule::ZserioArrayType_lastSpecialDigit> LicensePlateRestrictionRule::readLastSpecialDigit(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getIsLastDigitRule() == true && getLastDigitRuleType() == ::nds::rules::types::LicensePlateDigitRuleType::SPECIAL_DIGIT)
    {
        ZserioArrayType_lastSpecialDigit readField(allocator);
        readField.read(in, static_cast<size_t>(getNumLastSpecialDigits()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_lastSpecialDigit>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_lastSpecialDigit>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint8_t> LicensePlateRestrictionRule::readNumSpecificPlates(::zserio::BitStreamReader& in)
{
    if (getIsSpecificPlates() == true)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(static_cast<uint8_t>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint8_t> LicensePlateRestrictionRule::readNumSpecificPlates(LicensePlateRestrictionRule::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getIsSpecificPlates() == true)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(context.getNumSpecificPlates().read<::zserio::StdIntArrayTraits<uint8_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LicensePlateRestrictionRule::ZserioArrayType_specificPlates> LicensePlateRestrictionRule::readSpecificPlates(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getIsSpecificPlates() == true)
    {
        ZserioArrayType_specificPlates readField(allocator);
        readField.read(in, static_cast<size_t>(getNumSpecificPlates()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_specificPlates>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_specificPlates>(::zserio::NullOpt);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/RegionValidity.h>

namespace nds
{
namespace rules
{
namespace types
{

RegionValidity::RegionValidity(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_roads_(allocator),
        m_attributes_(::zserio::NullOpt)
{
}

RegionValidity::RegionValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_roads_(readRoads(in, allocator)),
        m_attributes_(readAttributes(in, allocator))
{
}

RegionValidity::RegionValidity(RegionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_roads_(readRoads(context, in, allocator)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RegionValidity::RegionValidity(const RegionValidity& other) :
        m_roads_(other.m_roads_),
        m_attributes_(other.m_attributes_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RegionValidity& RegionValidity::operator=(const RegionValidity& other)
{
    m_roads_ = other.m_roads_;
    m_attributes_ = other.m_attributes_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RegionValidity::RegionValidity(RegionValidity&& other) :
        m_roads_(::std::move(other.m_roads_)),
        m_attributes_(::std::move(other.m_attributes_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

RegionValidity& RegionValidity::operator=(RegionValidity&& other)
{
    m_roads_ = ::std::move(other.m_roads_);
    m_attributes_ = ::std::move(other.m_attributes_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

RegionValidity::RegionValidity(::zserio::PropagateAllocatorT,
        const RegionValidity& other, const allocator_type& allocator) :
        m_roads_(::zserio::allocatorPropagatingCopy(other.m_roads_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void RegionValidity::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RegionValidity::isInitialized() const
{
    return m_isInitialized;
}

void RegionValidity::initializeChildren()
{
    if (isAttributesSet())
        m_attributes_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift RegionValidity::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'RegionValidity' is not initialized!");

    return m_shift_;
}

::nds::core::types::RoadTypeSet& RegionValidity::getRoads()
{
    return m_roads_;
}

const ::nds::core::types::RoadTypeSet& RegionValidity::getRoads() const
{
    return m_roads_;
}

void RegionValidity::setRoads(const ::nds::core::types::RoadTypeSet& roads_)
{
    m_roads_ = roads_;
}

void RegionValidity::setRoads(::nds::core::types::RoadTypeSet&& roads_)
{
    m_roads_ = ::std::move(roads_);
}

::zserio::vector<::nds::rules::types::RegionValidityAttribute>& RegionValidity::getAttributes()
{
    return m_attributes_.value().getRawArray();
}

const ::zserio::vector<::nds::rules::types::RegionValidityAttribute>& RegionValidity::getAttributes() const
{
    return m_attributes_.value().getRawArray();
}

void RegionValidity::setAttributes(const ::zserio::vector<::nds::rules::types::RegionValidityAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RegionValidity::setAttributes(::zserio::vector<::nds::rules::types::RegionValidityAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

bool RegionValidity::isAttributesUsed() const
{
    return (isAttributesSet());
}

bool RegionValidity::isAttributesSet() const
{
    return m_attributes_.hasValue();
}

void RegionValidity::resetAttributes()
{
    m_attributes_.reset();
}

void RegionValidity::initPackingContext(RegionValidity::ZserioPackingContext& context) const
{
    m_roads_.initPackingContext(context.getRoads());
}

size_t RegionValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roads_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isAttributesSet())
    {
        endBitPosition += m_attributes_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RegionValidity::bitSizeOf(RegionValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roads_.bitSizeOf(context.getRoads(), endBitPosition);
    endBitPosition += 1;
    if (isAttributesSet())
    {
        endBitPosition += m_attributes_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RegionValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roads_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isAttributesSet())
    {
        endBitPosition = m_attributes_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t RegionValidity::initializeOffsets(RegionValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roads_.initializeOffsets(context.getRoads(), endBitPosition);
    endBitPosition += 1;
    if (isAttributesSet())
    {
        endBitPosition = m_attributes_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool RegionValidity::operator==(const RegionValidity& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_roads_ == other.m_roads_) &&
                (!isAttributesUsed() ? !other.isAttributesUsed() : (m_attributes_ == other.m_attributes_));
    }

    return true;
}

uint32_t RegionValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_roads_);
    if (isAttributesUsed())
        result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RegionValidity::write(::zserio::BitStreamWriter& out) const
{
    m_roads_.write(out);
    if (isAttributesSet())
    {
        out.writeBool(true);
        m_attributes_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RegionValidity::write(RegionValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_roads_.write(context.getRoads(), out);
    if (isAttributesSet())
    {
        out.writeBool(true);
        m_attributes_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RegionValidity::ZserioArrayExpressions_attributes::initializeElement(RegionValidity&,
        ::nds::rules::types::RegionValidityAttribute& element, size_t)
{
    element.initializeChildren();
}

void RegionValidity::ZserioElementFactory_attributes::create(RegionValidity&        ,
        ::zserio::vector<::nds::rules::types::RegionValidityAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RegionValidity::ZserioElementFactory_attributes::create(RegionValidity&        ,
        ::zserio::vector<::nds::rules::types::RegionValidityAttribute>& array,
        ::nds::rules::types::RegionValidityAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::types::RoadTypeSet RegionValidity::readRoads(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::RoadTypeSet(in, allocator);
}

::nds::core::types::RoadTypeSet RegionValidity::readRoads(RegionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::RoadTypeSet(context.getRoads(), in, allocator);
}
::zserio::InplaceOptionalHolder<RegionValidity::ZserioArrayType_attributes> RegionValidity::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_attributes readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_attributes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_attributes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RegionValidity::ZserioArrayType_attributes> RegionValidity::readAttributes(RegionValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_attributes readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_attributes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_attributes>(::zserio::NullOpt);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/RegionValidityAttribute.h>

namespace nds
{
namespace rules
{
namespace types
{

RegionValidityAttribute::RegionValidityAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_type_(::nds::rules::types::RegionValidityType()),
        m_value_(allocator)
{
}

RegionValidityAttribute::RegionValidityAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(in)),
        m_value_(readValue(in, allocator))
{
}

RegionValidityAttribute::RegionValidityAttribute(RegionValidityAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(context, in)),
        m_value_(readValue(context, in, allocator))
{
}

RegionValidityAttribute::RegionValidityAttribute(const RegionValidityAttribute& other) :
        m_type_(other.m_type_),
        m_value_(other.m_value_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RegionValidityAttribute& RegionValidityAttribute::operator=(const RegionValidityAttribute& other)
{
    m_type_ = other.m_type_;
    m_value_ = other.m_value_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RegionValidityAttribute::RegionValidityAttribute(RegionValidityAttribute&& other) :
        m_type_(::std::move(other.m_type_)),
        m_value_(::std::move(other.m_value_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RegionValidityAttribute& RegionValidityAttribute::operator=(RegionValidityAttribute&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_value_ = ::std::move(other.m_value_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RegionValidityAttribute::RegionValidityAttribute(::zserio::PropagateAllocatorT,
        const RegionValidityAttribute& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RegionValidityAttribute::initializeChildren()
{
    m_value_.initialize(static_cast<::nds::rules::types::RegionValidityType>(getType()));

    m_areChildrenInitialized = true;
}

::nds::rules::types::RegionValidityType RegionValidityAttribute::getType() const
{
    return m_type_;
}

void RegionValidityAttribute::setType(::nds::rules::types::RegionValidityType type_)
{
    m_type_ = type_;
}

::nds::rules::types::RegionValidityValue& RegionValidityAttribute::getValue()
{
    return m_value_;
}

const ::nds::rules::types::RegionValidityValue& RegionValidityAttribute::getValue() const
{
    return m_value_;
}

void RegionValidityAttribute::setValue(const ::nds::rules::types::RegionValidityValue& value_)
{
    m_value_ = value_;
}

void RegionValidityAttribute::setValue(::nds::rules::types::RegionValidityValue&& value_)
{
    m_value_ = ::std::move(value_);
}

void RegionValidityAttribute::initPackingContext(RegionValidityAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    m_value_.initPackingContext(context.getValue());
}

size_t RegionValidityAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += m_value_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RegionValidityAttribute::bitSizeOf(RegionValidityAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += m_value_.bitSizeOf(context.getValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RegionValidityAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = m_value_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RegionValidityAttribute::initializeOffsets(RegionValidityAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = m_value_.initializeOffsets(context.getValue(), endBitPosition);

    return endBitPosition;
}

bool RegionValidityAttribute::operator==(const RegionValidityAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_value_ == other.m_value_);
    }

    return true;
}

uint32_t RegionValidityAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_value_);

    return result;
}

void RegionValidityAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    // check parameters
    if (m_value_.getType() != static_cast<::nds::rules::types::RegionValidityType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RegionValidityAttribute.value: ") <<
                m_value_.getType() << " != " << static_cast<::nds::rules::types::RegionValidityType>(getType()) << "!";
    }
    m_value_.write(out);
}

void RegionValidityAttribute::write(RegionValidityAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    // check parameters
    if (m_value_.getType() != static_cast<::nds::rules::types::RegionValidityType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RegionValidityAttribute.value: ") <<
                m_value_.getType() << " != " << static_cast<::nds::rules::types::RegionValidityType>(getType()) << "!";
    }
    m_value_.write(context.getValue(), out);
}

::nds::rules::types::RegionValidityType RegionValidityAttribute::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::RegionValidityType>(in);
}

::nds::rules::types::RegionValidityType RegionValidityAttribute::readType(RegionValidityAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::RegionValidityType>(context.getType(), in);
}
::nds::rules::types::RegionValidityValue RegionValidityAttribute::readValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::types::RegionValidityValue(in, static_cast<::nds::rules::types::RegionValidityType>(getType()), allocator);
}

::nds::rules::types::RegionValidityValue RegionValidityAttribute::readValue(RegionValidityAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::types::RegionValidityValue(context.getValue(), in, static_cast<::nds::rules::types::RegionValidityType>(getType()), allocator);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/SupplementaryWarningSignText.h>

namespace nds
{
namespace rules
{
namespace types
{

SupplementaryWarningSignText::SupplementaryWarningSignText(const allocator_type& allocator) noexcept :
        m_languageCode_(::zserio::NullOpt),
        m_text_(allocator)
{
}

SupplementaryWarningSignText::SupplementaryWarningSignText(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_languageCode_(readLanguageCode(in)),
        m_text_(readText(in, allocator))
{
}

SupplementaryWarningSignText::SupplementaryWarningSignText(SupplementaryWarningSignText::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_languageCode_(readLanguageCode(context, in)),
        m_text_(readText(in, allocator))
{
}

SupplementaryWarningSignText::SupplementaryWarningSignText(::zserio::PropagateAllocatorT,
        const SupplementaryWarningSignText& other, const allocator_type& allocator) :
        m_languageCode_(::zserio::allocatorPropagatingCopy(other.m_languageCode_, allocator)),
        m_text_(::zserio::allocatorPropagatingCopy(other.m_text_, allocator))
{
}

::nds::core::types::LanguageCode SupplementaryWarningSignText::getLanguageCode() const
{
    return m_languageCode_.value();
}

void SupplementaryWarningSignText::setLanguageCode(::nds::core::types::LanguageCode languageCode_)
{
    m_languageCode_ = languageCode_;
}

bool SupplementaryWarningSignText::isLanguageCodeUsed() const
{
    return (isLanguageCodeSet());
}

bool SupplementaryWarningSignText::isLanguageCodeSet() const
{
    return m_languageCode_.hasValue();
}

void SupplementaryWarningSignText::resetLanguageCode()
{
    m_languageCode_.reset();
}

::zserio::string<>& SupplementaryWarningSignText::getText()
{
    return m_text_;
}

const ::zserio::string<>& SupplementaryWarningSignText::getText() const
{
    return m_text_;
}

void SupplementaryWarningSignText::setText(const ::zserio::string<>& text_)
{
    m_text_ = text_;
}

void SupplementaryWarningSignText::setText(::zserio::string<>&& text_)
{
    m_text_ = ::std::move(text_);
}

void SupplementaryWarningSignText::initPackingContext(SupplementaryWarningSignText::ZserioPackingContext& context) const
{
    if (isLanguageCodeSet())
    {
        context.getLanguageCode().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_.value());
    }
}

size_t SupplementaryWarningSignText::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isLanguageCodeSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_text_);

    return endBitPosition - bitPosition;
}

size_t SupplementaryWarningSignText::bitSizeOf(SupplementaryWarningSignText::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isLanguageCodeSet())
    {
        endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_text_);

    return endBitPosition - bitPosition;
}

size_t SupplementaryWarningSignText::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isLanguageCodeSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_text_);

    return endBitPosition;
}

size_t SupplementaryWarningSignText::initializeOffsets(SupplementaryWarningSignText::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isLanguageCodeSet())
    {
        endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_.value());
    }
    endBitPosition += ::zserio::bitSizeOfString(m_text_);

    return endBitPosition;
}

bool SupplementaryWarningSignText::operator==(const SupplementaryWarningSignText& other) const
{
    if (this != &other)
    {
        return
                (!isLanguageCodeUsed() ? !other.isLanguageCodeUsed() : (m_languageCode_ == other.m_languageCode_)) &&
                (m_text_ == other.m_text_);
    }

    return true;
}

uint32_t SupplementaryWarningSignText::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isLanguageCodeUsed())
        result = ::zserio::calcHashCode(result, m_languageCode_);
    result = ::zserio::calcHashCode(result, m_text_);

    return result;
}

void SupplementaryWarningSignText::write(::zserio::BitStreamWriter& out) const
{
    if (isLanguageCodeSet())
    {
        out.writeBool(true);
        out.writeVarUInt16(m_languageCode_.value());
    }
    else
    {
        out.writeBool(false);
    }
    out.writeString(m_text_);
}

void SupplementaryWarningSignText::write(SupplementaryWarningSignText::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    if (isLanguageCodeSet())
    {
        out.writeBool(true);
        context.getLanguageCode().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(out, m_languageCode_.value());
    }
    else
    {
        out.writeBool(false);
    }
    out.writeString(m_text_);
}

::zserio::InplaceOptionalHolder<::nds::core::types::LanguageCode> SupplementaryWarningSignText::readLanguageCode(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::LanguageCode>(static_cast<::nds::core::types::LanguageCode>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::LanguageCode>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::LanguageCode> SupplementaryWarningSignText::readLanguageCode(SupplementaryWarningSignText::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::LanguageCode>(context.getLanguageCode().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::LanguageCode>(::zserio::NullOpt);
}
::zserio::string<> SupplementaryWarningSignText::readText(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/TimeZoneName.h>

namespace nds
{
namespace rules
{
namespace types
{

TimeZoneName::TimeZoneName(const allocator_type& allocator) noexcept :
        m_languageCode_(::nds::core::types::LanguageCode()),
        m_nameString_(allocator)
{
}

TimeZoneName::TimeZoneName(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_languageCode_(readLanguageCode(in)),
        m_nameString_(readNameString(in, allocator))
{
}

TimeZoneName::TimeZoneName(TimeZoneName::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_languageCode_(readLanguageCode(context, in)),
        m_nameString_(readNameString(in, allocator))
{
}

TimeZoneName::TimeZoneName(::zserio::PropagateAllocatorT,
        const TimeZoneName& other, const allocator_type& allocator) :
        m_languageCode_(::zserio::allocatorPropagatingCopy(other.m_languageCode_, allocator)),
        m_nameString_(::zserio::allocatorPropagatingCopy(other.m_nameString_, allocator))
{
}

::nds::core::types::LanguageCode TimeZoneName::getLanguageCode() const
{
    return m_languageCode_;
}

void TimeZoneName::setLanguageCode(::nds::core::types::LanguageCode languageCode_)
{
    m_languageCode_ = languageCode_;
}

::zserio::string<>& TimeZoneName::getNameString()
{
    return m_nameString_;
}

const ::zserio::string<>& TimeZoneName::getNameString() const
{
    return m_nameString_;
}

void TimeZoneName::setNameString(const ::zserio::string<>& nameString_)
{
    m_nameString_ = nameString_;
}

void TimeZoneName::setNameString(::zserio::string<>&& nameString_)
{
    m_nameString_ = ::std::move(nameString_);
}

void TimeZoneName::initPackingContext(TimeZoneName::ZserioPackingContext& context) const
{
    context.getLanguageCode().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
}

size_t TimeZoneName::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_nameString_);

    return endBitPosition - bitPosition;
}

size_t TimeZoneName::bitSizeOf(TimeZoneName::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_nameString_);

    return endBitPosition - bitPosition;
}

size_t TimeZoneName::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_nameString_);

    return endBitPosition;
}

size_t TimeZoneName::initializeOffsets(TimeZoneName::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_nameString_);

    return endBitPosition;
}

bool TimeZoneName::operator==(const TimeZoneName& other) const
{
    if (this != &other)
    {
        return
                (m_languageCode_ == other.m_languageCode_) &&
                (m_nameString_ == other.m_nameString_);
    }

    return true;
}

uint32_t TimeZoneName::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_languageCode_);
    result = ::zserio::calcHashCode(result, m_nameString_);

    return result;
}

void TimeZoneName::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_languageCode_);
    out.writeString(m_nameString_);
}

void TimeZoneName::write(TimeZoneName::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLanguageCode().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(out, m_languageCode_);
    out.writeString(m_nameString_);
}

::nds::core::types::LanguageCode TimeZoneName::readLanguageCode(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LanguageCode>(in.readVarUInt16());
}

::nds::core::types::LanguageCode TimeZoneName::readLanguageCode(TimeZoneName::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLanguageCode().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(in);
}
::zserio::string<> TimeZoneName::readNameString(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/rules/types/TimeZone.h>

namespace nds
{
namespace rules
{
namespace types
{

TimeZone::TimeZone(const allocator_type& allocator) noexcept :
        m_olsonId_(::zserio::NullOpt),
        m_timeZoneConfigurations_(allocator)
{
}

TimeZone::TimeZone(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_olsonId_(readOlsonId(in, allocator)),
        m_timeZoneConfigurations_(readTimeZoneConfigurations(in, allocator))
{
}

TimeZone::TimeZone(TimeZone::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_olsonId_(readOlsonId(in, allocator)),
        m_timeZoneConfigurations_(readTimeZoneConfigurations(context, in, allocator))
{
}

TimeZone::TimeZone(::zserio::PropagateAllocatorT,
        const TimeZone& other, const allocator_type& allocator) :
        m_olsonId_(::zserio::allocatorPropagatingCopy(other.m_olsonId_, allocator)),
        m_timeZoneConfigurations_(::zserio::allocatorPropagatingCopy(other.m_timeZoneConfigurations_, allocator))
{
}

::zserio::string<>& TimeZone::getOlsonId()
{
    return m_olsonId_.value();
}

const ::zserio::string<>& TimeZone::getOlsonId() const
{
    return m_olsonId_.value();
}

void TimeZone::setOlsonId(const ::zserio::string<>& olsonId_)
{
    m_olsonId_ = olsonId_;
}

void TimeZone::setOlsonId(::zserio::string<>&& olsonId_)
{
    m_olsonId_ = ::std::move(olsonId_);
}

bool TimeZone::isOlsonIdUsed() const
{
    return (isOlsonIdSet());
}

bool TimeZone::isOlsonIdSet() const
{
    return m_olsonId_.hasValue();
}

void TimeZone::resetOlsonId()
{
    m_olsonId_.reset();
}

::zserio::vector<::nds::rules::types::TimeZoneConfiguration>& TimeZone::getTimeZoneConfigurations()
{
    return m_timeZoneConfigurations_.getRawArray();
}

const ::zserio::vector<::nds::rules::types::TimeZoneConfiguration>& TimeZone::getTimeZoneConfigurations() const
{
    return m_timeZoneConfigurations_.getRawArray();
}

void TimeZone::setTimeZoneConfigurations(const ::zserio::vector<::nds::rules::types::TimeZoneConfiguration>& timeZoneConfigurations_)
{
    m_timeZoneConfigurations_ = ZserioArrayType_timeZoneConfigurations(timeZoneConfigurations_);
}

void TimeZone::setTimeZoneConfigurations(::zserio::vector<::nds::rules::types::TimeZoneConfiguration>&& timeZoneConfigurations_)
{
    m_timeZoneConfigurations_ = ZserioArrayType_timeZoneConfigurations(std::move(timeZoneConfigurations_));
}

void TimeZone::initPackingContext(TimeZone::ZserioPackingContext&) const
{
}

size_t TimeZone::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isOlsonIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_olsonId_.value());
    }
    endBitPosition += m_timeZoneConfigurations_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TimeZone::bitSizeOf(TimeZone::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isOlsonIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_olsonId_.value());
    }
    endBitPosition += m_timeZoneConfigurations_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TimeZone::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isOlsonIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_olsonId_.value());
    }
    endBitPosition = m_timeZoneConfigurations_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t TimeZone::initializeOffsets(TimeZone::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isOlsonIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_olsonId_.value());
    }
    endBitPosition = m_timeZoneConfigurations_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TimeZone::operator==(const TimeZone& other) const
{
    if (this != &other)
    {
        return
                (!isOlsonIdUsed() ? !other.isOlsonIdUsed() : (m_olsonId_ == other.m_olsonId_)) &&
                (m_timeZoneConfigurations_ == other.m_timeZoneConfigurations_);
    }

    return true;
}

uint32_t TimeZone::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isOlsonIdUsed())
        result = ::zserio::calcHashCode(result, m_olsonId_);
    result = ::zserio::calcHashCode(result, m_timeZoneConfigurations_);

    return result;
}

void TimeZone::write(::zserio::BitStreamWriter& out) const
{
    if (isOlsonIdSet())
    {
        out.writeBool(true);
        out.writeString(m_olsonId_.value());
    }
    else
    {
        out.writeBool(false);
    }

    // check constraint
    if (!(getTimeZoneConfigurations().size() >= 1))
        throw ::zserio::ConstraintException("Write: Constraint violated at TimeZone.timeZoneConfigurations!");
    m_timeZoneConfigurations_.write(*this, out);
}

void TimeZone::write(TimeZone::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    if (isOlsonIdSet())
    {
        out.writeBool(true);
        out.writeString(m_olsonId_.value());
    }
    else
    {
        out.writeBool(false);
    }

    // check constraint
    if (!(getTimeZoneConfigurations().size() >= 1))
        throw ::zserio::ConstraintException("Write: Constraint violated at TimeZone.timeZoneConfigurations!");
    m_timeZoneConfigurations_.writePacked(*this, out);
}

void TimeZone::ZserioElementFactory_timeZoneConfigurations::create(TimeZone&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneConfiguration>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TimeZone::ZserioElementFactory_timeZoneConfigurations::create(TimeZone&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneConfiguration>& array,
        ::nds::rules::types::TimeZoneConfiguration::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::zserio::InplaceOptionalHolder<::zserio::string<>> TimeZone::readOlsonId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}
TimeZone::ZserioArrayType_timeZoneConfigurations TimeZone::readTimeZoneConfigurations(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_timeZoneConfigurations readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() >= 1))
        throw ::zserio::ConstraintException("Read: Constraint violated at TimeZone.timeZoneConfigurations!");

    return readField;
}

TimeZone::ZserioArrayType_timeZoneConfigurations TimeZone::readTimeZoneConfigurations(TimeZone::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_timeZoneConfigurations readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() >= 1))
        throw ::zserio::ConstraintException("Read: Constraint violated at TimeZone.timeZoneConfigurations!");

    return readField;
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/TimeZoneConfiguration.h>

namespace nds
{
namespace rules
{
namespace types
{

TimeZoneConfiguration::TimeZoneConfiguration(const allocator_type& allocator) noexcept :
        m_validFromDate_(allocator),
        m_utcOffset_(::nds::core::types::QuarterHourTimeOffset()),
        m_timeZoneNames_(::zserio::NullOpt),
        m_timeZoneAbbreviations_(::zserio::NullOpt),
        m_dayLightSavingTime_(::zserio::NullOpt)
{
}

TimeZoneConfiguration::TimeZoneConfiguration(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_validFromDate_(readValidFromDate(in, allocator)),
        m_utcOffset_(readUtcOffset(in)),
        m_timeZoneNames_(readTimeZoneNames(in, allocator)),
        m_timeZoneAbbreviations_(readTimeZoneAbbreviations(in, allocator)),
        m_dayLightSavingTime_(readDayLightSavingTime(in, allocator))
{
}

TimeZoneConfiguration::TimeZoneConfiguration(TimeZoneConfiguration::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_validFromDate_(readValidFromDate(context, in, allocator)),
        m_utcOffset_(readUtcOffset(context, in)),
        m_timeZoneNames_(readTimeZoneNames(context, in, allocator)),
        m_timeZoneAbbreviations_(readTimeZoneAbbreviations(context, in, allocator)),
        m_dayLightSavingTime_(readDayLightSavingTime(context, in, allocator))
{
}

TimeZoneConfiguration::TimeZoneConfiguration(::zserio::PropagateAllocatorT,
        const TimeZoneConfiguration& other, const allocator_type& allocator) :
        m_validFromDate_(::zserio::allocatorPropagatingCopy(other.m_validFromDate_, allocator)),
        m_utcOffset_(::zserio::allocatorPropagatingCopy(other.m_utcOffset_, allocator)),
        m_timeZoneNames_(::zserio::allocatorPropagatingCopy(other.m_timeZoneNames_, allocator)),
        m_timeZoneAbbreviations_(::zserio::allocatorPropagatingCopy(other.m_timeZoneAbbreviations_, allocator)),
        m_dayLightSavingTime_(::zserio::allocatorPropagatingCopy(other.m_dayLightSavingTime_, allocator))
{
}

::nds::core::conditions::DayOfYear& TimeZoneConfiguration::getValidFromDate()
{
    return m_validFromDate_;
}

const ::nds::core::conditions::DayOfYear& TimeZoneConfiguration::getValidFromDate() const
{
    return m_validFromDate_;
}

void TimeZoneConfiguration::setValidFromDate(const ::nds::core::conditions::DayOfYear& validFromDate_)
{
    m_validFromDate_ = validFromDate_;
}

void TimeZoneConfiguration::setValidFromDate(::nds::core::conditions::DayOfYear&& validFromDate_)
{
    m_validFromDate_ = ::std::move(validFromDate_);
}

::nds::core::types::QuarterHourTimeOffset TimeZoneConfiguration::getUtcOffset() const
{
    return m_utcOffset_;
}

void TimeZoneConfiguration::setUtcOffset(::nds::core::types::QuarterHourTimeOffset utcOffset_)
{
    m_utcOffset_ = utcOffset_;
}

::zserio::vector<::nds::rules::types::TimeZoneName>& TimeZoneConfiguration::getTimeZoneNames()
{
    return m_timeZoneNames_.value().getRawArray();
}

const ::zserio::vector<::nds::rules::types::TimeZoneName>& TimeZoneConfiguration::getTimeZoneNames() const
{
    return m_timeZoneNames_.value().getRawArray();
}

void TimeZoneConfiguration::setTimeZoneNames(const ::zserio::vector<::nds::rules::types::TimeZoneName>& timeZoneNames_)
{
    m_timeZoneNames_ = ZserioArrayType_timeZoneNames(timeZoneNames_);
}

void TimeZoneConfiguration::setTimeZoneNames(::zserio::vector<::nds::rules::types::TimeZoneName>&& timeZoneNames_)
{
    m_timeZoneNames_ = ZserioArrayType_timeZoneNames(std::move(timeZoneNames_));
}

bool TimeZoneConfiguration::isTimeZoneNamesUsed() const
{
    return (isTimeZoneNamesSet());
}

bool TimeZoneConfiguration::isTimeZoneNamesSet() const
{
    return m_timeZoneNames_.hasValue();
}

void TimeZoneConfiguration::resetTimeZoneNames()
{
    m_timeZoneNames_.reset();
}

::zserio::vector<::nds::rules::types::TimeZoneName>& TimeZoneConfiguration::getTimeZoneAbbreviations()
{
    return m_timeZoneAbbreviations_.value().getRawArray();
}

const ::zserio::vector<::nds::rules::types::TimeZoneName>& TimeZoneConfiguration::getTimeZoneAbbreviations() const
{
    return m_timeZoneAbbreviations_.value().getRawArray();
}

void TimeZoneConfiguration::setTimeZoneAbbreviations(const ::zserio::vector<::nds::rules::types::TimeZoneName>& timeZoneAbbreviations_)
{
    m_timeZoneAbbreviations_ = ZserioArrayType_timeZoneAbbreviations(timeZoneAbbreviations_);
}

void TimeZoneConfiguration::setTimeZoneAbbreviations(::zserio::vector<::nds::rules::types::TimeZoneName>&& timeZoneAbbreviations_)
{
    m_timeZoneAbbreviations_ = ZserioArrayType_timeZoneAbbreviations(std::move(timeZoneAbbreviations_));
}

bool TimeZoneConfiguration::isTimeZoneAbbreviationsUsed() const
{
    return (isTimeZoneAbbreviationsSet());
}

bool TimeZoneConfiguration::isTimeZoneAbbreviationsSet() const
{
    return m_timeZoneAbbreviations_.hasValue();
}

void TimeZoneConfiguration::resetTimeZoneAbbreviations()
{
    m_timeZoneAbbreviations_.reset();
}

::nds::rules::types::DayLightSavingTime& TimeZoneConfiguration::getDayLightSavingTime()
{
    return m_dayLightSavingTime_.value();
}

const ::nds::rules::types::DayLightSavingTime& TimeZoneConfiguration::getDayLightSavingTime() const
{
    return m_dayLightSavingTime_.value();
}

void TimeZoneConfiguration::setDayLightSavingTime(const ::nds::rules::types::DayLightSavingTime& dayLightSavingTime_)
{
    m_dayLightSavingTime_ = dayLightSavingTime_;
}

void TimeZoneConfiguration::setDayLightSavingTime(::nds::rules::types::DayLightSavingTime&& dayLightSavingTime_)
{
    m_dayLightSavingTime_ = ::std::move(dayLightSavingTime_);
}

bool TimeZoneConfiguration::isDayLightSavingTimeUsed() const
{
    return (isDayLightSavingTimeSet());
}

bool TimeZoneConfiguration::isDayLightSavingTimeSet() const
{
    return m_dayLightSavingTime_.hasValue();
}

void TimeZoneConfiguration::resetDayLightSavingTime()
{
    m_dayLightSavingTime_.reset();
}

void TimeZoneConfiguration::initPackingContext(TimeZoneConfiguration::ZserioPackingContext& context) const
{
    m_validFromDate_.initPackingContext(context.getValidFromDate());
    context.getUtcOffset().init<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(m_utcOffset_);
    if (isDayLightSavingTimeSet())
    {
        m_dayLightSavingTime_.value().initPackingContext(context.getDayLightSavingTime());
    }
}

size_t TimeZoneConfiguration::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_validFromDate_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isTimeZoneNamesSet())
    {
        endBitPosition += m_timeZoneNames_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isTimeZoneAbbreviationsSet())
    {
        endBitPosition += m_timeZoneAbbreviations_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isDayLightSavingTimeSet())
    {
        endBitPosition += m_dayLightSavingTime_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TimeZoneConfiguration::bitSizeOf(TimeZoneConfiguration::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_validFromDate_.bitSizeOf(context.getValidFromDate(), endBitPosition);
    endBitPosition += context.getUtcOffset().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(m_utcOffset_);
    endBitPosition += 1;
    if (isTimeZoneNamesSet())
    {
        endBitPosition += m_timeZoneNames_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isTimeZoneAbbreviationsSet())
    {
        endBitPosition += m_timeZoneAbbreviations_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isDayLightSavingTimeSet())
    {
        endBitPosition += m_dayLightSavingTime_.value().bitSizeOf(context.getDayLightSavingTime(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TimeZoneConfiguration::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_validFromDate_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isTimeZoneNamesSet())
    {
        endBitPosition = m_timeZoneNames_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isTimeZoneAbbreviationsSet())
    {
        endBitPosition = m_timeZoneAbbreviations_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isDayLightSavingTimeSet())
    {
        endBitPosition = m_dayLightSavingTime_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t TimeZoneConfiguration::initializeOffsets(TimeZoneConfiguration::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_validFromDate_.initializeOffsets(context.getValidFromDate(), endBitPosition);
    endBitPosition += context.getUtcOffset().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(m_utcOffset_);
    endBitPosition += 1;
    if (isTimeZoneNamesSet())
    {
        endBitPosition = m_timeZoneNames_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isTimeZoneAbbreviationsSet())
    {
        endBitPosition = m_timeZoneAbbreviations_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isDayLightSavingTimeSet())
    {
        endBitPosition = m_dayLightSavingTime_.value().initializeOffsets(context.getDayLightSavingTime(), endBitPosition);
    }

    return endBitPosition;
}

bool TimeZoneConfiguration::operator==(const TimeZoneConfiguration& other) const
{
    if (this != &other)
    {
        return
                (m_validFromDate_ == other.m_validFromDate_) &&
                (m_utcOffset_ == other.m_utcOffset_) &&
                (!isTimeZoneNamesUsed() ? !other.isTimeZoneNamesUsed() : (m_timeZoneNames_ == other.m_timeZoneNames_)) &&
                (!isTimeZoneAbbreviationsUsed() ? !other.isTimeZoneAbbreviationsUsed() : (m_timeZoneAbbreviations_ == other.m_timeZoneAbbreviations_)) &&
                (!isDayLightSavingTimeUsed() ? !other.isDayLightSavingTimeUsed() : (m_dayLightSavingTime_ == other.m_dayLightSavingTime_));
    }

    return true;
}

uint32_t TimeZoneConfiguration::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_validFromDate_);
    result = ::zserio::calcHashCode(result, m_utcOffset_);
    if (isTimeZoneNamesUsed())
        result = ::zserio::calcHashCode(result, m_timeZoneNames_);
    if (isTimeZoneAbbreviationsUsed())
        result = ::zserio::calcHashCode(result, m_timeZoneAbbreviations_);
    if (isDayLightSavingTimeUsed())
        result = ::zserio::calcHashCode(result, m_dayLightSavingTime_);

    return result;
}

void TimeZoneConfiguration::write(::zserio::BitStreamWriter& out) const
{
    m_validFromDate_.write(out);
    out.writeSignedBits(m_utcOffset_, UINT8_C(8));
    if (isTimeZoneNamesSet())
    {
        out.writeBool(true);
        m_timeZoneNames_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isTimeZoneAbbreviationsSet())
    {
        out.writeBool(true);
        m_timeZoneAbbreviations_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDayLightSavingTimeSet())
    {
        out.writeBool(true);
        m_dayLightSavingTime_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void TimeZoneConfiguration::write(TimeZoneConfiguration::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_validFromDate_.write(context.getValidFromDate(), out);
    context.getUtcOffset().write<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(out, m_utcOffset_);
    if (isTimeZoneNamesSet())
    {
        out.writeBool(true);
        m_timeZoneNames_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isTimeZoneAbbreviationsSet())
    {
        out.writeBool(true);
        m_timeZoneAbbreviations_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDayLightSavingTimeSet())
    {
        out.writeBool(true);
        m_dayLightSavingTime_.value().write(context.getDayLightSavingTime(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

void TimeZoneConfiguration::ZserioElementFactory_timeZoneNames::create(TimeZoneConfiguration&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneName>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TimeZoneConfiguration::ZserioElementFactory_timeZoneNames::create(TimeZoneConfiguration&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneName>& array,
        ::nds::rules::types::TimeZoneName::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void TimeZoneConfiguration::ZserioElementFactory_timeZoneAbbreviations::create(TimeZoneConfiguration&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneName>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TimeZoneConfiguration::ZserioElementFactory_timeZoneAbbreviations::create(TimeZoneConfiguration&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneName>& array,
        ::nds::rules::types::TimeZoneName::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::conditions::DayOfYear TimeZoneConfiguration::readValidFromDate(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::conditions::DayOfYear(in, allocator);
}

::nds::core::conditions::DayOfYear TimeZoneConfiguration::readValidFromDate(TimeZoneConfiguration::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::conditions::DayOfYear(context.getValidFromDate(), in, allocator);
}
::nds::core::types::QuarterHourTimeOffset TimeZoneConfiguration::readUtcOffset(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::QuarterHourTimeOffset>(in.readSignedBits(UINT8_C(8)));
}

::nds::core::types::QuarterHourTimeOffset TimeZoneConfiguration::readUtcOffset(TimeZoneConfiguration::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getUtcOffset().read<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(in);
}
::zserio::InplaceOptionalHolder<TimeZoneConfiguration::ZserioArrayType_timeZoneNames> TimeZoneConfiguration::readTimeZoneNames(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_timeZoneNames readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_timeZoneNames>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_timeZoneNames>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<TimeZoneConfiguration::ZserioArrayType_timeZoneNames> TimeZoneConfiguration::readTimeZoneNames(TimeZoneConfiguration::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_timeZoneNames readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_timeZoneNames>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_timeZoneNames>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<TimeZoneConfiguration::ZserioArrayType_timeZoneAbbreviations> TimeZoneConfiguration::readTimeZoneAbbreviations(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_timeZoneAbbreviations readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_timeZoneAbbreviations>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_timeZoneAbbreviations>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<TimeZoneConfiguration::ZserioArrayType_timeZoneAbbreviations> TimeZoneConfiguration::readTimeZoneAbbreviations(TimeZoneConfiguration::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_timeZoneAbbreviations readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_timeZoneAbbreviations>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_timeZoneAbbreviations>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::rules::types::DayLightSavingTime> TimeZoneConfiguration::readDayLightSavingTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::DayLightSavingTime>(::nds::rules::types::DayLightSavingTime(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::DayLightSavingTime>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::types::DayLightSavingTime> TimeZoneConfiguration::readDayLightSavingTime(TimeZoneConfiguration::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::DayLightSavingTime>(::nds::rules::types::DayLightSavingTime(context.getDayLightSavingTime(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::DayLightSavingTime>(::zserio::NullOpt);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/DayLightSavingTime.h>

namespace nds
{
namespace rules
{
namespace types
{

DayLightSavingTime::DayLightSavingTime(const allocator_type& allocator) noexcept :
        m_utcOffset_(::nds::core::types::QuarterHourTimeOffset()),
        m_names_(::zserio::NullOpt),
        m_abbreviationNames_(::zserio::NullOpt),
        m_startTimeOfDay_(allocator),
        m_startWeekdayInMonth_(allocator),
        m_startMonthOfYear_(::nds::core::conditions::MonthOfYear()),
        m_endTimeOfDay_(allocator),
        m_endWeekdayInMonth_(allocator),
        m_endMonthOfYear_(::nds::core::conditions::MonthOfYear())
{
}

DayLightSavingTime::DayLightSavingTime(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_utcOffset_(readUtcOffset(in)),
        m_names_(readNames(in, allocator)),
        m_abbreviationNames_(readAbbreviationNames(in, allocator)),
        m_startTimeOfDay_(readStartTimeOfDay(in, allocator)),
        m_startWeekdayInMonth_(readStartWeekdayInMonth(in, allocator)),
        m_startMonthOfYear_(readStartMonthOfYear(in)),
        m_endTimeOfDay_(readEndTimeOfDay(in, allocator)),
        m_endWeekdayInMonth_(readEndWeekdayInMonth(in, allocator)),
        m_endMonthOfYear_(readEndMonthOfYear(in))
{
}

DayLightSavingTime::DayLightSavingTime(DayLightSavingTime::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_utcOffset_(readUtcOffset(context, in)),
        m_names_(readNames(context, in, allocator)),
        m_abbreviationNames_(readAbbreviationNames(context, in, allocator)),
        m_startTimeOfDay_(readStartTimeOfDay(context, in, allocator)),
        m_startWeekdayInMonth_(readStartWeekdayInMonth(context, in, allocator)),
        m_startMonthOfYear_(readStartMonthOfYear(context, in)),
        m_endTimeOfDay_(readEndTimeOfDay(context, in, allocator)),
        m_endWeekdayInMonth_(readEndWeekdayInMonth(context, in, allocator)),
        m_endMonthOfYear_(readEndMonthOfYear(context, in))
{
}

DayLightSavingTime::DayLightSavingTime(::zserio::PropagateAllocatorT,
        const DayLightSavingTime& other, const allocator_type& allocator) :
        m_utcOffset_(::zserio::allocatorPropagatingCopy(other.m_utcOffset_, allocator)),
        m_names_(::zserio::allocatorPropagatingCopy(other.m_names_, allocator)),
        m_abbreviationNames_(::zserio::allocatorPropagatingCopy(other.m_abbreviationNames_, allocator)),
        m_startTimeOfDay_(::zserio::allocatorPropagatingCopy(other.m_startTimeOfDay_, allocator)),
        m_startWeekdayInMonth_(::zserio::allocatorPropagatingCopy(other.m_startWeekdayInMonth_, allocator)),
        m_startMonthOfYear_(::zserio::allocatorPropagatingCopy(other.m_startMonthOfYear_, allocator)),
        m_endTimeOfDay_(::zserio::allocatorPropagatingCopy(other.m_endTimeOfDay_, allocator)),
        m_endWeekdayInMonth_(::zserio::allocatorPropagatingCopy(other.m_endWeekdayInMonth_, allocator)),
        m_endMonthOfYear_(::zserio::allocatorPropagatingCopy(other.m_endMonthOfYear_, allocator))
{
}

::nds::core::types::QuarterHourTimeOffset DayLightSavingTime::getUtcOffset() const
{
    return m_utcOffset_;
}

void DayLightSavingTime::setUtcOffset(::nds::core::types::QuarterHourTimeOffset utcOffset_)
{
    m_utcOffset_ = utcOffset_;
}

::zserio::vector<::nds::rules::types::TimeZoneName>& DayLightSavingTime::getNames()
{
    return m_names_.value().getRawArray();
}

const ::zserio::vector<::nds::rules::types::TimeZoneName>& DayLightSavingTime::getNames() const
{
    return m_names_.value().getRawArray();
}

void DayLightSavingTime::setNames(const ::zserio::vector<::nds::rules::types::TimeZoneName>& names_)
{
    m_names_ = ZserioArrayType_names(names_);
}

void DayLightSavingTime::setNames(::zserio::vector<::nds::rules::types::TimeZoneName>&& names_)
{
    m_names_ = ZserioArrayType_names(std::move(names_));
}

bool DayLightSavingTime::isNamesUsed() const
{
    return (isNamesSet());
}

bool DayLightSavingTime::isNamesSet() const
{
    return m_names_.hasValue();
}

void DayLightSavingTime::resetNames()
{
    m_names_.reset();
}

::zserio::vector<::nds::rules::types::TimeZoneName>& DayLightSavingTime::getAbbreviationNames()
{
    return m_abbreviationNames_.value().getRawArray();
}

const ::zserio::vector<::nds::rules::types::TimeZoneName>& DayLightSavingTime::getAbbreviationNames() const
{
    return m_abbreviationNames_.value().getRawArray();
}

void DayLightSavingTime::setAbbreviationNames(const ::zserio::vector<::nds::rules::types::TimeZoneName>& abbreviationNames_)
{
    m_abbreviationNames_ = ZserioArrayType_abbreviationNames(abbreviationNames_);
}

void DayLightSavingTime::setAbbreviationNames(::zserio::vector<::nds::rules::types::TimeZoneName>&& abbreviationNames_)
{
    m_abbreviationNames_ = ZserioArrayType_abbreviationNames(std::move(abbreviationNames_));
}

bool DayLightSavingTime::isAbbreviationNamesUsed() const
{
    return (isAbbreviationNamesSet());
}

bool DayLightSavingTime::isAbbreviationNamesSet() const
{
    return m_abbreviationNames_.hasValue();
}

void DayLightSavingTime::resetAbbreviationNames()
{
    m_abbreviationNames_.reset();
}

::nds::core::conditions::TimeOfDay& DayLightSavingTime::getStartTimeOfDay()
{
    return m_startTimeOfDay_;
}

const ::nds::core::conditions::TimeOfDay& DayLightSavingTime::getStartTimeOfDay() const
{
    return m_startTimeOfDay_;
}

void DayLightSavingTime::setStartTimeOfDay(const ::nds::core::conditions::TimeOfDay& startTimeOfDay_)
{
    m_startTimeOfDay_ = startTimeOfDay_;
}

void DayLightSavingTime::setStartTimeOfDay(::nds::core::conditions::TimeOfDay&& startTimeOfDay_)
{
    m_startTimeOfDay_ = ::std::move(startTimeOfDay_);
}

::nds::core::conditions::WeekdayInMonth& DayLightSavingTime::getStartWeekdayInMonth()
{
    return m_startWeekdayInMonth_;
}

const ::nds::core::conditions::WeekdayInMonth& DayLightSavingTime::getStartWeekdayInMonth() const
{
    return m_startWeekdayInMonth_;
}

void DayLightSavingTime::setStartWeekdayInMonth(const ::nds::core::conditions::WeekdayInMonth& startWeekdayInMonth_)
{
    m_startWeekdayInMonth_ = startWeekdayInMonth_;
}

void DayLightSavingTime::setStartWeekdayInMonth(::nds::core::conditions::WeekdayInMonth&& startWeekdayInMonth_)
{
    m_startWeekdayInMonth_ = ::std::move(startWeekdayInMonth_);
}

::nds::core::conditions::MonthOfYear DayLightSavingTime::getStartMonthOfYear() const
{
    return m_startMonthOfYear_;
}

void DayLightSavingTime::setStartMonthOfYear(::nds::core::conditions::MonthOfYear startMonthOfYear_)
{
    m_startMonthOfYear_ = startMonthOfYear_;
}

::nds::core::conditions::TimeOfDay& DayLightSavingTime::getEndTimeOfDay()
{
    return m_endTimeOfDay_;
}

const ::nds::core::conditions::TimeOfDay& DayLightSavingTime::getEndTimeOfDay() const
{
    return m_endTimeOfDay_;
}

void DayLightSavingTime::setEndTimeOfDay(const ::nds::core::conditions::TimeOfDay& endTimeOfDay_)
{
    m_endTimeOfDay_ = endTimeOfDay_;
}

void DayLightSavingTime::setEndTimeOfDay(::nds::core::conditions::TimeOfDay&& endTimeOfDay_)
{
    m_endTimeOfDay_ = ::std::move(endTimeOfDay_);
}

::nds::core::conditions::WeekdayInMonth& DayLightSavingTime::getEndWeekdayInMonth()
{
    return m_endWeekdayInMonth_;
}

const ::nds::core::conditions::WeekdayInMonth& DayLightSavingTime::getEndWeekdayInMonth() const
{
    return m_endWeekdayInMonth_;
}

void DayLightSavingTime::setEndWeekdayInMonth(const ::nds::core::conditions::WeekdayInMonth& endWeekdayInMonth_)
{
    m_endWeekdayInMonth_ = endWeekdayInMonth_;
}

void DayLightSavingTime::setEndWeekdayInMonth(::nds::core::conditions::WeekdayInMonth&& endWeekdayInMonth_)
{
    m_endWeekdayInMonth_ = ::std::move(endWeekdayInMonth_);
}

::nds::core::conditions::MonthOfYear DayLightSavingTime::getEndMonthOfYear() const
{
    return m_endMonthOfYear_;
}

void DayLightSavingTime::setEndMonthOfYear(::nds::core::conditions::MonthOfYear endMonthOfYear_)
{
    m_endMonthOfYear_ = endMonthOfYear_;
}

void DayLightSavingTime::initPackingContext(DayLightSavingTime::ZserioPackingContext& context) const
{
    context.getUtcOffset().init<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(m_utcOffset_);
    m_startTimeOfDay_.initPackingContext(context.getStartTimeOfDay());
    m_startWeekdayInMonth_.initPackingContext(context.getStartWeekdayInMonth());
    context.getStartMonthOfYear().init<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(m_startMonthOfYear_);
    m_endTimeOfDay_.initPackingContext(context.getEndTimeOfDay());
    m_endWeekdayInMonth_.initPackingContext(context.getEndWeekdayInMonth());
    context.getEndMonthOfYear().init<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(m_endMonthOfYear_);
}

size_t DayLightSavingTime::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isNamesSet())
    {
        endBitPosition += m_names_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isAbbreviationNamesSet())
    {
        endBitPosition += m_abbreviationNames_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += m_startTimeOfDay_.bitSizeOf(endBitPosition);
    endBitPosition += m_startWeekdayInMonth_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(4);
    endBitPosition += m_endTimeOfDay_.bitSizeOf(endBitPosition);
    endBitPosition += m_endWeekdayInMonth_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(4);

    return endBitPosition - bitPosition;
}

size_t DayLightSavingTime::bitSizeOf(DayLightSavingTime::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getUtcOffset().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(m_utcOffset_);
    endBitPosition += 1;
    if (isNamesSet())
    {
        endBitPosition += m_names_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isAbbreviationNamesSet())
    {
        endBitPosition += m_abbreviationNames_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += m_startTimeOfDay_.bitSizeOf(context.getStartTimeOfDay(), endBitPosition);
    endBitPosition += m_startWeekdayInMonth_.bitSizeOf(context.getStartWeekdayInMonth(), endBitPosition);
    endBitPosition += context.getStartMonthOfYear().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(m_startMonthOfYear_);
    endBitPosition += m_endTimeOfDay_.bitSizeOf(context.getEndTimeOfDay(), endBitPosition);
    endBitPosition += m_endWeekdayInMonth_.bitSizeOf(context.getEndWeekdayInMonth(), endBitPosition);
    endBitPosition += context.getEndMonthOfYear().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(m_endMonthOfYear_);

    return endBitPosition - bitPosition;
}

size_t DayLightSavingTime::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isNamesSet())
    {
        endBitPosition = m_names_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isAbbreviationNamesSet())
    {
        endBitPosition = m_abbreviationNames_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition = m_startTimeOfDay_.initializeOffsets(endBitPosition);
    endBitPosition = m_startWeekdayInMonth_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(4);
    endBitPosition = m_endTimeOfDay_.initializeOffsets(endBitPosition);
    endBitPosition = m_endWeekdayInMonth_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(4);

    return endBitPosition;
}

size_t DayLightSavingTime::initializeOffsets(DayLightSavingTime::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getUtcOffset().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(m_utcOffset_);
    endBitPosition += 1;
    if (isNamesSet())
    {
        endBitPosition = m_names_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isAbbreviationNamesSet())
    {
        endBitPosition = m_abbreviationNames_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = m_startTimeOfDay_.initializeOffsets(context.getStartTimeOfDay(), endBitPosition);
    endBitPosition = m_startWeekdayInMonth_.initializeOffsets(context.getStartWeekdayInMonth(), endBitPosition);
    endBitPosition += context.getStartMonthOfYear().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(m_startMonthOfYear_);
    endBitPosition = m_endTimeOfDay_.initializeOffsets(context.getEndTimeOfDay(), endBitPosition);
    endBitPosition = m_endWeekdayInMonth_.initializeOffsets(context.getEndWeekdayInMonth(), endBitPosition);
    endBitPosition += context.getEndMonthOfYear().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(m_endMonthOfYear_);

    return endBitPosition;
}

bool DayLightSavingTime::operator==(const DayLightSavingTime& other) const
{
    if (this != &other)
    {
        return
                (m_utcOffset_ == other.m_utcOffset_) &&
                (!isNamesUsed() ? !other.isNamesUsed() : (m_names_ == other.m_names_)) &&
                (!isAbbreviationNamesUsed() ? !other.isAbbreviationNamesUsed() : (m_abbreviationNames_ == other.m_abbreviationNames_)) &&
                (m_startTimeOfDay_ == other.m_startTimeOfDay_) &&
                (m_startWeekdayInMonth_ == other.m_startWeekdayInMonth_) &&
                (m_startMonthOfYear_ == other.m_startMonthOfYear_) &&
                (m_endTimeOfDay_ == other.m_endTimeOfDay_) &&
                (m_endWeekdayInMonth_ == other.m_endWeekdayInMonth_) &&
                (m_endMonthOfYear_ == other.m_endMonthOfYear_);
    }

    return true;
}

uint32_t DayLightSavingTime::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_utcOffset_);
    if (isNamesUsed())
        result = ::zserio::calcHashCode(result, m_names_);
    if (isAbbreviationNamesUsed())
        result = ::zserio::calcHashCode(result, m_abbreviationNames_);
    result = ::zserio::calcHashCode(result, m_startTimeOfDay_);
    result = ::zserio::calcHashCode(result, m_startWeekdayInMonth_);
    result = ::zserio::calcHashCode(result, m_startMonthOfYear_);
    result = ::zserio::calcHashCode(result, m_endTimeOfDay_);
    result = ::zserio::calcHashCode(result, m_endWeekdayInMonth_);
    result = ::zserio::calcHashCode(result, m_endMonthOfYear_);

    return result;
}

void DayLightSavingTime::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_utcOffset_, UINT8_C(8));
    if (isNamesSet())
    {
        out.writeBool(true);
        m_names_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isAbbreviationNamesSet())
    {
        out.writeBool(true);
        m_abbreviationNames_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    m_startTimeOfDay_.write(out);
    m_startWeekdayInMonth_.write(out);
    out.writeBits(m_startMonthOfYear_, UINT8_C(4));
    m_endTimeOfDay_.write(out);
    m_endWeekdayInMonth_.write(out);
    out.writeBits(m_endMonthOfYear_, UINT8_C(4));
}

void DayLightSavingTime::write(DayLightSavingTime::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getUtcOffset().write<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(out, m_utcOffset_);
    if (isNamesSet())
    {
        out.writeBool(true);
        m_names_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isAbbreviationNamesSet())
    {
        out.writeBool(true);
        m_abbreviationNames_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    m_startTimeOfDay_.write(context.getStartTimeOfDay(), out);
    m_startWeekdayInMonth_.write(context.getStartWeekdayInMonth(), out);
    context.getStartMonthOfYear().write<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(out, m_startMonthOfYear_);
    m_endTimeOfDay_.write(context.getEndTimeOfDay(), out);
    m_endWeekdayInMonth_.write(context.getEndWeekdayInMonth(), out);
    context.getEndMonthOfYear().write<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(out, m_endMonthOfYear_);
}

void DayLightSavingTime::ZserioElementFactory_names::create(DayLightSavingTime&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneName>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void DayLightSavingTime::ZserioElementFactory_names::create(DayLightSavingTime&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneName>& array,
        ::nds::rules::types::TimeZoneName::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void DayLightSavingTime::ZserioElementFactory_abbreviationNames::create(DayLightSavingTime&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneName>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void DayLightSavingTime::ZserioElementFactory_abbreviationNames::create(DayLightSavingTime&        ,
        ::zserio::vector<::nds::rules::types::TimeZoneName>& array,
        ::nds::rules::types::TimeZoneName::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::types::QuarterHourTimeOffset DayLightSavingTime::readUtcOffset(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::QuarterHourTimeOffset>(in.readSignedBits(UINT8_C(8)));
}

::nds::core::types::QuarterHourTimeOffset DayLightSavingTime::readUtcOffset(DayLightSavingTime::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getUtcOffset().read<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(in);
}
::zserio::InplaceOptionalHolder<DayLightSavingTime::ZserioArrayType_names> DayLightSavingTime::readNames(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_names readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_names>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_names>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<DayLightSavingTime::ZserioArrayType_names> DayLightSavingTime::readNames(DayLightSavingTime::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_names readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_names>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_names>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<DayLightSavingTime::ZserioArrayType_abbreviationNames> DayLightSavingTime::readAbbreviationNames(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_abbreviationNames readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_abbreviationNames>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_abbreviationNames>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<DayLightSavingTime::ZserioArrayType_abbreviationNames> DayLightSavingTime::readAbbreviationNames(DayLightSavingTime::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_abbreviationNames readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_abbreviationNames>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_abbreviationNames>(::zserio::NullOpt);
}
::nds::core::conditions::TimeOfDay DayLightSavingTime::readStartTimeOfDay(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::conditions::TimeOfDay(in, allocator);
}

::nds::core::conditions::TimeOfDay DayLightSavingTime::readStartTimeOfDay(DayLightSavingTime::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::conditions::TimeOfDay(context.getStartTimeOfDay(), in, allocator);
}
::nds::core::conditions::WeekdayInMonth DayLightSavingTime::readStartWeekdayInMonth(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::conditions::WeekdayInMonth(in, allocator);
}

::nds::core::conditions::WeekdayInMonth DayLightSavingTime::readStartWeekdayInMonth(DayLightSavingTime::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::conditions::WeekdayInMonth(context.getStartWeekdayInMonth(), in, allocator);
}
::nds::core::conditions::MonthOfYear DayLightSavingTime::readStartMonthOfYear(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::conditions::MonthOfYear>(in.readBits(UINT8_C(4)));
}

::nds::core::conditions::MonthOfYear DayLightSavingTime::readStartMonthOfYear(DayLightSavingTime::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStartMonthOfYear().read<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(in);
}
::nds::core::conditions::TimeOfDay DayLightSavingTime::readEndTimeOfDay(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::conditions::TimeOfDay(in, allocator);
}

::nds::core::conditions::TimeOfDay DayLightSavingTime::readEndTimeOfDay(DayLightSavingTime::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::conditions::TimeOfDay(context.getEndTimeOfDay(), in, allocator);
}
::nds::core::conditions::WeekdayInMonth DayLightSavingTime::readEndWeekdayInMonth(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::conditions::WeekdayInMonth(in, allocator);
}

::nds::core::conditions::WeekdayInMonth DayLightSavingTime::readEndWeekdayInMonth(DayLightSavingTime::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::conditions::WeekdayInMonth(context.getEndWeekdayInMonth(), in, allocator);
}
::nds::core::conditions::MonthOfYear DayLightSavingTime::readEndMonthOfYear(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::conditions::MonthOfYear>(in.readBits(UINT8_C(4)));
}

::nds::core::conditions::MonthOfYear DayLightSavingTime::readEndMonthOfYear(DayLightSavingTime::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getEndMonthOfYear().read<::zserio::BitFieldArrayTraits<::nds::core::conditions::MonthOfYear, UINT8_C(4)>>(in);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/TrafficLightFaceList.h>

namespace nds
{
namespace rules
{
namespace types
{

TrafficLightFaceList::TrafficLightFaceList(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_hasLensPositions_(bool()),
        m_faces_(allocator)
{
}

TrafficLightFaceList::TrafficLightFaceList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_hasLensPositions_(readHasLensPositions(in)),
        m_faces_(readFaces(in, allocator))
{
}

TrafficLightFaceList::TrafficLightFaceList(TrafficLightFaceList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_hasLensPositions_(readHasLensPositions(in)),
        m_faces_(readFaces(context, in, allocator))
{
}

TrafficLightFaceList::TrafficLightFaceList(const TrafficLightFaceList& other) :
        m_hasLensPositions_(other.m_hasLensPositions_),
        m_faces_(other.m_faces_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficLightFaceList& TrafficLightFaceList::operator=(const TrafficLightFaceList& other)
{
    m_hasLensPositions_ = other.m_hasLensPositions_;
    m_faces_ = other.m_faces_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficLightFaceList::TrafficLightFaceList(TrafficLightFaceList&& other) :
        m_hasLensPositions_(::std::move(other.m_hasLensPositions_)),
        m_faces_(::std::move(other.m_faces_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficLightFaceList& TrafficLightFaceList::operator=(TrafficLightFaceList&& other)
{
    m_hasLensPositions_ = ::std::move(other.m_hasLensPositions_);
    m_faces_ = ::std::move(other.m_faces_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficLightFaceList::TrafficLightFaceList(::zserio::PropagateAllocatorT,
        const TrafficLightFaceList& other, const allocator_type& allocator) :
        m_hasLensPositions_(::zserio::allocatorPropagatingCopy(other.m_hasLensPositions_, allocator)),
        m_faces_(::zserio::allocatorPropagatingCopy(other.m_faces_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void TrafficLightFaceList::initializeChildren()
{
    m_faces_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

bool TrafficLightFaceList::getHasLensPositions() const
{
    return m_hasLensPositions_;
}

void TrafficLightFaceList::setHasLensPositions(bool hasLensPositions_)
{
    m_hasLensPositions_ = hasLensPositions_;
}

::zserio::vector<::nds::rules::types::TrafficLightFace>& TrafficLightFaceList::getFaces()
{
    return m_faces_.getRawArray();
}

const ::zserio::vector<::nds::rules::types::TrafficLightFace>& TrafficLightFaceList::getFaces() const
{
    return m_faces_.getRawArray();
}

void TrafficLightFaceList::setFaces(const ::zserio::vector<::nds::rules::types::TrafficLightFace>& faces_)
{
    m_faces_ = ZserioArrayType_faces(faces_);
}

void TrafficLightFaceList::setFaces(::zserio::vector<::nds::rules::types::TrafficLightFace>&& faces_)
{
    m_faces_ = ZserioArrayType_faces(std::move(faces_));
}

void TrafficLightFaceList::initPackingContext(TrafficLightFaceList::ZserioPackingContext&) const
{
}

size_t TrafficLightFaceList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += m_faces_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLightFaceList::bitSizeOf(TrafficLightFaceList::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += m_faces_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLightFaceList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition = m_faces_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLightFaceList::initializeOffsets(TrafficLightFaceList::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition = m_faces_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLightFaceList::operator==(const TrafficLightFaceList& other) const
{
    if (this != &other)
    {
        return
                (m_hasLensPositions_ == other.m_hasLensPositions_) &&
                (m_faces_ == other.m_faces_);
    }

    return true;
}

uint32_t TrafficLightFaceList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_hasLensPositions_);
    result = ::zserio::calcHashCode(result, m_faces_);

    return result;
}

void TrafficLightFaceList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasLensPositions_);
    m_faces_.write(*this, out);
}

void TrafficLightFaceList::write(TrafficLightFaceList::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasLensPositions_);
    m_faces_.writePacked(*this, out);
}

void TrafficLightFaceList::ZserioArrayExpressions_faces::initializeElement(TrafficLightFaceList& owner,
        ::nds::rules::types::TrafficLightFace& element, size_t)
{
    element.initialize(static_cast<bool>(owner.getHasLensPositions()));
}

void TrafficLightFaceList::ZserioElementFactory_faces::create(TrafficLightFaceList&         owner,
        ::zserio::vector<::nds::rules::types::TrafficLightFace>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(owner.getHasLensPositions()), array.get_allocator());
}

void TrafficLightFaceList::ZserioElementFactory_faces::create(TrafficLightFaceList&         owner,
        ::zserio::vector<::nds::rules::types::TrafficLightFace>& array,
        ::nds::rules::types::TrafficLightFace::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(owner.getHasLensPositions()), array.get_allocator());
}

bool TrafficLightFaceList::readHasLensPositions(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
TrafficLightFaceList::ZserioArrayType_faces TrafficLightFaceList::readFaces(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_faces readField(allocator);
    readField.read(*this, in);

    return readField;
}

TrafficLightFaceList::ZserioArrayType_faces TrafficLightFaceList::readFaces(TrafficLightFaceList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_faces readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/TrafficLightFace.h>

namespace nds
{
namespace rules
{
namespace types
{

TrafficLightFace::TrafficLightFace(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_face_(allocator),
        m_lensPositions_(allocator)
{
}

TrafficLightFace::TrafficLightFace(::zserio::BitStreamReader& in,
        bool hasLensPositions_, const allocator_type& allocator) :
        m_hasLensPositions_(hasLensPositions_),
        m_isInitialized(true),
        m_face_(readFace(in, allocator)),
        m_lensPositions_(readLensPositions(in, allocator))
{
}

TrafficLightFace::TrafficLightFace(TrafficLightFace::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool hasLensPositions_, const allocator_type& allocator) :
        m_hasLensPositions_(hasLensPositions_),
        m_isInitialized(true),
        m_face_(readFace(context, in, allocator)),
        m_lensPositions_(readLensPositions(context, in, allocator))
{
}

TrafficLightFace::TrafficLightFace(const TrafficLightFace& other) :
        m_face_(other.m_face_),
        m_lensPositions_(other.m_lensPositions_)
{
    if (other.m_isInitialized)
        initialize(other.m_hasLensPositions_);
    else
        m_isInitialized = false;
}

TrafficLightFace& TrafficLightFace::operator=(const TrafficLightFace& other)
{
    m_face_ = other.m_face_;
    m_lensPositions_ = other.m_lensPositions_;
    if (other.m_isInitialized)
        initialize(other.m_hasLensPositions_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLightFace::TrafficLightFace(TrafficLightFace&& other) :
        m_face_(::std::move(other.m_face_)),
        m_lensPositions_(::std::move(other.m_lensPositions_))
{
    if (other.m_isInitialized)
        initialize(other.m_hasLensPositions_);
    else
        m_isInitialized = false;
}

TrafficLightFace& TrafficLightFace::operator=(TrafficLightFace&& other)
{
    m_face_ = ::std::move(other.m_face_);
    m_lensPositions_ = ::std::move(other.m_lensPositions_);
    if (other.m_isInitialized)
        initialize(other.m_hasLensPositions_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLightFace::TrafficLightFace(::zserio::PropagateAllocatorT,
        const TrafficLightFace& other, const allocator_type& allocator) :
        m_face_(::zserio::allocatorPropagatingCopy(other.m_face_, allocator)),
        m_lensPositions_(::zserio::allocatorPropagatingCopy(other.m_lensPositions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_hasLensPositions_);
    else
        m_isInitialized = false;
}

void TrafficLightFace::initialize(
        bool hasLensPositions_)
{
    m_hasLensPositions_ = hasLensPositions_;
    m_isInitialized = true;

    initializeChildren();
}

bool TrafficLightFace::isInitialized() const
{
    return m_isInitialized;
}

void TrafficLightFace::initializeChildren()
{
    m_face_.initialize(static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0));
    m_lensPositions_.initializeElements(*this);
}

bool TrafficLightFace::getHasLensPositions() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasLensPositions' of compound 'TrafficLightFace' is not initialized!");

    return m_hasLensPositions_;
}

::nds::core::geometry::BoundingPolygon3D& TrafficLightFace::getFace()
{
    return m_face_;
}

const ::nds::core::geometry::BoundingPolygon3D& TrafficLightFace::getFace() const
{
    return m_face_;
}

void TrafficLightFace::setFace(const ::nds::core::geometry::BoundingPolygon3D& face_)
{
    m_face_ = face_;
}

void TrafficLightFace::setFace(::nds::core::geometry::BoundingPolygon3D&& face_)
{
    m_face_ = ::std::move(face_);
}

::zserio::vector<::nds::core::geometry::Position3D>& TrafficLightFace::getLensPositions()
{
    return m_lensPositions_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Position3D>& TrafficLightFace::getLensPositions() const
{
    return m_lensPositions_.getRawArray();
}

void TrafficLightFace::setLensPositions(const ::zserio::vector<::nds::core::geometry::Position3D>& lensPositions_)
{
    m_lensPositions_ = ZserioArrayType_lensPositions(lensPositions_);
}

void TrafficLightFace::setLensPositions(::zserio::vector<::nds::core::geometry::Position3D>&& lensPositions_)
{
    m_lensPositions_ = ZserioArrayType_lensPositions(std::move(lensPositions_));
}

void TrafficLightFace::initPackingContext(TrafficLightFace::ZserioPackingContext& context) const
{
    m_face_.initPackingContext(context.getFace());
}

size_t TrafficLightFace::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_face_.bitSizeOf(endBitPosition);
    endBitPosition += m_lensPositions_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLightFace::bitSizeOf(TrafficLightFace::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_face_.bitSizeOf(context.getFace(), endBitPosition);
    endBitPosition += m_lensPositions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLightFace::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_face_.initializeOffsets(endBitPosition);
    endBitPosition = m_lensPositions_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLightFace::initializeOffsets(TrafficLightFace::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_face_.initializeOffsets(context.getFace(), endBitPosition);
    endBitPosition = m_lensPositions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLightFace::operator==(const TrafficLightFace& other) const
{
    if (this != &other)
    {
        return
                (getHasLensPositions() == other.getHasLensPositions()) &&
                (m_face_ == other.m_face_) &&
                (m_lensPositions_ == other.m_lensPositions_);
    }

    return true;
}

uint32_t TrafficLightFace::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHasLensPositions());
    result = ::zserio::calcHashCode(result, m_face_);
    result = ::zserio::calcHashCode(result, m_lensPositions_);

    return result;
}

void TrafficLightFace::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_face_.getXyShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter xyShift for field TrafficLightFace.face: ") <<
                m_face_.getXyShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    if (m_face_.getZShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter zShift for field TrafficLightFace.face: ") <<
                m_face_.getZShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_face_.write(out);

    m_lensPositions_.write(*this, out);
}

void TrafficLightFace::write(TrafficLightFace::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_face_.getXyShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter xyShift for field TrafficLightFace.face: ") <<
                m_face_.getXyShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    if (m_face_.getZShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter zShift for field TrafficLightFace.face: ") <<
                m_face_.getZShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_face_.write(context.getFace(), out);

    m_lensPositions_.writePacked(*this, out);
}

void TrafficLightFace::ZserioArrayExpressions_lensPositions::initializeElement(TrafficLightFace&,
        ::nds::core::geometry::Position3D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0));
}

void TrafficLightFace::ZserioElementFactory_lensPositions::create(TrafficLightFace&        ,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), array.get_allocator());
}

void TrafficLightFace::ZserioElementFactory_lensPositions::create(TrafficLightFace&        ,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::nds::core::geometry::Position3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), array.get_allocator());
}

::nds::core::geometry::BoundingPolygon3D TrafficLightFace::readFace(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::BoundingPolygon3D(in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::core::geometry::BoundingPolygon3D TrafficLightFace::readFace(TrafficLightFace::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::BoundingPolygon3D(context.getFace(), in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}
TrafficLightFace::ZserioArrayType_lensPositions TrafficLightFace::readLensPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lensPositions readField(allocator);
    readField.read(*this, in);

    return readField;
}

TrafficLightFace::ZserioArrayType_lensPositions TrafficLightFace::readLensPositions(TrafficLightFace::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lensPositions readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/TrafficLightLayout.h>

namespace nds
{
namespace rules
{
namespace types
{

TrafficLightLayout::TrafficLightLayout(const allocator_type& allocator) noexcept :
        m_constructionType_(::nds::rules::types::TrafficLightConstructionType()),
        m_numLenses_(uint8_t()),
        m_lensValue_(allocator)
{
}

TrafficLightLayout::TrafficLightLayout(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_constructionType_(readConstructionType(in)),
        m_numLenses_(readNumLenses(in)),
        m_lensValue_(readLensValue(in, allocator))
{
}

TrafficLightLayout::TrafficLightLayout(TrafficLightLayout::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_constructionType_(readConstructionType(context, in)),
        m_numLenses_(readNumLenses(context, in)),
        m_lensValue_(readLensValue(context, in, allocator))
{
}

TrafficLightLayout::TrafficLightLayout(::zserio::PropagateAllocatorT,
        const TrafficLightLayout& other, const allocator_type& allocator) :
        m_constructionType_(::zserio::allocatorPropagatingCopy(other.m_constructionType_, allocator)),
        m_numLenses_(::zserio::allocatorPropagatingCopy(other.m_numLenses_, allocator)),
        m_lensValue_(::zserio::allocatorPropagatingCopy(other.m_lensValue_, allocator))
{
}

::nds::rules::types::TrafficLightConstructionType TrafficLightLayout::getConstructionType() const
{
    return m_constructionType_;
}

void TrafficLightLayout::setConstructionType(::nds::rules::types::TrafficLightConstructionType constructionType_)
{
    m_constructionType_ = constructionType_;
}

uint8_t TrafficLightLayout::getNumLenses() const
{
    return m_numLenses_;
}

void TrafficLightLayout::setNumLenses(uint8_t numLenses_)
{
    m_numLenses_ = numLenses_;
}

::zserio::vector<::nds::rules::types::TrafficLightLens>& TrafficLightLayout::getLensValue()
{
    return m_lensValue_.getRawArray();
}

const ::zserio::vector<::nds::rules::types::TrafficLightLens>& TrafficLightLayout::getLensValue() const
{
    return m_lensValue_.getRawArray();
}

void TrafficLightLayout::setLensValue(const ::zserio::vector<::nds::rules::types::TrafficLightLens>& lensValue_)
{
    m_lensValue_ = ZserioArrayType_lensValue(lensValue_);
}

void TrafficLightLayout::setLensValue(::zserio::vector<::nds::rules::types::TrafficLightLens>&& lensValue_)
{
    m_lensValue_ = ZserioArrayType_lensValue(std::move(lensValue_));
}

void TrafficLightLayout::initPackingContext(TrafficLightLayout::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getConstructionType(), m_constructionType_);
    context.getNumLenses().init<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(m_numLenses_);
}

size_t TrafficLightLayout::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_constructionType_);
    endBitPosition += UINT8_C(4);
    endBitPosition += m_lensValue_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLightLayout::bitSizeOf(TrafficLightLayout::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getConstructionType(), m_constructionType_);
    endBitPosition += context.getNumLenses().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(m_numLenses_);
    endBitPosition += m_lensValue_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLightLayout::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_constructionType_);
    endBitPosition += UINT8_C(4);
    endBitPosition = m_lensValue_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLightLayout::initializeOffsets(TrafficLightLayout::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getConstructionType(), endBitPosition,
        m_constructionType_);
    endBitPosition += context.getNumLenses().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(m_numLenses_);
    endBitPosition = m_lensValue_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLightLayout::operator==(const TrafficLightLayout& other) const
{
    if (this != &other)
    {
        return
                (m_constructionType_ == other.m_constructionType_) &&
                (m_numLenses_ == other.m_numLenses_) &&
                (m_lensValue_ == other.m_lensValue_);
    }

    return true;
}

uint32_t TrafficLightLayout::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_constructionType_);
    result = ::zserio::calcHashCode(result, m_numLenses_);
    result = ::zserio::calcHashCode(result, m_lensValue_);

    return result;
}

void TrafficLightLayout::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_constructionType_);

    out.writeBits(m_numLenses_, UINT8_C(4));

    // check array length
    if (m_lensValue_.getRawArray().size() != static_cast<size_t>(getNumLenses()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLightLayout.lensValue: ") <<
                m_lensValue_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLenses()) << "!";
    }
    m_lensValue_.write(*this, out);
}

void TrafficLightLayout::write(TrafficLightLayout::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getConstructionType(), out, m_constructionType_);

    context.getNumLenses().write<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(out, m_numLenses_);

    // check array length
    if (m_lensValue_.getRawArray().size() != static_cast<size_t>(getNumLenses()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLightLayout.lensValue: ") <<
                m_lensValue_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLenses()) << "!";
    }
    m_lensValue_.writePacked(*this, out);
}

void TrafficLightLayout::ZserioElementFactory_lensValue::create(TrafficLightLayout&        ,
        ::zserio::vector<::nds::rules::types::TrafficLightLens>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficLightLayout::ZserioElementFactory_lensValue::create(TrafficLightLayout&        ,
        ::zserio::vector<::nds::rules::types::TrafficLightLens>& array,
        ::nds::rules::types::TrafficLightLens::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::types::TrafficLightConstructionType TrafficLightLayout::readConstructionType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightConstructionType>(in);
}

::nds::rules::types::TrafficLightConstructionType TrafficLightLayout::readConstructionType(TrafficLightLayout::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightConstructionType>(context.getConstructionType(), in);
}
uint8_t TrafficLightLayout::readNumLenses(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(4)));
}

uint8_t TrafficLightLayout::readNumLenses(TrafficLightLayout::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumLenses().read<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(in);
}
TrafficLightLayout::ZserioArrayType_lensValue TrafficLightLayout::readLensValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lensValue readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumLenses()));

    return readField;
}

TrafficLightLayout::ZserioArrayType_lensValue TrafficLightLayout::readLensValue(TrafficLightLayout::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lensValue readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumLenses()));

    return readField;
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/rules/types/TrafficLightLens.h>
#include <nds/rules/types/TrafficLightLensType.h>

namespace nds
{
namespace rules
{
namespace types
{

TrafficLightLens::TrafficLightLens(const allocator_type&) noexcept :
        m_groupedLens_(bool()),
        m_group_(::zserio::NullOpt),
        m_lensType_(::nds::rules::types::TrafficLightLensType()),
        m_lensDetails_(::zserio::NullOpt),
        m_lensDetailList_(::zserio::NullOpt)
{
}

TrafficLightLens::TrafficLightLens(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_groupedLens_(readGroupedLens(in)),
        m_group_(readGroup(in)),
        m_lensType_(readLensType(in)),
        m_lensDetails_(readLensDetails(in, allocator)),
        m_lensDetailList_(readLensDetailList(in, allocator))
{
}

TrafficLightLens::TrafficLightLens(TrafficLightLens::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_groupedLens_(readGroupedLens(in)),
        m_group_(readGroup(context, in)),
        m_lensType_(readLensType(context, in)),
        m_lensDetails_(readLensDetails(context, in, allocator)),
        m_lensDetailList_(readLensDetailList(context, in, allocator))
{
}

TrafficLightLens::TrafficLightLens(::zserio::PropagateAllocatorT,
        const TrafficLightLens& other, const allocator_type& allocator) :
        m_groupedLens_(::zserio::allocatorPropagatingCopy(other.m_groupedLens_, allocator)),
        m_group_(::zserio::allocatorPropagatingCopy(other.m_group_, allocator)),
        m_lensType_(::zserio::allocatorPropagatingCopy(other.m_lensType_, allocator)),
        m_lensDetails_(::zserio::allocatorPropagatingCopy(other.m_lensDetails_, allocator)),
        m_lensDetailList_(::zserio::allocatorPropagatingCopy(other.m_lensDetailList_, allocator))
{
}

bool TrafficLightLens::getGroupedLens() const
{
    return m_groupedLens_;
}

void TrafficLightLens::setGroupedLens(bool groupedLens_)
{
    m_groupedLens_ = groupedLens_;
}

::nds::rules::types::TrafficLightLensGroup TrafficLightLens::getGroup() const
{
    return m_group_.value();
}

void TrafficLightLens::setGroup(::nds::rules::types::TrafficLightLensGroup group_)
{
    m_group_ = group_;
}

bool TrafficLightLens::isGroupUsed() const
{
    return (getGroupedLens());
}

bool TrafficLightLens::isGroupSet() const
{
    return m_group_.hasValue();
}

void TrafficLightLens::resetGroup()
{
    m_group_.reset();
}

::nds::rules::types::TrafficLightLensType TrafficLightLens::getLensType() const
{
    return m_lensType_;
}

void TrafficLightLens::setLensType(::nds::rules::types::TrafficLightLensType lensType_)
{
    m_lensType_ = lensType_;
}

::nds::rules::types::TrafficLightLensDetails& TrafficLightLens::getLensDetails()
{
    return m_lensDetails_.value();
}

const ::nds::rules::types::TrafficLightLensDetails& TrafficLightLens::getLensDetails() const
{
    return m_lensDetails_.value();
}

void TrafficLightLens::setLensDetails(const ::nds::rules::types::TrafficLightLensDetails& lensDetails_)
{
    m_lensDetails_ = lensDetails_;
}

void TrafficLightLens::setLensDetails(::nds::rules::types::TrafficLightLensDetails&& lensDetails_)
{
    m_lensDetails_ = ::std::move(lensDetails_);
}

bool TrafficLightLens::isLensDetailsUsed() const
{
    return (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED);
}

bool TrafficLightLens::isLensDetailsSet() const
{
    return m_lensDetails_.hasValue();
}

void TrafficLightLens::resetLensDetails()
{
    m_lensDetails_.reset();
}

::zserio::vector<::nds::rules::types::TrafficLightLensDetails>& TrafficLightLens::getLensDetailList()
{
    return m_lensDetailList_.value().getRawArray();
}

const ::zserio::vector<::nds::rules::types::TrafficLightLensDetails>& TrafficLightLens::getLensDetailList() const
{
    return m_lensDetailList_.value().getRawArray();
}

void TrafficLightLens::setLensDetailList(const ::zserio::vector<::nds::rules::types::TrafficLightLensDetails>& lensDetailList_)
{
    m_lensDetailList_ = ZserioArrayType_lensDetailList(lensDetailList_);
}

void TrafficLightLens::setLensDetailList(::zserio::vector<::nds::rules::types::TrafficLightLensDetails>&& lensDetailList_)
{
    m_lensDetailList_ = ZserioArrayType_lensDetailList(std::move(lensDetailList_));
}

bool TrafficLightLens::isLensDetailListUsed() const
{
    return (getLensType() == ::nds::rules::types::TrafficLightLensType::MIXED);
}

bool TrafficLightLens::isLensDetailListSet() const
{
    return m_lensDetailList_.hasValue();
}

void TrafficLightLens::resetLensDetailList()
{
    m_lensDetailList_.reset();
}

void TrafficLightLens::initPackingContext(TrafficLightLens::ZserioPackingContext& context) const
{
    if (getGroupedLens())
    {
        context.getGroup().init<::zserio::BitFieldArrayTraits<::nds::rules::types::TrafficLightLensGroup, UINT8_C(4)>>(m_group_.value());
    }
    ::zserio::initPackingContext(context.getLensType(), m_lensType_);
    if (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        m_lensDetails_.value().initPackingContext(context.getLensDetails());
    }
}

size_t TrafficLightLens::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getGroupedLens())
    {
        endBitPosition += UINT8_C(4);
    }
    endBitPosition += ::zserio::bitSizeOf(m_lensType_);
    if (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        endBitPosition += m_lensDetails_.value().bitSizeOf(endBitPosition);
    }
    if (getLensType() == ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        endBitPosition += m_lensDetailList_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficLightLens::bitSizeOf(TrafficLightLens::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getGroupedLens())
    {
        endBitPosition += context.getGroup().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::rules::types::TrafficLightLensGroup, UINT8_C(4)>>(m_group_.value());
    }
    endBitPosition += ::zserio::bitSizeOf(context.getLensType(), m_lensType_);
    if (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        endBitPosition += m_lensDetails_.value().bitSizeOf(context.getLensDetails(), endBitPosition);
    }
    if (getLensType() == ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        endBitPosition += m_lensDetailList_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TrafficLightLens::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getGroupedLens())
    {
        endBitPosition += UINT8_C(4);
    }
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_lensType_);
    if (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        endBitPosition = m_lensDetails_.value().initializeOffsets(endBitPosition);
    }
    if (getLensType() == ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        endBitPosition = m_lensDetailList_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t TrafficLightLens::initializeOffsets(TrafficLightLens::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getGroupedLens())
    {
        endBitPosition += context.getGroup().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::rules::types::TrafficLightLensGroup, UINT8_C(4)>>(m_group_.value());
    }
    endBitPosition = ::zserio::initializeOffsets(context.getLensType(), endBitPosition,
        m_lensType_);
    if (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        endBitPosition = m_lensDetails_.value().initializeOffsets(context.getLensDetails(), endBitPosition);
    }
    if (getLensType() == ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        endBitPosition = m_lensDetailList_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool TrafficLightLens::operator==(const TrafficLightLens& other) const
{
    if (this != &other)
    {
        return
                (m_groupedLens_ == other.m_groupedLens_) &&
                (!isGroupUsed() ? !other.isGroupUsed() : (m_group_ == other.m_group_)) &&
                (m_lensType_ == other.m_lensType_) &&
                (!isLensDetailsUsed() ? !other.isLensDetailsUsed() : (m_lensDetails_ == other.m_lensDetails_)) &&
                (!isLensDetailListUsed() ? !other.isLensDetailListUsed() : (m_lensDetailList_ == other.m_lensDetailList_));
    }

    return true;
}

uint32_t TrafficLightLens::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_groupedLens_);
    if (isGroupUsed())
        result = ::zserio::calcHashCode(result, m_group_);
    result = ::zserio::calcHashCode(result, m_lensType_);
    if (isLensDetailsUsed())
        result = ::zserio::calcHashCode(result, m_lensDetails_);
    if (isLensDetailListUsed())
        result = ::zserio::calcHashCode(result, m_lensDetailList_);

    return result;
}

void TrafficLightLens::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_groupedLens_);
    if (getGroupedLens())
    {
        out.writeBits(m_group_.value(), UINT8_C(4));
    }
    ::zserio::write(out, m_lensType_);
    if (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        m_lensDetails_.value().write(out);
    }
    if (getLensType() == ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        m_lensDetailList_.value().write(*this, out);
    }
}

void TrafficLightLens::write(TrafficLightLens::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_groupedLens_);
    if (getGroupedLens())
    {
        context.getGroup().write<::zserio::BitFieldArrayTraits<::nds::rules::types::TrafficLightLensGroup, UINT8_C(4)>>(out, m_group_.value());
    }
    ::zserio::write(context.getLensType(), out, m_lensType_);
    if (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        m_lensDetails_.value().write(context.getLensDetails(), out);
    }
    if (getLensType() == ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        m_lensDetailList_.value().writePacked(*this, out);
    }
}

void TrafficLightLens::ZserioElementFactory_lensDetailList::create(TrafficLightLens&        ,
        ::zserio::vector<::nds::rules::types::TrafficLightLensDetails>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TrafficLightLens::ZserioElementFactory_lensDetailList::create(TrafficLightLens&        ,
        ::zserio::vector<::nds::rules::types::TrafficLightLensDetails>& array,
        ::nds::rules::types::TrafficLightLensDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

bool TrafficLightLens::readGroupedLens(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensGroup> TrafficLightLens::readGroup(::zserio::BitStreamReader& in)
{
    if (getGroupedLens())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensGroup>(static_cast<::nds::rules::types::TrafficLightLensGroup>(in.readBits(UINT8_C(4))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensGroup>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensGroup> TrafficLightLens::readGroup(TrafficLightLens::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getGroupedLens())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensGroup>(context.getGroup().read<::zserio::BitFieldArrayTraits<::nds::rules::types::TrafficLightLensGroup, UINT8_C(4)>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensGroup>(::zserio::NullOpt);
}
::nds::rules::types::TrafficLightLensType TrafficLightLens::readLensType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightLensType>(in);
}

::nds::rules::types::TrafficLightLensType TrafficLightLens::readLensType(TrafficLightLens::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightLensType>(context.getLensType(), in);
}
::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensDetails> TrafficLightLens::readLensDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensDetails>(::nds::rules::types::TrafficLightLensDetails(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensDetails>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensDetails> TrafficLightLens::readLensDetails(TrafficLightLens::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getLensType() != ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensDetails>(::nds::rules::types::TrafficLightLensDetails(context.getLensDetails(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::types::TrafficLightLensDetails>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<TrafficLightLens::ZserioArrayType_lensDetailList> TrafficLightLens::readLensDetailList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getLensType() == ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        ZserioArrayType_lensDetailList readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_lensDetailList>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_lensDetailList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<TrafficLightLens::ZserioArrayType_lensDetailList> TrafficLightLens::readLensDetailList(TrafficLightLens::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getLensType() == ::nds::rules::types::TrafficLightLensType::MIXED)
    {
        ZserioArrayType_lensDetailList readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_lensDetailList>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_lensDetailList>(::zserio::NullOpt);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/TrafficLightLensDetails.h>

namespace nds
{
namespace rules
{
namespace types
{

TrafficLightLensDetails::TrafficLightLensDetails(const allocator_type&) noexcept :
        m_color_(::nds::rules::types::TrafficLightLensColor()),
        m_isInverted_(bool()),
        m_inlayType_(::nds::rules::types::TrafficLightInlayType())
{
}

TrafficLightLensDetails::TrafficLightLensDetails(::zserio::BitStreamReader& in, const allocator_type&) :
        m_color_(readColor(in)),
        m_isInverted_(readIsInverted(in)),
        m_inlayType_(readInlayType(in))
{
}

TrafficLightLensDetails::TrafficLightLensDetails(TrafficLightLensDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_color_(readColor(context, in)),
        m_isInverted_(readIsInverted(in)),
        m_inlayType_(readInlayType(context, in))
{
}

TrafficLightLensDetails::TrafficLightLensDetails(::zserio::PropagateAllocatorT,
        const TrafficLightLensDetails& other, const allocator_type& allocator) :
        m_color_(::zserio::allocatorPropagatingCopy(other.m_color_, allocator)),
        m_isInverted_(::zserio::allocatorPropagatingCopy(other.m_isInverted_, allocator)),
        m_inlayType_(::zserio::allocatorPropagatingCopy(other.m_inlayType_, allocator))
{
}

::nds::rules::types::TrafficLightLensColor TrafficLightLensDetails::getColor() const
{
    return m_color_;
}

void TrafficLightLensDetails::setColor(::nds::rules::types::TrafficLightLensColor color_)
{
    m_color_ = color_;
}

bool TrafficLightLensDetails::getIsInverted() const
{
    return m_isInverted_;
}

void TrafficLightLensDetails::setIsInverted(bool isInverted_)
{
    m_isInverted_ = isInverted_;
}

::nds::rules::types::TrafficLightInlayType TrafficLightLensDetails::getInlayType() const
{
    return m_inlayType_;
}

void TrafficLightLensDetails::setInlayType(::nds::rules::types::TrafficLightInlayType inlayType_)
{
    m_inlayType_ = inlayType_;
}

void TrafficLightLensDetails::initPackingContext(TrafficLightLensDetails::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getColor(), m_color_);
    ::zserio::initPackingContext(context.getInlayType(), m_inlayType_);
}

size_t TrafficLightLensDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_color_);
    endBitPosition += UINT8_C(1);
    endBitPosition += ::zserio::bitSizeOf(m_inlayType_);

    return endBitPosition - bitPosition;
}

size_t TrafficLightLensDetails::bitSizeOf(TrafficLightLensDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getColor(), m_color_);
    endBitPosition += UINT8_C(1);
    endBitPosition += ::zserio::bitSizeOf(context.getInlayType(), m_inlayType_);

    return endBitPosition - bitPosition;
}

size_t TrafficLightLensDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_color_);
    endBitPosition += UINT8_C(1);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_inlayType_);

    return endBitPosition;
}

size_t TrafficLightLensDetails::initializeOffsets(TrafficLightLensDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getColor(), endBitPosition,
        m_color_);
    endBitPosition += UINT8_C(1);
    endBitPosition = ::zserio::initializeOffsets(context.getInlayType(), endBitPosition,
        m_inlayType_);

    return endBitPosition;
}

bool TrafficLightLensDetails::operator==(const TrafficLightLensDetails& other) const
{
    if (this != &other)
    {
        return
                (m_color_ == other.m_color_) &&
                (m_isInverted_ == other.m_isInverted_) &&
                (m_inlayType_ == other.m_inlayType_);
    }

    return true;
}

uint32_t TrafficLightLensDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_color_);
    result = ::zserio::calcHashCode(result, m_isInverted_);
    result = ::zserio::calcHashCode(result, m_inlayType_);

    return result;
}

void TrafficLightLensDetails::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_color_);
    out.writeBool(m_isInverted_);
    ::zserio::write(out, m_inlayType_);
}

void TrafficLightLensDetails::write(TrafficLightLensDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getColor(), out, m_color_);
    out.writeBool(m_isInverted_);
    ::zserio::write(context.getInlayType(), out, m_inlayType_);
}

::nds::rules::types::TrafficLightLensColor TrafficLightLensDetails::readColor(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightLensColor>(in);
}

::nds::rules::types::TrafficLightLensColor TrafficLightLensDetails::readColor(TrafficLightLensDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightLensColor>(context.getColor(), in);
}
bool TrafficLightLensDetails::readIsInverted(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::rules::types::TrafficLightInlayType TrafficLightLensDetails::readInlayType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightInlayType>(in);
}

::nds::rules::types::TrafficLightInlayType TrafficLightLensDetails::readInlayType(TrafficLightLensDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightInlayType>(context.getInlayType(), in);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/TrafficLightCycle.h>

namespace nds
{
namespace rules
{
namespace types
{

TrafficLightCycle::TrafficLightCycle(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_numLenses_(uint8_t()),
        m_phases_(allocator)
{
}

TrafficLightCycle::TrafficLightCycle(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_numLenses_(readNumLenses(in)),
        m_phases_(readPhases(in, allocator))
{
}

TrafficLightCycle::TrafficLightCycle(TrafficLightCycle::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_numLenses_(readNumLenses(context, in)),
        m_phases_(readPhases(context, in, allocator))
{
}

TrafficLightCycle::TrafficLightCycle(const TrafficLightCycle& other) :
        m_numLenses_(other.m_numLenses_),
        m_phases_(other.m_phases_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficLightCycle& TrafficLightCycle::operator=(const TrafficLightCycle& other)
{
    m_numLenses_ = other.m_numLenses_;
    m_phases_ = other.m_phases_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficLightCycle::TrafficLightCycle(TrafficLightCycle&& other) :
        m_numLenses_(::std::move(other.m_numLenses_)),
        m_phases_(::std::move(other.m_phases_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

TrafficLightCycle& TrafficLightCycle::operator=(TrafficLightCycle&& other)
{
    m_numLenses_ = ::std::move(other.m_numLenses_);
    m_phases_ = ::std::move(other.m_phases_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

TrafficLightCycle::TrafficLightCycle(::zserio::PropagateAllocatorT,
        const TrafficLightCycle& other, const allocator_type& allocator) :
        m_numLenses_(::zserio::allocatorPropagatingCopy(other.m_numLenses_, allocator)),
        m_phases_(::zserio::allocatorPropagatingCopy(other.m_phases_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void TrafficLightCycle::initializeChildren()
{
    m_phases_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

uint8_t TrafficLightCycle::getNumLenses() const
{
    return m_numLenses_;
}

void TrafficLightCycle::setNumLenses(uint8_t numLenses_)
{
    m_numLenses_ = numLenses_;
}

::zserio::vector<::nds::rules::types::TrafficLightPhase>& TrafficLightCycle::getPhases()
{
    return m_phases_.getRawArray();
}

const ::zserio::vector<::nds::rules::types::TrafficLightPhase>& TrafficLightCycle::getPhases() const
{
    return m_phases_.getRawArray();
}

void TrafficLightCycle::setPhases(const ::zserio::vector<::nds::rules::types::TrafficLightPhase>& phases_)
{
    m_phases_ = ZserioArrayType_phases(phases_);
}

void TrafficLightCycle::setPhases(::zserio::vector<::nds::rules::types::TrafficLightPhase>&& phases_)
{
    m_phases_ = ZserioArrayType_phases(std::move(phases_));
}

void TrafficLightCycle::initPackingContext(TrafficLightCycle::ZserioPackingContext& context) const
{
    context.getNumLenses().init<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(m_numLenses_);
}

size_t TrafficLightCycle::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(4);
    endBitPosition += m_phases_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLightCycle::bitSizeOf(TrafficLightCycle::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLenses().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(m_numLenses_);
    endBitPosition += m_phases_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TrafficLightCycle::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(4);
    endBitPosition = m_phases_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t TrafficLightCycle::initializeOffsets(TrafficLightCycle::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLenses().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(m_numLenses_);
    endBitPosition = m_phases_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TrafficLightCycle::operator==(const TrafficLightCycle& other) const
{
    if (this != &other)
    {
        return
                (m_numLenses_ == other.m_numLenses_) &&
                (m_phases_ == other.m_phases_);
    }

    return true;
}

uint32_t TrafficLightCycle::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numLenses_);
    result = ::zserio::calcHashCode(result, m_phases_);

    return result;
}

void TrafficLightCycle::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numLenses_, UINT8_C(4));
    m_phases_.write(*this, out);
}

void TrafficLightCycle::write(TrafficLightCycle::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumLenses().write<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(out, m_numLenses_);
    m_phases_.writePacked(*this, out);
}

void TrafficLightCycle::ZserioArrayExpressions_phases::initializeElement(TrafficLightCycle& owner,
        ::nds::rules::types::TrafficLightPhase& element, size_t)
{
    element.initialize(static_cast<uint8_t>(owner.getNumLenses()));
}

void TrafficLightCycle::ZserioElementFactory_phases::create(TrafficLightCycle&         owner,
        ::zserio::vector<::nds::rules::types::TrafficLightPhase>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint8_t>(owner.getNumLenses()), array.get_allocator());
}

void TrafficLightCycle::ZserioElementFactory_phases::create(TrafficLightCycle&         owner,
        ::zserio::vector<::nds::rules::types::TrafficLightPhase>& array,
        ::nds::rules::types::TrafficLightPhase::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint8_t>(owner.getNumLenses()), array.get_allocator());
}

uint8_t TrafficLightCycle::readNumLenses(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(4)));
}

uint8_t TrafficLightCycle::readNumLenses(TrafficLightCycle::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumLenses().read<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(4)>>(in);
}
TrafficLightCycle::ZserioArrayType_phases TrafficLightCycle::readPhases(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_phases readField(allocator);
    readField.read(*this, in);

    return readField;
}

TrafficLightCycle::ZserioArrayType_phases TrafficLightCycle::readPhases(TrafficLightCycle::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_phases readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/TrafficLightPhase.h>

namespace nds
{
namespace rules
{
namespace types
{

TrafficLightPhase::TrafficLightPhase(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_activeLense_(allocator),
        m_blinkingLense_(allocator),
        m_meaning_(::nds::rules::types::TrafficLightPhaseMeaning())
{
}

TrafficLightPhase::TrafficLightPhase(::zserio::BitStreamReader& in,
        uint8_t numLenses_, const allocator_type& allocator) :
        m_numLenses_(numLenses_),
        m_isInitialized(true),
        m_activeLense_(readActiveLense(in, allocator)),
        m_blinkingLense_(readBlinkingLense(in, allocator)),
        m_meaning_(readMeaning(in))
{
}

TrafficLightPhase::TrafficLightPhase(TrafficLightPhase::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint8_t numLenses_, const allocator_type& allocator) :
        m_numLenses_(numLenses_),
        m_isInitialized(true),
        m_activeLense_(readActiveLense(in, allocator)),
        m_blinkingLense_(readBlinkingLense(in, allocator)),
        m_meaning_(readMeaning(context, in))
{
}

TrafficLightPhase::TrafficLightPhase(const TrafficLightPhase& other) :
        m_activeLense_(other.m_activeLense_),
        m_blinkingLense_(other.m_blinkingLense_),
        m_meaning_(other.m_meaning_)
{
    if (other.m_isInitialized)
        initialize(other.m_numLenses_);
    else
        m_isInitialized = false;
}

TrafficLightPhase& TrafficLightPhase::operator=(const TrafficLightPhase& other)
{
    m_activeLense_ = other.m_activeLense_;
    m_blinkingLense_ = other.m_blinkingLense_;
    m_meaning_ = other.m_meaning_;
    if (other.m_isInitialized)
        initialize(other.m_numLenses_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLightPhase::TrafficLightPhase(TrafficLightPhase&& other) :
        m_activeLense_(::std::move(other.m_activeLense_)),
        m_blinkingLense_(::std::move(other.m_blinkingLense_)),
        m_meaning_(::std::move(other.m_meaning_))
{
    if (other.m_isInitialized)
        initialize(other.m_numLenses_);
    else
        m_isInitialized = false;
}

TrafficLightPhase& TrafficLightPhase::operator=(TrafficLightPhase&& other)
{
    m_activeLense_ = ::std::move(other.m_activeLense_);
    m_blinkingLense_ = ::std::move(other.m_blinkingLense_);
    m_meaning_ = ::std::move(other.m_meaning_);
    if (other.m_isInitialized)
        initialize(other.m_numLenses_);
    else
        m_isInitialized = false;

    return *this;
}

TrafficLightPhase::TrafficLightPhase(::zserio::PropagateAllocatorT,
        const TrafficLightPhase& other, const allocator_type& allocator) :
        m_activeLense_(::zserio::allocatorPropagatingCopy(other.m_activeLense_, allocator)),
        m_blinkingLense_(::zserio::allocatorPropagatingCopy(other.m_blinkingLense_, allocator)),
        m_meaning_(::zserio::allocatorPropagatingCopy(other.m_meaning_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numLenses_);
    else
        m_isInitialized = false;
}

void TrafficLightPhase::initialize(
        uint8_t numLenses_)
{
    m_numLenses_ = numLenses_;
    m_isInitialized = true;
}

bool TrafficLightPhase::isInitialized() const
{
    return m_isInitialized;
}

uint8_t TrafficLightPhase::getNumLenses() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numLenses' of compound 'TrafficLightPhase' is not initialized!");

    return m_numLenses_;
}

::zserio::vector<bool>& TrafficLightPhase::getActiveLense()
{
    return m_activeLense_.getRawArray();
}

const ::zserio::vector<bool>& TrafficLightPhase::getActiveLense() const
{
    return m_activeLense_.getRawArray();
}

void TrafficLightPhase::setActiveLense(const ::zserio::vector<bool>& activeLense_)
{
    m_activeLense_ = ZserioArrayType_activeLense(activeLense_);
}

void TrafficLightPhase::setActiveLense(::zserio::vector<bool>&& activeLense_)
{
    m_activeLense_ = ZserioArrayType_activeLense(std::move(activeLense_));
}

::zserio::vector<bool>& TrafficLightPhase::getBlinkingLense()
{
    return m_blinkingLense_.getRawArray();
}

const ::zserio::vector<bool>& TrafficLightPhase::getBlinkingLense() const
{
    return m_blinkingLense_.getRawArray();
}

void TrafficLightPhase::setBlinkingLense(const ::zserio::vector<bool>& blinkingLense_)
{
    m_blinkingLense_ = ZserioArrayType_blinkingLense(blinkingLense_);
}

void TrafficLightPhase::setBlinkingLense(::zserio::vector<bool>&& blinkingLense_)
{
    m_blinkingLense_ = ZserioArrayType_blinkingLense(std::move(blinkingLense_));
}

::nds::rules::types::TrafficLightPhaseMeaning TrafficLightPhase::getMeaning() const
{
    return m_meaning_;
}

void TrafficLightPhase::setMeaning(::nds::rules::types::TrafficLightPhaseMeaning meaning_)
{
    m_meaning_ = meaning_;
}

void TrafficLightPhase::initPackingContext(TrafficLightPhase::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getMeaning(), m_meaning_);
}

size_t TrafficLightPhase::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_activeLense_.bitSizeOf(endBitPosition);
    endBitPosition += m_blinkingLense_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_meaning_);

    return endBitPosition - bitPosition;
}

size_t TrafficLightPhase::bitSizeOf(TrafficLightPhase::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_activeLense_.bitSizeOf(endBitPosition);
    endBitPosition += m_blinkingLense_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(context.getMeaning(), m_meaning_);

    return endBitPosition - bitPosition;
}

size_t TrafficLightPhase::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_activeLense_.initializeOffsets(endBitPosition);
    endBitPosition = m_blinkingLense_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_meaning_);

    return endBitPosition;
}

size_t TrafficLightPhase::initializeOffsets(TrafficLightPhase::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_activeLense_.initializeOffsets(endBitPosition);
    endBitPosition = m_blinkingLense_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(context.getMeaning(), endBitPosition,
        m_meaning_);

    return endBitPosition;
}

bool TrafficLightPhase::operator==(const TrafficLightPhase& other) const
{
    if (this != &other)
    {
        return
                (getNumLenses() == other.getNumLenses()) &&
                (m_activeLense_ == other.m_activeLense_) &&
                (m_blinkingLense_ == other.m_blinkingLense_) &&
                (m_meaning_ == other.m_meaning_);
    }

    return true;
}

uint32_t TrafficLightPhase::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumLenses());
    result = ::zserio::calcHashCode(result, m_activeLense_);
    result = ::zserio::calcHashCode(result, m_blinkingLense_);
    result = ::zserio::calcHashCode(result, m_meaning_);

    return result;
}

void TrafficLightPhase::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_activeLense_.getRawArray().size() != static_cast<size_t>(getNumLenses()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLightPhase.activeLense: ") <<
                m_activeLense_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLenses()) << "!";
    }
    m_activeLense_.write(out);

    // check array length
    if (m_blinkingLense_.getRawArray().size() != static_cast<size_t>(getNumLenses()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLightPhase.blinkingLense: ") <<
                m_blinkingLense_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLenses()) << "!";
    }
    m_blinkingLense_.write(out);

    ::zserio::write(out, m_meaning_);
}

void TrafficLightPhase::write(TrafficLightPhase::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_activeLense_.getRawArray().size() != static_cast<size_t>(getNumLenses()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLightPhase.activeLense: ") <<
                m_activeLense_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLenses()) << "!";
    }
    m_activeLense_.write(out);

    // check array length
    if (m_blinkingLense_.getRawArray().size() != static_cast<size_t>(getNumLenses()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TrafficLightPhase.blinkingLense: ") <<
                m_blinkingLense_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLenses()) << "!";
    }
    m_blinkingLense_.write(out);

    ::zserio::write(context.getMeaning(), out, m_meaning_);
}

TrafficLightPhase::ZserioArrayType_activeLense TrafficLightPhase::readActiveLense(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_activeLense readField(allocator);
    readField.read(in, static_cast<size_t>(getNumLenses()));

    return readField;
}
TrafficLightPhase::ZserioArrayType_blinkingLense TrafficLightPhase::readBlinkingLense(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_blinkingLense readField(allocator);
    readField.read(in, static_cast<size_t>(getNumLenses()));

    return readField;
}
::nds::rules::types::TrafficLightPhaseMeaning TrafficLightPhase::readMeaning(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightPhaseMeaning>(in);
}

::nds::rules::types::TrafficLightPhaseMeaning TrafficLightPhase::readMeaning(TrafficLightPhase::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::types::TrafficLightPhaseMeaning>(context.getMeaning(), in);
}

} // namespace types
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/types/RegionValidityValue.h>

namespace nds
{
namespace rules
{
namespace types
{

RegionValidityValue::RegionValidityValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RegionValidityValue::RegionValidityValue(::zserio::BitStreamReader& in,
        ::nds::rules::types::RegionValidityType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RegionValidityValue::RegionValidityValue(RegionValidityValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::types::RegionValidityType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RegionValidityValue::RegionValidityValue(const RegionValidityValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RegionValidityValue& RegionValidityValue::operator=(const RegionValidityValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RegionValidityValue::RegionValidityValue(RegionValidityValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RegionValidityValue& RegionValidityValue::operator=(RegionValidityValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RegionValidityValue::RegionValidityValue(::zserio::PropagateAllocatorT,
        const RegionValidityValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RegionValidityValue::initialize(
        ::nds::rules::types::RegionValidityType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RegionValidityValue::isInitialized() const
{
    return m_isInitialized;
}

::nds::rules::types::RegionValidityType RegionValidityValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RegionValidityValue' is not initialized!");

    return m_type_;
}

uint16_t RegionValidityValue::getNumLanes() const
{
    return m_objectChoice.get<uint16_t>();
}

void RegionValidityValue::setNumLanes(uint16_t numLanes_)
{
    m_objectChoice = numLanes_;
}

uint16_t RegionValidityValue::getMinLanes() const
{
    return m_objectChoice.get<uint16_t>();
}

void RegionValidityValue::setMinLanes(uint16_t minLanes_)
{
    m_objectChoice = minLanes_;
}

bool RegionValidityValue::getPaved() const
{
    return m_objectChoice.get<bool>();
}

void RegionValidityValue::setPaved(bool paved_)
{
    m_objectChoice = paved_;
}

::nds::rules::types::TrafficZone RegionValidityValue::getTrafficZone() const
{
    return m_objectChoice.get<::nds::rules::types::TrafficZone>();
}

void RegionValidityValue::setTrafficZone(::nds::rules::types::TrafficZone trafficZone_)
{
    m_objectChoice = trafficZone_;
}

::nds::core::types::PriorityRoadClass RegionValidityValue::getPriorityRoadClass() const
{
    return m_objectChoice.get<::nds::core::types::PriorityRoadClass>();
}

void RegionValidityValue::setPriorityRoadClass(::nds::core::types::PriorityRoadClass priorityRoadClass_)
{
    m_objectChoice = priorityRoadClass_;
}

::nds::rules::types::MetricRoadWidth RegionValidityValue::getRoadMinimumWidth() const
{
    return m_objectChoice.get<::nds::rules::types::MetricRoadWidth>();
}

void RegionValidityValue::setRoadMinimumWidth(::nds::rules::types::MetricRoadWidth roadMinimumWidth_)
{
    m_objectChoice = roadMinimumWidth_;
}

::nds::rules::types::MetricRoadWidth RegionValidityValue::getRoadMaximumWidth() const
{
    return m_objectChoice.get<::nds::rules::types::MetricRoadWidth>();
}

void RegionValidityValue::setRoadMaximumWidth(::nds::rules::types::MetricRoadWidth roadMaximumWidth_)
{
    m_objectChoice = roadMaximumWidth_;
}

RegionValidityValue::ChoiceTag RegionValidityValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        return CHOICE_numLanes;
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        return CHOICE_minLanes;
    case ::nds::rules::types::RegionValidityType::PAVED:
        return CHOICE_paved;
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        return CHOICE_trafficZone;
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        return CHOICE_priorityRoadClass;
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        return UNDEFINED_CHOICE;
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        return UNDEFINED_CHOICE;
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        return CHOICE_roadMinimumWidth;
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        return CHOICE_roadMaximumWidth;
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        return UNDEFINED_CHOICE;
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        return UNDEFINED_CHOICE;
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        return UNDEFINED_CHOICE;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RegionValidityValue::initPackingContext(RegionValidityValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        context.getNumLanes().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        context.getMinLanes().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::PAVED:
        break;
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        ::zserio::initPackingContext(context.getTrafficZone(), m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        context.getPriorityRoadClass().init<::zserio::BitFieldArrayTraits<::nds::core::types::PriorityRoadClass, UINT8_C(4)>>(m_objectChoice.get<::nds::core::types::PriorityRoadClass>());
        break;
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        context.getRoadMinimumWidth().init<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        context.getRoadMaximumWidth().init<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }
}

size_t RegionValidityValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::PAVED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        endBitPosition += UINT8_C(4);
        break;
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RegionValidityValue::bitSizeOf(RegionValidityValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        endBitPosition += context.getMinLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::PAVED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficZone(), m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        endBitPosition += context.getPriorityRoadClass().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::types::PriorityRoadClass, UINT8_C(4)>>(m_objectChoice.get<::nds::core::types::PriorityRoadClass>());
        break;
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        endBitPosition += context.getRoadMinimumWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        endBitPosition += context.getRoadMaximumWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }

    return endBitPosition - bitPosition;
}

size_t RegionValidityValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::PAVED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        endBitPosition += UINT8_C(4);
        break;
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }

    return endBitPosition;
}

size_t RegionValidityValue::initializeOffsets(RegionValidityValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        endBitPosition += context.getMinLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::PAVED:
        endBitPosition += UINT8_C(1);
        break;
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficZone(), endBitPosition,
        m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        endBitPosition += context.getPriorityRoadClass().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::types::PriorityRoadClass, UINT8_C(4)>>(m_objectChoice.get<::nds::core::types::PriorityRoadClass>());
        break;
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        endBitPosition += context.getRoadMinimumWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        endBitPosition += context.getRoadMaximumWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }

    return endBitPosition;
}

bool RegionValidityValue::operator==(const RegionValidityValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<uint16_t>() == other.m_objectChoice.get<uint16_t>());
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<uint16_t>() == other.m_objectChoice.get<uint16_t>());
    case ::nds::rules::types::RegionValidityType::PAVED:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<bool>() == other.m_objectChoice.get<bool>());
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::TrafficZone>() == other.m_objectChoice.get<::nds::rules::types::TrafficZone>());
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::types::PriorityRoadClass>() == other.m_objectChoice.get<::nds::core::types::PriorityRoadClass>());
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        return true; // empty
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        return true; // empty
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MetricRoadWidth>() == other.m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::rules::types::MetricRoadWidth>() == other.m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        return true; // empty
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        return true; // empty
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        return true; // empty
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }
}

uint32_t RegionValidityValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::rules::types::RegionValidityType::NUM_LANES:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<uint16_t>());
            break;
        case ::nds::rules::types::RegionValidityType::MIN_LANES:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<uint16_t>());
            break;
        case ::nds::rules::types::RegionValidityType::PAVED:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<bool>());
            break;
        case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::TrafficZone>());
            break;
        case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::types::PriorityRoadClass>());
            break;
        case ::nds::rules::types::RegionValidityType::BEGINNER:
            // empty
            break;
        case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
            // empty
            break;
        case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
            break;
        case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
            break;
        case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
            // empty
            break;
        case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
            // empty
            break;
        case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
            // empty
            break;
        default:
            break;
        }
    }

    return result;
}

void RegionValidityValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        out.writeVarUInt16(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        out.writeVarUInt16(m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::PAVED:
        out.writeBool(m_objectChoice.get<bool>());
        break;
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        ::zserio::write(out, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        out.writeBits(m_objectChoice.get<::nds::core::types::PriorityRoadClass>(), UINT8_C(4));
        break;
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        out.writeVarUInt32(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        out.writeVarUInt32(m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }
}

void RegionValidityValue::write(RegionValidityValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        context.getNumLanes().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        context.getMinLanes().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_objectChoice.get<uint16_t>());
        break;
    case ::nds::rules::types::RegionValidityType::PAVED:
        out.writeBool(m_objectChoice.get<bool>());
        break;
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        ::zserio::write(context.getTrafficZone(), out, m_objectChoice.get<::nds::rules::types::TrafficZone>());
        break;
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        context.getPriorityRoadClass().write<::zserio::BitFieldArrayTraits<::nds::core::types::PriorityRoadClass, UINT8_C(4)>>(out, m_objectChoice.get<::nds::core::types::PriorityRoadClass>());
        break;
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        context.getRoadMinimumWidth().write<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(out, m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        context.getRoadMaximumWidth().write<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(out, m_objectChoice.get<::nds::rules::types::MetricRoadWidth>());
        break;
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        // empty
        break;
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        // empty
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }
}

::zserio::AnyHolder<> RegionValidityValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        return ::zserio::AnyHolder<>(static_cast<uint16_t>(in.readVarUInt16()), allocator);
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        return ::zserio::AnyHolder<>(static_cast<uint16_t>(in.readVarUInt16()), allocator);
    case ::nds::rules::types::RegionValidityType::PAVED:
        return ::zserio::AnyHolder<>(static_cast<bool>(in.readBool()), allocator);
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficZone>(in), allocator);
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        return ::zserio::AnyHolder<>(static_cast<::nds::core::types::PriorityRoadClass>(in.readBits(UINT8_C(4))), allocator);
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::MetricRoadWidth>(in.readVarUInt32()), allocator);
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        return ::zserio::AnyHolder<>(static_cast<::nds::rules::types::MetricRoadWidth>(in.readVarUInt32()), allocator);
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        return ::zserio::AnyHolder<>(allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }
}

::zserio::AnyHolder<> RegionValidityValue::readObject(RegionValidityValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        return ::zserio::AnyHolder<>(context.getNumLanes().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in), allocator);
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        return ::zserio::AnyHolder<>(context.getMinLanes().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in), allocator);
    case ::nds::rules::types::RegionValidityType::PAVED:
        return ::zserio::AnyHolder<>(static_cast<bool>(in.readBool()), allocator);
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::rules::types::TrafficZone>(context.getTrafficZone(), in), allocator);
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        return ::zserio::AnyHolder<>(context.getPriorityRoadClass().read<::zserio::BitFieldArrayTraits<::nds::core::types::PriorityRoadClass, UINT8_C(4)>>(in), allocator);
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        return ::zserio::AnyHolder<>(context.getRoadMinimumWidth().read<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(in), allocator);
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        return ::zserio::AnyHolder<>(context.getRoadMaximumWidth().read<::zserio::VarIntNNArrayTraits<::nds::rules::types::MetricRoadWidth>>(in), allocator);
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        return ::zserio::AnyHolder<>(allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }
}

::zserio::AnyHolder<> RegionValidityValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::rules::types::RegionValidityType::NUM_LANES:
        return ::zserio::allocatorPropagatingCopy<uint16_t>(m_objectChoice, allocator);
    case ::nds::rules::types::RegionValidityType::MIN_LANES:
        return ::zserio::allocatorPropagatingCopy<uint16_t>(m_objectChoice, allocator);
    case ::nds::rules::types::RegionValidityType::PAVED:
        return ::zserio::allocatorPropagatingCopy<bool>(m_objectChoice, allocator);
    case ::nds::rules::types::RegionValidityType::TRAFFIC_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::TrafficZone>(m_objectChoice, allocator);
    case ::nds::rules::types::RegionValidityType::PRIORITY_ROAD_CLASS:
        return ::zserio::allocatorPropagatingCopy<::nds::core::types::PriorityRoadClass>(m_objectChoice, allocator);
    case ::nds::rules::types::RegionValidityType::BEGINNER:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::NO_MARKINGS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::ROAD_MINIMUM_WIDTH:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MetricRoadWidth>(m_objectChoice, allocator);
    case ::nds::rules::types::RegionValidityType::ROAD_MAXIMUM_WIDTH:
        return ::zserio::allocatorPropagatingCopy<::nds::rules::types::MetricRoadWidth>(m_objectChoice, allocator);
    case ::nds::rules::types::RegionValidityType::HAS_STREET_LIGHTS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::SHARED_ROAD_SURFACE_WITH_PEDESTRIANS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::rules::types::RegionValidityType::IN_BUSINESS_DISTRICT:
        return ::zserio::AnyHolder<>(allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RegionValidityValue!");
    }
}

} // namespace types
} // namespace rules
} // namespace nds
