/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#ifndef NDS_RULES_TYPES_REGION_DRIVING_RULES_H
#define NDS_RULES_TYPES_REGION_DRIVING_RULES_H

#include <zserio/CppRuntimeVersion.h>
#if CPP_EXTENSION_RUNTIME_VERSION_NUMBER != 2012000
    #error Version mismatch between Zserio runtime library and Zserio compiler!
    #error Please update your Zserio runtime library to the version 2.12.0.
#endif

#include <zserio/Traits.h>
#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/AllocatorPropagatingCopy.h>
#include <zserio/DeltaContext.h>
#include <memory>
#include <zserio/OptionalHolder.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/reference/types/MarkingColor.h>
#include <nds/rules/types/DrivingRulesContent.h>
#include <nds/rules/types/EmergencyRules.h>
#include <nds/rules/types/LaneMergeRules.h>
#include <nds/rules/types/RoadSideParkingRules.h>
#include <nds/rules/types/SolidLineCrossingRules.h>

namespace nds
{
namespace rules
{
namespace types
{

class RegionDrivingRules
{
public:
    class ZserioPackingContext
    {
    public:
        ::zserio::DeltaContext& getContent()
        {
            return m_content_;
        }

        ::zserio::DeltaContext& getTemporaryLaneMarkingColor()
        {
            return m_temporaryLaneMarkingColor_;
        }

    private:
        ::zserio::DeltaContext m_content_;
        ::zserio::DeltaContext m_temporaryLaneMarkingColor_;
    };

    using allocator_type = ::std::allocator<uint8_t>;

    RegionDrivingRules() noexcept :
            RegionDrivingRules(allocator_type())
    {}

    explicit RegionDrivingRules(const allocator_type& allocator) noexcept;

    template <typename ZSERIO_T_stayCurbside = bool,
            typename ZSERIO_T_temporaryLaneMarkingColor = ::nds::lane::reference::types::MarkingColor,
            typename ZSERIO_T_curbsidePassingAllowed = bool,
            typename ZSERIO_T_emergencyRules = ::nds::rules::types::EmergencyRules,
            typename ZSERIO_T_yieldOncoming = bool,
            typename ZSERIO_T_yieldCurbSide = bool,
            typename ZSERIO_T_alwaysAllowed = bool,
            typename ZSERIO_T_solidLineCrossingRules = ::nds::rules::types::SolidLineCrossingRules,
            typename ZSERIO_T_roadSideParkingRules = ::nds::rules::types::RoadSideParkingRules,
            typename ZSERIO_T_laneMergeRules = ::nds::rules::types::LaneMergeRules>
    RegionDrivingRules(
            ::nds::rules::types::DrivingRulesContent content_,
            ZSERIO_T_stayCurbside&& stayCurbside_,
            ZSERIO_T_temporaryLaneMarkingColor&& temporaryLaneMarkingColor_,
            ZSERIO_T_curbsidePassingAllowed&& curbsidePassingAllowed_,
            ZSERIO_T_emergencyRules&& emergencyRules_,
            ZSERIO_T_yieldOncoming&& yieldOncoming_,
            ZSERIO_T_yieldCurbSide&& yieldCurbSide_,
            ZSERIO_T_alwaysAllowed&& alwaysAllowed_,
            ZSERIO_T_solidLineCrossingRules&& solidLineCrossingRules_,
            ZSERIO_T_roadSideParkingRules&& roadSideParkingRules_,
            ZSERIO_T_laneMergeRules&& laneMergeRules_,
            const allocator_type& allocator = allocator_type()) :
            RegionDrivingRules(allocator)
    {
        m_content_ = content_;
        m_stayCurbside_ = ::std::forward<ZSERIO_T_stayCurbside>(stayCurbside_);
        m_temporaryLaneMarkingColor_ = ::std::forward<ZSERIO_T_temporaryLaneMarkingColor>(temporaryLaneMarkingColor_);
        m_curbsidePassingAllowed_ = ::std::forward<ZSERIO_T_curbsidePassingAllowed>(curbsidePassingAllowed_);
        m_emergencyRules_ = ::std::forward<ZSERIO_T_emergencyRules>(emergencyRules_);
        m_yieldOncoming_ = ::std::forward<ZSERIO_T_yieldOncoming>(yieldOncoming_);
        m_yieldCurbSide_ = ::std::forward<ZSERIO_T_yieldCurbSide>(yieldCurbSide_);
        m_alwaysAllowed_ = ::std::forward<ZSERIO_T_alwaysAllowed>(alwaysAllowed_);
        m_solidLineCrossingRules_ = ::std::forward<ZSERIO_T_solidLineCrossingRules>(solidLineCrossingRules_);
        m_roadSideParkingRules_ = ::std::forward<ZSERIO_T_roadSideParkingRules>(roadSideParkingRules_);
        m_laneMergeRules_ = ::std::forward<ZSERIO_T_laneMergeRules>(laneMergeRules_);
    }

    explicit RegionDrivingRules(::zserio::BitStreamReader& in, const allocator_type& allocator = allocator_type());
    explicit RegionDrivingRules(ZserioPackingContext& context,
            ::zserio::BitStreamReader& in, const allocator_type& allocator = allocator_type());

    ~RegionDrivingRules() = default;

    RegionDrivingRules(const RegionDrivingRules&) = default;
    RegionDrivingRules& operator=(const RegionDrivingRules&) = default;

    RegionDrivingRules(RegionDrivingRules&&) = default;
    RegionDrivingRules& operator=(RegionDrivingRules&&) = default;

    RegionDrivingRules(::zserio::PropagateAllocatorT,
            const RegionDrivingRules& other, const allocator_type& allocator);

    ::nds::rules::types::DrivingRulesContent getContent() const;
    void setContent(::nds::rules::types::DrivingRulesContent content_);

    bool getStayCurbside() const;
    void setStayCurbside(bool stayCurbside_);
    bool isStayCurbsideUsed() const;
    bool isStayCurbsideSet() const;
    void resetStayCurbside();

    ::nds::lane::reference::types::MarkingColor getTemporaryLaneMarkingColor() const;
    void setTemporaryLaneMarkingColor(::nds::lane::reference::types::MarkingColor temporaryLaneMarkingColor_);
    bool isTemporaryLaneMarkingColorUsed() const;
    bool isTemporaryLaneMarkingColorSet() const;
    void resetTemporaryLaneMarkingColor();

    bool getCurbsidePassingAllowed() const;
    void setCurbsidePassingAllowed(bool curbsidePassingAllowed_);
    bool isCurbsidePassingAllowedUsed() const;
    bool isCurbsidePassingAllowedSet() const;
    void resetCurbsidePassingAllowed();

    const ::nds::rules::types::EmergencyRules& getEmergencyRules() const;
    ::nds::rules::types::EmergencyRules& getEmergencyRules();
    void setEmergencyRules(const ::nds::rules::types::EmergencyRules& emergencyRules_);
    void setEmergencyRules(::nds::rules::types::EmergencyRules&& emergencyRules_);
    bool isEmergencyRulesUsed() const;
    bool isEmergencyRulesSet() const;
    void resetEmergencyRules();

    bool getYieldOncoming() const;
    void setYieldOncoming(bool yieldOncoming_);
    bool isYieldOncomingUsed() const;
    bool isYieldOncomingSet() const;
    void resetYieldOncoming();

    bool getYieldCurbSide() const;
    void setYieldCurbSide(bool yieldCurbSide_);
    bool isYieldCurbSideUsed() const;
    bool isYieldCurbSideSet() const;
    void resetYieldCurbSide();

    bool getAlwaysAllowed() const;
    void setAlwaysAllowed(bool alwaysAllowed_);
    bool isAlwaysAllowedUsed() const;
    bool isAlwaysAllowedSet() const;
    void resetAlwaysAllowed();

    const ::nds::rules::types::SolidLineCrossingRules& getSolidLineCrossingRules() const;
    ::nds::rules::types::SolidLineCrossingRules& getSolidLineCrossingRules();
    void setSolidLineCrossingRules(const ::nds::rules::types::SolidLineCrossingRules& solidLineCrossingRules_);
    void setSolidLineCrossingRules(::nds::rules::types::SolidLineCrossingRules&& solidLineCrossingRules_);
    bool isSolidLineCrossingRulesUsed() const;
    bool isSolidLineCrossingRulesSet() const;
    void resetSolidLineCrossingRules();

    const ::nds::rules::types::RoadSideParkingRules& getRoadSideParkingRules() const;
    ::nds::rules::types::RoadSideParkingRules& getRoadSideParkingRules();
    void setRoadSideParkingRules(const ::nds::rules::types::RoadSideParkingRules& roadSideParkingRules_);
    void setRoadSideParkingRules(::nds::rules::types::RoadSideParkingRules&& roadSideParkingRules_);
    bool isRoadSideParkingRulesUsed() const;
    bool isRoadSideParkingRulesSet() const;
    void resetRoadSideParkingRules();

    const ::nds::rules::types::LaneMergeRules& getLaneMergeRules() const;
    ::nds::rules::types::LaneMergeRules& getLaneMergeRules();
    void setLaneMergeRules(const ::nds::rules::types::LaneMergeRules& laneMergeRules_);
    void setLaneMergeRules(::nds::rules::types::LaneMergeRules&& laneMergeRules_);
    bool isLaneMergeRulesUsed() const;
    bool isLaneMergeRulesSet() const;
    void resetLaneMergeRules();

    void initPackingContext(ZserioPackingContext& context) const;

    size_t bitSizeOf(size_t bitPosition = 0) const;
    size_t bitSizeOf(ZserioPackingContext& context, size_t bitPosition) const;

    size_t initializeOffsets(size_t bitPosition = 0);
    size_t initializeOffsets(ZserioPackingContext& context, size_t bitPosition);

    bool operator==(const RegionDrivingRules& other) const;
    uint32_t hashCode() const;

    void write(::zserio::BitStreamWriter& out) const;
    void write(ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const;

private:
    ::nds::rules::types::DrivingRulesContent readContent(::zserio::BitStreamReader& in);
    ::nds::rules::types::DrivingRulesContent readContent(ZserioPackingContext& context,
            ::zserio::BitStreamReader& in);
    ::zserio::InplaceOptionalHolder<bool> readStayCurbside(::zserio::BitStreamReader& in);
    ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::MarkingColor> readTemporaryLaneMarkingColor(::zserio::BitStreamReader& in);
    ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::MarkingColor> readTemporaryLaneMarkingColor(ZserioPackingContext& context,
            ::zserio::BitStreamReader& in);
    ::zserio::InplaceOptionalHolder<bool> readCurbsidePassingAllowed(::zserio::BitStreamReader& in);
    ::zserio::InplaceOptionalHolder<::nds::rules::types::EmergencyRules> readEmergencyRules(::zserio::BitStreamReader& in,
            const allocator_type& allocator);
    ::zserio::InplaceOptionalHolder<bool> readYieldOncoming(::zserio::BitStreamReader& in);
    ::zserio::InplaceOptionalHolder<bool> readYieldCurbSide(::zserio::BitStreamReader& in);
    ::zserio::InplaceOptionalHolder<bool> readAlwaysAllowed(::zserio::BitStreamReader& in);
    ::zserio::InplaceOptionalHolder<::nds::rules::types::SolidLineCrossingRules> readSolidLineCrossingRules(::zserio::BitStreamReader& in,
            const allocator_type& allocator);
    ::zserio::InplaceOptionalHolder<::nds::rules::types::RoadSideParkingRules> readRoadSideParkingRules(::zserio::BitStreamReader& in,
            const allocator_type& allocator);
    ::zserio::InplaceOptionalHolder<::nds::rules::types::LaneMergeRules> readLaneMergeRules(::zserio::BitStreamReader& in,
            const allocator_type& allocator);

    ::nds::rules::types::DrivingRulesContent m_content_;
    ::zserio::InplaceOptionalHolder<bool> m_stayCurbside_;
    ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::MarkingColor> m_temporaryLaneMarkingColor_;
    ::zserio::InplaceOptionalHolder<bool> m_curbsidePassingAllowed_;
    ::zserio::InplaceOptionalHolder<::nds::rules::types::EmergencyRules> m_emergencyRules_;
    ::zserio::InplaceOptionalHolder<bool> m_yieldOncoming_;
    ::zserio::InplaceOptionalHolder<bool> m_yieldCurbSide_;
    ::zserio::InplaceOptionalHolder<bool> m_alwaysAllowed_;
    ::zserio::InplaceOptionalHolder<::nds::rules::types::SolidLineCrossingRules> m_solidLineCrossingRules_;
    ::zserio::InplaceOptionalHolder<::nds::rules::types::RoadSideParkingRules> m_roadSideParkingRules_;
    ::zserio::InplaceOptionalHolder<::nds::rules::types::LaneMergeRules> m_laneMergeRules_;
};

} // namespace types
} // namespace rules
} // namespace nds

#endif // NDS_RULES_TYPES_REGION_DRIVING_RULES_H
