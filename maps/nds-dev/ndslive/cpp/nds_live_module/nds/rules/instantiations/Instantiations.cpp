/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadRangeAttributeMetadata.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadRangeAttributeMetadata::RulesRoadRangeAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RulesRoadRangeAttributeMetadata::RulesRoadRangeAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RulesRoadRangeAttributeMetadata::RulesRoadRangeAttributeMetadata(RulesRoadRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RulesRoadRangeAttributeMetadata::RulesRoadRangeAttributeMetadata(::zserio::PropagateAllocatorT,
        const RulesRoadRangeAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::rules::attributes::RulesRoadRangeAttributeType>& RulesRoadRangeAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesRoadRangeAttributeType>& RulesRoadRangeAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RulesRoadRangeAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::rules::attributes::RulesRoadRangeAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RulesRoadRangeAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::rules::attributes::RulesRoadRangeAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesRoadRangeAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesRoadRangeAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RulesRoadRangeAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RulesRoadRangeAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::rules::properties::RulesPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RulesRoadRangeAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RulesRoadRangeAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RulesRoadRangeAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RulesRoadRangeAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RulesRoadRangeAttributeMetadata::initPackingContext(RulesRoadRangeAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RulesRoadRangeAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeMetadata::bitSizeOf(RulesRoadRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesRoadRangeAttributeMetadata::initializeOffsets(RulesRoadRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RulesRoadRangeAttributeMetadata::operator==(const RulesRoadRangeAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RulesRoadRangeAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RulesRoadRangeAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RulesRoadRangeAttributeMetadata::write(RulesRoadRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RulesRoadRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesRoadRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesRoadRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::nds::rules::properties::RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesRoadRangeAttributeMetadata::ZserioArrayType_availableAttributes RulesRoadRangeAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RulesRoadRangeAttributeMetadata::ZserioArrayType_availableAttributes RulesRoadRangeAttributeMetadata::readAvailableAttributes(RulesRoadRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RulesRoadRangeAttributeMetadata::ZserioArrayType_availableProperties RulesRoadRangeAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RulesRoadRangeAttributeMetadata::ZserioArrayType_availableProperties RulesRoadRangeAttributeMetadata::readAvailableProperties(RulesRoadRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RulesRoadRangeAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RulesRoadRangeAttributeMetadata::readAvailableConditions(RulesRoadRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadPositionAttributeMetadata.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadPositionAttributeMetadata::RulesRoadPositionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RulesRoadPositionAttributeMetadata::RulesRoadPositionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RulesRoadPositionAttributeMetadata::RulesRoadPositionAttributeMetadata(RulesRoadPositionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RulesRoadPositionAttributeMetadata::RulesRoadPositionAttributeMetadata(::zserio::PropagateAllocatorT,
        const RulesRoadPositionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::rules::attributes::RulesRoadPositionAttributeType>& RulesRoadPositionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesRoadPositionAttributeType>& RulesRoadPositionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RulesRoadPositionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::rules::attributes::RulesRoadPositionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RulesRoadPositionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::rules::attributes::RulesRoadPositionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesRoadPositionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesRoadPositionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RulesRoadPositionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RulesRoadPositionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::rules::properties::RulesPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RulesRoadPositionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RulesRoadPositionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RulesRoadPositionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RulesRoadPositionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RulesRoadPositionAttributeMetadata::initPackingContext(RulesRoadPositionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RulesRoadPositionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeMetadata::bitSizeOf(RulesRoadPositionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesRoadPositionAttributeMetadata::initializeOffsets(RulesRoadPositionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RulesRoadPositionAttributeMetadata::operator==(const RulesRoadPositionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RulesRoadPositionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RulesRoadPositionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RulesRoadPositionAttributeMetadata::write(RulesRoadPositionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RulesRoadPositionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesRoadPositionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadPositionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesRoadPositionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::nds::rules::properties::RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesRoadPositionAttributeMetadata::ZserioArrayType_availableAttributes RulesRoadPositionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RulesRoadPositionAttributeMetadata::ZserioArrayType_availableAttributes RulesRoadPositionAttributeMetadata::readAvailableAttributes(RulesRoadPositionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RulesRoadPositionAttributeMetadata::ZserioArrayType_availableProperties RulesRoadPositionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RulesRoadPositionAttributeMetadata::ZserioArrayType_availableProperties RulesRoadPositionAttributeMetadata::readAvailableProperties(RulesRoadPositionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RulesRoadPositionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RulesRoadPositionAttributeMetadata::readAvailableConditions(RulesRoadPositionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneRangeAttributeMetadata.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneRangeAttributeMetadata::RulesLaneRangeAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RulesLaneRangeAttributeMetadata::RulesLaneRangeAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RulesLaneRangeAttributeMetadata::RulesLaneRangeAttributeMetadata(RulesLaneRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RulesLaneRangeAttributeMetadata::RulesLaneRangeAttributeMetadata(::zserio::PropagateAllocatorT,
        const RulesLaneRangeAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::rules::attributes::RulesLaneRangeAttributeType>& RulesLaneRangeAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesLaneRangeAttributeType>& RulesLaneRangeAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RulesLaneRangeAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::rules::attributes::RulesLaneRangeAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RulesLaneRangeAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::rules::attributes::RulesLaneRangeAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesLaneRangeAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesLaneRangeAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RulesLaneRangeAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RulesLaneRangeAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::rules::properties::RulesPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RulesLaneRangeAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RulesLaneRangeAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RulesLaneRangeAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RulesLaneRangeAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RulesLaneRangeAttributeMetadata::initPackingContext(RulesLaneRangeAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RulesLaneRangeAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeMetadata::bitSizeOf(RulesLaneRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesLaneRangeAttributeMetadata::initializeOffsets(RulesLaneRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RulesLaneRangeAttributeMetadata::operator==(const RulesLaneRangeAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RulesLaneRangeAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RulesLaneRangeAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RulesLaneRangeAttributeMetadata::write(RulesLaneRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RulesLaneRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesLaneRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesLaneRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::nds::rules::properties::RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesLaneRangeAttributeMetadata::ZserioArrayType_availableAttributes RulesLaneRangeAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RulesLaneRangeAttributeMetadata::ZserioArrayType_availableAttributes RulesLaneRangeAttributeMetadata::readAvailableAttributes(RulesLaneRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RulesLaneRangeAttributeMetadata::ZserioArrayType_availableProperties RulesLaneRangeAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RulesLaneRangeAttributeMetadata::ZserioArrayType_availableProperties RulesLaneRangeAttributeMetadata::readAvailableProperties(RulesLaneRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RulesLaneRangeAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RulesLaneRangeAttributeMetadata::readAvailableConditions(RulesLaneRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLanePositionAttributeMetadata.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLanePositionAttributeMetadata::RulesLanePositionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RulesLanePositionAttributeMetadata::RulesLanePositionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RulesLanePositionAttributeMetadata::RulesLanePositionAttributeMetadata(RulesLanePositionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RulesLanePositionAttributeMetadata::RulesLanePositionAttributeMetadata(::zserio::PropagateAllocatorT,
        const RulesLanePositionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::rules::attributes::RulesLanePositionAttributeType>& RulesLanePositionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesLanePositionAttributeType>& RulesLanePositionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RulesLanePositionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::rules::attributes::RulesLanePositionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RulesLanePositionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::rules::attributes::RulesLanePositionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesLanePositionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesLanePositionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RulesLanePositionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RulesLanePositionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::rules::properties::RulesPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RulesLanePositionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RulesLanePositionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RulesLanePositionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RulesLanePositionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RulesLanePositionAttributeMetadata::initPackingContext(RulesLanePositionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RulesLanePositionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeMetadata::bitSizeOf(RulesLanePositionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesLanePositionAttributeMetadata::initializeOffsets(RulesLanePositionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RulesLanePositionAttributeMetadata::operator==(const RulesLanePositionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RulesLanePositionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RulesLanePositionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RulesLanePositionAttributeMetadata::write(RulesLanePositionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RulesLanePositionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesLanePositionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLanePositionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesLanePositionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::nds::rules::properties::RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesLanePositionAttributeMetadata::ZserioArrayType_availableAttributes RulesLanePositionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RulesLanePositionAttributeMetadata::ZserioArrayType_availableAttributes RulesLanePositionAttributeMetadata::readAvailableAttributes(RulesLanePositionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RulesLanePositionAttributeMetadata::ZserioArrayType_availableProperties RulesLanePositionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RulesLanePositionAttributeMetadata::ZserioArrayType_availableProperties RulesLanePositionAttributeMetadata::readAvailableProperties(RulesLanePositionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RulesLanePositionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RulesLanePositionAttributeMetadata::readAvailableConditions(RulesLanePositionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesTransitionAttributeMetadata.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesTransitionAttributeMetadata::RulesTransitionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RulesTransitionAttributeMetadata::RulesTransitionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RulesTransitionAttributeMetadata::RulesTransitionAttributeMetadata(RulesTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RulesTransitionAttributeMetadata::RulesTransitionAttributeMetadata(::zserio::PropagateAllocatorT,
        const RulesTransitionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::rules::attributes::RulesTransitionAttributeType>& RulesTransitionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesTransitionAttributeType>& RulesTransitionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RulesTransitionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::rules::attributes::RulesTransitionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RulesTransitionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::rules::attributes::RulesTransitionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesTransitionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesTransitionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RulesTransitionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RulesTransitionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::rules::properties::RulesPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RulesTransitionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RulesTransitionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RulesTransitionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RulesTransitionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RulesTransitionAttributeMetadata::initPackingContext(RulesTransitionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RulesTransitionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeMetadata::bitSizeOf(RulesTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesTransitionAttributeMetadata::initializeOffsets(RulesTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RulesTransitionAttributeMetadata::operator==(const RulesTransitionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RulesTransitionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RulesTransitionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RulesTransitionAttributeMetadata::write(RulesTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RulesTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::nds::rules::properties::RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesTransitionAttributeMetadata::ZserioArrayType_availableAttributes RulesTransitionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RulesTransitionAttributeMetadata::ZserioArrayType_availableAttributes RulesTransitionAttributeMetadata::readAvailableAttributes(RulesTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RulesTransitionAttributeMetadata::ZserioArrayType_availableProperties RulesTransitionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RulesTransitionAttributeMetadata::ZserioArrayType_availableProperties RulesTransitionAttributeMetadata::readAvailableProperties(RulesTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RulesTransitionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RulesTransitionAttributeMetadata::readAvailableConditions(RulesTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneTransitionAttributeMetadata.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneTransitionAttributeMetadata::RulesLaneTransitionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RulesLaneTransitionAttributeMetadata::RulesLaneTransitionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RulesLaneTransitionAttributeMetadata::RulesLaneTransitionAttributeMetadata(RulesLaneTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RulesLaneTransitionAttributeMetadata::RulesLaneTransitionAttributeMetadata(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::rules::attributes::RulesLaneTransitionAttributeType>& RulesLaneTransitionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesLaneTransitionAttributeType>& RulesLaneTransitionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RulesLaneTransitionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::rules::attributes::RulesLaneTransitionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RulesLaneTransitionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::rules::attributes::RulesLaneTransitionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesLaneTransitionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesLaneTransitionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RulesLaneTransitionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RulesLaneTransitionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::rules::properties::RulesPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RulesLaneTransitionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RulesLaneTransitionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RulesLaneTransitionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RulesLaneTransitionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RulesLaneTransitionAttributeMetadata::initPackingContext(RulesLaneTransitionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RulesLaneTransitionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeMetadata::bitSizeOf(RulesLaneTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesLaneTransitionAttributeMetadata::initializeOffsets(RulesLaneTransitionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RulesLaneTransitionAttributeMetadata::operator==(const RulesLaneTransitionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RulesLaneTransitionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RulesLaneTransitionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RulesLaneTransitionAttributeMetadata::write(RulesLaneTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RulesLaneTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesLaneTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneTransitionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesLaneTransitionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::nds::rules::properties::RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesLaneTransitionAttributeMetadata::ZserioArrayType_availableAttributes RulesLaneTransitionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RulesLaneTransitionAttributeMetadata::ZserioArrayType_availableAttributes RulesLaneTransitionAttributeMetadata::readAvailableAttributes(RulesLaneTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RulesLaneTransitionAttributeMetadata::ZserioArrayType_availableProperties RulesLaneTransitionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RulesLaneTransitionAttributeMetadata::ZserioArrayType_availableProperties RulesLaneTransitionAttributeMetadata::readAvailableProperties(RulesLaneTransitionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RulesLaneTransitionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RulesLaneTransitionAttributeMetadata::readAvailableConditions(RulesLaneTransitionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRegionAttributeMetadata.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRegionAttributeMetadata::RulesRegionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RulesRegionAttributeMetadata::RulesRegionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RulesRegionAttributeMetadata::RulesRegionAttributeMetadata(RulesRegionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RulesRegionAttributeMetadata::RulesRegionAttributeMetadata(::zserio::PropagateAllocatorT,
        const RulesRegionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::rules::attributes::RulesRegionAttributeType>& RulesRegionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesRegionAttributeType>& RulesRegionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RulesRegionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::rules::attributes::RulesRegionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RulesRegionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::rules::attributes::RulesRegionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesRegionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesRegionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RulesRegionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RulesRegionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::rules::properties::RulesPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RulesRegionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RulesRegionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RulesRegionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RulesRegionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RulesRegionAttributeMetadata::initPackingContext(RulesRegionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RulesRegionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeMetadata::bitSizeOf(RulesRegionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesRegionAttributeMetadata::initializeOffsets(RulesRegionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RulesRegionAttributeMetadata::operator==(const RulesRegionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RulesRegionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RulesRegionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RulesRegionAttributeMetadata::write(RulesRegionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RulesRegionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesRegionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRegionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesRegionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::nds::rules::properties::RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesRegionAttributeMetadata::ZserioArrayType_availableAttributes RulesRegionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RulesRegionAttributeMetadata::ZserioArrayType_availableAttributes RulesRegionAttributeMetadata::readAvailableAttributes(RulesRegionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RulesRegionAttributeMetadata::ZserioArrayType_availableProperties RulesRegionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RulesRegionAttributeMetadata::ZserioArrayType_availableProperties RulesRegionAttributeMetadata::readAvailableProperties(RulesRegionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RulesRegionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RulesRegionAttributeMetadata::readAvailableConditions(RulesRegionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLineRangeAttributeMetadata.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLineRangeAttributeMetadata::RulesDisplayLineRangeAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RulesDisplayLineRangeAttributeMetadata::RulesDisplayLineRangeAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RulesDisplayLineRangeAttributeMetadata::RulesDisplayLineRangeAttributeMetadata(RulesDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RulesDisplayLineRangeAttributeMetadata::RulesDisplayLineRangeAttributeMetadata(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>& RulesDisplayLineRangeAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>& RulesDisplayLineRangeAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RulesDisplayLineRangeAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RulesDisplayLineRangeAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesDisplayLineRangeAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesDisplayLineRangeAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RulesDisplayLineRangeAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RulesDisplayLineRangeAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::rules::properties::RulesPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RulesDisplayLineRangeAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RulesDisplayLineRangeAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RulesDisplayLineRangeAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RulesDisplayLineRangeAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RulesDisplayLineRangeAttributeMetadata::initPackingContext(RulesDisplayLineRangeAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RulesDisplayLineRangeAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeMetadata::bitSizeOf(RulesDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLineRangeAttributeMetadata::initializeOffsets(RulesDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLineRangeAttributeMetadata::operator==(const RulesDisplayLineRangeAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RulesDisplayLineRangeAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RulesDisplayLineRangeAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RulesDisplayLineRangeAttributeMetadata::write(RulesDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RulesDisplayLineRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesDisplayLineRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesDisplayLineRangeAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::nds::rules::properties::RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesDisplayLineRangeAttributeMetadata::ZserioArrayType_availableAttributes RulesDisplayLineRangeAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RulesDisplayLineRangeAttributeMetadata::ZserioArrayType_availableAttributes RulesDisplayLineRangeAttributeMetadata::readAvailableAttributes(RulesDisplayLineRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RulesDisplayLineRangeAttributeMetadata::ZserioArrayType_availableProperties RulesDisplayLineRangeAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RulesDisplayLineRangeAttributeMetadata::ZserioArrayType_availableProperties RulesDisplayLineRangeAttributeMetadata::readAvailableProperties(RulesDisplayLineRangeAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RulesDisplayLineRangeAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RulesDisplayLineRangeAttributeMetadata::readAvailableConditions(RulesDisplayLineRangeAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLinePositionAttributeMetadata.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLinePositionAttributeMetadata::RulesDisplayLinePositionAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

RulesDisplayLinePositionAttributeMetadata::RulesDisplayLinePositionAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

RulesDisplayLinePositionAttributeMetadata::RulesDisplayLinePositionAttributeMetadata(RulesDisplayLinePositionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

RulesDisplayLinePositionAttributeMetadata::RulesDisplayLinePositionAttributeMetadata(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>& RulesDisplayLinePositionAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>& RulesDisplayLinePositionAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void RulesDisplayLinePositionAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void RulesDisplayLinePositionAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesDisplayLinePositionAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& RulesDisplayLinePositionAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void RulesDisplayLinePositionAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::rules::properties::RulesPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void RulesDisplayLinePositionAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::rules::properties::RulesPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& RulesDisplayLinePositionAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& RulesDisplayLinePositionAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void RulesDisplayLinePositionAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void RulesDisplayLinePositionAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void RulesDisplayLinePositionAttributeMetadata::initPackingContext(RulesDisplayLinePositionAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t RulesDisplayLinePositionAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeMetadata::bitSizeOf(RulesDisplayLinePositionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLinePositionAttributeMetadata::initializeOffsets(RulesDisplayLinePositionAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLinePositionAttributeMetadata::operator==(const RulesDisplayLinePositionAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t RulesDisplayLinePositionAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void RulesDisplayLinePositionAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void RulesDisplayLinePositionAttributeMetadata::write(RulesDisplayLinePositionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void RulesDisplayLinePositionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesDisplayLinePositionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeMetadata::ZserioElementFactory_availableProperties::create(RulesDisplayLinePositionAttributeMetadata&        ,
        ::zserio::vector<::nds::rules::properties::RulesPropertyType>& array,
        ::nds::rules::properties::RulesPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesDisplayLinePositionAttributeMetadata::ZserioArrayType_availableAttributes RulesDisplayLinePositionAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

RulesDisplayLinePositionAttributeMetadata::ZserioArrayType_availableAttributes RulesDisplayLinePositionAttributeMetadata::readAvailableAttributes(RulesDisplayLinePositionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RulesDisplayLinePositionAttributeMetadata::ZserioArrayType_availableProperties RulesDisplayLinePositionAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RulesDisplayLinePositionAttributeMetadata::ZserioArrayType_availableProperties RulesDisplayLinePositionAttributeMetadata::readAvailableProperties(RulesDisplayLinePositionAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection RulesDisplayLinePositionAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection RulesDisplayLinePositionAttributeMetadata::readAvailableConditions(RulesDisplayLinePositionAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadRangeAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadRangeAttributeMapList::RulesRoadRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesRoadRangeAttributeMapList::RulesRoadRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesRoadRangeAttributeMapList::RulesRoadRangeAttributeMapList(RulesRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesRoadRangeAttributeMapList::RulesRoadRangeAttributeMapList(const RulesRoadRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeMapList& RulesRoadRangeAttributeMapList::operator=(const RulesRoadRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeMapList::RulesRoadRangeAttributeMapList(RulesRoadRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeMapList& RulesRoadRangeAttributeMapList::operator=(RulesRoadRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeMapList::RulesRoadRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesRoadRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRoadRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesRoadRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader& RulesRoadRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader& RulesRoadRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesRoadRangeAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesRoadRangeAttributeMapList::setHeader(::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeMap>& RulesRoadRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeMap>& RulesRoadRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesRoadRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesRoadRangeAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesRoadRangeAttributeMapList::initPackingContext(RulesRoadRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesRoadRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeMapList::bitSizeOf(RulesRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadRangeAttributeMapList::initializeOffsets(RulesRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadRangeAttributeMapList::operator==(const RulesRoadRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesRoadRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesRoadRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRoadRangeAttributeMapList::write(RulesRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRoadRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesRoadRangeAttributeMapList& owner,
        ::nds::rules::instantiations::RulesRoadRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadRangeAttributeMapList::ZserioElementFactory_maps::create(RulesRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadRangeAttributeMapList::ZserioElementFactory_maps::create(RulesRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeMap>& array,
        ::nds::rules::instantiations::RulesRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRoadRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadRangeAttributeMapList::readNumMaps(RulesRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader RulesRoadRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader RulesRoadRangeAttributeMapList::readHeader(RulesRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesRoadRangeAttributeMapList::ZserioArrayType_maps RulesRoadRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRoadRangeAttributeMapList::ZserioArrayType_maps RulesRoadRangeAttributeMapList::readMaps(RulesRoadRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectRoadRangeAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectRoadRangeAttributeMapList::RulesIndirectRoadRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesIndirectRoadRangeAttributeMapList::RulesIndirectRoadRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesIndirectRoadRangeAttributeMapList::RulesIndirectRoadRangeAttributeMapList(RulesIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesIndirectRoadRangeAttributeMapList::RulesIndirectRoadRangeAttributeMapList(const RulesIndirectRoadRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadRangeAttributeMapList& RulesIndirectRoadRangeAttributeMapList::operator=(const RulesIndirectRoadRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadRangeAttributeMapList::RulesIndirectRoadRangeAttributeMapList(RulesIndirectRoadRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadRangeAttributeMapList& RulesIndirectRoadRangeAttributeMapList::operator=(RulesIndirectRoadRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadRangeAttributeMapList::RulesIndirectRoadRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesIndirectRoadRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectRoadRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectRoadRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectRoadRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectRoadRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectRoadRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesIndirectRoadRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesIndirectRoadRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader& RulesIndirectRoadRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader& RulesIndirectRoadRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesIndirectRoadRangeAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesIndirectRoadRangeAttributeMapList::setHeader(::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeMap>& RulesIndirectRoadRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeMap>& RulesIndirectRoadRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesIndirectRoadRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesIndirectRoadRangeAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesIndirectRoadRangeAttributeMapList::initPackingContext(RulesIndirectRoadRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesIndirectRoadRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadRangeAttributeMapList::bitSizeOf(RulesIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectRoadRangeAttributeMapList::initializeOffsets(RulesIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectRoadRangeAttributeMapList::operator==(const RulesIndirectRoadRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesIndirectRoadRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesIndirectRoadRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesIndirectRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesIndirectRoadRangeAttributeMapList::write(RulesIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesIndirectRoadRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesIndirectRoadRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesIndirectRoadRangeAttributeMapList& owner,
        ::nds::rules::instantiations::RulesIndirectRoadRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectRoadRangeAttributeMapList::ZserioElementFactory_maps::create(RulesIndirectRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMapList::ZserioElementFactory_maps::create(RulesIndirectRoadRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeMap>& array,
        ::nds::rules::instantiations::RulesIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesIndirectRoadRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesIndirectRoadRangeAttributeMapList::readNumMaps(RulesIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader RulesIndirectRoadRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader RulesIndirectRoadRangeAttributeMapList::readHeader(RulesIndirectRoadRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesIndirectRoadRangeAttributeMapList::ZserioArrayType_maps RulesIndirectRoadRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesIndirectRoadRangeAttributeMapList::ZserioArrayType_maps RulesIndirectRoadRangeAttributeMapList::readMaps(RulesIndirectRoadRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadLocationRangeAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadLocationRangeAttributeMapList::RulesRoadLocationRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesRoadLocationRangeAttributeMapList::RulesRoadLocationRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesRoadLocationRangeAttributeMapList::RulesRoadLocationRangeAttributeMapList(RulesRoadLocationRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesRoadLocationRangeAttributeMapList::RulesRoadLocationRangeAttributeMapList(const RulesRoadLocationRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationRangeAttributeMapList& RulesRoadLocationRangeAttributeMapList::operator=(const RulesRoadLocationRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationRangeAttributeMapList::RulesRoadLocationRangeAttributeMapList(RulesRoadLocationRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationRangeAttributeMapList& RulesRoadLocationRangeAttributeMapList::operator=(RulesRoadLocationRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationRangeAttributeMapList::RulesRoadLocationRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesRoadLocationRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadLocationRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadLocationRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadLocationRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadLocationRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadLocationRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRoadLocationRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesRoadLocationRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader& RulesRoadLocationRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader& RulesRoadLocationRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesRoadLocationRangeAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesRoadLocationRangeAttributeMapList::setHeader(::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeMap>& RulesRoadLocationRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeMap>& RulesRoadLocationRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesRoadLocationRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesRoadLocationRangeAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesRoadLocationRangeAttributeMapList::initPackingContext(RulesRoadLocationRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesRoadLocationRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationRangeAttributeMapList::bitSizeOf(RulesRoadLocationRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadLocationRangeAttributeMapList::initializeOffsets(RulesRoadLocationRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadLocationRangeAttributeMapList::operator==(const RulesRoadLocationRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesRoadLocationRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesRoadLocationRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRoadLocationRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRoadLocationRangeAttributeMapList::write(RulesRoadLocationRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRoadLocationRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRoadLocationRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesRoadLocationRangeAttributeMapList& owner,
        ::nds::rules::instantiations::RulesRoadLocationRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadLocationRangeAttributeMapList::ZserioElementFactory_maps::create(RulesRoadLocationRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadLocationRangeAttributeMapList::ZserioElementFactory_maps::create(RulesRoadLocationRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeMap>& array,
        ::nds::rules::instantiations::RulesRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRoadLocationRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadLocationRangeAttributeMapList::readNumMaps(RulesRoadLocationRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader RulesRoadLocationRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader RulesRoadLocationRangeAttributeMapList::readHeader(RulesRoadLocationRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesRoadLocationRangeAttributeMapList::ZserioArrayType_maps RulesRoadLocationRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRoadLocationRangeAttributeMapList::ZserioArrayType_maps RulesRoadLocationRangeAttributeMapList::readMaps(RulesRoadLocationRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadPositionAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadPositionAttributeMapList::RulesRoadPositionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesRoadPositionAttributeMapList::RulesRoadPositionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesRoadPositionAttributeMapList::RulesRoadPositionAttributeMapList(RulesRoadPositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesRoadPositionAttributeMapList::RulesRoadPositionAttributeMapList(const RulesRoadPositionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeMapList& RulesRoadPositionAttributeMapList::operator=(const RulesRoadPositionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeMapList::RulesRoadPositionAttributeMapList(RulesRoadPositionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeMapList& RulesRoadPositionAttributeMapList::operator=(RulesRoadPositionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeMapList::RulesRoadPositionAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesRoadPositionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadPositionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadPositionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadPositionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadPositionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadPositionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRoadPositionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesRoadPositionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader& RulesRoadPositionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader& RulesRoadPositionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesRoadPositionAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesRoadPositionAttributeMapList::setHeader(::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeMap>& RulesRoadPositionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeMap>& RulesRoadPositionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesRoadPositionAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesRoadPositionAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesRoadPositionAttributeMapList::initPackingContext(RulesRoadPositionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesRoadPositionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeMapList::bitSizeOf(RulesRoadPositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadPositionAttributeMapList::initializeOffsets(RulesRoadPositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadPositionAttributeMapList::operator==(const RulesRoadPositionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesRoadPositionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesRoadPositionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRoadPositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRoadPositionAttributeMapList::write(RulesRoadPositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRoadPositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRoadPositionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesRoadPositionAttributeMapList& owner,
        ::nds::rules::instantiations::RulesRoadPositionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadPositionAttributeMapList::ZserioElementFactory_maps::create(RulesRoadPositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadPositionAttributeMapList::ZserioElementFactory_maps::create(RulesRoadPositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeMap>& array,
        ::nds::rules::instantiations::RulesRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRoadPositionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadPositionAttributeMapList::readNumMaps(RulesRoadPositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader RulesRoadPositionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader RulesRoadPositionAttributeMapList::readHeader(RulesRoadPositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesRoadPositionAttributeMapList::ZserioArrayType_maps RulesRoadPositionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRoadPositionAttributeMapList::ZserioArrayType_maps RulesRoadPositionAttributeMapList::readMaps(RulesRoadPositionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectRoadPositionAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectRoadPositionAttributeMapList::RulesIndirectRoadPositionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesIndirectRoadPositionAttributeMapList::RulesIndirectRoadPositionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesIndirectRoadPositionAttributeMapList::RulesIndirectRoadPositionAttributeMapList(RulesIndirectRoadPositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesIndirectRoadPositionAttributeMapList::RulesIndirectRoadPositionAttributeMapList(const RulesIndirectRoadPositionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadPositionAttributeMapList& RulesIndirectRoadPositionAttributeMapList::operator=(const RulesIndirectRoadPositionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadPositionAttributeMapList::RulesIndirectRoadPositionAttributeMapList(RulesIndirectRoadPositionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadPositionAttributeMapList& RulesIndirectRoadPositionAttributeMapList::operator=(RulesIndirectRoadPositionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadPositionAttributeMapList::RulesIndirectRoadPositionAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesIndirectRoadPositionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectRoadPositionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectRoadPositionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectRoadPositionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectRoadPositionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectRoadPositionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesIndirectRoadPositionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesIndirectRoadPositionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader& RulesIndirectRoadPositionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader& RulesIndirectRoadPositionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesIndirectRoadPositionAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesIndirectRoadPositionAttributeMapList::setHeader(::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeMap>& RulesIndirectRoadPositionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeMap>& RulesIndirectRoadPositionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesIndirectRoadPositionAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesIndirectRoadPositionAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesIndirectRoadPositionAttributeMapList::initPackingContext(RulesIndirectRoadPositionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesIndirectRoadPositionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadPositionAttributeMapList::bitSizeOf(RulesIndirectRoadPositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadPositionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectRoadPositionAttributeMapList::initializeOffsets(RulesIndirectRoadPositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectRoadPositionAttributeMapList::operator==(const RulesIndirectRoadPositionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesIndirectRoadPositionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesIndirectRoadPositionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesIndirectRoadPositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesIndirectRoadPositionAttributeMapList::write(RulesIndirectRoadPositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesIndirectRoadPositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesIndirectRoadPositionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesIndirectRoadPositionAttributeMapList& owner,
        ::nds::rules::instantiations::RulesIndirectRoadPositionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectRoadPositionAttributeMapList::ZserioElementFactory_maps::create(RulesIndirectRoadPositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMapList::ZserioElementFactory_maps::create(RulesIndirectRoadPositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeMap>& array,
        ::nds::rules::instantiations::RulesIndirectRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesIndirectRoadPositionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesIndirectRoadPositionAttributeMapList::readNumMaps(RulesIndirectRoadPositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader RulesIndirectRoadPositionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader RulesIndirectRoadPositionAttributeMapList::readHeader(RulesIndirectRoadPositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadPositionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesIndirectRoadPositionAttributeMapList::ZserioArrayType_maps RulesIndirectRoadPositionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesIndirectRoadPositionAttributeMapList::ZserioArrayType_maps RulesIndirectRoadPositionAttributeMapList::readMaps(RulesIndirectRoadPositionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneRangeAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneRangeAttributeMapList::RulesLaneRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesLaneRangeAttributeMapList::RulesLaneRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesLaneRangeAttributeMapList::RulesLaneRangeAttributeMapList(RulesLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesLaneRangeAttributeMapList::RulesLaneRangeAttributeMapList(const RulesLaneRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeMapList& RulesLaneRangeAttributeMapList::operator=(const RulesLaneRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeMapList::RulesLaneRangeAttributeMapList(RulesLaneRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeMapList& RulesLaneRangeAttributeMapList::operator=(RulesLaneRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeMapList::RulesLaneRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesLaneRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLaneRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLaneRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLaneRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesLaneRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesLaneRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader& RulesLaneRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader& RulesLaneRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesLaneRangeAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesLaneRangeAttributeMapList::setHeader(::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeMap>& RulesLaneRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeMap>& RulesLaneRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesLaneRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesLaneRangeAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesLaneRangeAttributeMapList::initPackingContext(RulesLaneRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesLaneRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeMapList::bitSizeOf(RulesLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneRangeAttributeMapList::initializeOffsets(RulesLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneRangeAttributeMapList::operator==(const RulesLaneRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesLaneRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesLaneRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesLaneRangeAttributeMapList::write(RulesLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesLaneRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesLaneRangeAttributeMapList& owner,
        ::nds::rules::instantiations::RulesLaneRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLaneRangeAttributeMapList::ZserioElementFactory_maps::create(RulesLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLaneRangeAttributeMapList::ZserioElementFactory_maps::create(RulesLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeMap>& array,
        ::nds::rules::instantiations::RulesLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesLaneRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesLaneRangeAttributeMapList::readNumMaps(RulesLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader RulesLaneRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader RulesLaneRangeAttributeMapList::readHeader(RulesLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesLaneRangeAttributeMapList::ZserioArrayType_maps RulesLaneRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesLaneRangeAttributeMapList::ZserioArrayType_maps RulesLaneRangeAttributeMapList::readMaps(RulesLaneRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectLaneRangeAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectLaneRangeAttributeMapList::RulesIndirectLaneRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesIndirectLaneRangeAttributeMapList::RulesIndirectLaneRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesIndirectLaneRangeAttributeMapList::RulesIndirectLaneRangeAttributeMapList(RulesIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesIndirectLaneRangeAttributeMapList::RulesIndirectLaneRangeAttributeMapList(const RulesIndirectLaneRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLaneRangeAttributeMapList& RulesIndirectLaneRangeAttributeMapList::operator=(const RulesIndirectLaneRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLaneRangeAttributeMapList::RulesIndirectLaneRangeAttributeMapList(RulesIndirectLaneRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLaneRangeAttributeMapList& RulesIndirectLaneRangeAttributeMapList::operator=(RulesIndirectLaneRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLaneRangeAttributeMapList::RulesIndirectLaneRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesIndirectLaneRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectLaneRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectLaneRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectLaneRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectLaneRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectLaneRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesIndirectLaneRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesIndirectLaneRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader& RulesIndirectLaneRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader& RulesIndirectLaneRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesIndirectLaneRangeAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesIndirectLaneRangeAttributeMapList::setHeader(::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeMap>& RulesIndirectLaneRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeMap>& RulesIndirectLaneRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesIndirectLaneRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesIndirectLaneRangeAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesIndirectLaneRangeAttributeMapList::initPackingContext(RulesIndirectLaneRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesIndirectLaneRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLaneRangeAttributeMapList::bitSizeOf(RulesIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLaneRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectLaneRangeAttributeMapList::initializeOffsets(RulesIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectLaneRangeAttributeMapList::operator==(const RulesIndirectLaneRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesIndirectLaneRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesIndirectLaneRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesIndirectLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesIndirectLaneRangeAttributeMapList::write(RulesIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesIndirectLaneRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesIndirectLaneRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesIndirectLaneRangeAttributeMapList& owner,
        ::nds::rules::instantiations::RulesIndirectLaneRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectLaneRangeAttributeMapList::ZserioElementFactory_maps::create(RulesIndirectLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMapList::ZserioElementFactory_maps::create(RulesIndirectLaneRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeMap>& array,
        ::nds::rules::instantiations::RulesIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesIndirectLaneRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesIndirectLaneRangeAttributeMapList::readNumMaps(RulesIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader RulesIndirectLaneRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader RulesIndirectLaneRangeAttributeMapList::readHeader(RulesIndirectLaneRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesIndirectLaneRangeAttributeMapList::ZserioArrayType_maps RulesIndirectLaneRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesIndirectLaneRangeAttributeMapList::ZserioArrayType_maps RulesIndirectLaneRangeAttributeMapList::readMaps(RulesIndirectLaneRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLanePositionAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLanePositionAttributeMapList::RulesLanePositionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesLanePositionAttributeMapList::RulesLanePositionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesLanePositionAttributeMapList::RulesLanePositionAttributeMapList(RulesLanePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesLanePositionAttributeMapList::RulesLanePositionAttributeMapList(const RulesLanePositionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeMapList& RulesLanePositionAttributeMapList::operator=(const RulesLanePositionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeMapList::RulesLanePositionAttributeMapList(RulesLanePositionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeMapList& RulesLanePositionAttributeMapList::operator=(RulesLanePositionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeMapList::RulesLanePositionAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesLanePositionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLanePositionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLanePositionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesLanePositionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLanePositionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLanePositionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesLanePositionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesLanePositionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader& RulesLanePositionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader& RulesLanePositionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesLanePositionAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesLanePositionAttributeMapList::setHeader(::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeMap>& RulesLanePositionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeMap>& RulesLanePositionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesLanePositionAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesLanePositionAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesLanePositionAttributeMapList::initPackingContext(RulesLanePositionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesLanePositionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeMapList::bitSizeOf(RulesLanePositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLanePositionAttributeMapList::initializeOffsets(RulesLanePositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLanePositionAttributeMapList::operator==(const RulesLanePositionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesLanePositionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesLanePositionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesLanePositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesLanePositionAttributeMapList::write(RulesLanePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesLanePositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesLanePositionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesLanePositionAttributeMapList& owner,
        ::nds::rules::instantiations::RulesLanePositionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLanePositionAttributeMapList::ZserioElementFactory_maps::create(RulesLanePositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLanePositionAttributeMapList::ZserioElementFactory_maps::create(RulesLanePositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeMap>& array,
        ::nds::rules::instantiations::RulesLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesLanePositionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesLanePositionAttributeMapList::readNumMaps(RulesLanePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader RulesLanePositionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader RulesLanePositionAttributeMapList::readHeader(RulesLanePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesLanePositionAttributeMapList::ZserioArrayType_maps RulesLanePositionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesLanePositionAttributeMapList::ZserioArrayType_maps RulesLanePositionAttributeMapList::readMaps(RulesLanePositionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectLanePositionAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectLanePositionAttributeMapList::RulesIndirectLanePositionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesIndirectLanePositionAttributeMapList::RulesIndirectLanePositionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesIndirectLanePositionAttributeMapList::RulesIndirectLanePositionAttributeMapList(RulesIndirectLanePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesIndirectLanePositionAttributeMapList::RulesIndirectLanePositionAttributeMapList(const RulesIndirectLanePositionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLanePositionAttributeMapList& RulesIndirectLanePositionAttributeMapList::operator=(const RulesIndirectLanePositionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLanePositionAttributeMapList::RulesIndirectLanePositionAttributeMapList(RulesIndirectLanePositionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLanePositionAttributeMapList& RulesIndirectLanePositionAttributeMapList::operator=(RulesIndirectLanePositionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLanePositionAttributeMapList::RulesIndirectLanePositionAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesIndirectLanePositionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectLanePositionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectLanePositionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectLanePositionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectLanePositionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectLanePositionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesIndirectLanePositionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesIndirectLanePositionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader& RulesIndirectLanePositionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader& RulesIndirectLanePositionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesIndirectLanePositionAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesIndirectLanePositionAttributeMapList::setHeader(::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeMap>& RulesIndirectLanePositionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeMap>& RulesIndirectLanePositionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesIndirectLanePositionAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesIndirectLanePositionAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesIndirectLanePositionAttributeMapList::initPackingContext(RulesIndirectLanePositionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesIndirectLanePositionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLanePositionAttributeMapList::bitSizeOf(RulesIndirectLanePositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLanePositionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectLanePositionAttributeMapList::initializeOffsets(RulesIndirectLanePositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectLanePositionAttributeMapList::operator==(const RulesIndirectLanePositionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesIndirectLanePositionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesIndirectLanePositionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesIndirectLanePositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesIndirectLanePositionAttributeMapList::write(RulesIndirectLanePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesIndirectLanePositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesIndirectLanePositionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesIndirectLanePositionAttributeMapList& owner,
        ::nds::rules::instantiations::RulesIndirectLanePositionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectLanePositionAttributeMapList::ZserioElementFactory_maps::create(RulesIndirectLanePositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLanePositionAttributeMapList::ZserioElementFactory_maps::create(RulesIndirectLanePositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeMap>& array,
        ::nds::rules::instantiations::RulesIndirectLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesIndirectLanePositionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesIndirectLanePositionAttributeMapList::readNumMaps(RulesIndirectLanePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader RulesIndirectLanePositionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader RulesIndirectLanePositionAttributeMapList::readHeader(RulesIndirectLanePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLanePositionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesIndirectLanePositionAttributeMapList::ZserioArrayType_maps RulesIndirectLanePositionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesIndirectLanePositionAttributeMapList::ZserioArrayType_maps RulesIndirectLanePositionAttributeMapList::readMaps(RulesIndirectLanePositionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesTransitionAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesTransitionAttributeMapList::RulesTransitionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesTransitionAttributeMapList::RulesTransitionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesTransitionAttributeMapList::RulesTransitionAttributeMapList(RulesTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesTransitionAttributeMapList::RulesTransitionAttributeMapList(const RulesTransitionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeMapList& RulesTransitionAttributeMapList::operator=(const RulesTransitionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeMapList::RulesTransitionAttributeMapList(RulesTransitionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeMapList& RulesTransitionAttributeMapList::operator=(RulesTransitionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeMapList::RulesTransitionAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesTransitionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesTransitionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesTransitionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesTransitionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesTransitionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesTransitionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesTransitionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesTransitionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesTransitionAttributeMapListHeader& RulesTransitionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesTransitionAttributeMapListHeader& RulesTransitionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesTransitionAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesTransitionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesTransitionAttributeMapList::setHeader(::nds::rules::instantiations::RulesTransitionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeMap>& RulesTransitionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeMap>& RulesTransitionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesTransitionAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesTransitionAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesTransitionAttributeMapList::initPackingContext(RulesTransitionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesTransitionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeMapList::bitSizeOf(RulesTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesTransitionAttributeMapList::initializeOffsets(RulesTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesTransitionAttributeMapList::operator==(const RulesTransitionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesTransitionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesTransitionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesTransitionAttributeMapList::write(RulesTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesTransitionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesTransitionAttributeMapList& owner,
        ::nds::rules::instantiations::RulesTransitionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesTransitionAttributeMapList::ZserioElementFactory_maps::create(RulesTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesTransitionAttributeMapList::ZserioElementFactory_maps::create(RulesTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeMap>& array,
        ::nds::rules::instantiations::RulesTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesTransitionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesTransitionAttributeMapList::readNumMaps(RulesTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesTransitionAttributeMapListHeader RulesTransitionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesTransitionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesTransitionAttributeMapListHeader RulesTransitionAttributeMapList::readHeader(RulesTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesTransitionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesTransitionAttributeMapList::ZserioArrayType_maps RulesTransitionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesTransitionAttributeMapList::ZserioArrayType_maps RulesTransitionAttributeMapList::readMaps(RulesTransitionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadLocationTransitionAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadLocationTransitionAttributeMapList::RulesRoadLocationTransitionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesRoadLocationTransitionAttributeMapList::RulesRoadLocationTransitionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesRoadLocationTransitionAttributeMapList::RulesRoadLocationTransitionAttributeMapList(RulesRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesRoadLocationTransitionAttributeMapList::RulesRoadLocationTransitionAttributeMapList(const RulesRoadLocationTransitionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationTransitionAttributeMapList& RulesRoadLocationTransitionAttributeMapList::operator=(const RulesRoadLocationTransitionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationTransitionAttributeMapList::RulesRoadLocationTransitionAttributeMapList(RulesRoadLocationTransitionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationTransitionAttributeMapList& RulesRoadLocationTransitionAttributeMapList::operator=(RulesRoadLocationTransitionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationTransitionAttributeMapList::RulesRoadLocationTransitionAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesRoadLocationTransitionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadLocationTransitionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadLocationTransitionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadLocationTransitionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadLocationTransitionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadLocationTransitionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRoadLocationTransitionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesRoadLocationTransitionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesTransitionAttributeMapListHeader& RulesRoadLocationTransitionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesTransitionAttributeMapListHeader& RulesRoadLocationTransitionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesRoadLocationTransitionAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesTransitionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesRoadLocationTransitionAttributeMapList::setHeader(::nds::rules::instantiations::RulesTransitionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeMap>& RulesRoadLocationTransitionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeMap>& RulesRoadLocationTransitionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesRoadLocationTransitionAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesRoadLocationTransitionAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesRoadLocationTransitionAttributeMapList::initPackingContext(RulesRoadLocationTransitionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesRoadLocationTransitionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationTransitionAttributeMapList::bitSizeOf(RulesRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationTransitionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadLocationTransitionAttributeMapList::initializeOffsets(RulesRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadLocationTransitionAttributeMapList::operator==(const RulesRoadLocationTransitionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesRoadLocationTransitionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesRoadLocationTransitionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRoadLocationTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRoadLocationTransitionAttributeMapList::write(RulesRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRoadLocationTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRoadLocationTransitionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesRoadLocationTransitionAttributeMapList& owner,
        ::nds::rules::instantiations::RulesRoadLocationTransitionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadLocationTransitionAttributeMapList::ZserioElementFactory_maps::create(RulesRoadLocationTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadLocationTransitionAttributeMapList::ZserioElementFactory_maps::create(RulesRoadLocationTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeMap>& array,
        ::nds::rules::instantiations::RulesRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRoadLocationTransitionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadLocationTransitionAttributeMapList::readNumMaps(RulesRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesTransitionAttributeMapListHeader RulesRoadLocationTransitionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesTransitionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesTransitionAttributeMapListHeader RulesRoadLocationTransitionAttributeMapList::readHeader(RulesRoadLocationTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesTransitionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesRoadLocationTransitionAttributeMapList::ZserioArrayType_maps RulesRoadLocationTransitionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRoadLocationTransitionAttributeMapList::ZserioArrayType_maps RulesRoadLocationTransitionAttributeMapList::readMaps(RulesRoadLocationTransitionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneTransitionAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneTransitionAttributeMapList::RulesLaneTransitionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesLaneTransitionAttributeMapList::RulesLaneTransitionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesLaneTransitionAttributeMapList::RulesLaneTransitionAttributeMapList(RulesLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesLaneTransitionAttributeMapList::RulesLaneTransitionAttributeMapList(const RulesLaneTransitionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeMapList& RulesLaneTransitionAttributeMapList::operator=(const RulesLaneTransitionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeMapList::RulesLaneTransitionAttributeMapList(RulesLaneTransitionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeMapList& RulesLaneTransitionAttributeMapList::operator=(RulesLaneTransitionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeMapList::RulesLaneTransitionAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLaneTransitionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneTransitionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneTransitionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLaneTransitionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLaneTransitionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesLaneTransitionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesLaneTransitionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesLaneTransitionAttributeMapListHeader& RulesLaneTransitionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesLaneTransitionAttributeMapListHeader& RulesLaneTransitionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesLaneTransitionAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesLaneTransitionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesLaneTransitionAttributeMapList::setHeader(::nds::rules::instantiations::RulesLaneTransitionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeMap>& RulesLaneTransitionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeMap>& RulesLaneTransitionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesLaneTransitionAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesLaneTransitionAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesLaneTransitionAttributeMapList::initPackingContext(RulesLaneTransitionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesLaneTransitionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeMapList::bitSizeOf(RulesLaneTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneTransitionAttributeMapList::initializeOffsets(RulesLaneTransitionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneTransitionAttributeMapList::operator==(const RulesLaneTransitionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesLaneTransitionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesLaneTransitionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesLaneTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeMapList::write(RulesLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesLaneTransitionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesLaneTransitionAttributeMapList& owner,
        ::nds::rules::instantiations::RulesLaneTransitionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLaneTransitionAttributeMapList::ZserioElementFactory_maps::create(RulesLaneTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLaneTransitionAttributeMapList::ZserioElementFactory_maps::create(RulesLaneTransitionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeMap>& array,
        ::nds::rules::instantiations::RulesLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesLaneTransitionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesLaneTransitionAttributeMapList::readNumMaps(RulesLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesLaneTransitionAttributeMapListHeader RulesLaneTransitionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneTransitionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesLaneTransitionAttributeMapListHeader RulesLaneTransitionAttributeMapList::readHeader(RulesLaneTransitionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneTransitionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesLaneTransitionAttributeMapList::ZserioArrayType_maps RulesLaneTransitionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesLaneTransitionAttributeMapList::ZserioArrayType_maps RulesLaneTransitionAttributeMapList::readMaps(RulesLaneTransitionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRegionAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRegionAttributeMapList::RulesRegionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesRegionAttributeMapList::RulesRegionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesRegionAttributeMapList::RulesRegionAttributeMapList(RulesRegionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesRegionAttributeMapList::RulesRegionAttributeMapList(const RulesRegionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeMapList& RulesRegionAttributeMapList::operator=(const RulesRegionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeMapList::RulesRegionAttributeMapList(RulesRegionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeMapList& RulesRegionAttributeMapList::operator=(RulesRegionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeMapList::RulesRegionAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesRegionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRegionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRegionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRegionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRegionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRegionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRegionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesRegionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesRegionAttributeMapListHeader& RulesRegionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesRegionAttributeMapListHeader& RulesRegionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesRegionAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesRegionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesRegionAttributeMapList::setHeader(::nds::rules::instantiations::RulesRegionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeMap>& RulesRegionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeMap>& RulesRegionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesRegionAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesRegionAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesRegionAttributeMapList::initPackingContext(RulesRegionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesRegionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeMapList::bitSizeOf(RulesRegionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRegionAttributeMapList::initializeOffsets(RulesRegionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRegionAttributeMapList::operator==(const RulesRegionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesRegionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesRegionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRegionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRegionAttributeMapList::write(RulesRegionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesRegionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesRegionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesRegionAttributeMapList& owner,
        ::nds::rules::instantiations::RulesRegionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRegionAttributeMapList::ZserioElementFactory_maps::create(RulesRegionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRegionAttributeMapList::ZserioElementFactory_maps::create(RulesRegionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeMap>& array,
        ::nds::rules::instantiations::RulesRegionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRegionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRegionAttributeMapList::readNumMaps(RulesRegionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesRegionAttributeMapListHeader RulesRegionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRegionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesRegionAttributeMapListHeader RulesRegionAttributeMapList::readHeader(RulesRegionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRegionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesRegionAttributeMapList::ZserioArrayType_maps RulesRegionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRegionAttributeMapList::ZserioArrayType_maps RulesRegionAttributeMapList::readMaps(RulesRegionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLineRangeAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLineRangeAttributeMapList::RulesDisplayLineRangeAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesDisplayLineRangeAttributeMapList::RulesDisplayLineRangeAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesDisplayLineRangeAttributeMapList::RulesDisplayLineRangeAttributeMapList(RulesDisplayLineRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesDisplayLineRangeAttributeMapList::RulesDisplayLineRangeAttributeMapList(const RulesDisplayLineRangeAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeMapList& RulesDisplayLineRangeAttributeMapList::operator=(const RulesDisplayLineRangeAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeMapList::RulesDisplayLineRangeAttributeMapList(RulesDisplayLineRangeAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeMapList& RulesDisplayLineRangeAttributeMapList::operator=(RulesDisplayLineRangeAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeMapList::RulesDisplayLineRangeAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesDisplayLineRangeAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLineRangeAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLineRangeAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesDisplayLineRangeAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesDisplayLineRangeAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesDisplayLineRangeAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesDisplayLineRangeAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesDisplayLineRangeAttributeMapListHeader& RulesDisplayLineRangeAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesDisplayLineRangeAttributeMapListHeader& RulesDisplayLineRangeAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesDisplayLineRangeAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesDisplayLineRangeAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesDisplayLineRangeAttributeMapList::setHeader(::nds::rules::instantiations::RulesDisplayLineRangeAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeMap>& RulesDisplayLineRangeAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeMap>& RulesDisplayLineRangeAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesDisplayLineRangeAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesDisplayLineRangeAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesDisplayLineRangeAttributeMapList::initPackingContext(RulesDisplayLineRangeAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesDisplayLineRangeAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeMapList::bitSizeOf(RulesDisplayLineRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLineRangeAttributeMapList::initializeOffsets(RulesDisplayLineRangeAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLineRangeAttributeMapList::operator==(const RulesDisplayLineRangeAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesDisplayLineRangeAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesDisplayLineRangeAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesDisplayLineRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeMapList::write(RulesDisplayLineRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesDisplayLineRangeAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesDisplayLineRangeAttributeMapList& owner,
        ::nds::rules::instantiations::RulesDisplayLineRangeAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesDisplayLineRangeAttributeMapList::ZserioElementFactory_maps::create(RulesDisplayLineRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLineRangeAttributeMapList::ZserioElementFactory_maps::create(RulesDisplayLineRangeAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeMap>& array,
        ::nds::rules::instantiations::RulesDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesDisplayLineRangeAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesDisplayLineRangeAttributeMapList::readNumMaps(RulesDisplayLineRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesDisplayLineRangeAttributeMapListHeader RulesDisplayLineRangeAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesDisplayLineRangeAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesDisplayLineRangeAttributeMapListHeader RulesDisplayLineRangeAttributeMapList::readHeader(RulesDisplayLineRangeAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesDisplayLineRangeAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesDisplayLineRangeAttributeMapList::ZserioArrayType_maps RulesDisplayLineRangeAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesDisplayLineRangeAttributeMapList::ZserioArrayType_maps RulesDisplayLineRangeAttributeMapList::readMaps(RulesDisplayLineRangeAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLinePositionAttributeMapList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLinePositionAttributeMapList::RulesDisplayLinePositionAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

RulesDisplayLinePositionAttributeMapList::RulesDisplayLinePositionAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

RulesDisplayLinePositionAttributeMapList::RulesDisplayLinePositionAttributeMapList(RulesDisplayLinePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

RulesDisplayLinePositionAttributeMapList::RulesDisplayLinePositionAttributeMapList(const RulesDisplayLinePositionAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeMapList& RulesDisplayLinePositionAttributeMapList::operator=(const RulesDisplayLinePositionAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeMapList::RulesDisplayLinePositionAttributeMapList(RulesDisplayLinePositionAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeMapList& RulesDisplayLinePositionAttributeMapList::operator=(RulesDisplayLinePositionAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeMapList::RulesDisplayLinePositionAttributeMapList(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesDisplayLinePositionAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLinePositionAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLinePositionAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesDisplayLinePositionAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesDisplayLinePositionAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesDisplayLinePositionAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void RulesDisplayLinePositionAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::rules::instantiations::RulesDisplayLinePositionAttributeMapListHeader& RulesDisplayLinePositionAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::rules::instantiations::RulesDisplayLinePositionAttributeMapListHeader& RulesDisplayLinePositionAttributeMapList::getHeader() const
{
    return m_header_;
}

void RulesDisplayLinePositionAttributeMapList::setHeader(const ::nds::rules::instantiations::RulesDisplayLinePositionAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void RulesDisplayLinePositionAttributeMapList::setHeader(::nds::rules::instantiations::RulesDisplayLinePositionAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeMap>& RulesDisplayLinePositionAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeMap>& RulesDisplayLinePositionAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void RulesDisplayLinePositionAttributeMapList::setMaps(const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void RulesDisplayLinePositionAttributeMapList::setMaps(::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void RulesDisplayLinePositionAttributeMapList::initPackingContext(RulesDisplayLinePositionAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t RulesDisplayLinePositionAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeMapList::bitSizeOf(RulesDisplayLinePositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLinePositionAttributeMapList::initializeOffsets(RulesDisplayLinePositionAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLinePositionAttributeMapList::operator==(const RulesDisplayLinePositionAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t RulesDisplayLinePositionAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void RulesDisplayLinePositionAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesDisplayLinePositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeMapList::write(RulesDisplayLinePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field RulesDisplayLinePositionAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeMapList::ZserioArrayExpressions_maps::initializeElement(RulesDisplayLinePositionAttributeMapList& owner,
        ::nds::rules::instantiations::RulesDisplayLinePositionAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesDisplayLinePositionAttributeMapList::ZserioElementFactory_maps::create(RulesDisplayLinePositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLinePositionAttributeMapList::ZserioElementFactory_maps::create(RulesDisplayLinePositionAttributeMapList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeMap>& array,
        ::nds::rules::instantiations::RulesDisplayLinePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesDisplayLinePositionAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesDisplayLinePositionAttributeMapList::readNumMaps(RulesDisplayLinePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::rules::instantiations::RulesDisplayLinePositionAttributeMapListHeader RulesDisplayLinePositionAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesDisplayLinePositionAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::rules::instantiations::RulesDisplayLinePositionAttributeMapListHeader RulesDisplayLinePositionAttributeMapList::readHeader(RulesDisplayLinePositionAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesDisplayLinePositionAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
RulesDisplayLinePositionAttributeMapList::ZserioArrayType_maps RulesDisplayLinePositionAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesDisplayLinePositionAttributeMapList::ZserioArrayType_maps RulesDisplayLinePositionAttributeMapList::readMaps(RulesDisplayLinePositionAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadRangeAttributeMapListHeader.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadRangeAttributeMapListHeader::RulesRoadRangeAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RulesRoadRangeAttributeMapListHeader::RulesRoadRangeAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RulesRoadRangeAttributeMapListHeader::RulesRoadRangeAttributeMapListHeader(RulesRoadRangeAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RulesRoadRangeAttributeMapListHeader::RulesRoadRangeAttributeMapListHeader(const RulesRoadRangeAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeMapListHeader& RulesRoadRangeAttributeMapListHeader::operator=(const RulesRoadRangeAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeMapListHeader::RulesRoadRangeAttributeMapListHeader(RulesRoadRangeAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeMapListHeader& RulesRoadRangeAttributeMapListHeader::operator=(RulesRoadRangeAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeMapListHeader::RulesRoadRangeAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RulesRoadRangeAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RulesRoadRangeAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RulesRoadRangeAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RulesRoadRangeAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RulesRoadRangeAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::rules::attributes::RulesRoadRangeAttributeType>& RulesRoadRangeAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesRoadRangeAttributeType>& RulesRoadRangeAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RulesRoadRangeAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::rules::attributes::RulesRoadRangeAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RulesRoadRangeAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::rules::attributes::RulesRoadRangeAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesRoadRangeAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesRoadRangeAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RulesRoadRangeAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RulesRoadRangeAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RulesRoadRangeAttributeMapListHeader::initPackingContext(RulesRoadRangeAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RulesRoadRangeAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeMapListHeader::bitSizeOf(RulesRoadRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadRangeAttributeMapListHeader::initializeOffsets(RulesRoadRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadRangeAttributeMapListHeader::operator==(const RulesRoadRangeAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RulesRoadRangeAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RulesRoadRangeAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesRoadRangeAttributeMapListHeader::write(RulesRoadRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesRoadRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesRoadRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesRoadRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesRoadRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesRoadRangeAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRoadRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesRoadRangeAttributeMapListHeader::readAttributeTypeCode(RulesRoadRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RulesRoadRangeAttributeMapListHeader::ZserioArrayType_conditionType RulesRoadRangeAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRoadRangeAttributeMapListHeader::ZserioArrayType_conditionType RulesRoadRangeAttributeMapListHeader::readConditionType(RulesRoadRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadPositionAttributeMapListHeader.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadPositionAttributeMapListHeader::RulesRoadPositionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RulesRoadPositionAttributeMapListHeader::RulesRoadPositionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RulesRoadPositionAttributeMapListHeader::RulesRoadPositionAttributeMapListHeader(RulesRoadPositionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RulesRoadPositionAttributeMapListHeader::RulesRoadPositionAttributeMapListHeader(const RulesRoadPositionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeMapListHeader& RulesRoadPositionAttributeMapListHeader::operator=(const RulesRoadPositionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeMapListHeader::RulesRoadPositionAttributeMapListHeader(RulesRoadPositionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeMapListHeader& RulesRoadPositionAttributeMapListHeader::operator=(RulesRoadPositionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeMapListHeader::RulesRoadPositionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RulesRoadPositionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RulesRoadPositionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RulesRoadPositionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RulesRoadPositionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RulesRoadPositionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::rules::attributes::RulesRoadPositionAttributeType>& RulesRoadPositionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesRoadPositionAttributeType>& RulesRoadPositionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RulesRoadPositionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::rules::attributes::RulesRoadPositionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RulesRoadPositionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::rules::attributes::RulesRoadPositionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesRoadPositionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesRoadPositionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RulesRoadPositionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RulesRoadPositionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RulesRoadPositionAttributeMapListHeader::initPackingContext(RulesRoadPositionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RulesRoadPositionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeMapListHeader::bitSizeOf(RulesRoadPositionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadPositionAttributeMapListHeader::initializeOffsets(RulesRoadPositionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadPositionAttributeMapListHeader::operator==(const RulesRoadPositionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RulesRoadPositionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RulesRoadPositionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesRoadPositionAttributeMapListHeader::write(RulesRoadPositionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesRoadPositionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesRoadPositionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadPositionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesRoadPositionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesRoadPositionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesRoadPositionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRoadPositionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesRoadPositionAttributeMapListHeader::readAttributeTypeCode(RulesRoadPositionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RulesRoadPositionAttributeMapListHeader::ZserioArrayType_conditionType RulesRoadPositionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRoadPositionAttributeMapListHeader::ZserioArrayType_conditionType RulesRoadPositionAttributeMapListHeader::readConditionType(RulesRoadPositionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneRangeAttributeMapListHeader.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneRangeAttributeMapListHeader::RulesLaneRangeAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RulesLaneRangeAttributeMapListHeader::RulesLaneRangeAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RulesLaneRangeAttributeMapListHeader::RulesLaneRangeAttributeMapListHeader(RulesLaneRangeAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RulesLaneRangeAttributeMapListHeader::RulesLaneRangeAttributeMapListHeader(const RulesLaneRangeAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeMapListHeader& RulesLaneRangeAttributeMapListHeader::operator=(const RulesLaneRangeAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeMapListHeader::RulesLaneRangeAttributeMapListHeader(RulesLaneRangeAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeMapListHeader& RulesLaneRangeAttributeMapListHeader::operator=(RulesLaneRangeAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeMapListHeader::RulesLaneRangeAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RulesLaneRangeAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RulesLaneRangeAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RulesLaneRangeAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RulesLaneRangeAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RulesLaneRangeAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::rules::attributes::RulesLaneRangeAttributeType>& RulesLaneRangeAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesLaneRangeAttributeType>& RulesLaneRangeAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RulesLaneRangeAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::rules::attributes::RulesLaneRangeAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RulesLaneRangeAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::rules::attributes::RulesLaneRangeAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesLaneRangeAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesLaneRangeAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RulesLaneRangeAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RulesLaneRangeAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RulesLaneRangeAttributeMapListHeader::initPackingContext(RulesLaneRangeAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RulesLaneRangeAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeMapListHeader::bitSizeOf(RulesLaneRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneRangeAttributeMapListHeader::initializeOffsets(RulesLaneRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneRangeAttributeMapListHeader::operator==(const RulesLaneRangeAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RulesLaneRangeAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RulesLaneRangeAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesLaneRangeAttributeMapListHeader::write(RulesLaneRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesLaneRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesLaneRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesLaneRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesLaneRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesLaneRangeAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesLaneRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesLaneRangeAttributeMapListHeader::readAttributeTypeCode(RulesLaneRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RulesLaneRangeAttributeMapListHeader::ZserioArrayType_conditionType RulesLaneRangeAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesLaneRangeAttributeMapListHeader::ZserioArrayType_conditionType RulesLaneRangeAttributeMapListHeader::readConditionType(RulesLaneRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLanePositionAttributeMapListHeader.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLanePositionAttributeMapListHeader::RulesLanePositionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RulesLanePositionAttributeMapListHeader::RulesLanePositionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RulesLanePositionAttributeMapListHeader::RulesLanePositionAttributeMapListHeader(RulesLanePositionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RulesLanePositionAttributeMapListHeader::RulesLanePositionAttributeMapListHeader(const RulesLanePositionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeMapListHeader& RulesLanePositionAttributeMapListHeader::operator=(const RulesLanePositionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeMapListHeader::RulesLanePositionAttributeMapListHeader(RulesLanePositionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeMapListHeader& RulesLanePositionAttributeMapListHeader::operator=(RulesLanePositionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeMapListHeader::RulesLanePositionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RulesLanePositionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RulesLanePositionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RulesLanePositionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RulesLanePositionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RulesLanePositionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::rules::attributes::RulesLanePositionAttributeType>& RulesLanePositionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesLanePositionAttributeType>& RulesLanePositionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RulesLanePositionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::rules::attributes::RulesLanePositionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RulesLanePositionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::rules::attributes::RulesLanePositionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesLanePositionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesLanePositionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RulesLanePositionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RulesLanePositionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RulesLanePositionAttributeMapListHeader::initPackingContext(RulesLanePositionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RulesLanePositionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeMapListHeader::bitSizeOf(RulesLanePositionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLanePositionAttributeMapListHeader::initializeOffsets(RulesLanePositionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLanePositionAttributeMapListHeader::operator==(const RulesLanePositionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RulesLanePositionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RulesLanePositionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesLanePositionAttributeMapListHeader::write(RulesLanePositionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesLanePositionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesLanePositionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLanePositionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesLanePositionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesLanePositionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesLanePositionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesLanePositionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesLanePositionAttributeMapListHeader::readAttributeTypeCode(RulesLanePositionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RulesLanePositionAttributeMapListHeader::ZserioArrayType_conditionType RulesLanePositionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesLanePositionAttributeMapListHeader::ZserioArrayType_conditionType RulesLanePositionAttributeMapListHeader::readConditionType(RulesLanePositionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesTransitionAttributeMapListHeader.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesTransitionAttributeMapListHeader::RulesTransitionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RulesTransitionAttributeMapListHeader::RulesTransitionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RulesTransitionAttributeMapListHeader::RulesTransitionAttributeMapListHeader(RulesTransitionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RulesTransitionAttributeMapListHeader::RulesTransitionAttributeMapListHeader(const RulesTransitionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeMapListHeader& RulesTransitionAttributeMapListHeader::operator=(const RulesTransitionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeMapListHeader::RulesTransitionAttributeMapListHeader(RulesTransitionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeMapListHeader& RulesTransitionAttributeMapListHeader::operator=(RulesTransitionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeMapListHeader::RulesTransitionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RulesTransitionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RulesTransitionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RulesTransitionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RulesTransitionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RulesTransitionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::rules::attributes::RulesTransitionAttributeType>& RulesTransitionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesTransitionAttributeType>& RulesTransitionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RulesTransitionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::rules::attributes::RulesTransitionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RulesTransitionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::rules::attributes::RulesTransitionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesTransitionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesTransitionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RulesTransitionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RulesTransitionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RulesTransitionAttributeMapListHeader::initPackingContext(RulesTransitionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RulesTransitionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeMapListHeader::bitSizeOf(RulesTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesTransitionAttributeMapListHeader::initializeOffsets(RulesTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesTransitionAttributeMapListHeader::operator==(const RulesTransitionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RulesTransitionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RulesTransitionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesTransitionAttributeMapListHeader::write(RulesTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesTransitionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesTransitionAttributeMapListHeader::readAttributeTypeCode(RulesTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RulesTransitionAttributeMapListHeader::ZserioArrayType_conditionType RulesTransitionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesTransitionAttributeMapListHeader::ZserioArrayType_conditionType RulesTransitionAttributeMapListHeader::readConditionType(RulesTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneTransitionAttributeMapListHeader.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneTransitionAttributeMapListHeader::RulesLaneTransitionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RulesLaneTransitionAttributeMapListHeader::RulesLaneTransitionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RulesLaneTransitionAttributeMapListHeader::RulesLaneTransitionAttributeMapListHeader(RulesLaneTransitionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RulesLaneTransitionAttributeMapListHeader::RulesLaneTransitionAttributeMapListHeader(const RulesLaneTransitionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeMapListHeader& RulesLaneTransitionAttributeMapListHeader::operator=(const RulesLaneTransitionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeMapListHeader::RulesLaneTransitionAttributeMapListHeader(RulesLaneTransitionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeMapListHeader& RulesLaneTransitionAttributeMapListHeader::operator=(RulesLaneTransitionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeMapListHeader::RulesLaneTransitionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RulesLaneTransitionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RulesLaneTransitionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RulesLaneTransitionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RulesLaneTransitionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::rules::attributes::RulesLaneTransitionAttributeType>& RulesLaneTransitionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesLaneTransitionAttributeType>& RulesLaneTransitionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RulesLaneTransitionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::rules::attributes::RulesLaneTransitionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RulesLaneTransitionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::rules::attributes::RulesLaneTransitionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesLaneTransitionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesLaneTransitionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RulesLaneTransitionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RulesLaneTransitionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RulesLaneTransitionAttributeMapListHeader::initPackingContext(RulesLaneTransitionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RulesLaneTransitionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeMapListHeader::bitSizeOf(RulesLaneTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneTransitionAttributeMapListHeader::initializeOffsets(RulesLaneTransitionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneTransitionAttributeMapListHeader::operator==(const RulesLaneTransitionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RulesLaneTransitionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RulesLaneTransitionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeMapListHeader::write(RulesLaneTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesLaneTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneTransitionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesLaneTransitionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesLaneTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesLaneTransitionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesLaneTransitionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesLaneTransitionAttributeMapListHeader::readAttributeTypeCode(RulesLaneTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RulesLaneTransitionAttributeMapListHeader::ZserioArrayType_conditionType RulesLaneTransitionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesLaneTransitionAttributeMapListHeader::ZserioArrayType_conditionType RulesLaneTransitionAttributeMapListHeader::readConditionType(RulesLaneTransitionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRegionAttributeMapListHeader.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRegionAttributeMapListHeader::RulesRegionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RulesRegionAttributeMapListHeader::RulesRegionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RulesRegionAttributeMapListHeader::RulesRegionAttributeMapListHeader(RulesRegionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RulesRegionAttributeMapListHeader::RulesRegionAttributeMapListHeader(const RulesRegionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeMapListHeader& RulesRegionAttributeMapListHeader::operator=(const RulesRegionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeMapListHeader::RulesRegionAttributeMapListHeader(RulesRegionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeMapListHeader& RulesRegionAttributeMapListHeader::operator=(RulesRegionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeMapListHeader::RulesRegionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RulesRegionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RulesRegionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RulesRegionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RulesRegionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RulesRegionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::rules::attributes::RulesRegionAttributeType>& RulesRegionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesRegionAttributeType>& RulesRegionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RulesRegionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::rules::attributes::RulesRegionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RulesRegionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::rules::attributes::RulesRegionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesRegionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesRegionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RulesRegionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RulesRegionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RulesRegionAttributeMapListHeader::initPackingContext(RulesRegionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RulesRegionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeMapListHeader::bitSizeOf(RulesRegionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRegionAttributeMapListHeader::initializeOffsets(RulesRegionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRegionAttributeMapListHeader::operator==(const RulesRegionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RulesRegionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RulesRegionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesRegionAttributeMapListHeader::write(RulesRegionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesRegionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesRegionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRegionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesRegionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesRegionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesRegionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRegionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesRegionAttributeMapListHeader::readAttributeTypeCode(RulesRegionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RulesRegionAttributeMapListHeader::ZserioArrayType_conditionType RulesRegionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesRegionAttributeMapListHeader::ZserioArrayType_conditionType RulesRegionAttributeMapListHeader::readConditionType(RulesRegionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLineRangeAttributeMapListHeader.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLineRangeAttributeMapListHeader::RulesDisplayLineRangeAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RulesDisplayLineRangeAttributeMapListHeader::RulesDisplayLineRangeAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RulesDisplayLineRangeAttributeMapListHeader::RulesDisplayLineRangeAttributeMapListHeader(RulesDisplayLineRangeAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RulesDisplayLineRangeAttributeMapListHeader::RulesDisplayLineRangeAttributeMapListHeader(const RulesDisplayLineRangeAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeMapListHeader& RulesDisplayLineRangeAttributeMapListHeader::operator=(const RulesDisplayLineRangeAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeMapListHeader::RulesDisplayLineRangeAttributeMapListHeader(RulesDisplayLineRangeAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeMapListHeader& RulesDisplayLineRangeAttributeMapListHeader::operator=(RulesDisplayLineRangeAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeMapListHeader::RulesDisplayLineRangeAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RulesDisplayLineRangeAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RulesDisplayLineRangeAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RulesDisplayLineRangeAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RulesDisplayLineRangeAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>& RulesDisplayLineRangeAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>& RulesDisplayLineRangeAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RulesDisplayLineRangeAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RulesDisplayLineRangeAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesDisplayLineRangeAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesDisplayLineRangeAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RulesDisplayLineRangeAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RulesDisplayLineRangeAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RulesDisplayLineRangeAttributeMapListHeader::initPackingContext(RulesDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RulesDisplayLineRangeAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeMapListHeader::bitSizeOf(RulesDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLineRangeAttributeMapListHeader::initializeOffsets(RulesDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLineRangeAttributeMapListHeader::operator==(const RulesDisplayLineRangeAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RulesDisplayLineRangeAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RulesDisplayLineRangeAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeMapListHeader::write(RulesDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesDisplayLineRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesDisplayLineRangeAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesDisplayLineRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesDisplayLineRangeAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesDisplayLineRangeAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesDisplayLineRangeAttributeMapListHeader::readAttributeTypeCode(RulesDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RulesDisplayLineRangeAttributeMapListHeader::ZserioArrayType_conditionType RulesDisplayLineRangeAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesDisplayLineRangeAttributeMapListHeader::ZserioArrayType_conditionType RulesDisplayLineRangeAttributeMapListHeader::readConditionType(RulesDisplayLineRangeAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLinePositionAttributeMapListHeader.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLinePositionAttributeMapListHeader::RulesDisplayLinePositionAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

RulesDisplayLinePositionAttributeMapListHeader::RulesDisplayLinePositionAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

RulesDisplayLinePositionAttributeMapListHeader::RulesDisplayLinePositionAttributeMapListHeader(RulesDisplayLinePositionAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

RulesDisplayLinePositionAttributeMapListHeader::RulesDisplayLinePositionAttributeMapListHeader(const RulesDisplayLinePositionAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeMapListHeader& RulesDisplayLinePositionAttributeMapListHeader::operator=(const RulesDisplayLinePositionAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeMapListHeader::RulesDisplayLinePositionAttributeMapListHeader(RulesDisplayLinePositionAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeMapListHeader& RulesDisplayLinePositionAttributeMapListHeader::operator=(RulesDisplayLinePositionAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeMapListHeader::RulesDisplayLinePositionAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void RulesDisplayLinePositionAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool RulesDisplayLinePositionAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t RulesDisplayLinePositionAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'RulesDisplayLinePositionAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>& RulesDisplayLinePositionAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>& RulesDisplayLinePositionAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void RulesDisplayLinePositionAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void RulesDisplayLinePositionAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesDisplayLinePositionAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& RulesDisplayLinePositionAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void RulesDisplayLinePositionAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void RulesDisplayLinePositionAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void RulesDisplayLinePositionAttributeMapListHeader::initPackingContext(RulesDisplayLinePositionAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t RulesDisplayLinePositionAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeMapListHeader::bitSizeOf(RulesDisplayLinePositionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLinePositionAttributeMapListHeader::initializeOffsets(RulesDisplayLinePositionAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLinePositionAttributeMapListHeader::operator==(const RulesDisplayLinePositionAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t RulesDisplayLinePositionAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void RulesDisplayLinePositionAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeMapListHeader::write(RulesDisplayLinePositionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesDisplayLinePositionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeMapListHeader::ZserioElementFactory_conditionType::create(RulesDisplayLinePositionAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

RulesDisplayLinePositionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesDisplayLinePositionAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesDisplayLinePositionAttributeMapListHeader::ZserioArrayType_attributeTypeCode RulesDisplayLinePositionAttributeMapListHeader::readAttributeTypeCode(RulesDisplayLinePositionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
RulesDisplayLinePositionAttributeMapListHeader::ZserioArrayType_conditionType RulesDisplayLinePositionAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

RulesDisplayLinePositionAttributeMapListHeader::ZserioArrayType_conditionType RulesDisplayLinePositionAttributeMapListHeader::readConditionType(RulesDisplayLinePositionAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadRangeAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadRangeAttributeMap::RulesRoadRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesRoadRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesRoadRangeAttributeMap::RulesRoadRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesRoadRangeAttributeMap::RulesRoadRangeAttributeMap(RulesRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesRoadRangeAttributeMap::RulesRoadRangeAttributeMap(const RulesRoadRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeMap& RulesRoadRangeAttributeMap::operator=(const RulesRoadRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeMap::RulesRoadRangeAttributeMap(RulesRoadRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeMap& RulesRoadRangeAttributeMap::operator=(RulesRoadRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeMap::RulesRoadRangeAttributeMap(::zserio::PropagateAllocatorT,
        const RulesRoadRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesRoadRangeAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesRoadRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesRoadRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& RulesRoadRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& RulesRoadRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesRoadRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesRoadRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RulesRoadRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RulesRoadRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesRoadRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesRoadRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRoadRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRoadRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesRoadRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesRoadRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesRoadRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesRoadRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& RulesRoadRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& RulesRoadRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesRoadRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesRoadRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRoadRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRoadRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesRoadRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesRoadRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRoadRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRoadRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesRoadRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesRoadRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesRoadRangeAttributeMap::initPackingContext(RulesRoadRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesRoadRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeMap::bitSizeOf(RulesRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadRangeAttributeMap::initializeOffsets(RulesRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadRangeAttributeMap::operator==(const RulesRoadRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesRoadRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesRoadRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRoadRangeAttributeMap::write(RulesRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesRoadRangeAttributeMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesRoadRangeAttributeMap& owner,
        ::nds::rules::instantiations::RulesRoadRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(owner.getAttributeTypeCode()));
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& array,
        ::nds::rules::instantiations::RulesRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRoadRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesRoadRangeAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesRoadRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadRangeAttributeType>(in);
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadRangeAttributeMap::readAttributeTypeCode(RulesRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesRoadRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRoadRangeAttributeMap::readFeature(RulesRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadRangeAttributeMap::ZserioArrayType_featureReferences RulesRoadRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadRangeAttributeMap::ZserioArrayType_featureReferences RulesRoadRangeAttributeMap::readFeatureReferences(RulesRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadRangeAttributeMap::ZserioArrayType_featureValidities RulesRoadRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadRangeAttributeMap::ZserioArrayType_featureValidities RulesRoadRangeAttributeMap::readFeatureValidities(RulesRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadRangeAttributeMap::ZserioArrayType_featureValuePtr RulesRoadRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadRangeAttributeMap::ZserioArrayType_featureValuePtr RulesRoadRangeAttributeMap::readFeatureValuePtr(RulesRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesRoadRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesRoadRangeAttributeMap::readAttribute(RulesRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadRangeAttributeMap::ZserioArrayType_attributeValues RulesRoadRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadRangeAttributeMap::ZserioArrayType_attributeValues RulesRoadRangeAttributeMap::readAttributeValues(RulesRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRoadRangeAttributeMap::ZserioArrayType_attributeProperties RulesRoadRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadRangeAttributeMap::ZserioArrayType_attributeProperties RulesRoadRangeAttributeMap::readAttributeProperties(RulesRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRoadRangeAttributeMap::ZserioArrayType_attributeConditions RulesRoadRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadRangeAttributeMap::ZserioArrayType_attributeConditions RulesRoadRangeAttributeMap::readAttributeConditions(RulesRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectRoadRangeAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectRoadRangeAttributeMap::RulesIndirectRoadRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesRoadRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesIndirectRoadRangeAttributeMap::RulesIndirectRoadRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesIndirectRoadRangeAttributeMap::RulesIndirectRoadRangeAttributeMap(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesIndirectRoadRangeAttributeMap::RulesIndirectRoadRangeAttributeMap(const RulesIndirectRoadRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadRangeAttributeMap& RulesIndirectRoadRangeAttributeMap::operator=(const RulesIndirectRoadRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadRangeAttributeMap::RulesIndirectRoadRangeAttributeMap(RulesIndirectRoadRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadRangeAttributeMap& RulesIndirectRoadRangeAttributeMap::operator=(RulesIndirectRoadRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadRangeAttributeMap::RulesIndirectRoadRangeAttributeMap(::zserio::PropagateAllocatorT,
        const RulesIndirectRoadRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectRoadRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectRoadRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectRoadRangeAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectRoadRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectRoadRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesIndirectRoadRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesIndirectRoadRangeAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesIndirectRoadRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesIndirectRoadRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& RulesIndirectRoadRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& RulesIndirectRoadRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesIndirectRoadRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesIndirectRoadRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RulesIndirectRoadRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RulesIndirectRoadRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesIndirectRoadRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesIndirectRoadRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesIndirectRoadRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesIndirectRoadRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesIndirectRoadRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesIndirectRoadRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesIndirectRoadRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesIndirectRoadRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& RulesIndirectRoadRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& RulesIndirectRoadRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesIndirectRoadRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesIndirectRoadRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesIndirectRoadRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesIndirectRoadRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesIndirectRoadRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesIndirectRoadRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesIndirectRoadRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesIndirectRoadRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesIndirectRoadRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesIndirectRoadRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesIndirectRoadRangeAttributeMap::initPackingContext(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesIndirectRoadRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadRangeAttributeMap::bitSizeOf(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectRoadRangeAttributeMap::initializeOffsets(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectRoadRangeAttributeMap::operator==(const RulesIndirectRoadRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesIndirectRoadRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesIndirectRoadRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesIndirectRoadRangeAttributeMap::write(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesIndirectRoadRangeAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(RulesIndirectRoadRangeAttributeMap&,
        ::nds::road::reference::types::RoadReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::nds::road::reference::types::RoadReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesIndirectRoadRangeAttributeMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesIndirectRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesIndirectRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesIndirectRoadRangeAttributeMap& owner,
        ::nds::rules::instantiations::RulesRoadRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(owner.getAttributeTypeCode()));
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesIndirectRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesIndirectRoadRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& array,
        ::nds::rules::instantiations::RulesRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesIndirectRoadRangeAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesIndirectRoadRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectRoadRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesIndirectRoadRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesIndirectRoadRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadRangeAttributeType>(in);
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesIndirectRoadRangeAttributeMap::readAttributeTypeCode(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesIndirectRoadRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesIndirectRoadRangeAttributeMap::readFeature(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectRoadRangeAttributeMap::ZserioArrayType_featureReferences RulesIndirectRoadRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadRangeAttributeMap::ZserioArrayType_featureReferences RulesIndirectRoadRangeAttributeMap::readFeatureReferences(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectRoadRangeAttributeMap::ZserioArrayType_featureValidities RulesIndirectRoadRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadRangeAttributeMap::ZserioArrayType_featureValidities RulesIndirectRoadRangeAttributeMap::readFeatureValidities(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectRoadRangeAttributeMap::ZserioArrayType_featureValuePtr RulesIndirectRoadRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadRangeAttributeMap::ZserioArrayType_featureValuePtr RulesIndirectRoadRangeAttributeMap::readFeatureValuePtr(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesIndirectRoadRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesIndirectRoadRangeAttributeMap::readAttribute(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectRoadRangeAttributeMap::ZserioArrayType_attributeValues RulesIndirectRoadRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectRoadRangeAttributeMap::ZserioArrayType_attributeValues RulesIndirectRoadRangeAttributeMap::readAttributeValues(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesIndirectRoadRangeAttributeMap::ZserioArrayType_attributeProperties RulesIndirectRoadRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectRoadRangeAttributeMap::ZserioArrayType_attributeProperties RulesIndirectRoadRangeAttributeMap::readAttributeProperties(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesIndirectRoadRangeAttributeMap::ZserioArrayType_attributeConditions RulesIndirectRoadRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectRoadRangeAttributeMap::ZserioArrayType_attributeConditions RulesIndirectRoadRangeAttributeMap::readAttributeConditions(RulesIndirectRoadRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadLocationRangeAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadLocationRangeAttributeMap::RulesRoadLocationRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesRoadRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesRoadLocationRangeAttributeMap::RulesRoadLocationRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesRoadLocationRangeAttributeMap::RulesRoadLocationRangeAttributeMap(RulesRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesRoadLocationRangeAttributeMap::RulesRoadLocationRangeAttributeMap(const RulesRoadLocationRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationRangeAttributeMap& RulesRoadLocationRangeAttributeMap::operator=(const RulesRoadLocationRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationRangeAttributeMap::RulesRoadLocationRangeAttributeMap(RulesRoadLocationRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationRangeAttributeMap& RulesRoadLocationRangeAttributeMap::operator=(RulesRoadLocationRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationRangeAttributeMap::RulesRoadLocationRangeAttributeMap(::zserio::PropagateAllocatorT,
        const RulesRoadLocationRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadLocationRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadLocationRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadLocationRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadLocationRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadLocationRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadLocationRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesRoadLocationRangeAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesRoadLocationRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesRoadLocationRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::location::RoadLocationReference>& RulesRoadLocationRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& RulesRoadLocationRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesRoadLocationRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesRoadLocationRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::location::RoadLocationReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& RulesRoadLocationRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& RulesRoadLocationRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesRoadLocationRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesRoadLocationRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRoadLocationRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRoadLocationRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesRoadLocationRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesRoadLocationRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesRoadLocationRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesRoadLocationRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& RulesRoadLocationRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& RulesRoadLocationRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesRoadLocationRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesRoadLocationRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRoadLocationRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRoadLocationRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesRoadLocationRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesRoadLocationRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRoadLocationRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRoadLocationRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesRoadLocationRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesRoadLocationRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesRoadLocationRangeAttributeMap::initPackingContext(RulesRoadLocationRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesRoadLocationRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationRangeAttributeMap::bitSizeOf(RulesRoadLocationRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadLocationRangeAttributeMap::initializeOffsets(RulesRoadLocationRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadLocationRangeAttributeMap::operator==(const RulesRoadLocationRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesRoadLocationRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesRoadLocationRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRoadLocationRangeAttributeMap::write(RulesRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& array,
        ::nds::road::reference::location::RoadLocationReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadLocationRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesRoadLocationRangeAttributeMap& owner,
        ::nds::road::reference::location::RoadLocationRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesRoadLocationRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesRoadLocationRangeAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& array,
        ::nds::road::reference::location::RoadLocationRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadLocationRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesRoadLocationRangeAttributeMap& owner,
        ::nds::rules::instantiations::RulesRoadRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(owner.getAttributeTypeCode()));
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesRoadLocationRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesRoadLocationRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttribute>& array,
        ::nds::rules::instantiations::RulesRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRoadLocationRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesRoadLocationRangeAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadLocationRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesRoadLocationRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadLocationRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRoadLocationRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadLocationRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadRangeAttributeType>(in);
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadLocationRangeAttributeMap::readAttributeTypeCode(RulesRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesRoadLocationRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRoadLocationRangeAttributeMap::readFeature(RulesRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadLocationRangeAttributeMap::ZserioArrayType_featureReferences RulesRoadLocationRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadLocationRangeAttributeMap::ZserioArrayType_featureReferences RulesRoadLocationRangeAttributeMap::readFeatureReferences(RulesRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadLocationRangeAttributeMap::ZserioArrayType_featureValidities RulesRoadLocationRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadLocationRangeAttributeMap::ZserioArrayType_featureValidities RulesRoadLocationRangeAttributeMap::readFeatureValidities(RulesRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadLocationRangeAttributeMap::ZserioArrayType_featureValuePtr RulesRoadLocationRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadLocationRangeAttributeMap::ZserioArrayType_featureValuePtr RulesRoadLocationRangeAttributeMap::readFeatureValuePtr(RulesRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesRoadLocationRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesRoadLocationRangeAttributeMap::readAttribute(RulesRoadLocationRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadLocationRangeAttributeMap::ZserioArrayType_attributeValues RulesRoadLocationRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadLocationRangeAttributeMap::ZserioArrayType_attributeValues RulesRoadLocationRangeAttributeMap::readAttributeValues(RulesRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRoadLocationRangeAttributeMap::ZserioArrayType_attributeProperties RulesRoadLocationRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadLocationRangeAttributeMap::ZserioArrayType_attributeProperties RulesRoadLocationRangeAttributeMap::readAttributeProperties(RulesRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRoadLocationRangeAttributeMap::ZserioArrayType_attributeConditions RulesRoadLocationRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadLocationRangeAttributeMap::ZserioArrayType_attributeConditions RulesRoadLocationRangeAttributeMap::readAttributeConditions(RulesRoadLocationRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadPositionAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadPositionAttributeMap::RulesRoadPositionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesRoadPositionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesRoadPositionAttributeMap::RulesRoadPositionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesRoadPositionAttributeMap::RulesRoadPositionAttributeMap(RulesRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesRoadPositionAttributeMap::RulesRoadPositionAttributeMap(const RulesRoadPositionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeMap& RulesRoadPositionAttributeMap::operator=(const RulesRoadPositionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeMap::RulesRoadPositionAttributeMap(RulesRoadPositionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeMap& RulesRoadPositionAttributeMap::operator=(RulesRoadPositionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeMap::RulesRoadPositionAttributeMap(::zserio::PropagateAllocatorT,
        const RulesRoadPositionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadPositionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadPositionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadPositionAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadPositionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadPositionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesRoadPositionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesRoadPositionAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesRoadPositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesRoadPositionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesRoadPositionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& RulesRoadPositionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& RulesRoadPositionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesRoadPositionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesRoadPositionAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& RulesRoadPositionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& RulesRoadPositionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesRoadPositionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesRoadPositionAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::types::RoadPositionValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRoadPositionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRoadPositionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesRoadPositionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesRoadPositionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesRoadPositionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesRoadPositionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& RulesRoadPositionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& RulesRoadPositionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesRoadPositionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesRoadPositionAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRoadPositionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRoadPositionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesRoadPositionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesRoadPositionAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRoadPositionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRoadPositionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesRoadPositionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesRoadPositionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesRoadPositionAttributeMap::initPackingContext(RulesRoadPositionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesRoadPositionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeMap::bitSizeOf(RulesRoadPositionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadPositionAttributeMap::initializeOffsets(RulesRoadPositionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadPositionAttributeMap::operator==(const RulesRoadPositionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesRoadPositionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesRoadPositionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRoadPositionAttributeMap::write(RulesRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadPositionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesRoadPositionAttributeMap& owner,
        ::nds::road::reference::types::RoadPositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesRoadPositionAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesRoadPositionAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& array,
        ::nds::road::reference::types::RoadPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadPositionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesRoadPositionAttributeMap& owner,
        ::nds::rules::instantiations::RulesRoadPositionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(owner.getAttributeTypeCode()));
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesRoadPositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesRoadPositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& array,
        ::nds::rules::instantiations::RulesRoadPositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRoadPositionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesRoadPositionAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadPositionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesRoadPositionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadPositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesRoadPositionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadPositionAttributeType>(in);
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesRoadPositionAttributeMap::readAttributeTypeCode(RulesRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadPositionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesRoadPositionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRoadPositionAttributeMap::readFeature(RulesRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadPositionAttributeMap::ZserioArrayType_featureReferences RulesRoadPositionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadPositionAttributeMap::ZserioArrayType_featureReferences RulesRoadPositionAttributeMap::readFeatureReferences(RulesRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadPositionAttributeMap::ZserioArrayType_featureValidities RulesRoadPositionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadPositionAttributeMap::ZserioArrayType_featureValidities RulesRoadPositionAttributeMap::readFeatureValidities(RulesRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadPositionAttributeMap::ZserioArrayType_featureValuePtr RulesRoadPositionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadPositionAttributeMap::ZserioArrayType_featureValuePtr RulesRoadPositionAttributeMap::readFeatureValuePtr(RulesRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesRoadPositionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesRoadPositionAttributeMap::readAttribute(RulesRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadPositionAttributeMap::ZserioArrayType_attributeValues RulesRoadPositionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadPositionAttributeMap::ZserioArrayType_attributeValues RulesRoadPositionAttributeMap::readAttributeValues(RulesRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRoadPositionAttributeMap::ZserioArrayType_attributeProperties RulesRoadPositionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadPositionAttributeMap::ZserioArrayType_attributeProperties RulesRoadPositionAttributeMap::readAttributeProperties(RulesRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRoadPositionAttributeMap::ZserioArrayType_attributeConditions RulesRoadPositionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadPositionAttributeMap::ZserioArrayType_attributeConditions RulesRoadPositionAttributeMap::readAttributeConditions(RulesRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectRoadPositionAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectRoadPositionAttributeMap::RulesIndirectRoadPositionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesRoadPositionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesIndirectRoadPositionAttributeMap::RulesIndirectRoadPositionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesIndirectRoadPositionAttributeMap::RulesIndirectRoadPositionAttributeMap(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesIndirectRoadPositionAttributeMap::RulesIndirectRoadPositionAttributeMap(const RulesIndirectRoadPositionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadPositionAttributeMap& RulesIndirectRoadPositionAttributeMap::operator=(const RulesIndirectRoadPositionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadPositionAttributeMap::RulesIndirectRoadPositionAttributeMap(RulesIndirectRoadPositionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadPositionAttributeMap& RulesIndirectRoadPositionAttributeMap::operator=(RulesIndirectRoadPositionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadPositionAttributeMap::RulesIndirectRoadPositionAttributeMap(::zserio::PropagateAllocatorT,
        const RulesIndirectRoadPositionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectRoadPositionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectRoadPositionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectRoadPositionAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectRoadPositionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectRoadPositionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesIndirectRoadPositionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesIndirectRoadPositionAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesRoadPositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesIndirectRoadPositionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesIndirectRoadPositionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& RulesIndirectRoadPositionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& RulesIndirectRoadPositionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesIndirectRoadPositionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesIndirectRoadPositionAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& RulesIndirectRoadPositionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& RulesIndirectRoadPositionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesIndirectRoadPositionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesIndirectRoadPositionAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::types::RoadPositionValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesIndirectRoadPositionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesIndirectRoadPositionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesIndirectRoadPositionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesIndirectRoadPositionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesIndirectRoadPositionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesIndirectRoadPositionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& RulesIndirectRoadPositionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& RulesIndirectRoadPositionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesIndirectRoadPositionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesIndirectRoadPositionAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesIndirectRoadPositionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesIndirectRoadPositionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesIndirectRoadPositionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesIndirectRoadPositionAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesIndirectRoadPositionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesIndirectRoadPositionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesIndirectRoadPositionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesIndirectRoadPositionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesIndirectRoadPositionAttributeMap::initPackingContext(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesIndirectRoadPositionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadPositionAttributeMap::bitSizeOf(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadPositionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectRoadPositionAttributeMap::initializeOffsets(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectRoadPositionAttributeMap::operator==(const RulesIndirectRoadPositionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesIndirectRoadPositionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesIndirectRoadPositionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesIndirectRoadPositionAttributeMap::write(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesIndirectRoadPositionAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(RulesIndirectRoadPositionAttributeMap&,
        ::nds::road::reference::types::RoadReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesIndirectRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesIndirectRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::nds::road::reference::types::RoadReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesIndirectRoadPositionAttributeMap& owner,
        ::nds::road::reference::types::RoadPositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesIndirectRoadPositionAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesIndirectRoadPositionAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& array,
        ::nds::road::reference::types::RoadPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesIndirectRoadPositionAttributeMap& owner,
        ::nds::rules::instantiations::RulesRoadPositionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(owner.getAttributeTypeCode()));
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesIndirectRoadPositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesIndirectRoadPositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttribute>& array,
        ::nds::rules::instantiations::RulesRoadPositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesIndirectRoadPositionAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesIndirectRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesIndirectRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesIndirectRoadPositionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesIndirectRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectRoadPositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesIndirectRoadPositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesIndirectRoadPositionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadPositionAttributeType>(in);
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesIndirectRoadPositionAttributeMap::readAttributeTypeCode(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadPositionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesIndirectRoadPositionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesIndirectRoadPositionAttributeMap::readFeature(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectRoadPositionAttributeMap::ZserioArrayType_featureReferences RulesIndirectRoadPositionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadPositionAttributeMap::ZserioArrayType_featureReferences RulesIndirectRoadPositionAttributeMap::readFeatureReferences(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectRoadPositionAttributeMap::ZserioArrayType_featureValidities RulesIndirectRoadPositionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadPositionAttributeMap::ZserioArrayType_featureValidities RulesIndirectRoadPositionAttributeMap::readFeatureValidities(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectRoadPositionAttributeMap::ZserioArrayType_featureValuePtr RulesIndirectRoadPositionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadPositionAttributeMap::ZserioArrayType_featureValuePtr RulesIndirectRoadPositionAttributeMap::readFeatureValuePtr(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesIndirectRoadPositionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesIndirectRoadPositionAttributeMap::readAttribute(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectRoadPositionAttributeMap::ZserioArrayType_attributeValues RulesIndirectRoadPositionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectRoadPositionAttributeMap::ZserioArrayType_attributeValues RulesIndirectRoadPositionAttributeMap::readAttributeValues(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesIndirectRoadPositionAttributeMap::ZserioArrayType_attributeProperties RulesIndirectRoadPositionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectRoadPositionAttributeMap::ZserioArrayType_attributeProperties RulesIndirectRoadPositionAttributeMap::readAttributeProperties(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesIndirectRoadPositionAttributeMap::ZserioArrayType_attributeConditions RulesIndirectRoadPositionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectRoadPositionAttributeMap::ZserioArrayType_attributeConditions RulesIndirectRoadPositionAttributeMap::readAttributeConditions(RulesIndirectRoadPositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneRangeAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneRangeAttributeMap::RulesLaneRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesLaneRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesLaneRangeAttributeMap::RulesLaneRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesLaneRangeAttributeMap::RulesLaneRangeAttributeMap(RulesLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesLaneRangeAttributeMap::RulesLaneRangeAttributeMap(const RulesLaneRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeMap& RulesLaneRangeAttributeMap::operator=(const RulesLaneRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeMap::RulesLaneRangeAttributeMap(RulesLaneRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeMap& RulesLaneRangeAttributeMap::operator=(RulesLaneRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeMap::RulesLaneRangeAttributeMap(::zserio::PropagateAllocatorT,
        const RulesLaneRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLaneRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLaneRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLaneRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesLaneRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesLaneRangeAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesLaneRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesLaneRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RulesLaneRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RulesLaneRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesLaneRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesLaneRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RulesLaneRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RulesLaneRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesLaneRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesLaneRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesLaneRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesLaneRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesLaneRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesLaneRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesLaneRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesLaneRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& RulesLaneRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& RulesLaneRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesLaneRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesLaneRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesLaneRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesLaneRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesLaneRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesLaneRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesLaneRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesLaneRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesLaneRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesLaneRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesLaneRangeAttributeMap::initPackingContext(RulesLaneRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesLaneRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeMap::bitSizeOf(RulesLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneRangeAttributeMap::initializeOffsets(RulesLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneRangeAttributeMap::operator==(const RulesLaneRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesLaneRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesLaneRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesLaneRangeAttributeMap::write(RulesLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesLaneRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesLaneRangeAttributeMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLaneRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesLaneRangeAttributeMap& owner,
        ::nds::rules::instantiations::RulesLaneRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(owner.getAttributeTypeCode()));
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& array,
        ::nds::rules::instantiations::RulesLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesLaneRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesLaneRangeAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesLaneRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesLaneRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesLaneRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneRangeAttributeType>(in);
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesLaneRangeAttributeMap::readAttributeTypeCode(RulesLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesLaneRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesLaneRangeAttributeMap::readFeature(RulesLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneRangeAttributeMap::ZserioArrayType_featureReferences RulesLaneRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLaneRangeAttributeMap::ZserioArrayType_featureReferences RulesLaneRangeAttributeMap::readFeatureReferences(RulesLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesLaneRangeAttributeMap::ZserioArrayType_featureValidities RulesLaneRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLaneRangeAttributeMap::ZserioArrayType_featureValidities RulesLaneRangeAttributeMap::readFeatureValidities(RulesLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesLaneRangeAttributeMap::ZserioArrayType_featureValuePtr RulesLaneRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLaneRangeAttributeMap::ZserioArrayType_featureValuePtr RulesLaneRangeAttributeMap::readFeatureValuePtr(RulesLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesLaneRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesLaneRangeAttributeMap::readAttribute(RulesLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneRangeAttributeMap::ZserioArrayType_attributeValues RulesLaneRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesLaneRangeAttributeMap::ZserioArrayType_attributeValues RulesLaneRangeAttributeMap::readAttributeValues(RulesLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesLaneRangeAttributeMap::ZserioArrayType_attributeProperties RulesLaneRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesLaneRangeAttributeMap::ZserioArrayType_attributeProperties RulesLaneRangeAttributeMap::readAttributeProperties(RulesLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesLaneRangeAttributeMap::ZserioArrayType_attributeConditions RulesLaneRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesLaneRangeAttributeMap::ZserioArrayType_attributeConditions RulesLaneRangeAttributeMap::readAttributeConditions(RulesLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectLaneRangeAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectLaneRangeAttributeMap::RulesIndirectLaneRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesLaneRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesIndirectLaneRangeAttributeMap::RulesIndirectLaneRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesIndirectLaneRangeAttributeMap::RulesIndirectLaneRangeAttributeMap(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesIndirectLaneRangeAttributeMap::RulesIndirectLaneRangeAttributeMap(const RulesIndirectLaneRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLaneRangeAttributeMap& RulesIndirectLaneRangeAttributeMap::operator=(const RulesIndirectLaneRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLaneRangeAttributeMap::RulesIndirectLaneRangeAttributeMap(RulesIndirectLaneRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLaneRangeAttributeMap& RulesIndirectLaneRangeAttributeMap::operator=(RulesIndirectLaneRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLaneRangeAttributeMap::RulesIndirectLaneRangeAttributeMap(::zserio::PropagateAllocatorT,
        const RulesIndirectLaneRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectLaneRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectLaneRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectLaneRangeAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectLaneRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectLaneRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesIndirectLaneRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesIndirectLaneRangeAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesIndirectLaneRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesIndirectLaneRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& RulesIndirectLaneRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& RulesIndirectLaneRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesIndirectLaneRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesIndirectLaneRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RulesIndirectLaneRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RulesIndirectLaneRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesIndirectLaneRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesIndirectLaneRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesIndirectLaneRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesIndirectLaneRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesIndirectLaneRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesIndirectLaneRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesIndirectLaneRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesIndirectLaneRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& RulesIndirectLaneRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& RulesIndirectLaneRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesIndirectLaneRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesIndirectLaneRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesIndirectLaneRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesIndirectLaneRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesIndirectLaneRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesIndirectLaneRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesIndirectLaneRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesIndirectLaneRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesIndirectLaneRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesIndirectLaneRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesIndirectLaneRangeAttributeMap::initPackingContext(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesIndirectLaneRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLaneRangeAttributeMap::bitSizeOf(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLaneRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectLaneRangeAttributeMap::initializeOffsets(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectLaneRangeAttributeMap::operator==(const RulesIndirectLaneRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesIndirectLaneRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesIndirectLaneRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesIndirectLaneRangeAttributeMap::write(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesIndirectLaneRangeAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(RulesIndirectLaneRangeAttributeMap&,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesIndirectLaneRangeAttributeMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesIndirectLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesIndirectLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesIndirectLaneRangeAttributeMap& owner,
        ::nds::rules::instantiations::RulesLaneRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(owner.getAttributeTypeCode()));
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesIndirectLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesIndirectLaneRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttribute>& array,
        ::nds::rules::instantiations::RulesLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesIndirectLaneRangeAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesIndirectLaneRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectLaneRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesIndirectLaneRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesIndirectLaneRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneRangeAttributeType>(in);
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesIndirectLaneRangeAttributeMap::readAttributeTypeCode(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesIndirectLaneRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesIndirectLaneRangeAttributeMap::readFeature(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectLaneRangeAttributeMap::ZserioArrayType_featureReferences RulesIndirectLaneRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLaneRangeAttributeMap::ZserioArrayType_featureReferences RulesIndirectLaneRangeAttributeMap::readFeatureReferences(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectLaneRangeAttributeMap::ZserioArrayType_featureValidities RulesIndirectLaneRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLaneRangeAttributeMap::ZserioArrayType_featureValidities RulesIndirectLaneRangeAttributeMap::readFeatureValidities(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectLaneRangeAttributeMap::ZserioArrayType_featureValuePtr RulesIndirectLaneRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLaneRangeAttributeMap::ZserioArrayType_featureValuePtr RulesIndirectLaneRangeAttributeMap::readFeatureValuePtr(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesIndirectLaneRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesIndirectLaneRangeAttributeMap::readAttribute(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectLaneRangeAttributeMap::ZserioArrayType_attributeValues RulesIndirectLaneRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectLaneRangeAttributeMap::ZserioArrayType_attributeValues RulesIndirectLaneRangeAttributeMap::readAttributeValues(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesIndirectLaneRangeAttributeMap::ZserioArrayType_attributeProperties RulesIndirectLaneRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectLaneRangeAttributeMap::ZserioArrayType_attributeProperties RulesIndirectLaneRangeAttributeMap::readAttributeProperties(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesIndirectLaneRangeAttributeMap::ZserioArrayType_attributeConditions RulesIndirectLaneRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectLaneRangeAttributeMap::ZserioArrayType_attributeConditions RulesIndirectLaneRangeAttributeMap::readAttributeConditions(RulesIndirectLaneRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLanePositionAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLanePositionAttributeMap::RulesLanePositionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesLanePositionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesLanePositionAttributeMap::RulesLanePositionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesLanePositionAttributeMap::RulesLanePositionAttributeMap(RulesLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesLanePositionAttributeMap::RulesLanePositionAttributeMap(const RulesLanePositionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeMap& RulesLanePositionAttributeMap::operator=(const RulesLanePositionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeMap::RulesLanePositionAttributeMap(RulesLanePositionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeMap& RulesLanePositionAttributeMap::operator=(RulesLanePositionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeMap::RulesLanePositionAttributeMap(::zserio::PropagateAllocatorT,
        const RulesLanePositionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLanePositionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLanePositionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesLanePositionAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLanePositionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLanePositionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesLanePositionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesLanePositionAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesLanePositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesLanePositionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesLanePositionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RulesLanePositionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RulesLanePositionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesLanePositionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesLanePositionAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& RulesLanePositionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& RulesLanePositionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesLanePositionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesLanePositionAttributeMap::setFeatureValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesLanePositionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesLanePositionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesLanePositionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesLanePositionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesLanePositionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesLanePositionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& RulesLanePositionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& RulesLanePositionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesLanePositionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesLanePositionAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesLanePositionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesLanePositionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesLanePositionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesLanePositionAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesLanePositionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesLanePositionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesLanePositionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesLanePositionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesLanePositionAttributeMap::initPackingContext(RulesLanePositionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesLanePositionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeMap::bitSizeOf(RulesLanePositionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLanePositionAttributeMap::initializeOffsets(RulesLanePositionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLanePositionAttributeMap::operator==(const RulesLanePositionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesLanePositionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesLanePositionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesLanePositionAttributeMap::write(RulesLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesLanePositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLanePositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesLanePositionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesLanePositionAttributeMap& owner,
        ::nds::lane::reference::types::LaneGroupPositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLanePositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesLanePositionAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLanePositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesLanePositionAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& array,
        ::nds::lane::reference::types::LaneGroupPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLanePositionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesLanePositionAttributeMap& owner,
        ::nds::rules::instantiations::RulesLanePositionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(owner.getAttributeTypeCode()));
}

void RulesLanePositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesLanePositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesLanePositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesLanePositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& array,
        ::nds::rules::instantiations::RulesLanePositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesLanePositionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesLanePositionAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesLanePositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLanePositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesLanePositionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesLanePositionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesLanePositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLanePositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesLanePositionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLanePositionAttributeType>(in);
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesLanePositionAttributeMap::readAttributeTypeCode(RulesLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLanePositionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesLanePositionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesLanePositionAttributeMap::readFeature(RulesLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLanePositionAttributeMap::ZserioArrayType_featureReferences RulesLanePositionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLanePositionAttributeMap::ZserioArrayType_featureReferences RulesLanePositionAttributeMap::readFeatureReferences(RulesLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesLanePositionAttributeMap::ZserioArrayType_featureValidities RulesLanePositionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLanePositionAttributeMap::ZserioArrayType_featureValidities RulesLanePositionAttributeMap::readFeatureValidities(RulesLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesLanePositionAttributeMap::ZserioArrayType_featureValuePtr RulesLanePositionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLanePositionAttributeMap::ZserioArrayType_featureValuePtr RulesLanePositionAttributeMap::readFeatureValuePtr(RulesLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesLanePositionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesLanePositionAttributeMap::readAttribute(RulesLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLanePositionAttributeMap::ZserioArrayType_attributeValues RulesLanePositionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesLanePositionAttributeMap::ZserioArrayType_attributeValues RulesLanePositionAttributeMap::readAttributeValues(RulesLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesLanePositionAttributeMap::ZserioArrayType_attributeProperties RulesLanePositionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesLanePositionAttributeMap::ZserioArrayType_attributeProperties RulesLanePositionAttributeMap::readAttributeProperties(RulesLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesLanePositionAttributeMap::ZserioArrayType_attributeConditions RulesLanePositionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesLanePositionAttributeMap::ZserioArrayType_attributeConditions RulesLanePositionAttributeMap::readAttributeConditions(RulesLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectLanePositionAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectLanePositionAttributeMap::RulesIndirectLanePositionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesLanePositionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesIndirectLanePositionAttributeMap::RulesIndirectLanePositionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesIndirectLanePositionAttributeMap::RulesIndirectLanePositionAttributeMap(RulesIndirectLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesIndirectLanePositionAttributeMap::RulesIndirectLanePositionAttributeMap(const RulesIndirectLanePositionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLanePositionAttributeMap& RulesIndirectLanePositionAttributeMap::operator=(const RulesIndirectLanePositionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLanePositionAttributeMap::RulesIndirectLanePositionAttributeMap(RulesIndirectLanePositionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLanePositionAttributeMap& RulesIndirectLanePositionAttributeMap::operator=(RulesIndirectLanePositionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLanePositionAttributeMap::RulesIndirectLanePositionAttributeMap(::zserio::PropagateAllocatorT,
        const RulesIndirectLanePositionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectLanePositionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectLanePositionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectLanePositionAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectLanePositionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectLanePositionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesIndirectLanePositionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesIndirectLanePositionAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesLanePositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesIndirectLanePositionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesIndirectLanePositionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& RulesIndirectLanePositionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& RulesIndirectLanePositionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesIndirectLanePositionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesIndirectLanePositionAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& RulesIndirectLanePositionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& RulesIndirectLanePositionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesIndirectLanePositionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesIndirectLanePositionAttributeMap::setFeatureValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesIndirectLanePositionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesIndirectLanePositionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesIndirectLanePositionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesIndirectLanePositionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesIndirectLanePositionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesIndirectLanePositionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& RulesIndirectLanePositionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& RulesIndirectLanePositionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesIndirectLanePositionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesIndirectLanePositionAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesIndirectLanePositionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesIndirectLanePositionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesIndirectLanePositionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesIndirectLanePositionAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesIndirectLanePositionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesIndirectLanePositionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesIndirectLanePositionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesIndirectLanePositionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesIndirectLanePositionAttributeMap::initPackingContext(RulesIndirectLanePositionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesIndirectLanePositionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLanePositionAttributeMap::bitSizeOf(RulesIndirectLanePositionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLanePositionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectLanePositionAttributeMap::initializeOffsets(RulesIndirectLanePositionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectLanePositionAttributeMap::operator==(const RulesIndirectLanePositionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesIndirectLanePositionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesIndirectLanePositionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesIndirectLanePositionAttributeMap::write(RulesIndirectLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesIndirectLanePositionAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(RulesIndirectLanePositionAttributeMap&,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesIndirectLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesIndirectLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectLanePositionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesIndirectLanePositionAttributeMap& owner,
        ::nds::lane::reference::types::LaneGroupPositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesIndirectLanePositionAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesIndirectLanePositionAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& array,
        ::nds::lane::reference::types::LaneGroupPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLanePositionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesIndirectLanePositionAttributeMap& owner,
        ::nds::rules::instantiations::RulesLanePositionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(owner.getAttributeTypeCode()));
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesIndirectLanePositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesIndirectLanePositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttribute>& array,
        ::nds::rules::instantiations::RulesLanePositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesIndirectLanePositionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesIndirectLanePositionAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesIndirectLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesIndirectLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectLanePositionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesIndirectLanePositionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesIndirectLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectLanePositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesIndirectLanePositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesIndirectLanePositionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLanePositionAttributeType>(in);
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesIndirectLanePositionAttributeMap::readAttributeTypeCode(RulesIndirectLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLanePositionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesIndirectLanePositionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesIndirectLanePositionAttributeMap::readFeature(RulesIndirectLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectLanePositionAttributeMap::ZserioArrayType_featureReferences RulesIndirectLanePositionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLanePositionAttributeMap::ZserioArrayType_featureReferences RulesIndirectLanePositionAttributeMap::readFeatureReferences(RulesIndirectLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectLanePositionAttributeMap::ZserioArrayType_featureValidities RulesIndirectLanePositionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLanePositionAttributeMap::ZserioArrayType_featureValidities RulesIndirectLanePositionAttributeMap::readFeatureValidities(RulesIndirectLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectLanePositionAttributeMap::ZserioArrayType_featureValuePtr RulesIndirectLanePositionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLanePositionAttributeMap::ZserioArrayType_featureValuePtr RulesIndirectLanePositionAttributeMap::readFeatureValuePtr(RulesIndirectLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesIndirectLanePositionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesIndirectLanePositionAttributeMap::readAttribute(RulesIndirectLanePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectLanePositionAttributeMap::ZserioArrayType_attributeValues RulesIndirectLanePositionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectLanePositionAttributeMap::ZserioArrayType_attributeValues RulesIndirectLanePositionAttributeMap::readAttributeValues(RulesIndirectLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesIndirectLanePositionAttributeMap::ZserioArrayType_attributeProperties RulesIndirectLanePositionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectLanePositionAttributeMap::ZserioArrayType_attributeProperties RulesIndirectLanePositionAttributeMap::readAttributeProperties(RulesIndirectLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesIndirectLanePositionAttributeMap::ZserioArrayType_attributeConditions RulesIndirectLanePositionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesIndirectLanePositionAttributeMap::ZserioArrayType_attributeConditions RulesIndirectLanePositionAttributeMap::readAttributeConditions(RulesIndirectLanePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneTransitionAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneTransitionAttributeMap::RulesLaneTransitionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesLaneTransitionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesLaneTransitionAttributeMap::RulesLaneTransitionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesLaneTransitionAttributeMap::RulesLaneTransitionAttributeMap(RulesLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesLaneTransitionAttributeMap::RulesLaneTransitionAttributeMap(const RulesLaneTransitionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeMap& RulesLaneTransitionAttributeMap::operator=(const RulesLaneTransitionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeMap::RulesLaneTransitionAttributeMap(RulesLaneTransitionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeMap& RulesLaneTransitionAttributeMap::operator=(RulesLaneTransitionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeMap::RulesLaneTransitionAttributeMap(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLaneTransitionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneTransitionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneTransitionAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLaneTransitionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLaneTransitionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesLaneTransitionAttributeType RulesLaneTransitionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesLaneTransitionAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesLaneTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesLaneTransitionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesLaneTransitionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& RulesLaneTransitionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& RulesLaneTransitionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesLaneTransitionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesLaneTransitionAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RulesLaneTransitionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RulesLaneTransitionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesLaneTransitionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesLaneTransitionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesLaneTransitionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesLaneTransitionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesLaneTransitionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesLaneTransitionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesLaneTransitionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesLaneTransitionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttribute>& RulesLaneTransitionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttribute>& RulesLaneTransitionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesLaneTransitionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesLaneTransitionAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesLaneTransitionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesLaneTransitionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesLaneTransitionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesLaneTransitionAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesLaneTransitionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesLaneTransitionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesLaneTransitionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesLaneTransitionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesLaneTransitionAttributeMap::initPackingContext(RulesLaneTransitionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesLaneTransitionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeMap::bitSizeOf(RulesLaneTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneTransitionAttributeMap::initializeOffsets(RulesLaneTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneTransitionAttributeMap::operator==(const RulesLaneTransitionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesLaneTransitionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesLaneTransitionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeMap::write(RulesLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(RulesLaneTransitionAttributeMap&,
        ::nds::lane::reference::types::LaneGroupTransitionReference& element, size_t)
{
    element.initializeChildren();
}

void RulesLaneTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RulesLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RulesLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& array,
        ::nds::lane::reference::types::LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesLaneTransitionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesLaneTransitionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLaneTransitionAttributeMap::ZserioElementFactory_featureValidities::create(RulesLaneTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLaneTransitionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesLaneTransitionAttributeMap& owner,
        ::nds::rules::instantiations::RulesLaneTransitionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(owner.getAttributeTypeCode()));
}

void RulesLaneTransitionAttributeMap::ZserioElementFactory_attributeValues::create(RulesLaneTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesLaneTransitionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesLaneTransitionAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesLaneTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesLaneTransitionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesLaneTransitionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesLaneTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesLaneTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesLaneTransitionAttributeType RulesLaneTransitionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneTransitionAttributeType>(in);
}

::nds::rules::attributes::RulesLaneTransitionAttributeType RulesLaneTransitionAttributeMap::readAttributeTypeCode(RulesLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesLaneTransitionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesLaneTransitionAttributeMap::readFeature(RulesLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneTransitionAttributeMap::ZserioArrayType_featureReferences RulesLaneTransitionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLaneTransitionAttributeMap::ZserioArrayType_featureReferences RulesLaneTransitionAttributeMap::readFeatureReferences(RulesLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesLaneTransitionAttributeMap::ZserioArrayType_featureValidities RulesLaneTransitionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesLaneTransitionAttributeMap::ZserioArrayType_featureValuePtr RulesLaneTransitionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLaneTransitionAttributeMap::ZserioArrayType_featureValuePtr RulesLaneTransitionAttributeMap::readFeatureValuePtr(RulesLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesLaneTransitionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesLaneTransitionAttributeMap::readAttribute(RulesLaneTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneTransitionAttributeMap::ZserioArrayType_attributeValues RulesLaneTransitionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesLaneTransitionAttributeMap::ZserioArrayType_attributeProperties RulesLaneTransitionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesLaneTransitionAttributeMap::ZserioArrayType_attributeProperties RulesLaneTransitionAttributeMap::readAttributeProperties(RulesLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesLaneTransitionAttributeMap::ZserioArrayType_attributeConditions RulesLaneTransitionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesLaneTransitionAttributeMap::ZserioArrayType_attributeConditions RulesLaneTransitionAttributeMap::readAttributeConditions(RulesLaneTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesTransitionAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesTransitionAttributeMap::RulesTransitionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesTransitionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesTransitionAttributeMap::RulesTransitionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesTransitionAttributeMap::RulesTransitionAttributeMap(RulesTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesTransitionAttributeMap::RulesTransitionAttributeMap(const RulesTransitionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeMap& RulesTransitionAttributeMap::operator=(const RulesTransitionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeMap::RulesTransitionAttributeMap(RulesTransitionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeMap& RulesTransitionAttributeMap::operator=(RulesTransitionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeMap::RulesTransitionAttributeMap(::zserio::PropagateAllocatorT,
        const RulesTransitionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesTransitionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesTransitionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesTransitionAttributeMap::initializeChildren()
{
    m_featureReferences_.initializeElements(*this);
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesTransitionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesTransitionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesTransitionAttributeType RulesTransitionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesTransitionAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesTransitionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesTransitionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::TransitionReference>& RulesTransitionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::TransitionReference>& RulesTransitionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesTransitionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::TransitionReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesTransitionAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::TransitionReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RulesTransitionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RulesTransitionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesTransitionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesTransitionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesTransitionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesTransitionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesTransitionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesTransitionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesTransitionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesTransitionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& RulesTransitionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& RulesTransitionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesTransitionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesTransitionAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesTransitionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesTransitionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesTransitionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesTransitionAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesTransitionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesTransitionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesTransitionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesTransitionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesTransitionAttributeMap::initPackingContext(RulesTransitionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesTransitionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeMap::bitSizeOf(RulesTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesTransitionAttributeMap::initializeOffsets(RulesTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesTransitionAttributeMap::operator==(const RulesTransitionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesTransitionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesTransitionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesTransitionAttributeMap::write(RulesTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesTransitionAttributeMap::ZserioArrayExpressions_featureReferences::initializeElement(RulesTransitionAttributeMap&,
        ::nds::road::reference::types::TransitionReference& element, size_t)
{
    element.initializeChildren();
}

void RulesTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RulesTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RulesTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::nds::road::reference::types::TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesTransitionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesTransitionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesTransitionAttributeMap::ZserioElementFactory_featureValidities::create(RulesTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesTransitionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesTransitionAttributeMap& owner,
        ::nds::rules::instantiations::RulesTransitionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(owner.getAttributeTypeCode()));
}

void RulesTransitionAttributeMap::ZserioElementFactory_attributeValues::create(RulesTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesTransitionAttributeMap::ZserioElementFactory_attributeValues::create(RulesTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& array,
        ::nds::rules::instantiations::RulesTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesTransitionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesTransitionAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesTransitionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesTransitionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesTransitionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesTransitionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesTransitionAttributeType RulesTransitionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesTransitionAttributeType>(in);
}

::nds::rules::attributes::RulesTransitionAttributeType RulesTransitionAttributeMap::readAttributeTypeCode(RulesTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesTransitionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesTransitionAttributeMap::readFeature(RulesTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesTransitionAttributeMap::ZserioArrayType_featureReferences RulesTransitionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesTransitionAttributeMap::ZserioArrayType_featureReferences RulesTransitionAttributeMap::readFeatureReferences(RulesTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesTransitionAttributeMap::ZserioArrayType_featureValidities RulesTransitionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesTransitionAttributeMap::ZserioArrayType_featureValuePtr RulesTransitionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesTransitionAttributeMap::ZserioArrayType_featureValuePtr RulesTransitionAttributeMap::readFeatureValuePtr(RulesTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesTransitionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesTransitionAttributeMap::readAttribute(RulesTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesTransitionAttributeMap::ZserioArrayType_attributeValues RulesTransitionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesTransitionAttributeMap::ZserioArrayType_attributeValues RulesTransitionAttributeMap::readAttributeValues(RulesTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesTransitionAttributeMap::ZserioArrayType_attributeProperties RulesTransitionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesTransitionAttributeMap::ZserioArrayType_attributeProperties RulesTransitionAttributeMap::readAttributeProperties(RulesTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesTransitionAttributeMap::ZserioArrayType_attributeConditions RulesTransitionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesTransitionAttributeMap::ZserioArrayType_attributeConditions RulesTransitionAttributeMap::readAttributeConditions(RulesTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadLocationTransitionAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadLocationTransitionAttributeMap::RulesRoadLocationTransitionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesTransitionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesRoadLocationTransitionAttributeMap::RulesRoadLocationTransitionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesRoadLocationTransitionAttributeMap::RulesRoadLocationTransitionAttributeMap(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesRoadLocationTransitionAttributeMap::RulesRoadLocationTransitionAttributeMap(const RulesRoadLocationTransitionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationTransitionAttributeMap& RulesRoadLocationTransitionAttributeMap::operator=(const RulesRoadLocationTransitionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationTransitionAttributeMap::RulesRoadLocationTransitionAttributeMap(RulesRoadLocationTransitionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationTransitionAttributeMap& RulesRoadLocationTransitionAttributeMap::operator=(RulesRoadLocationTransitionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationTransitionAttributeMap::RulesRoadLocationTransitionAttributeMap(::zserio::PropagateAllocatorT,
        const RulesRoadLocationTransitionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadLocationTransitionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadLocationTransitionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadLocationTransitionAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadLocationTransitionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadLocationTransitionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesTransitionAttributeType RulesRoadLocationTransitionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesRoadLocationTransitionAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesRoadLocationTransitionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesRoadLocationTransitionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& RulesRoadLocationTransitionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& RulesRoadLocationTransitionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesRoadLocationTransitionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesRoadLocationTransitionAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RulesRoadLocationTransitionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RulesRoadLocationTransitionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesRoadLocationTransitionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesRoadLocationTransitionAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRoadLocationTransitionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRoadLocationTransitionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesRoadLocationTransitionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesRoadLocationTransitionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesRoadLocationTransitionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesRoadLocationTransitionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& RulesRoadLocationTransitionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& RulesRoadLocationTransitionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesRoadLocationTransitionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesRoadLocationTransitionAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRoadLocationTransitionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRoadLocationTransitionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesRoadLocationTransitionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesRoadLocationTransitionAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRoadLocationTransitionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRoadLocationTransitionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesRoadLocationTransitionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesRoadLocationTransitionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesRoadLocationTransitionAttributeMap::initPackingContext(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesRoadLocationTransitionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationTransitionAttributeMap::bitSizeOf(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationTransitionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadLocationTransitionAttributeMap::initializeOffsets(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadLocationTransitionAttributeMap::operator==(const RulesRoadLocationTransitionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesRoadLocationTransitionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesRoadLocationTransitionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRoadLocationTransitionAttributeMap::write(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRoadLocationTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RulesRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadLocationTransitionAttributeMap::ZserioElementFactory_featureReferences::create(RulesRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& array,
        ::nds::road::reference::location::RoadLocationTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadLocationTransitionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesRoadLocationTransitionAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadLocationTransitionAttributeMap::ZserioElementFactory_featureValidities::create(RulesRoadLocationTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadLocationTransitionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesRoadLocationTransitionAttributeMap& owner,
        ::nds::rules::instantiations::RulesTransitionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(owner.getAttributeTypeCode()));
}

void RulesRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeValues::create(RulesRoadLocationTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeValues::create(RulesRoadLocationTransitionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttribute>& array,
        ::nds::rules::instantiations::RulesTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRoadLocationTransitionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesRoadLocationTransitionAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadLocationTransitionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesRoadLocationTransitionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadLocationTransitionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRoadLocationTransitionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesTransitionAttributeType RulesRoadLocationTransitionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesTransitionAttributeType>(in);
}

::nds::rules::attributes::RulesTransitionAttributeType RulesRoadLocationTransitionAttributeMap::readAttributeTypeCode(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesRoadLocationTransitionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRoadLocationTransitionAttributeMap::readFeature(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadLocationTransitionAttributeMap::ZserioArrayType_featureReferences RulesRoadLocationTransitionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadLocationTransitionAttributeMap::ZserioArrayType_featureReferences RulesRoadLocationTransitionAttributeMap::readFeatureReferences(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadLocationTransitionAttributeMap::ZserioArrayType_featureValidities RulesRoadLocationTransitionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadLocationTransitionAttributeMap::ZserioArrayType_featureValuePtr RulesRoadLocationTransitionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadLocationTransitionAttributeMap::ZserioArrayType_featureValuePtr RulesRoadLocationTransitionAttributeMap::readFeatureValuePtr(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesRoadLocationTransitionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesRoadLocationTransitionAttributeMap::readAttribute(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadLocationTransitionAttributeMap::ZserioArrayType_attributeValues RulesRoadLocationTransitionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadLocationTransitionAttributeMap::ZserioArrayType_attributeValues RulesRoadLocationTransitionAttributeMap::readAttributeValues(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRoadLocationTransitionAttributeMap::ZserioArrayType_attributeProperties RulesRoadLocationTransitionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadLocationTransitionAttributeMap::ZserioArrayType_attributeProperties RulesRoadLocationTransitionAttributeMap::readAttributeProperties(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRoadLocationTransitionAttributeMap::ZserioArrayType_attributeConditions RulesRoadLocationTransitionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRoadLocationTransitionAttributeMap::ZserioArrayType_attributeConditions RulesRoadLocationTransitionAttributeMap::readAttributeConditions(RulesRoadLocationTransitionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRegionAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRegionAttributeMap::RulesRegionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesRegionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesRegionAttributeMap::RulesRegionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesRegionAttributeMap::RulesRegionAttributeMap(RulesRegionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesRegionAttributeMap::RulesRegionAttributeMap(const RulesRegionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeMap& RulesRegionAttributeMap::operator=(const RulesRegionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeMap::RulesRegionAttributeMap(RulesRegionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeMap& RulesRegionAttributeMap::operator=(RulesRegionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeMap::RulesRegionAttributeMap(::zserio::PropagateAllocatorT,
        const RulesRegionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRegionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRegionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRegionAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRegionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRegionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesRegionAttributeType RulesRegionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesRegionAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesRegionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesRegionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesRegionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::core::types::RegionId>& RulesRegionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::core::types::RegionId>& RulesRegionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesRegionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::core::types::RegionId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesRegionAttributeMap::setFeatureReferences(::zserio::vector<::nds::core::types::RegionId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::rules::types::RegionValidity>& RulesRegionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::rules::types::RegionValidity>& RulesRegionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesRegionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::rules::types::RegionValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesRegionAttributeMap::setFeatureValidities(::zserio::vector<::nds::rules::types::RegionValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRegionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesRegionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesRegionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesRegionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesRegionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesRegionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesRegionAttribute>& RulesRegionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRegionAttribute>& RulesRegionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesRegionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesRegionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesRegionAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesRegionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRegionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesRegionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesRegionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesRegionAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRegionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesRegionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesRegionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesRegionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesRegionAttributeMap::initPackingContext(RulesRegionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesRegionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeMap::bitSizeOf(RulesRegionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRegionAttributeMap::initializeOffsets(RulesRegionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRegionAttributeMap::operator==(const RulesRegionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesRegionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesRegionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRegionAttributeMap::write(RulesRegionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesRegionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesRegionAttributeMap& owner,
        ::nds::rules::types::RegionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRegionAttributeMap::ZserioElementFactory_featureValidities::create(RulesRegionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::types::RegionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRegionAttributeMap::ZserioElementFactory_featureValidities::create(RulesRegionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::types::RegionValidity>& array,
        ::nds::rules::types::RegionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRegionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesRegionAttributeMap& owner,
        ::nds::rules::instantiations::RulesRegionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesRegionAttributeType>(owner.getAttributeTypeCode()));
}

void RulesRegionAttributeMap::ZserioElementFactory_attributeValues::create(RulesRegionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRegionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesRegionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRegionAttributeMap::ZserioElementFactory_attributeValues::create(RulesRegionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRegionAttribute>& array,
        ::nds::rules::instantiations::RulesRegionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesRegionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesRegionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesRegionAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesRegionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRegionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRegionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesRegionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRegionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesRegionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesRegionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRegionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRegionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesRegionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesRegionAttributeType RulesRegionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRegionAttributeType>(in);
}

::nds::rules::attributes::RulesRegionAttributeType RulesRegionAttributeMap::readAttributeTypeCode(RulesRegionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRegionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesRegionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRegionAttributeMap::readFeature(RulesRegionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRegionAttributeMap::ZserioArrayType_featureReferences RulesRegionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRegionAttributeMap::ZserioArrayType_featureReferences RulesRegionAttributeMap::readFeatureReferences(RulesRegionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRegionAttributeMap::ZserioArrayType_featureValidities RulesRegionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRegionAttributeMap::ZserioArrayType_featureValidities RulesRegionAttributeMap::readFeatureValidities(RulesRegionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRegionAttributeMap::ZserioArrayType_featureValuePtr RulesRegionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRegionAttributeMap::ZserioArrayType_featureValuePtr RulesRegionAttributeMap::readFeatureValuePtr(RulesRegionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesRegionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesRegionAttributeMap::readAttribute(RulesRegionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRegionAttributeMap::ZserioArrayType_attributeValues RulesRegionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRegionAttributeMap::ZserioArrayType_attributeValues RulesRegionAttributeMap::readAttributeValues(RulesRegionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRegionAttributeMap::ZserioArrayType_attributeProperties RulesRegionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRegionAttributeMap::ZserioArrayType_attributeProperties RulesRegionAttributeMap::readAttributeProperties(RulesRegionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesRegionAttributeMap::ZserioArrayType_attributeConditions RulesRegionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesRegionAttributeMap::ZserioArrayType_attributeConditions RulesRegionAttributeMap::readAttributeConditions(RulesRegionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLineRangeAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLineRangeAttributeMap::RulesDisplayLineRangeAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesDisplayLineRangeAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesDisplayLineRangeAttributeMap::RulesDisplayLineRangeAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesDisplayLineRangeAttributeMap::RulesDisplayLineRangeAttributeMap(RulesDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesDisplayLineRangeAttributeMap::RulesDisplayLineRangeAttributeMap(const RulesDisplayLineRangeAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeMap& RulesDisplayLineRangeAttributeMap::operator=(const RulesDisplayLineRangeAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeMap::RulesDisplayLineRangeAttributeMap(RulesDisplayLineRangeAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeMap& RulesDisplayLineRangeAttributeMap::operator=(RulesDisplayLineRangeAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeMap::RulesDisplayLineRangeAttributeMap(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesDisplayLineRangeAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLineRangeAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLineRangeAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesDisplayLineRangeAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesDisplayLineRangeAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeType RulesDisplayLineRangeAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesDisplayLineRangeAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesDisplayLineRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesDisplayLineRangeAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesDisplayLineRangeAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::display::reference::types::DisplayLineReference>& RulesDisplayLineRangeAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& RulesDisplayLineRangeAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesDisplayLineRangeAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesDisplayLineRangeAttributeMap::setFeatureReferences(::zserio::vector<::nds::display::reference::types::DisplayLineReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& RulesDisplayLineRangeAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& RulesDisplayLineRangeAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesDisplayLineRangeAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesDisplayLineRangeAttributeMap::setFeatureValidities(::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesDisplayLineRangeAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesDisplayLineRangeAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesDisplayLineRangeAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesDisplayLineRangeAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesDisplayLineRangeAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesDisplayLineRangeAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttribute>& RulesDisplayLineRangeAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttribute>& RulesDisplayLineRangeAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesDisplayLineRangeAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesDisplayLineRangeAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesDisplayLineRangeAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesDisplayLineRangeAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesDisplayLineRangeAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesDisplayLineRangeAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesDisplayLineRangeAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesDisplayLineRangeAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesDisplayLineRangeAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesDisplayLineRangeAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesDisplayLineRangeAttributeMap::initPackingContext(RulesDisplayLineRangeAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesDisplayLineRangeAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeMap::bitSizeOf(RulesDisplayLineRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLineRangeAttributeMap::initializeOffsets(RulesDisplayLineRangeAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLineRangeAttributeMap::operator==(const RulesDisplayLineRangeAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesDisplayLineRangeAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesDisplayLineRangeAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeMap::write(RulesDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_featureReferences::create(RulesDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::nds::display::reference::types::DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesDisplayLineRangeAttributeMap& owner,
        ::nds::display::reference::types::DisplayLineRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesDisplayLineRangeAttributeMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_featureValidities::create(RulesDisplayLineRangeAttributeMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& array,
        ::nds::display::reference::types::DisplayLineRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLineRangeAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesDisplayLineRangeAttributeMap& owner,
        ::nds::rules::instantiations::RulesDisplayLineRangeAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(owner.getAttributeTypeCode()));
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesDisplayLineRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_attributeValues::create(RulesDisplayLineRangeAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttribute>& array,
        ::nds::rules::instantiations::RulesDisplayLineRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesDisplayLineRangeAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesDisplayLineRangeAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_attributeProperties::create(RulesDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesDisplayLineRangeAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeMap::ZserioElementFactory_attributeConditions::create(RulesDisplayLineRangeAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeType RulesDisplayLineRangeAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(in);
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeType RulesDisplayLineRangeAttributeMap::readAttributeTypeCode(RulesDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesDisplayLineRangeAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesDisplayLineRangeAttributeMap::readFeature(RulesDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLineRangeAttributeMap::ZserioArrayType_featureReferences RulesDisplayLineRangeAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLineRangeAttributeMap::ZserioArrayType_featureReferences RulesDisplayLineRangeAttributeMap::readFeatureReferences(RulesDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesDisplayLineRangeAttributeMap::ZserioArrayType_featureValidities RulesDisplayLineRangeAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLineRangeAttributeMap::ZserioArrayType_featureValidities RulesDisplayLineRangeAttributeMap::readFeatureValidities(RulesDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesDisplayLineRangeAttributeMap::ZserioArrayType_featureValuePtr RulesDisplayLineRangeAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLineRangeAttributeMap::ZserioArrayType_featureValuePtr RulesDisplayLineRangeAttributeMap::readFeatureValuePtr(RulesDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesDisplayLineRangeAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesDisplayLineRangeAttributeMap::readAttribute(RulesDisplayLineRangeAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLineRangeAttributeMap::ZserioArrayType_attributeValues RulesDisplayLineRangeAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesDisplayLineRangeAttributeMap::ZserioArrayType_attributeValues RulesDisplayLineRangeAttributeMap::readAttributeValues(RulesDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesDisplayLineRangeAttributeMap::ZserioArrayType_attributeProperties RulesDisplayLineRangeAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesDisplayLineRangeAttributeMap::ZserioArrayType_attributeProperties RulesDisplayLineRangeAttributeMap::readAttributeProperties(RulesDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesDisplayLineRangeAttributeMap::ZserioArrayType_attributeConditions RulesDisplayLineRangeAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesDisplayLineRangeAttributeMap::ZserioArrayType_attributeConditions RulesDisplayLineRangeAttributeMap::readAttributeConditions(RulesDisplayLineRangeAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLinePositionAttributeMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLinePositionAttributeMap::RulesDisplayLinePositionAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesDisplayLinePositionAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

RulesDisplayLinePositionAttributeMap::RulesDisplayLinePositionAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

RulesDisplayLinePositionAttributeMap::RulesDisplayLinePositionAttributeMap(RulesDisplayLinePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

RulesDisplayLinePositionAttributeMap::RulesDisplayLinePositionAttributeMap(const RulesDisplayLinePositionAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeMap& RulesDisplayLinePositionAttributeMap::operator=(const RulesDisplayLinePositionAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeMap::RulesDisplayLinePositionAttributeMap(RulesDisplayLinePositionAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeMap& RulesDisplayLinePositionAttributeMap::operator=(RulesDisplayLinePositionAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeMap::RulesDisplayLinePositionAttributeMap(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesDisplayLinePositionAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLinePositionAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLinePositionAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesDisplayLinePositionAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesDisplayLinePositionAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeType RulesDisplayLinePositionAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesDisplayLinePositionAttributeMap::setAttributeTypeCode(::nds::rules::attributes::RulesDisplayLinePositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator RulesDisplayLinePositionAttributeMap::getFeature() const
{
    return m_feature_;
}

void RulesDisplayLinePositionAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::display::reference::types::DisplayLineReference>& RulesDisplayLinePositionAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& RulesDisplayLinePositionAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void RulesDisplayLinePositionAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void RulesDisplayLinePositionAttributeMap::setFeatureReferences(::zserio::vector<::nds::display::reference::types::DisplayLineReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& RulesDisplayLinePositionAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& RulesDisplayLinePositionAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void RulesDisplayLinePositionAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void RulesDisplayLinePositionAttributeMap::setFeatureValidities(::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesDisplayLinePositionAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& RulesDisplayLinePositionAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void RulesDisplayLinePositionAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void RulesDisplayLinePositionAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator RulesDisplayLinePositionAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void RulesDisplayLinePositionAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttribute>& RulesDisplayLinePositionAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttribute>& RulesDisplayLinePositionAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void RulesDisplayLinePositionAttributeMap::setAttributeValues(const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void RulesDisplayLinePositionAttributeMap::setAttributeValues(::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesDisplayLinePositionAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& RulesDisplayLinePositionAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void RulesDisplayLinePositionAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void RulesDisplayLinePositionAttributeMap::setAttributeProperties(::zserio::vector<::nds::rules::instantiations::RulesPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& RulesDisplayLinePositionAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& RulesDisplayLinePositionAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void RulesDisplayLinePositionAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void RulesDisplayLinePositionAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void RulesDisplayLinePositionAttributeMap::initPackingContext(RulesDisplayLinePositionAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t RulesDisplayLinePositionAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeMap::bitSizeOf(RulesDisplayLinePositionAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLinePositionAttributeMap::initializeOffsets(RulesDisplayLinePositionAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLinePositionAttributeMap::operator==(const RulesDisplayLinePositionAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t RulesDisplayLinePositionAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void RulesDisplayLinePositionAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeMap::write(RulesDisplayLinePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesDisplayLinePositionAttributeMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_featureReferences::create(RulesDisplayLinePositionAttributeMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::nds::display::reference::types::DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(RulesDisplayLinePositionAttributeMap& owner,
        ::nds::display::reference::types::DisplayLinePositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesDisplayLinePositionAttributeMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_featureValidities::create(RulesDisplayLinePositionAttributeMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& array,
        ::nds::display::reference::types::DisplayLinePositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLinePositionAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(RulesDisplayLinePositionAttributeMap& owner,
        ::nds::rules::instantiations::RulesDisplayLinePositionAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(owner.getAttributeTypeCode()));
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesDisplayLinePositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_attributeValues::create(RulesDisplayLinePositionAttributeMap&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttribute>& array,
        ::nds::rules::instantiations::RulesDisplayLinePositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void RulesDisplayLinePositionAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(RulesDisplayLinePositionAttributeMap&,
        ::nds::rules::instantiations::RulesPropertyList& element, size_t)
{
    element.initializeChildren();
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesDisplayLinePositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_attributeProperties::create(RulesDisplayLinePositionAttributeMap&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesPropertyList>& array,
        ::nds::rules::instantiations::RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(RulesDisplayLinePositionAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesDisplayLinePositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeMap::ZserioElementFactory_attributeConditions::create(RulesDisplayLinePositionAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeType RulesDisplayLinePositionAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(in);
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeType RulesDisplayLinePositionAttributeMap::readAttributeTypeCode(RulesDisplayLinePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator RulesDisplayLinePositionAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesDisplayLinePositionAttributeMap::readFeature(RulesDisplayLinePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLinePositionAttributeMap::ZserioArrayType_featureReferences RulesDisplayLinePositionAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLinePositionAttributeMap::ZserioArrayType_featureReferences RulesDisplayLinePositionAttributeMap::readFeatureReferences(RulesDisplayLinePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesDisplayLinePositionAttributeMap::ZserioArrayType_featureValidities RulesDisplayLinePositionAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLinePositionAttributeMap::ZserioArrayType_featureValidities RulesDisplayLinePositionAttributeMap::readFeatureValidities(RulesDisplayLinePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesDisplayLinePositionAttributeMap::ZserioArrayType_featureValuePtr RulesDisplayLinePositionAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLinePositionAttributeMap::ZserioArrayType_featureValuePtr RulesDisplayLinePositionAttributeMap::readFeatureValuePtr(RulesDisplayLinePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator RulesDisplayLinePositionAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator RulesDisplayLinePositionAttributeMap::readAttribute(RulesDisplayLinePositionAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLinePositionAttributeMap::ZserioArrayType_attributeValues RulesDisplayLinePositionAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesDisplayLinePositionAttributeMap::ZserioArrayType_attributeValues RulesDisplayLinePositionAttributeMap::readAttributeValues(RulesDisplayLinePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesDisplayLinePositionAttributeMap::ZserioArrayType_attributeProperties RulesDisplayLinePositionAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesDisplayLinePositionAttributeMap::ZserioArrayType_attributeProperties RulesDisplayLinePositionAttributeMap::readAttributeProperties(RulesDisplayLinePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
RulesDisplayLinePositionAttributeMap::ZserioArrayType_attributeConditions RulesDisplayLinePositionAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

RulesDisplayLinePositionAttributeMap::ZserioArrayType_attributeConditions RulesDisplayLinePositionAttributeMap::readAttributeConditions(RulesDisplayLinePositionAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadRangeAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadRangeAttribute::RulesRoadRangeAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RulesRoadRangeAttribute::RulesRoadRangeAttribute(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRoadRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RulesRoadRangeAttribute::RulesRoadRangeAttribute(RulesRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRoadRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RulesRoadRangeAttribute::RulesRoadRangeAttribute(const RulesRoadRangeAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttribute& RulesRoadRangeAttribute::operator=(const RulesRoadRangeAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttribute::RulesRoadRangeAttribute(RulesRoadRangeAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttribute& RulesRoadRangeAttribute::operator=(RulesRoadRangeAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttribute::RulesRoadRangeAttribute(::zserio::PropagateAllocatorT,
        const RulesRoadRangeAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RulesRoadRangeAttribute::initialize(
        ::nds::rules::attributes::RulesRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadRangeAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadRangeAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()));
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadRangeAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RulesRoadRangeAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::rules::attributes::RulesRoadRangeAttributeValue& RulesRoadRangeAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesRoadRangeAttributeValue& RulesRoadRangeAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesRoadRangeAttribute::setAttributeValue(const ::nds::rules::attributes::RulesRoadRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesRoadRangeAttribute::setAttributeValue(::nds::rules::attributes::RulesRoadRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RulesRoadRangeAttribute::initPackingContext(RulesRoadRangeAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RulesRoadRangeAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttribute::bitSizeOf(RulesRoadRangeAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesRoadRangeAttribute::initializeOffsets(RulesRoadRangeAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RulesRoadRangeAttribute::operator==(const RulesRoadRangeAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RulesRoadRangeAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RulesRoadRangeAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRoadRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RulesRoadRangeAttribute::write(RulesRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRoadRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::rules::attributes::RulesRoadRangeAttributeValue RulesRoadRangeAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRoadRangeAttributeValue(in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesRoadRangeAttributeValue RulesRoadRangeAttribute::readAttributeValue(RulesRoadRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRoadRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadPositionAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadPositionAttribute::RulesRoadPositionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RulesRoadPositionAttribute::RulesRoadPositionAttribute(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRoadPositionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RulesRoadPositionAttribute::RulesRoadPositionAttribute(RulesRoadPositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRoadPositionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RulesRoadPositionAttribute::RulesRoadPositionAttribute(const RulesRoadPositionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttribute& RulesRoadPositionAttribute::operator=(const RulesRoadPositionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttribute::RulesRoadPositionAttribute(RulesRoadPositionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttribute& RulesRoadPositionAttribute::operator=(RulesRoadPositionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttribute::RulesRoadPositionAttribute(::zserio::PropagateAllocatorT,
        const RulesRoadPositionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RulesRoadPositionAttribute::initialize(
        ::nds::rules::attributes::RulesRoadPositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadPositionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadPositionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()));
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesRoadPositionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RulesRoadPositionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::rules::attributes::RulesRoadPositionAttributeValue& RulesRoadPositionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesRoadPositionAttributeValue& RulesRoadPositionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesRoadPositionAttribute::setAttributeValue(const ::nds::rules::attributes::RulesRoadPositionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesRoadPositionAttribute::setAttributeValue(::nds::rules::attributes::RulesRoadPositionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RulesRoadPositionAttribute::initPackingContext(RulesRoadPositionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RulesRoadPositionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttribute::bitSizeOf(RulesRoadPositionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesRoadPositionAttribute::initializeOffsets(RulesRoadPositionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RulesRoadPositionAttribute::operator==(const RulesRoadPositionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RulesRoadPositionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RulesRoadPositionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRoadPositionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RulesRoadPositionAttribute::write(RulesRoadPositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRoadPositionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::rules::attributes::RulesRoadPositionAttributeValue RulesRoadPositionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRoadPositionAttributeValue(in, static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesRoadPositionAttributeValue RulesRoadPositionAttribute::readAttributeValue(RulesRoadPositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRoadPositionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneRangeAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneRangeAttribute::RulesLaneRangeAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RulesLaneRangeAttribute::RulesLaneRangeAttribute(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLaneRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RulesLaneRangeAttribute::RulesLaneRangeAttribute(RulesLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLaneRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RulesLaneRangeAttribute::RulesLaneRangeAttribute(const RulesLaneRangeAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttribute& RulesLaneRangeAttribute::operator=(const RulesLaneRangeAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttribute::RulesLaneRangeAttribute(RulesLaneRangeAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttribute& RulesLaneRangeAttribute::operator=(RulesLaneRangeAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttribute::RulesLaneRangeAttribute(::zserio::PropagateAllocatorT,
        const RulesLaneRangeAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RulesLaneRangeAttribute::initialize(
        ::nds::rules::attributes::RulesLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneRangeAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneRangeAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()));
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesLaneRangeAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RulesLaneRangeAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::rules::attributes::RulesLaneRangeAttributeValue& RulesLaneRangeAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesLaneRangeAttributeValue& RulesLaneRangeAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesLaneRangeAttribute::setAttributeValue(const ::nds::rules::attributes::RulesLaneRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesLaneRangeAttribute::setAttributeValue(::nds::rules::attributes::RulesLaneRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RulesLaneRangeAttribute::initPackingContext(RulesLaneRangeAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RulesLaneRangeAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttribute::bitSizeOf(RulesLaneRangeAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesLaneRangeAttribute::initializeOffsets(RulesLaneRangeAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RulesLaneRangeAttribute::operator==(const RulesLaneRangeAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RulesLaneRangeAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RulesLaneRangeAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLaneRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RulesLaneRangeAttribute::write(RulesLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLaneRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::rules::attributes::RulesLaneRangeAttributeValue RulesLaneRangeAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLaneRangeAttributeValue(in, static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesLaneRangeAttributeValue RulesLaneRangeAttribute::readAttributeValue(RulesLaneRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLaneRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLanePositionAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLanePositionAttribute::RulesLanePositionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RulesLanePositionAttribute::RulesLanePositionAttribute(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLanePositionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RulesLanePositionAttribute::RulesLanePositionAttribute(RulesLanePositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLanePositionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RulesLanePositionAttribute::RulesLanePositionAttribute(const RulesLanePositionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttribute& RulesLanePositionAttribute::operator=(const RulesLanePositionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttribute::RulesLanePositionAttribute(RulesLanePositionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttribute& RulesLanePositionAttribute::operator=(RulesLanePositionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttribute::RulesLanePositionAttribute(::zserio::PropagateAllocatorT,
        const RulesLanePositionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RulesLanePositionAttribute::initialize(
        ::nds::rules::attributes::RulesLanePositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLanePositionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RulesLanePositionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()));
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesLanePositionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RulesLanePositionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::rules::attributes::RulesLanePositionAttributeValue& RulesLanePositionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesLanePositionAttributeValue& RulesLanePositionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesLanePositionAttribute::setAttributeValue(const ::nds::rules::attributes::RulesLanePositionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesLanePositionAttribute::setAttributeValue(::nds::rules::attributes::RulesLanePositionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RulesLanePositionAttribute::initPackingContext(RulesLanePositionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RulesLanePositionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttribute::bitSizeOf(RulesLanePositionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesLanePositionAttribute::initializeOffsets(RulesLanePositionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RulesLanePositionAttribute::operator==(const RulesLanePositionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RulesLanePositionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RulesLanePositionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLanePositionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RulesLanePositionAttribute::write(RulesLanePositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLanePositionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::rules::attributes::RulesLanePositionAttributeValue RulesLanePositionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLanePositionAttributeValue(in, static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesLanePositionAttributeValue RulesLanePositionAttribute::readAttributeValue(RulesLanePositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLanePositionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesTransitionAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesTransitionAttribute::RulesTransitionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RulesTransitionAttribute::RulesTransitionAttribute(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RulesTransitionAttribute::RulesTransitionAttribute(RulesTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RulesTransitionAttribute::RulesTransitionAttribute(const RulesTransitionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesTransitionAttribute& RulesTransitionAttribute::operator=(const RulesTransitionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttribute::RulesTransitionAttribute(RulesTransitionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesTransitionAttribute& RulesTransitionAttribute::operator=(RulesTransitionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttribute::RulesTransitionAttribute(::zserio::PropagateAllocatorT,
        const RulesTransitionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RulesTransitionAttribute::initialize(
        ::nds::rules::attributes::RulesTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesTransitionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RulesTransitionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()));
}

::nds::rules::attributes::RulesTransitionAttributeType RulesTransitionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RulesTransitionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::rules::attributes::RulesTransitionAttributeValue& RulesTransitionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesTransitionAttributeValue& RulesTransitionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesTransitionAttribute::setAttributeValue(const ::nds::rules::attributes::RulesTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesTransitionAttribute::setAttributeValue(::nds::rules::attributes::RulesTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RulesTransitionAttribute::initPackingContext(RulesTransitionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RulesTransitionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttribute::bitSizeOf(RulesTransitionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesTransitionAttribute::initializeOffsets(RulesTransitionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RulesTransitionAttribute::operator==(const RulesTransitionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RulesTransitionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RulesTransitionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RulesTransitionAttribute::write(RulesTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::rules::attributes::RulesTransitionAttributeValue RulesTransitionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesTransitionAttributeValue(in, static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesTransitionAttributeValue RulesTransitionAttribute::readAttributeValue(RulesTransitionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneTransitionAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneTransitionAttribute::RulesLaneTransitionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RulesLaneTransitionAttribute::RulesLaneTransitionAttribute(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesLaneTransitionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RulesLaneTransitionAttribute::RulesLaneTransitionAttribute(const RulesLaneTransitionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttribute& RulesLaneTransitionAttribute::operator=(const RulesLaneTransitionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttribute::RulesLaneTransitionAttribute(RulesLaneTransitionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttribute& RulesLaneTransitionAttribute::operator=(RulesLaneTransitionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttribute::RulesLaneTransitionAttribute(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RulesLaneTransitionAttribute::initialize(
        ::nds::rules::attributes::RulesLaneTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneTransitionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneTransitionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()));
}

::nds::rules::attributes::RulesLaneTransitionAttributeType RulesLaneTransitionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RulesLaneTransitionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::rules::attributes::RulesLaneTransitionAttributeValue& RulesLaneTransitionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesLaneTransitionAttributeValue& RulesLaneTransitionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesLaneTransitionAttribute::setAttributeValue(const ::nds::rules::attributes::RulesLaneTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesLaneTransitionAttribute::setAttributeValue(::nds::rules::attributes::RulesLaneTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

size_t RulesLaneTransitionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

bool RulesLaneTransitionAttribute::operator==(const RulesLaneTransitionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RulesLaneTransitionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RulesLaneTransitionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLaneTransitionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

::nds::rules::attributes::RulesLaneTransitionAttributeValue RulesLaneTransitionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLaneTransitionAttributeValue(in, static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRegionAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRegionAttribute::RulesRegionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RulesRegionAttribute::RulesRegionAttribute(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRegionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RulesRegionAttribute::RulesRegionAttribute(RulesRegionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesRegionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RulesRegionAttribute::RulesRegionAttribute(const RulesRegionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesRegionAttribute& RulesRegionAttribute::operator=(const RulesRegionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttribute::RulesRegionAttribute(RulesRegionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesRegionAttribute& RulesRegionAttribute::operator=(RulesRegionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttribute::RulesRegionAttribute(::zserio::PropagateAllocatorT,
        const RulesRegionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RulesRegionAttribute::initialize(
        ::nds::rules::attributes::RulesRegionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRegionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RulesRegionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()));
}

::nds::rules::attributes::RulesRegionAttributeType RulesRegionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RulesRegionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::rules::attributes::RulesRegionAttributeValue& RulesRegionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesRegionAttributeValue& RulesRegionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesRegionAttribute::setAttributeValue(const ::nds::rules::attributes::RulesRegionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesRegionAttribute::setAttributeValue(::nds::rules::attributes::RulesRegionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RulesRegionAttribute::initPackingContext(RulesRegionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RulesRegionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttribute::bitSizeOf(RulesRegionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesRegionAttribute::initializeOffsets(RulesRegionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RulesRegionAttribute::operator==(const RulesRegionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RulesRegionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RulesRegionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRegionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RulesRegionAttribute::write(RulesRegionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRegionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::rules::attributes::RulesRegionAttributeValue RulesRegionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRegionAttributeValue(in, static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesRegionAttributeValue RulesRegionAttribute::readAttributeValue(RulesRegionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRegionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLineRangeAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLineRangeAttribute::RulesDisplayLineRangeAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RulesDisplayLineRangeAttribute::RulesDisplayLineRangeAttribute(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesDisplayLineRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RulesDisplayLineRangeAttribute::RulesDisplayLineRangeAttribute(RulesDisplayLineRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesDisplayLineRangeAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RulesDisplayLineRangeAttribute::RulesDisplayLineRangeAttribute(const RulesDisplayLineRangeAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttribute& RulesDisplayLineRangeAttribute::operator=(const RulesDisplayLineRangeAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttribute::RulesDisplayLineRangeAttribute(RulesDisplayLineRangeAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttribute& RulesDisplayLineRangeAttribute::operator=(RulesDisplayLineRangeAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttribute::RulesDisplayLineRangeAttribute(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RulesDisplayLineRangeAttribute::initialize(
        ::nds::rules::attributes::RulesDisplayLineRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLineRangeAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLineRangeAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()));
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeType RulesDisplayLineRangeAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RulesDisplayLineRangeAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeValue& RulesDisplayLineRangeAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesDisplayLineRangeAttributeValue& RulesDisplayLineRangeAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesDisplayLineRangeAttribute::setAttributeValue(const ::nds::rules::attributes::RulesDisplayLineRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesDisplayLineRangeAttribute::setAttributeValue(::nds::rules::attributes::RulesDisplayLineRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RulesDisplayLineRangeAttribute::initPackingContext(RulesDisplayLineRangeAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RulesDisplayLineRangeAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttribute::bitSizeOf(RulesDisplayLineRangeAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLineRangeAttribute::initializeOffsets(RulesDisplayLineRangeAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLineRangeAttribute::operator==(const RulesDisplayLineRangeAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RulesDisplayLineRangeAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RulesDisplayLineRangeAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesDisplayLineRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RulesDisplayLineRangeAttribute::write(RulesDisplayLineRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesDisplayLineRangeAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeValue RulesDisplayLineRangeAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesDisplayLineRangeAttributeValue(in, static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeValue RulesDisplayLineRangeAttribute::readAttributeValue(RulesDisplayLineRangeAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesDisplayLineRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLinePositionAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLinePositionAttribute::RulesDisplayLinePositionAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

RulesDisplayLinePositionAttribute::RulesDisplayLinePositionAttribute(::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesDisplayLinePositionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

RulesDisplayLinePositionAttribute::RulesDisplayLinePositionAttribute(RulesDisplayLinePositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::rules::attributes::RulesDisplayLinePositionAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

RulesDisplayLinePositionAttribute::RulesDisplayLinePositionAttribute(const RulesDisplayLinePositionAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttribute& RulesDisplayLinePositionAttribute::operator=(const RulesDisplayLinePositionAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttribute::RulesDisplayLinePositionAttribute(RulesDisplayLinePositionAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttribute& RulesDisplayLinePositionAttribute::operator=(RulesDisplayLinePositionAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttribute::RulesDisplayLinePositionAttribute(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void RulesDisplayLinePositionAttribute::initialize(
        ::nds::rules::attributes::RulesDisplayLinePositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLinePositionAttribute::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLinePositionAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()));
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeType RulesDisplayLinePositionAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'RulesDisplayLinePositionAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeValue& RulesDisplayLinePositionAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesDisplayLinePositionAttributeValue& RulesDisplayLinePositionAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesDisplayLinePositionAttribute::setAttributeValue(const ::nds::rules::attributes::RulesDisplayLinePositionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesDisplayLinePositionAttribute::setAttributeValue(::nds::rules::attributes::RulesDisplayLinePositionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void RulesDisplayLinePositionAttribute::initPackingContext(RulesDisplayLinePositionAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t RulesDisplayLinePositionAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttribute::bitSizeOf(RulesDisplayLinePositionAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLinePositionAttribute::initializeOffsets(RulesDisplayLinePositionAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLinePositionAttribute::operator==(const RulesDisplayLinePositionAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t RulesDisplayLinePositionAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void RulesDisplayLinePositionAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesDisplayLinePositionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void RulesDisplayLinePositionAttribute::write(RulesDisplayLinePositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesDisplayLinePositionAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeValue RulesDisplayLinePositionAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesDisplayLinePositionAttributeValue(in, static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeValue RulesDisplayLinePositionAttribute::readAttributeValue(RulesDisplayLinePositionAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesDisplayLinePositionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesProperty.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesProperty::RulesProperty(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_propertyTypeCode_(allocator),
        m_propertyValue_(allocator)
{
}

RulesProperty::RulesProperty(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(in, allocator)),
        m_propertyValue_(readPropertyValue(in, allocator))
{
}

RulesProperty::RulesProperty(RulesProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(context, in, allocator)),
        m_propertyValue_(readPropertyValue(context, in, allocator))
{
}

RulesProperty::RulesProperty(const RulesProperty& other) :
        m_propertyTypeCode_(other.m_propertyTypeCode_),
        m_propertyValue_(other.m_propertyValue_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesProperty& RulesProperty::operator=(const RulesProperty& other)
{
    m_propertyTypeCode_ = other.m_propertyTypeCode_;
    m_propertyValue_ = other.m_propertyValue_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesProperty::RulesProperty(RulesProperty&& other) :
        m_propertyTypeCode_(::std::move(other.m_propertyTypeCode_)),
        m_propertyValue_(::std::move(other.m_propertyValue_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesProperty& RulesProperty::operator=(RulesProperty&& other)
{
    m_propertyTypeCode_ = ::std::move(other.m_propertyTypeCode_);
    m_propertyValue_ = ::std::move(other.m_propertyValue_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesProperty::RulesProperty(::zserio::PropagateAllocatorT,
        const RulesProperty& other, const allocator_type& allocator) :
        m_propertyTypeCode_(::zserio::allocatorPropagatingCopy(other.m_propertyTypeCode_, allocator)),
        m_propertyValue_(::zserio::allocatorPropagatingCopy(other.m_propertyValue_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesProperty::initializeChildren()
{
    m_propertyValue_.initialize(getPropertyTypeCode());

    m_areChildrenInitialized = true;
}

::nds::rules::properties::RulesPropertyType& RulesProperty::getPropertyTypeCode()
{
    return m_propertyTypeCode_;
}

const ::nds::rules::properties::RulesPropertyType& RulesProperty::getPropertyTypeCode() const
{
    return m_propertyTypeCode_;
}

void RulesProperty::setPropertyTypeCode(const ::nds::rules::properties::RulesPropertyType& propertyTypeCode_)
{
    m_propertyTypeCode_ = propertyTypeCode_;
}

void RulesProperty::setPropertyTypeCode(::nds::rules::properties::RulesPropertyType&& propertyTypeCode_)
{
    m_propertyTypeCode_ = ::std::move(propertyTypeCode_);
}

::nds::rules::properties::RulesPropertyValue& RulesProperty::getPropertyValue()
{
    return m_propertyValue_;
}

const ::nds::rules::properties::RulesPropertyValue& RulesProperty::getPropertyValue() const
{
    return m_propertyValue_;
}

void RulesProperty::setPropertyValue(const ::nds::rules::properties::RulesPropertyValue& propertyValue_)
{
    m_propertyValue_ = propertyValue_;
}

void RulesProperty::setPropertyValue(::nds::rules::properties::RulesPropertyValue&& propertyValue_)
{
    m_propertyValue_ = ::std::move(propertyValue_);
}

void RulesProperty::initPackingContext(RulesProperty::ZserioPackingContext& context) const
{
    m_propertyTypeCode_.initPackingContext(context.getPropertyTypeCode());
    m_propertyValue_.initPackingContext(context.getPropertyValue());
}

size_t RulesProperty::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesProperty::bitSizeOf(RulesProperty::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(context.getPropertyValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesProperty::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RulesProperty::initializeOffsets(RulesProperty::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(context.getPropertyValue(), endBitPosition);

    return endBitPosition;
}

bool RulesProperty::operator==(const RulesProperty& other) const
{
    if (this != &other)
    {
        return
                (m_propertyTypeCode_ == other.m_propertyTypeCode_) &&
                (m_propertyValue_ == other.m_propertyValue_);
    }

    return true;
}

uint32_t RulesProperty::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_propertyTypeCode_);
    result = ::zserio::calcHashCode(result, m_propertyValue_);

    return result;
}

void RulesProperty::write(::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field RulesProperty.propertyValue!");
    }
    m_propertyValue_.write(out);
}

void RulesProperty::write(RulesProperty::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(context.getPropertyTypeCode(), out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field RulesProperty.propertyValue!");
    }
    m_propertyValue_.write(context.getPropertyValue(), out);
}

::nds::rules::properties::RulesPropertyType RulesProperty::readPropertyTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::properties::RulesPropertyType(in, allocator);
}

::nds::rules::properties::RulesPropertyType RulesProperty::readPropertyTypeCode(RulesProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::properties::RulesPropertyType(context.getPropertyTypeCode(), in, allocator);
}
::nds::rules::properties::RulesPropertyValue RulesProperty::readPropertyValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::properties::RulesPropertyValue(in, getPropertyTypeCode(), allocator);
}

::nds::rules::properties::RulesPropertyValue RulesProperty::readPropertyValue(RulesProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::properties::RulesPropertyValue(context.getPropertyValue(), in, getPropertyTypeCode(), allocator);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRegionAttributeSet.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRegionAttributeSet::RulesRegionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RulesRegionAttributeSet::RulesRegionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RulesRegionAttributeSet::RulesRegionAttributeSet(RulesRegionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RulesRegionAttributeSet::RulesRegionAttributeSet(::zserio::PropagateAllocatorT,
        const RulesRegionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RulesRegionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RulesRegionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RulesRegionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::rules::instantiations::RulesRegionFullAttribute>& RulesRegionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRegionFullAttribute>& RulesRegionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RulesRegionAttributeSet::setAttributes(const ::zserio::vector<::nds::rules::instantiations::RulesRegionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RulesRegionAttributeSet::setAttributes(::zserio::vector<::nds::rules::instantiations::RulesRegionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RulesRegionAttributeSet::initPackingContext(RulesRegionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RulesRegionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeSet::bitSizeOf(RulesRegionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRegionAttributeSet::initializeOffsets(RulesRegionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRegionAttributeSet::operator==(const RulesRegionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RulesRegionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RulesRegionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesRegionAttributeSet::write(RulesRegionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesRegionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RulesRegionAttributeSet&,
        ::nds::rules::instantiations::RulesRegionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RulesRegionAttributeSet::ZserioElementFactory_attributes::create(RulesRegionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesRegionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRegionAttributeSet::ZserioElementFactory_attributes::create(RulesRegionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesRegionFullAttribute>& array,
        ::nds::rules::instantiations::RulesRegionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RulesRegionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRegionAttributeSet::readNumEntries(RulesRegionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRegionAttributeSet::ZserioArrayType_attributes RulesRegionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RulesRegionAttributeSet::ZserioArrayType_attributes RulesRegionAttributeSet::readAttributes(RulesRegionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadRangeAttributeSet.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadRangeAttributeSet::RulesRoadRangeAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RulesRoadRangeAttributeSet::RulesRoadRangeAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RulesRoadRangeAttributeSet::RulesRoadRangeAttributeSet(RulesRoadRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RulesRoadRangeAttributeSet::RulesRoadRangeAttributeSet(::zserio::PropagateAllocatorT,
        const RulesRoadRangeAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RulesRoadRangeAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RulesRoadRangeAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RulesRoadRangeAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadRangeFullAttribute>& RulesRoadRangeAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeFullAttribute>& RulesRoadRangeAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RulesRoadRangeAttributeSet::setAttributes(const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RulesRoadRangeAttributeSet::setAttributes(::zserio::vector<::nds::rules::instantiations::RulesRoadRangeFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RulesRoadRangeAttributeSet::initPackingContext(RulesRoadRangeAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RulesRoadRangeAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeSet::bitSizeOf(RulesRoadRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadRangeAttributeSet::initializeOffsets(RulesRoadRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadRangeAttributeSet::operator==(const RulesRoadRangeAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RulesRoadRangeAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RulesRoadRangeAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesRoadRangeAttributeSet::write(RulesRoadRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesRoadRangeAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RulesRoadRangeAttributeSet&,
        ::nds::rules::instantiations::RulesRoadRangeFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadRangeAttributeSet::ZserioElementFactory_attributes::create(RulesRoadRangeAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadRangeAttributeSet::ZserioElementFactory_attributes::create(RulesRoadRangeAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeFullAttribute>& array,
        ::nds::rules::instantiations::RulesRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RulesRoadRangeAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadRangeAttributeSet::readNumEntries(RulesRoadRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadRangeAttributeSet::ZserioArrayType_attributes RulesRoadRangeAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RulesRoadRangeAttributeSet::ZserioArrayType_attributes RulesRoadRangeAttributeSet::readAttributes(RulesRoadRangeAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadPositionAttributeSet.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadPositionAttributeSet::RulesRoadPositionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RulesRoadPositionAttributeSet::RulesRoadPositionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RulesRoadPositionAttributeSet::RulesRoadPositionAttributeSet(RulesRoadPositionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RulesRoadPositionAttributeSet::RulesRoadPositionAttributeSet(::zserio::PropagateAllocatorT,
        const RulesRoadPositionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RulesRoadPositionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RulesRoadPositionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RulesRoadPositionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadPositionFullAttribute>& RulesRoadPositionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionFullAttribute>& RulesRoadPositionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RulesRoadPositionAttributeSet::setAttributes(const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RulesRoadPositionAttributeSet::setAttributes(::zserio::vector<::nds::rules::instantiations::RulesRoadPositionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RulesRoadPositionAttributeSet::initPackingContext(RulesRoadPositionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RulesRoadPositionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeSet::bitSizeOf(RulesRoadPositionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadPositionAttributeSet::initializeOffsets(RulesRoadPositionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadPositionAttributeSet::operator==(const RulesRoadPositionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RulesRoadPositionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RulesRoadPositionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesRoadPositionAttributeSet::write(RulesRoadPositionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesRoadPositionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RulesRoadPositionAttributeSet&,
        ::nds::rules::instantiations::RulesRoadPositionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RulesRoadPositionAttributeSet::ZserioElementFactory_attributes::create(RulesRoadPositionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadPositionAttributeSet::ZserioElementFactory_attributes::create(RulesRoadPositionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionFullAttribute>& array,
        ::nds::rules::instantiations::RulesRoadPositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RulesRoadPositionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadPositionAttributeSet::readNumEntries(RulesRoadPositionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadPositionAttributeSet::ZserioArrayType_attributes RulesRoadPositionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RulesRoadPositionAttributeSet::ZserioArrayType_attributes RulesRoadPositionAttributeSet::readAttributes(RulesRoadPositionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneRangeAttributeSet.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneRangeAttributeSet::RulesLaneRangeAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RulesLaneRangeAttributeSet::RulesLaneRangeAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RulesLaneRangeAttributeSet::RulesLaneRangeAttributeSet(RulesLaneRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RulesLaneRangeAttributeSet::RulesLaneRangeAttributeSet(::zserio::PropagateAllocatorT,
        const RulesLaneRangeAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RulesLaneRangeAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RulesLaneRangeAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RulesLaneRangeAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::rules::instantiations::RulesLaneRangeFullAttribute>& RulesLaneRangeAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeFullAttribute>& RulesLaneRangeAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RulesLaneRangeAttributeSet::setAttributes(const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RulesLaneRangeAttributeSet::setAttributes(::zserio::vector<::nds::rules::instantiations::RulesLaneRangeFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RulesLaneRangeAttributeSet::initPackingContext(RulesLaneRangeAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RulesLaneRangeAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeSet::bitSizeOf(RulesLaneRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneRangeAttributeSet::initializeOffsets(RulesLaneRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneRangeAttributeSet::operator==(const RulesLaneRangeAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RulesLaneRangeAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RulesLaneRangeAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesLaneRangeAttributeSet::write(RulesLaneRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesLaneRangeAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RulesLaneRangeAttributeSet&,
        ::nds::rules::instantiations::RulesLaneRangeFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RulesLaneRangeAttributeSet::ZserioElementFactory_attributes::create(RulesLaneRangeAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneRangeAttributeSet::ZserioElementFactory_attributes::create(RulesLaneRangeAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeFullAttribute>& array,
        ::nds::rules::instantiations::RulesLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RulesLaneRangeAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesLaneRangeAttributeSet::readNumEntries(RulesLaneRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneRangeAttributeSet::ZserioArrayType_attributes RulesLaneRangeAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RulesLaneRangeAttributeSet::ZserioArrayType_attributes RulesLaneRangeAttributeSet::readAttributes(RulesLaneRangeAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLanePositionAttributeSet.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLanePositionAttributeSet::RulesLanePositionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RulesLanePositionAttributeSet::RulesLanePositionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RulesLanePositionAttributeSet::RulesLanePositionAttributeSet(RulesLanePositionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RulesLanePositionAttributeSet::RulesLanePositionAttributeSet(::zserio::PropagateAllocatorT,
        const RulesLanePositionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RulesLanePositionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RulesLanePositionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RulesLanePositionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::rules::instantiations::RulesLanePositionFullAttribute>& RulesLanePositionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionFullAttribute>& RulesLanePositionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RulesLanePositionAttributeSet::setAttributes(const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RulesLanePositionAttributeSet::setAttributes(::zserio::vector<::nds::rules::instantiations::RulesLanePositionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RulesLanePositionAttributeSet::initPackingContext(RulesLanePositionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RulesLanePositionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeSet::bitSizeOf(RulesLanePositionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLanePositionAttributeSet::initializeOffsets(RulesLanePositionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLanePositionAttributeSet::operator==(const RulesLanePositionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RulesLanePositionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RulesLanePositionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesLanePositionAttributeSet::write(RulesLanePositionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesLanePositionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RulesLanePositionAttributeSet&,
        ::nds::rules::instantiations::RulesLanePositionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RulesLanePositionAttributeSet::ZserioElementFactory_attributes::create(RulesLanePositionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLanePositionAttributeSet::ZserioElementFactory_attributes::create(RulesLanePositionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionFullAttribute>& array,
        ::nds::rules::instantiations::RulesLanePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RulesLanePositionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesLanePositionAttributeSet::readNumEntries(RulesLanePositionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLanePositionAttributeSet::ZserioArrayType_attributes RulesLanePositionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RulesLanePositionAttributeSet::ZserioArrayType_attributes RulesLanePositionAttributeSet::readAttributes(RulesLanePositionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesTransitionAttributeSet.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesTransitionAttributeSet::RulesTransitionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RulesTransitionAttributeSet::RulesTransitionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RulesTransitionAttributeSet::RulesTransitionAttributeSet(RulesTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RulesTransitionAttributeSet::RulesTransitionAttributeSet(::zserio::PropagateAllocatorT,
        const RulesTransitionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RulesTransitionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RulesTransitionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RulesTransitionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::rules::instantiations::RulesTransitionFullAttribute>& RulesTransitionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesTransitionFullAttribute>& RulesTransitionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RulesTransitionAttributeSet::setAttributes(const ::zserio::vector<::nds::rules::instantiations::RulesTransitionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RulesTransitionAttributeSet::setAttributes(::zserio::vector<::nds::rules::instantiations::RulesTransitionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RulesTransitionAttributeSet::initPackingContext(RulesTransitionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RulesTransitionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeSet::bitSizeOf(RulesTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesTransitionAttributeSet::initializeOffsets(RulesTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesTransitionAttributeSet::operator==(const RulesTransitionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RulesTransitionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RulesTransitionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesTransitionAttributeSet::write(RulesTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesTransitionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RulesTransitionAttributeSet&,
        ::nds::rules::instantiations::RulesTransitionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RulesTransitionAttributeSet::ZserioElementFactory_attributes::create(RulesTransitionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesTransitionAttributeSet::ZserioElementFactory_attributes::create(RulesTransitionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionFullAttribute>& array,
        ::nds::rules::instantiations::RulesTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RulesTransitionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesTransitionAttributeSet::readNumEntries(RulesTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RulesTransitionAttributeSet::ZserioArrayType_attributes RulesTransitionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RulesTransitionAttributeSet::ZserioArrayType_attributes RulesTransitionAttributeSet::readAttributes(RulesTransitionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneTransitionAttributeSet.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneTransitionAttributeSet::RulesLaneTransitionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RulesLaneTransitionAttributeSet::RulesLaneTransitionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RulesLaneTransitionAttributeSet::RulesLaneTransitionAttributeSet(RulesLaneTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RulesLaneTransitionAttributeSet::RulesLaneTransitionAttributeSet(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RulesLaneTransitionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RulesLaneTransitionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RulesLaneTransitionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionFullAttribute>& RulesLaneTransitionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionFullAttribute>& RulesLaneTransitionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RulesLaneTransitionAttributeSet::setAttributes(const ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RulesLaneTransitionAttributeSet::setAttributes(::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RulesLaneTransitionAttributeSet::initPackingContext(RulesLaneTransitionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RulesLaneTransitionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeSet::bitSizeOf(RulesLaneTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneTransitionAttributeSet::initializeOffsets(RulesLaneTransitionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneTransitionAttributeSet::operator==(const RulesLaneTransitionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RulesLaneTransitionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RulesLaneTransitionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeSet::write(RulesLaneTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RulesLaneTransitionAttributeSet&,
        ::nds::rules::instantiations::RulesLaneTransitionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RulesLaneTransitionAttributeSet::ZserioElementFactory_attributes::create(RulesLaneTransitionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneTransitionAttributeSet::ZserioElementFactory_attributes::create(RulesLaneTransitionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionFullAttribute>& array,
        ::nds::rules::instantiations::RulesLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RulesLaneTransitionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesLaneTransitionAttributeSet::readNumEntries(RulesLaneTransitionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneTransitionAttributeSet::ZserioArrayType_attributes RulesLaneTransitionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RulesLaneTransitionAttributeSet::ZserioArrayType_attributes RulesLaneTransitionAttributeSet::readAttributes(RulesLaneTransitionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLineRangeAttributeSet.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLineRangeAttributeSet::RulesDisplayLineRangeAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RulesDisplayLineRangeAttributeSet::RulesDisplayLineRangeAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RulesDisplayLineRangeAttributeSet::RulesDisplayLineRangeAttributeSet(RulesDisplayLineRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RulesDisplayLineRangeAttributeSet::RulesDisplayLineRangeAttributeSet(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RulesDisplayLineRangeAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RulesDisplayLineRangeAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RulesDisplayLineRangeAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeFullAttribute>& RulesDisplayLineRangeAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeFullAttribute>& RulesDisplayLineRangeAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RulesDisplayLineRangeAttributeSet::setAttributes(const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RulesDisplayLineRangeAttributeSet::setAttributes(::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RulesDisplayLineRangeAttributeSet::initPackingContext(RulesDisplayLineRangeAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RulesDisplayLineRangeAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeSet::bitSizeOf(RulesDisplayLineRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLineRangeAttributeSet::initializeOffsets(RulesDisplayLineRangeAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLineRangeAttributeSet::operator==(const RulesDisplayLineRangeAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RulesDisplayLineRangeAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RulesDisplayLineRangeAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeSet::write(RulesDisplayLineRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RulesDisplayLineRangeAttributeSet&,
        ::nds::rules::instantiations::RulesDisplayLineRangeFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RulesDisplayLineRangeAttributeSet::ZserioElementFactory_attributes::create(RulesDisplayLineRangeAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeSet::ZserioElementFactory_attributes::create(RulesDisplayLineRangeAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeFullAttribute>& array,
        ::nds::rules::instantiations::RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RulesDisplayLineRangeAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesDisplayLineRangeAttributeSet::readNumEntries(RulesDisplayLineRangeAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLineRangeAttributeSet::ZserioArrayType_attributes RulesDisplayLineRangeAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RulesDisplayLineRangeAttributeSet::ZserioArrayType_attributes RulesDisplayLineRangeAttributeSet::readAttributes(RulesDisplayLineRangeAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLinePositionAttributeSet.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLinePositionAttributeSet::RulesDisplayLinePositionAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

RulesDisplayLinePositionAttributeSet::RulesDisplayLinePositionAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

RulesDisplayLinePositionAttributeSet::RulesDisplayLinePositionAttributeSet(RulesDisplayLinePositionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

RulesDisplayLinePositionAttributeSet::RulesDisplayLinePositionAttributeSet(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void RulesDisplayLinePositionAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t RulesDisplayLinePositionAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void RulesDisplayLinePositionAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionFullAttribute>& RulesDisplayLinePositionAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionFullAttribute>& RulesDisplayLinePositionAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void RulesDisplayLinePositionAttributeSet::setAttributes(const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void RulesDisplayLinePositionAttributeSet::setAttributes(::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void RulesDisplayLinePositionAttributeSet::initPackingContext(RulesDisplayLinePositionAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t RulesDisplayLinePositionAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeSet::bitSizeOf(RulesDisplayLinePositionAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLinePositionAttributeSet::initializeOffsets(RulesDisplayLinePositionAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLinePositionAttributeSet::operator==(const RulesDisplayLinePositionAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t RulesDisplayLinePositionAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void RulesDisplayLinePositionAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeSet::write(RulesDisplayLinePositionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeSet::ZserioArrayExpressions_attributes::initializeElement(RulesDisplayLinePositionAttributeSet&,
        ::nds::rules::instantiations::RulesDisplayLinePositionFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void RulesDisplayLinePositionAttributeSet::ZserioElementFactory_attributes::create(RulesDisplayLinePositionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeSet::ZserioElementFactory_attributes::create(RulesDisplayLinePositionAttributeSet&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionFullAttribute>& array,
        ::nds::rules::instantiations::RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t RulesDisplayLinePositionAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesDisplayLinePositionAttributeSet::readNumEntries(RulesDisplayLinePositionAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLinePositionAttributeSet::ZserioArrayType_attributes RulesDisplayLinePositionAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

RulesDisplayLinePositionAttributeSet::ZserioArrayType_attributes RulesDisplayLinePositionAttributeSet::readAttributes(RulesDisplayLinePositionAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRegionFullAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRegionFullAttribute::RulesRegionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesRegionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RulesRegionFullAttribute::RulesRegionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RulesRegionFullAttribute::RulesRegionFullAttribute(RulesRegionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RulesRegionFullAttribute::RulesRegionFullAttribute(const RulesRegionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesRegionFullAttribute& RulesRegionFullAttribute::operator=(const RulesRegionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesRegionFullAttribute::RulesRegionFullAttribute(RulesRegionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesRegionFullAttribute& RulesRegionFullAttribute::operator=(RulesRegionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesRegionFullAttribute::RulesRegionFullAttribute(::zserio::PropagateAllocatorT,
        const RulesRegionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesRegionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::rules::attributes::RulesRegionAttributeType RulesRegionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesRegionFullAttribute::setAttributeTypeCode(::nds::rules::attributes::RulesRegionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::rules::attributes::RulesRegionAttributeValue& RulesRegionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesRegionAttributeValue& RulesRegionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesRegionFullAttribute::setAttributeValue(const ::nds::rules::attributes::RulesRegionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesRegionFullAttribute::setAttributeValue(::nds::rules::attributes::RulesRegionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::rules::instantiations::RulesPropertyList& RulesRegionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::rules::instantiations::RulesPropertyList& RulesRegionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RulesRegionFullAttribute::setProperties(const ::nds::rules::instantiations::RulesPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RulesRegionFullAttribute::setProperties(::nds::rules::instantiations::RulesPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RulesRegionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RulesRegionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RulesRegionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RulesRegionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RulesRegionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RulesRegionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RulesRegionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RulesRegionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RulesRegionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RulesRegionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RulesRegionFullAttribute::initPackingContext(RulesRegionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RulesRegionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesRegionFullAttribute::bitSizeOf(RulesRegionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesRegionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesRegionFullAttribute::initializeOffsets(RulesRegionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesRegionFullAttribute::operator==(const RulesRegionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RulesRegionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RulesRegionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRegionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RulesRegionFullAttribute::write(RulesRegionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRegionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::rules::attributes::RulesRegionAttributeType RulesRegionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRegionAttributeType>(in);
}

::nds::rules::attributes::RulesRegionAttributeType RulesRegionFullAttribute::readAttributeTypeCode(RulesRegionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRegionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::rules::attributes::RulesRegionAttributeValue RulesRegionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRegionAttributeValue(in, static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesRegionAttributeValue RulesRegionFullAttribute::readAttributeValue(RulesRegionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRegionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesRegionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesRegionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesRegionFullAttribute::readProperties(RulesRegionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesRegionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesRegionFullAttribute::readConditions(RulesRegionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadRangeFullAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadRangeFullAttribute::RulesRoadRangeFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesRoadRangeAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RulesRoadRangeFullAttribute::RulesRoadRangeFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RulesRoadRangeFullAttribute::RulesRoadRangeFullAttribute(RulesRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RulesRoadRangeFullAttribute::RulesRoadRangeFullAttribute(const RulesRoadRangeFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesRoadRangeFullAttribute& RulesRoadRangeFullAttribute::operator=(const RulesRoadRangeFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesRoadRangeFullAttribute::RulesRoadRangeFullAttribute(RulesRoadRangeFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesRoadRangeFullAttribute& RulesRoadRangeFullAttribute::operator=(RulesRoadRangeFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesRoadRangeFullAttribute::RulesRoadRangeFullAttribute(::zserio::PropagateAllocatorT,
        const RulesRoadRangeFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesRoadRangeFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadRangeFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesRoadRangeFullAttribute::setAttributeTypeCode(::nds::rules::attributes::RulesRoadRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::rules::attributes::RulesRoadRangeAttributeValue& RulesRoadRangeFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesRoadRangeAttributeValue& RulesRoadRangeFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesRoadRangeFullAttribute::setAttributeValue(const ::nds::rules::attributes::RulesRoadRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesRoadRangeFullAttribute::setAttributeValue(::nds::rules::attributes::RulesRoadRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::rules::instantiations::RulesPropertyList& RulesRoadRangeFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::rules::instantiations::RulesPropertyList& RulesRoadRangeFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RulesRoadRangeFullAttribute::setProperties(const ::nds::rules::instantiations::RulesPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RulesRoadRangeFullAttribute::setProperties(::nds::rules::instantiations::RulesPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RulesRoadRangeFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RulesRoadRangeFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RulesRoadRangeFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RulesRoadRangeFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RulesRoadRangeFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RulesRoadRangeFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RulesRoadRangeFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RulesRoadRangeFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RulesRoadRangeFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RulesRoadRangeFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RulesRoadRangeFullAttribute::initPackingContext(RulesRoadRangeFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RulesRoadRangeFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeFullAttribute::bitSizeOf(RulesRoadRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesRoadRangeFullAttribute::initializeOffsets(RulesRoadRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesRoadRangeFullAttribute::operator==(const RulesRoadRangeFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RulesRoadRangeFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RulesRoadRangeFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRoadRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RulesRoadRangeFullAttribute::write(RulesRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRoadRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadRangeFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadRangeAttributeType>(in);
}

::nds::rules::attributes::RulesRoadRangeAttributeType RulesRoadRangeFullAttribute::readAttributeTypeCode(RulesRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::rules::attributes::RulesRoadRangeAttributeValue RulesRoadRangeFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRoadRangeAttributeValue(in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesRoadRangeAttributeValue RulesRoadRangeFullAttribute::readAttributeValue(RulesRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRoadRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesRoadRangeAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesRoadRangeFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesRoadRangeFullAttribute::readProperties(RulesRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesRoadRangeFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesRoadRangeFullAttribute::readConditions(RulesRoadRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadPositionFullAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadPositionFullAttribute::RulesRoadPositionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesRoadPositionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RulesRoadPositionFullAttribute::RulesRoadPositionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RulesRoadPositionFullAttribute::RulesRoadPositionFullAttribute(RulesRoadPositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RulesRoadPositionFullAttribute::RulesRoadPositionFullAttribute(const RulesRoadPositionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesRoadPositionFullAttribute& RulesRoadPositionFullAttribute::operator=(const RulesRoadPositionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesRoadPositionFullAttribute::RulesRoadPositionFullAttribute(RulesRoadPositionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesRoadPositionFullAttribute& RulesRoadPositionFullAttribute::operator=(RulesRoadPositionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesRoadPositionFullAttribute::RulesRoadPositionFullAttribute(::zserio::PropagateAllocatorT,
        const RulesRoadPositionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesRoadPositionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesRoadPositionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesRoadPositionFullAttribute::setAttributeTypeCode(::nds::rules::attributes::RulesRoadPositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::rules::attributes::RulesRoadPositionAttributeValue& RulesRoadPositionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesRoadPositionAttributeValue& RulesRoadPositionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesRoadPositionFullAttribute::setAttributeValue(const ::nds::rules::attributes::RulesRoadPositionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesRoadPositionFullAttribute::setAttributeValue(::nds::rules::attributes::RulesRoadPositionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::rules::instantiations::RulesPropertyList& RulesRoadPositionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::rules::instantiations::RulesPropertyList& RulesRoadPositionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RulesRoadPositionFullAttribute::setProperties(const ::nds::rules::instantiations::RulesPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RulesRoadPositionFullAttribute::setProperties(::nds::rules::instantiations::RulesPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RulesRoadPositionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RulesRoadPositionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RulesRoadPositionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RulesRoadPositionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RulesRoadPositionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RulesRoadPositionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RulesRoadPositionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RulesRoadPositionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RulesRoadPositionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RulesRoadPositionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RulesRoadPositionFullAttribute::initPackingContext(RulesRoadPositionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RulesRoadPositionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionFullAttribute::bitSizeOf(RulesRoadPositionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesRoadPositionFullAttribute::initializeOffsets(RulesRoadPositionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesRoadPositionFullAttribute::operator==(const RulesRoadPositionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RulesRoadPositionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RulesRoadPositionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRoadPositionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RulesRoadPositionFullAttribute::write(RulesRoadPositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesRoadPositionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesRoadPositionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadPositionAttributeType>(in);
}

::nds::rules::attributes::RulesRoadPositionAttributeType RulesRoadPositionFullAttribute::readAttributeTypeCode(RulesRoadPositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesRoadPositionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::rules::attributes::RulesRoadPositionAttributeValue RulesRoadPositionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRoadPositionAttributeValue(in, static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesRoadPositionAttributeValue RulesRoadPositionFullAttribute::readAttributeValue(RulesRoadPositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesRoadPositionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesRoadPositionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesRoadPositionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesRoadPositionFullAttribute::readProperties(RulesRoadPositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesRoadPositionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesRoadPositionFullAttribute::readConditions(RulesRoadPositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneRangeFullAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneRangeFullAttribute::RulesLaneRangeFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesLaneRangeAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RulesLaneRangeFullAttribute::RulesLaneRangeFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RulesLaneRangeFullAttribute::RulesLaneRangeFullAttribute(RulesLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RulesLaneRangeFullAttribute::RulesLaneRangeFullAttribute(const RulesLaneRangeFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesLaneRangeFullAttribute& RulesLaneRangeFullAttribute::operator=(const RulesLaneRangeFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesLaneRangeFullAttribute::RulesLaneRangeFullAttribute(RulesLaneRangeFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesLaneRangeFullAttribute& RulesLaneRangeFullAttribute::operator=(RulesLaneRangeFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesLaneRangeFullAttribute::RulesLaneRangeFullAttribute(::zserio::PropagateAllocatorT,
        const RulesLaneRangeFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesLaneRangeFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesLaneRangeFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesLaneRangeFullAttribute::setAttributeTypeCode(::nds::rules::attributes::RulesLaneRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::rules::attributes::RulesLaneRangeAttributeValue& RulesLaneRangeFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesLaneRangeAttributeValue& RulesLaneRangeFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesLaneRangeFullAttribute::setAttributeValue(const ::nds::rules::attributes::RulesLaneRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesLaneRangeFullAttribute::setAttributeValue(::nds::rules::attributes::RulesLaneRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::rules::instantiations::RulesPropertyList& RulesLaneRangeFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::rules::instantiations::RulesPropertyList& RulesLaneRangeFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RulesLaneRangeFullAttribute::setProperties(const ::nds::rules::instantiations::RulesPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RulesLaneRangeFullAttribute::setProperties(::nds::rules::instantiations::RulesPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RulesLaneRangeFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RulesLaneRangeFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RulesLaneRangeFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RulesLaneRangeFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RulesLaneRangeFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RulesLaneRangeFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RulesLaneRangeFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RulesLaneRangeFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RulesLaneRangeFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RulesLaneRangeFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RulesLaneRangeFullAttribute::initPackingContext(RulesLaneRangeFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RulesLaneRangeFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeFullAttribute::bitSizeOf(RulesLaneRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesLaneRangeFullAttribute::initializeOffsets(RulesLaneRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesLaneRangeFullAttribute::operator==(const RulesLaneRangeFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RulesLaneRangeFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RulesLaneRangeFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLaneRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RulesLaneRangeFullAttribute::write(RulesLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLaneRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesLaneRangeFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneRangeAttributeType>(in);
}

::nds::rules::attributes::RulesLaneRangeAttributeType RulesLaneRangeFullAttribute::readAttributeTypeCode(RulesLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::rules::attributes::RulesLaneRangeAttributeValue RulesLaneRangeFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLaneRangeAttributeValue(in, static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesLaneRangeAttributeValue RulesLaneRangeFullAttribute::readAttributeValue(RulesLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLaneRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesLaneRangeAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesLaneRangeFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesLaneRangeFullAttribute::readProperties(RulesLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesLaneRangeFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesLaneRangeFullAttribute::readConditions(RulesLaneRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLanePositionFullAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLanePositionFullAttribute::RulesLanePositionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesLanePositionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RulesLanePositionFullAttribute::RulesLanePositionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RulesLanePositionFullAttribute::RulesLanePositionFullAttribute(RulesLanePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RulesLanePositionFullAttribute::RulesLanePositionFullAttribute(const RulesLanePositionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesLanePositionFullAttribute& RulesLanePositionFullAttribute::operator=(const RulesLanePositionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesLanePositionFullAttribute::RulesLanePositionFullAttribute(RulesLanePositionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesLanePositionFullAttribute& RulesLanePositionFullAttribute::operator=(RulesLanePositionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesLanePositionFullAttribute::RulesLanePositionFullAttribute(::zserio::PropagateAllocatorT,
        const RulesLanePositionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesLanePositionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesLanePositionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesLanePositionFullAttribute::setAttributeTypeCode(::nds::rules::attributes::RulesLanePositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::rules::attributes::RulesLanePositionAttributeValue& RulesLanePositionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesLanePositionAttributeValue& RulesLanePositionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesLanePositionFullAttribute::setAttributeValue(const ::nds::rules::attributes::RulesLanePositionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesLanePositionFullAttribute::setAttributeValue(::nds::rules::attributes::RulesLanePositionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::rules::instantiations::RulesPropertyList& RulesLanePositionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::rules::instantiations::RulesPropertyList& RulesLanePositionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RulesLanePositionFullAttribute::setProperties(const ::nds::rules::instantiations::RulesPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RulesLanePositionFullAttribute::setProperties(::nds::rules::instantiations::RulesPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RulesLanePositionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RulesLanePositionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RulesLanePositionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RulesLanePositionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RulesLanePositionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RulesLanePositionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RulesLanePositionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RulesLanePositionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RulesLanePositionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RulesLanePositionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RulesLanePositionFullAttribute::initPackingContext(RulesLanePositionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RulesLanePositionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionFullAttribute::bitSizeOf(RulesLanePositionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesLanePositionFullAttribute::initializeOffsets(RulesLanePositionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesLanePositionFullAttribute::operator==(const RulesLanePositionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RulesLanePositionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RulesLanePositionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLanePositionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RulesLanePositionFullAttribute::write(RulesLanePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLanePositionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesLanePositionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLanePositionAttributeType>(in);
}

::nds::rules::attributes::RulesLanePositionAttributeType RulesLanePositionFullAttribute::readAttributeTypeCode(RulesLanePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLanePositionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::rules::attributes::RulesLanePositionAttributeValue RulesLanePositionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLanePositionAttributeValue(in, static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesLanePositionAttributeValue RulesLanePositionFullAttribute::readAttributeValue(RulesLanePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLanePositionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesLanePositionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesLanePositionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesLanePositionFullAttribute::readProperties(RulesLanePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesLanePositionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesLanePositionFullAttribute::readConditions(RulesLanePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesTransitionFullAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesTransitionFullAttribute::RulesTransitionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesTransitionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RulesTransitionFullAttribute::RulesTransitionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RulesTransitionFullAttribute::RulesTransitionFullAttribute(RulesTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RulesTransitionFullAttribute::RulesTransitionFullAttribute(const RulesTransitionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesTransitionFullAttribute& RulesTransitionFullAttribute::operator=(const RulesTransitionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesTransitionFullAttribute::RulesTransitionFullAttribute(RulesTransitionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesTransitionFullAttribute& RulesTransitionFullAttribute::operator=(RulesTransitionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesTransitionFullAttribute::RulesTransitionFullAttribute(::zserio::PropagateAllocatorT,
        const RulesTransitionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesTransitionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::rules::attributes::RulesTransitionAttributeType RulesTransitionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesTransitionFullAttribute::setAttributeTypeCode(::nds::rules::attributes::RulesTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::rules::attributes::RulesTransitionAttributeValue& RulesTransitionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesTransitionAttributeValue& RulesTransitionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesTransitionFullAttribute::setAttributeValue(const ::nds::rules::attributes::RulesTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesTransitionFullAttribute::setAttributeValue(::nds::rules::attributes::RulesTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::rules::instantiations::RulesPropertyList& RulesTransitionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::rules::instantiations::RulesPropertyList& RulesTransitionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RulesTransitionFullAttribute::setProperties(const ::nds::rules::instantiations::RulesPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RulesTransitionFullAttribute::setProperties(::nds::rules::instantiations::RulesPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RulesTransitionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RulesTransitionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RulesTransitionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RulesTransitionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RulesTransitionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RulesTransitionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RulesTransitionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RulesTransitionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RulesTransitionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RulesTransitionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RulesTransitionFullAttribute::initPackingContext(RulesTransitionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RulesTransitionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesTransitionFullAttribute::bitSizeOf(RulesTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesTransitionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesTransitionFullAttribute::initializeOffsets(RulesTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesTransitionFullAttribute::operator==(const RulesTransitionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RulesTransitionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RulesTransitionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RulesTransitionFullAttribute::write(RulesTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::rules::attributes::RulesTransitionAttributeType RulesTransitionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesTransitionAttributeType>(in);
}

::nds::rules::attributes::RulesTransitionAttributeType RulesTransitionFullAttribute::readAttributeTypeCode(RulesTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::rules::attributes::RulesTransitionAttributeValue RulesTransitionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesTransitionAttributeValue(in, static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesTransitionAttributeValue RulesTransitionFullAttribute::readAttributeValue(RulesTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesTransitionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesTransitionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesTransitionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesTransitionFullAttribute::readProperties(RulesTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesTransitionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesTransitionFullAttribute::readConditions(RulesTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneTransitionFullAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneTransitionFullAttribute::RulesLaneTransitionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesLaneTransitionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RulesLaneTransitionFullAttribute::RulesLaneTransitionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RulesLaneTransitionFullAttribute::RulesLaneTransitionFullAttribute(RulesLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RulesLaneTransitionFullAttribute::RulesLaneTransitionFullAttribute(const RulesLaneTransitionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesLaneTransitionFullAttribute& RulesLaneTransitionFullAttribute::operator=(const RulesLaneTransitionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesLaneTransitionFullAttribute::RulesLaneTransitionFullAttribute(RulesLaneTransitionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesLaneTransitionFullAttribute& RulesLaneTransitionFullAttribute::operator=(RulesLaneTransitionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesLaneTransitionFullAttribute::RulesLaneTransitionFullAttribute(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesLaneTransitionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::rules::attributes::RulesLaneTransitionAttributeType RulesLaneTransitionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesLaneTransitionFullAttribute::setAttributeTypeCode(::nds::rules::attributes::RulesLaneTransitionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::rules::attributes::RulesLaneTransitionAttributeValue& RulesLaneTransitionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesLaneTransitionAttributeValue& RulesLaneTransitionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesLaneTransitionFullAttribute::setAttributeValue(const ::nds::rules::attributes::RulesLaneTransitionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesLaneTransitionFullAttribute::setAttributeValue(::nds::rules::attributes::RulesLaneTransitionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::rules::instantiations::RulesPropertyList& RulesLaneTransitionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::rules::instantiations::RulesPropertyList& RulesLaneTransitionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RulesLaneTransitionFullAttribute::setProperties(const ::nds::rules::instantiations::RulesPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RulesLaneTransitionFullAttribute::setProperties(::nds::rules::instantiations::RulesPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RulesLaneTransitionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RulesLaneTransitionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RulesLaneTransitionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RulesLaneTransitionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RulesLaneTransitionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RulesLaneTransitionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RulesLaneTransitionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RulesLaneTransitionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RulesLaneTransitionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RulesLaneTransitionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RulesLaneTransitionFullAttribute::initPackingContext(RulesLaneTransitionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RulesLaneTransitionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionFullAttribute::bitSizeOf(RulesLaneTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesLaneTransitionFullAttribute::initializeOffsets(RulesLaneTransitionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesLaneTransitionFullAttribute::operator==(const RulesLaneTransitionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RulesLaneTransitionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RulesLaneTransitionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLaneTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RulesLaneTransitionFullAttribute::write(RulesLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesLaneTransitionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::rules::attributes::RulesLaneTransitionAttributeType RulesLaneTransitionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneTransitionAttributeType>(in);
}

::nds::rules::attributes::RulesLaneTransitionAttributeType RulesLaneTransitionFullAttribute::readAttributeTypeCode(RulesLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesLaneTransitionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::rules::attributes::RulesLaneTransitionAttributeValue RulesLaneTransitionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesLaneTransitionAttributeValue(in, static_cast<::nds::rules::attributes::RulesLaneTransitionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesLaneTransitionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesLaneTransitionFullAttribute::readProperties(RulesLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesLaneTransitionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesLaneTransitionFullAttribute::readConditions(RulesLaneTransitionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLineRangeFullAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLineRangeFullAttribute::RulesDisplayLineRangeFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesDisplayLineRangeAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RulesDisplayLineRangeFullAttribute::RulesDisplayLineRangeFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RulesDisplayLineRangeFullAttribute::RulesDisplayLineRangeFullAttribute(RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RulesDisplayLineRangeFullAttribute::RulesDisplayLineRangeFullAttribute(const RulesDisplayLineRangeFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesDisplayLineRangeFullAttribute& RulesDisplayLineRangeFullAttribute::operator=(const RulesDisplayLineRangeFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesDisplayLineRangeFullAttribute::RulesDisplayLineRangeFullAttribute(RulesDisplayLineRangeFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesDisplayLineRangeFullAttribute& RulesDisplayLineRangeFullAttribute::operator=(RulesDisplayLineRangeFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesDisplayLineRangeFullAttribute::RulesDisplayLineRangeFullAttribute(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesDisplayLineRangeFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeType RulesDisplayLineRangeFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesDisplayLineRangeFullAttribute::setAttributeTypeCode(::nds::rules::attributes::RulesDisplayLineRangeAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeValue& RulesDisplayLineRangeFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesDisplayLineRangeAttributeValue& RulesDisplayLineRangeFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesDisplayLineRangeFullAttribute::setAttributeValue(const ::nds::rules::attributes::RulesDisplayLineRangeAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesDisplayLineRangeFullAttribute::setAttributeValue(::nds::rules::attributes::RulesDisplayLineRangeAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::rules::instantiations::RulesPropertyList& RulesDisplayLineRangeFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::rules::instantiations::RulesPropertyList& RulesDisplayLineRangeFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RulesDisplayLineRangeFullAttribute::setProperties(const ::nds::rules::instantiations::RulesPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RulesDisplayLineRangeFullAttribute::setProperties(::nds::rules::instantiations::RulesPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RulesDisplayLineRangeFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RulesDisplayLineRangeFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RulesDisplayLineRangeFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RulesDisplayLineRangeFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RulesDisplayLineRangeFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RulesDisplayLineRangeFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RulesDisplayLineRangeFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RulesDisplayLineRangeFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RulesDisplayLineRangeFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RulesDisplayLineRangeFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RulesDisplayLineRangeFullAttribute::initPackingContext(RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RulesDisplayLineRangeFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeFullAttribute::bitSizeOf(RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesDisplayLineRangeFullAttribute::initializeOffsets(RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesDisplayLineRangeFullAttribute::operator==(const RulesDisplayLineRangeFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RulesDisplayLineRangeFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RulesDisplayLineRangeFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesDisplayLineRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RulesDisplayLineRangeFullAttribute::write(RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesDisplayLineRangeFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeType RulesDisplayLineRangeFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(in);
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeType RulesDisplayLineRangeFullAttribute::readAttributeTypeCode(RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::rules::attributes::RulesDisplayLineRangeAttributeValue RulesDisplayLineRangeFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesDisplayLineRangeAttributeValue(in, static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesDisplayLineRangeAttributeValue RulesDisplayLineRangeFullAttribute::readAttributeValue(RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesDisplayLineRangeAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesDisplayLineRangeAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesDisplayLineRangeFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesDisplayLineRangeFullAttribute::readProperties(RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesDisplayLineRangeFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesDisplayLineRangeFullAttribute::readConditions(RulesDisplayLineRangeFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLinePositionFullAttribute.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLinePositionFullAttribute::RulesDisplayLinePositionFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::rules::attributes::RulesDisplayLinePositionAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

RulesDisplayLinePositionFullAttribute::RulesDisplayLinePositionFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

RulesDisplayLinePositionFullAttribute::RulesDisplayLinePositionFullAttribute(RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

RulesDisplayLinePositionFullAttribute::RulesDisplayLinePositionFullAttribute(const RulesDisplayLinePositionFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesDisplayLinePositionFullAttribute& RulesDisplayLinePositionFullAttribute::operator=(const RulesDisplayLinePositionFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesDisplayLinePositionFullAttribute::RulesDisplayLinePositionFullAttribute(RulesDisplayLinePositionFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RulesDisplayLinePositionFullAttribute& RulesDisplayLinePositionFullAttribute::operator=(RulesDisplayLinePositionFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RulesDisplayLinePositionFullAttribute::RulesDisplayLinePositionFullAttribute(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RulesDisplayLinePositionFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeType RulesDisplayLinePositionFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void RulesDisplayLinePositionFullAttribute::setAttributeTypeCode(::nds::rules::attributes::RulesDisplayLinePositionAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeValue& RulesDisplayLinePositionFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::rules::attributes::RulesDisplayLinePositionAttributeValue& RulesDisplayLinePositionFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void RulesDisplayLinePositionFullAttribute::setAttributeValue(const ::nds::rules::attributes::RulesDisplayLinePositionAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void RulesDisplayLinePositionFullAttribute::setAttributeValue(::nds::rules::attributes::RulesDisplayLinePositionAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::rules::instantiations::RulesPropertyList& RulesDisplayLinePositionFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::rules::instantiations::RulesPropertyList& RulesDisplayLinePositionFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void RulesDisplayLinePositionFullAttribute::setProperties(const ::nds::rules::instantiations::RulesPropertyList& properties_)
{
    m_properties_ = properties_;
}

void RulesDisplayLinePositionFullAttribute::setProperties(::nds::rules::instantiations::RulesPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool RulesDisplayLinePositionFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool RulesDisplayLinePositionFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void RulesDisplayLinePositionFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& RulesDisplayLinePositionFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& RulesDisplayLinePositionFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void RulesDisplayLinePositionFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void RulesDisplayLinePositionFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool RulesDisplayLinePositionFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool RulesDisplayLinePositionFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void RulesDisplayLinePositionFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void RulesDisplayLinePositionFullAttribute::initPackingContext(RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t RulesDisplayLinePositionFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionFullAttribute::bitSizeOf(RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RulesDisplayLinePositionFullAttribute::initializeOffsets(RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool RulesDisplayLinePositionFullAttribute::operator==(const RulesDisplayLinePositionFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t RulesDisplayLinePositionFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void RulesDisplayLinePositionFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesDisplayLinePositionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RulesDisplayLinePositionFullAttribute::write(RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RulesDisplayLinePositionFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeType RulesDisplayLinePositionFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(in);
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeType RulesDisplayLinePositionFullAttribute::readAttributeTypeCode(RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::rules::attributes::RulesDisplayLinePositionAttributeValue RulesDisplayLinePositionFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesDisplayLinePositionAttributeValue(in, static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::rules::attributes::RulesDisplayLinePositionAttributeValue RulesDisplayLinePositionFullAttribute::readAttributeValue(RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::attributes::RulesDisplayLinePositionAttributeValue(context.getAttributeValue(), in, static_cast<::nds::rules::attributes::RulesDisplayLinePositionAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesDisplayLinePositionFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList> RulesDisplayLinePositionFullAttribute::readProperties(RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::nds::rules::instantiations::RulesPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::rules::instantiations::RulesPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesDisplayLinePositionFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> RulesDisplayLinePositionFullAttribute::readConditions(RulesDisplayLinePositionFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesPropertyList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesPropertyList::RulesPropertyList(const allocator_type&) noexcept :
        m_numProperties_(uint8_t()),
        m_property_(::zserio::NullOpt)
{
}

RulesPropertyList::RulesPropertyList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(in)),
        m_property_(readProperty(in, allocator))
{
}

RulesPropertyList::RulesPropertyList(RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(context, in)),
        m_property_(readProperty(context, in, allocator))
{
}

RulesPropertyList::RulesPropertyList(::zserio::PropagateAllocatorT,
        const RulesPropertyList& other, const allocator_type& allocator) :
        m_numProperties_(::zserio::allocatorPropagatingCopy(other.m_numProperties_, allocator)),
        m_property_(::zserio::allocatorPropagatingCopy(other.m_property_, allocator))
{
}

void RulesPropertyList::initializeChildren()
{
    if (getNumProperties() > 0)
        m_property_.value().initializeElements(*this);
}

uint8_t RulesPropertyList::getNumProperties() const
{
    return m_numProperties_;
}

void RulesPropertyList::setNumProperties(uint8_t numProperties_)
{
    m_numProperties_ = numProperties_;
}

::zserio::vector<::nds::rules::instantiations::RulesProperty>& RulesPropertyList::getProperty()
{
    return m_property_.value().getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesProperty>& RulesPropertyList::getProperty() const
{
    return m_property_.value().getRawArray();
}

void RulesPropertyList::setProperty(const ::zserio::vector<::nds::rules::instantiations::RulesProperty>& property_)
{
    m_property_ = ZserioArrayType_property(property_);
}

void RulesPropertyList::setProperty(::zserio::vector<::nds::rules::instantiations::RulesProperty>&& property_)
{
    m_property_ = ZserioArrayType_property(std::move(property_));
}

bool RulesPropertyList::isPropertyUsed() const
{
    return (getNumProperties() > 0);
}

bool RulesPropertyList::isPropertySet() const
{
    return m_property_.hasValue();
}

void RulesPropertyList::resetProperty()
{
    m_property_.reset();
}

void RulesPropertyList::initPackingContext(RulesPropertyList::ZserioPackingContext& context) const
{
    context.getNumProperties().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
}

size_t RulesPropertyList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesPropertyList::bitSizeOf(RulesPropertyList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RulesPropertyList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t RulesPropertyList::initializeOffsets(RulesPropertyList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool RulesPropertyList::operator==(const RulesPropertyList& other) const
{
    if (this != &other)
    {
        return
                (m_numProperties_ == other.m_numProperties_) &&
                (!isPropertyUsed() ? !other.isPropertyUsed() : (m_property_ == other.m_property_));
    }

    return true;
}

uint32_t RulesPropertyList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numProperties_);
    if (isPropertyUsed())
        result = ::zserio::calcHashCode(result, m_property_);

    return result;
}

void RulesPropertyList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numProperties_, UINT8_C(8));

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void RulesPropertyList::write(RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumProperties().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numProperties_);

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void RulesPropertyList::ZserioArrayExpressions_property::initializeElement(RulesPropertyList&,
        ::nds::rules::instantiations::RulesProperty& element, size_t)
{
    element.initializeChildren();
}

void RulesPropertyList::ZserioElementFactory_property::create(RulesPropertyList&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesProperty>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesPropertyList::ZserioElementFactory_property::create(RulesPropertyList&        ,
        ::zserio::vector<::nds::rules::instantiations::RulesProperty>& array,
        ::nds::rules::instantiations::RulesProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t RulesPropertyList::readNumProperties(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t RulesPropertyList::readNumProperties(RulesPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumProperties().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::zserio::InplaceOptionalHolder<RulesPropertyList::ZserioArrayType_property> RulesPropertyList::readProperty(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RulesPropertyList::ZserioArrayType_property> RulesPropertyList::readProperty(RulesPropertyList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadRangeAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadRangeAttributeSetMap::RulesRoadRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesRoadRangeAttributeSetMap::RulesRoadRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesRoadRangeAttributeSetMap::RulesRoadRangeAttributeSetMap(RulesRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesRoadRangeAttributeSetMap::RulesRoadRangeAttributeSetMap(const RulesRoadRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeSetMap& RulesRoadRangeAttributeSetMap::operator=(const RulesRoadRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeSetMap::RulesRoadRangeAttributeSetMap(RulesRoadRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeSetMap& RulesRoadRangeAttributeSetMap::operator=(RulesRoadRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeSetMap::RulesRoadRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesRoadRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesRoadRangeAttributeSet& RulesRoadRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesRoadRangeAttributeSet& RulesRoadRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesRoadRangeAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesRoadRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesRoadRangeAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesRoadRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesRoadRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesRoadRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& RulesRoadRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& RulesRoadRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesRoadRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesRoadRangeAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RulesRoadRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RulesRoadRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesRoadRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesRoadRangeAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesRoadRangeAttributeSetMap::initPackingContext(RulesRoadRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesRoadRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeSetMap::bitSizeOf(RulesRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadRangeAttributeSetMap::initializeOffsets(RulesRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadRangeAttributeSetMap::operator==(const RulesRoadRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesRoadRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesRoadRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesRoadRangeAttributeSetMap::write(RulesRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesRoadRangeAttributeSetMap::ZserioElementFactory_references::create(RulesRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadRangeAttributeSetMap::ZserioElementFactory_references::create(RulesRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesRoadRangeAttributeSetMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesRoadRangeAttributeSet RulesRoadRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesRoadRangeAttributeSet RulesRoadRangeAttributeSetMap::readAttributeSet(RulesRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesRoadRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRoadRangeAttributeSetMap::readFeature(RulesRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadRangeAttributeSetMap::ZserioArrayType_references RulesRoadRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadRangeAttributeSetMap::ZserioArrayType_references RulesRoadRangeAttributeSetMap::readReferences(RulesRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadRangeAttributeSetMap::ZserioArrayType_validities RulesRoadRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadRangeAttributeSetMap::ZserioArrayType_validities RulesRoadRangeAttributeSetMap::readValidities(RulesRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectRoadRangeAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectRoadRangeAttributeSetMap::RulesIndirectRoadRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesIndirectRoadRangeAttributeSetMap::RulesIndirectRoadRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesIndirectRoadRangeAttributeSetMap::RulesIndirectRoadRangeAttributeSetMap(RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesIndirectRoadRangeAttributeSetMap::RulesIndirectRoadRangeAttributeSetMap(const RulesIndirectRoadRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadRangeAttributeSetMap& RulesIndirectRoadRangeAttributeSetMap::operator=(const RulesIndirectRoadRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadRangeAttributeSetMap::RulesIndirectRoadRangeAttributeSetMap(RulesIndirectRoadRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadRangeAttributeSetMap& RulesIndirectRoadRangeAttributeSetMap::operator=(RulesIndirectRoadRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadRangeAttributeSetMap::RulesIndirectRoadRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesIndirectRoadRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectRoadRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectRoadRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectRoadRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectRoadRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectRoadRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesRoadRangeAttributeSet& RulesIndirectRoadRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesRoadRangeAttributeSet& RulesIndirectRoadRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesIndirectRoadRangeAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesRoadRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesIndirectRoadRangeAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesRoadRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesIndirectRoadRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesIndirectRoadRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& RulesIndirectRoadRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& RulesIndirectRoadRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesIndirectRoadRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesIndirectRoadRangeAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RulesIndirectRoadRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& RulesIndirectRoadRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesIndirectRoadRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesIndirectRoadRangeAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::types::RoadRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesIndirectRoadRangeAttributeSetMap::initPackingContext(RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesIndirectRoadRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadRangeAttributeSetMap::bitSizeOf(RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectRoadRangeAttributeSetMap::initializeOffsets(RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectRoadRangeAttributeSetMap::operator==(const RulesIndirectRoadRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesIndirectRoadRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesIndirectRoadRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesIndirectRoadRangeAttributeSetMap::write(RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesIndirectRoadRangeAttributeSetMap::ZserioArrayExpressions_references::initializeElement(RulesIndirectRoadRangeAttributeSetMap&,
        ::nds::road::reference::types::RoadReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectRoadRangeAttributeSetMap::ZserioElementFactory_references::create(RulesIndirectRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectRoadRangeAttributeSetMap::ZserioElementFactory_references::create(RulesIndirectRoadRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::nds::road::reference::types::RoadReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectRoadRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesIndirectRoadRangeAttributeSetMap& owner,
        ::nds::road::reference::types::RoadRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesIndirectRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesIndirectRoadRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadRangeValidity>& array,
        ::nds::road::reference::types::RoadRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesRoadRangeAttributeSet RulesIndirectRoadRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesRoadRangeAttributeSet RulesIndirectRoadRangeAttributeSetMap::readAttributeSet(RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesIndirectRoadRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesIndirectRoadRangeAttributeSetMap::readFeature(RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectRoadRangeAttributeSetMap::ZserioArrayType_references RulesIndirectRoadRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadRangeAttributeSetMap::ZserioArrayType_references RulesIndirectRoadRangeAttributeSetMap::readReferences(RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectRoadRangeAttributeSetMap::ZserioArrayType_validities RulesIndirectRoadRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadRangeAttributeSetMap::ZserioArrayType_validities RulesIndirectRoadRangeAttributeSetMap::readValidities(RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadLocationRangeAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadLocationRangeAttributeSetMap::RulesRoadLocationRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesRoadLocationRangeAttributeSetMap::RulesRoadLocationRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesRoadLocationRangeAttributeSetMap::RulesRoadLocationRangeAttributeSetMap(RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesRoadLocationRangeAttributeSetMap::RulesRoadLocationRangeAttributeSetMap(const RulesRoadLocationRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationRangeAttributeSetMap& RulesRoadLocationRangeAttributeSetMap::operator=(const RulesRoadLocationRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationRangeAttributeSetMap::RulesRoadLocationRangeAttributeSetMap(RulesRoadLocationRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationRangeAttributeSetMap& RulesRoadLocationRangeAttributeSetMap::operator=(RulesRoadLocationRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationRangeAttributeSetMap::RulesRoadLocationRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesRoadLocationRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadLocationRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadLocationRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadLocationRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadLocationRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadLocationRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesRoadRangeAttributeSet& RulesRoadLocationRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesRoadRangeAttributeSet& RulesRoadLocationRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesRoadLocationRangeAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesRoadRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesRoadLocationRangeAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesRoadRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesRoadLocationRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesRoadLocationRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::location::RoadLocationReference>& RulesRoadLocationRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& RulesRoadLocationRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesRoadLocationRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesRoadLocationRangeAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::location::RoadLocationReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& RulesRoadLocationRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& RulesRoadLocationRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesRoadLocationRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesRoadLocationRangeAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesRoadLocationRangeAttributeSetMap::initPackingContext(RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesRoadLocationRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationRangeAttributeSetMap::bitSizeOf(RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadLocationRangeAttributeSetMap::initializeOffsets(RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadLocationRangeAttributeSetMap::operator==(const RulesRoadLocationRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesRoadLocationRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesRoadLocationRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesRoadLocationRangeAttributeSetMap::write(RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesRoadLocationRangeAttributeSetMap::ZserioElementFactory_references::create(RulesRoadLocationRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadLocationRangeAttributeSetMap::ZserioElementFactory_references::create(RulesRoadLocationRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationReference>& array,
        ::nds::road::reference::location::RoadLocationReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadLocationRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesRoadLocationRangeAttributeSetMap& owner,
        ::nds::road::reference::location::RoadLocationRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadLocationRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesRoadLocationRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadLocationRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesRoadLocationRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::location::RoadLocationRangeValidity>& array,
        ::nds::road::reference::location::RoadLocationRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesRoadRangeAttributeSet RulesRoadLocationRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesRoadRangeAttributeSet RulesRoadLocationRangeAttributeSetMap::readAttributeSet(RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesRoadLocationRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRoadLocationRangeAttributeSetMap::readFeature(RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadLocationRangeAttributeSetMap::ZserioArrayType_references RulesRoadLocationRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadLocationRangeAttributeSetMap::ZserioArrayType_references RulesRoadLocationRangeAttributeSetMap::readReferences(RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadLocationRangeAttributeSetMap::ZserioArrayType_validities RulesRoadLocationRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadLocationRangeAttributeSetMap::ZserioArrayType_validities RulesRoadLocationRangeAttributeSetMap::readValidities(RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadPositionAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadPositionAttributeSetMap::RulesRoadPositionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesRoadPositionAttributeSetMap::RulesRoadPositionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesRoadPositionAttributeSetMap::RulesRoadPositionAttributeSetMap(RulesRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesRoadPositionAttributeSetMap::RulesRoadPositionAttributeSetMap(const RulesRoadPositionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeSetMap& RulesRoadPositionAttributeSetMap::operator=(const RulesRoadPositionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeSetMap::RulesRoadPositionAttributeSetMap(RulesRoadPositionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeSetMap& RulesRoadPositionAttributeSetMap::operator=(RulesRoadPositionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeSetMap::RulesRoadPositionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesRoadPositionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadPositionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadPositionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadPositionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadPositionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadPositionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesRoadPositionAttributeSet& RulesRoadPositionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesRoadPositionAttributeSet& RulesRoadPositionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesRoadPositionAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesRoadPositionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesRoadPositionAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesRoadPositionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesRoadPositionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesRoadPositionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& RulesRoadPositionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& RulesRoadPositionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesRoadPositionAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesRoadPositionAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& RulesRoadPositionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& RulesRoadPositionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesRoadPositionAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesRoadPositionAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::types::RoadPositionValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesRoadPositionAttributeSetMap::initPackingContext(RulesRoadPositionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesRoadPositionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeSetMap::bitSizeOf(RulesRoadPositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadPositionAttributeSetMap::initializeOffsets(RulesRoadPositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadPositionAttributeSetMap::operator==(const RulesRoadPositionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesRoadPositionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesRoadPositionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesRoadPositionAttributeSetMap::write(RulesRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesRoadPositionAttributeSetMap::ZserioElementFactory_references::create(RulesRoadPositionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadPositionAttributeSetMap::ZserioElementFactory_references::create(RulesRoadPositionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadPositionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesRoadPositionAttributeSetMap& owner,
        ::nds::road::reference::types::RoadPositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadPositionAttributeSetMap::ZserioElementFactory_validities::create(RulesRoadPositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadPositionAttributeSetMap::ZserioElementFactory_validities::create(RulesRoadPositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& array,
        ::nds::road::reference::types::RoadPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesRoadPositionAttributeSet RulesRoadPositionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadPositionAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesRoadPositionAttributeSet RulesRoadPositionAttributeSetMap::readAttributeSet(RulesRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadPositionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesRoadPositionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRoadPositionAttributeSetMap::readFeature(RulesRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadPositionAttributeSetMap::ZserioArrayType_references RulesRoadPositionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadPositionAttributeSetMap::ZserioArrayType_references RulesRoadPositionAttributeSetMap::readReferences(RulesRoadPositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadPositionAttributeSetMap::ZserioArrayType_validities RulesRoadPositionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadPositionAttributeSetMap::ZserioArrayType_validities RulesRoadPositionAttributeSetMap::readValidities(RulesRoadPositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectRoadPositionAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectRoadPositionAttributeSetMap::RulesIndirectRoadPositionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesIndirectRoadPositionAttributeSetMap::RulesIndirectRoadPositionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesIndirectRoadPositionAttributeSetMap::RulesIndirectRoadPositionAttributeSetMap(RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesIndirectRoadPositionAttributeSetMap::RulesIndirectRoadPositionAttributeSetMap(const RulesIndirectRoadPositionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadPositionAttributeSetMap& RulesIndirectRoadPositionAttributeSetMap::operator=(const RulesIndirectRoadPositionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadPositionAttributeSetMap::RulesIndirectRoadPositionAttributeSetMap(RulesIndirectRoadPositionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadPositionAttributeSetMap& RulesIndirectRoadPositionAttributeSetMap::operator=(RulesIndirectRoadPositionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadPositionAttributeSetMap::RulesIndirectRoadPositionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesIndirectRoadPositionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectRoadPositionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectRoadPositionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectRoadPositionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectRoadPositionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectRoadPositionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesRoadPositionAttributeSet& RulesIndirectRoadPositionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesRoadPositionAttributeSet& RulesIndirectRoadPositionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesIndirectRoadPositionAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesRoadPositionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesIndirectRoadPositionAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesRoadPositionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesIndirectRoadPositionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesIndirectRoadPositionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& RulesIndirectRoadPositionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& RulesIndirectRoadPositionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesIndirectRoadPositionAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesIndirectRoadPositionAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& RulesIndirectRoadPositionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& RulesIndirectRoadPositionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesIndirectRoadPositionAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesIndirectRoadPositionAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::types::RoadPositionValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesIndirectRoadPositionAttributeSetMap::initPackingContext(RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesIndirectRoadPositionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadPositionAttributeSetMap::bitSizeOf(RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadPositionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectRoadPositionAttributeSetMap::initializeOffsets(RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectRoadPositionAttributeSetMap::operator==(const RulesIndirectRoadPositionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesIndirectRoadPositionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesIndirectRoadPositionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesIndirectRoadPositionAttributeSetMap::write(RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesIndirectRoadPositionAttributeSetMap::ZserioArrayExpressions_references::initializeElement(RulesIndirectRoadPositionAttributeSetMap&,
        ::nds::road::reference::types::RoadReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectRoadPositionAttributeSetMap::ZserioElementFactory_references::create(RulesIndirectRoadPositionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectRoadPositionAttributeSetMap::ZserioElementFactory_references::create(RulesIndirectRoadPositionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReferenceIndirect>& array,
        ::nds::road::reference::types::RoadReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectRoadPositionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesIndirectRoadPositionAttributeSetMap& owner,
        ::nds::road::reference::types::RoadPositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectRoadPositionAttributeSetMap::ZserioElementFactory_validities::create(RulesIndirectRoadPositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadPositionAttributeSetMap::ZserioElementFactory_validities::create(RulesIndirectRoadPositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadPositionValidity>& array,
        ::nds::road::reference::types::RoadPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesRoadPositionAttributeSet RulesIndirectRoadPositionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadPositionAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesRoadPositionAttributeSet RulesIndirectRoadPositionAttributeSetMap::readAttributeSet(RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRoadPositionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesIndirectRoadPositionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesIndirectRoadPositionAttributeSetMap::readFeature(RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectRoadPositionAttributeSetMap::ZserioArrayType_references RulesIndirectRoadPositionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadPositionAttributeSetMap::ZserioArrayType_references RulesIndirectRoadPositionAttributeSetMap::readReferences(RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectRoadPositionAttributeSetMap::ZserioArrayType_validities RulesIndirectRoadPositionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectRoadPositionAttributeSetMap::ZserioArrayType_validities RulesIndirectRoadPositionAttributeSetMap::readValidities(RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneRangeAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneRangeAttributeSetMap::RulesLaneRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesLaneRangeAttributeSetMap::RulesLaneRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesLaneRangeAttributeSetMap::RulesLaneRangeAttributeSetMap(RulesLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesLaneRangeAttributeSetMap::RulesLaneRangeAttributeSetMap(const RulesLaneRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeSetMap& RulesLaneRangeAttributeSetMap::operator=(const RulesLaneRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeSetMap::RulesLaneRangeAttributeSetMap(RulesLaneRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeSetMap& RulesLaneRangeAttributeSetMap::operator=(RulesLaneRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeSetMap::RulesLaneRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesLaneRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLaneRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLaneRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLaneRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesLaneRangeAttributeSet& RulesLaneRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesLaneRangeAttributeSet& RulesLaneRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesLaneRangeAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesLaneRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesLaneRangeAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesLaneRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesLaneRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesLaneRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RulesLaneRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RulesLaneRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesLaneRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesLaneRangeAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RulesLaneRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RulesLaneRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesLaneRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesLaneRangeAttributeSetMap::setValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesLaneRangeAttributeSetMap::initPackingContext(RulesLaneRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesLaneRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeSetMap::bitSizeOf(RulesLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneRangeAttributeSetMap::initializeOffsets(RulesLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneRangeAttributeSetMap::operator==(const RulesLaneRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesLaneRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesLaneRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesLaneRangeAttributeSetMap::write(RulesLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesLaneRangeAttributeSetMap::ZserioElementFactory_references::create(RulesLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneRangeAttributeSetMap::ZserioElementFactory_references::create(RulesLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesLaneRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesLaneRangeAttributeSetMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesLaneRangeAttributeSet RulesLaneRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneRangeAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesLaneRangeAttributeSet RulesLaneRangeAttributeSetMap::readAttributeSet(RulesLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesLaneRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesLaneRangeAttributeSetMap::readFeature(RulesLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneRangeAttributeSetMap::ZserioArrayType_references RulesLaneRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLaneRangeAttributeSetMap::ZserioArrayType_references RulesLaneRangeAttributeSetMap::readReferences(RulesLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesLaneRangeAttributeSetMap::ZserioArrayType_validities RulesLaneRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLaneRangeAttributeSetMap::ZserioArrayType_validities RulesLaneRangeAttributeSetMap::readValidities(RulesLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectLaneRangeAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectLaneRangeAttributeSetMap::RulesIndirectLaneRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesIndirectLaneRangeAttributeSetMap::RulesIndirectLaneRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesIndirectLaneRangeAttributeSetMap::RulesIndirectLaneRangeAttributeSetMap(RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesIndirectLaneRangeAttributeSetMap::RulesIndirectLaneRangeAttributeSetMap(const RulesIndirectLaneRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLaneRangeAttributeSetMap& RulesIndirectLaneRangeAttributeSetMap::operator=(const RulesIndirectLaneRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLaneRangeAttributeSetMap::RulesIndirectLaneRangeAttributeSetMap(RulesIndirectLaneRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLaneRangeAttributeSetMap& RulesIndirectLaneRangeAttributeSetMap::operator=(RulesIndirectLaneRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLaneRangeAttributeSetMap::RulesIndirectLaneRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesIndirectLaneRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectLaneRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectLaneRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectLaneRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectLaneRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectLaneRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesLaneRangeAttributeSet& RulesIndirectLaneRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesLaneRangeAttributeSet& RulesIndirectLaneRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesIndirectLaneRangeAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesLaneRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesIndirectLaneRangeAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesLaneRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesIndirectLaneRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesIndirectLaneRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& RulesIndirectLaneRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& RulesIndirectLaneRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesIndirectLaneRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesIndirectLaneRangeAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RulesIndirectLaneRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& RulesIndirectLaneRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesIndirectLaneRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesIndirectLaneRangeAttributeSetMap::setValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesIndirectLaneRangeAttributeSetMap::initPackingContext(RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesIndirectLaneRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLaneRangeAttributeSetMap::bitSizeOf(RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLaneRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectLaneRangeAttributeSetMap::initializeOffsets(RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectLaneRangeAttributeSetMap::operator==(const RulesIndirectLaneRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesIndirectLaneRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesIndirectLaneRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesIndirectLaneRangeAttributeSetMap::write(RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesIndirectLaneRangeAttributeSetMap::ZserioArrayExpressions_references::initializeElement(RulesIndirectLaneRangeAttributeSetMap&,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectLaneRangeAttributeSetMap::ZserioElementFactory_references::create(RulesIndirectLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectLaneRangeAttributeSetMap::ZserioElementFactory_references::create(RulesIndirectLaneRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectLaneRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesIndirectLaneRangeAttributeSetMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesIndirectLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLaneRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesIndirectLaneRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesLaneRangeAttributeSet RulesIndirectLaneRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneRangeAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesLaneRangeAttributeSet RulesIndirectLaneRangeAttributeSetMap::readAttributeSet(RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesIndirectLaneRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesIndirectLaneRangeAttributeSetMap::readFeature(RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectLaneRangeAttributeSetMap::ZserioArrayType_references RulesIndirectLaneRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLaneRangeAttributeSetMap::ZserioArrayType_references RulesIndirectLaneRangeAttributeSetMap::readReferences(RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectLaneRangeAttributeSetMap::ZserioArrayType_validities RulesIndirectLaneRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLaneRangeAttributeSetMap::ZserioArrayType_validities RulesIndirectLaneRangeAttributeSetMap::readValidities(RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLanePositionAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLanePositionAttributeSetMap::RulesLanePositionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesLanePositionAttributeSetMap::RulesLanePositionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesLanePositionAttributeSetMap::RulesLanePositionAttributeSetMap(RulesLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesLanePositionAttributeSetMap::RulesLanePositionAttributeSetMap(const RulesLanePositionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeSetMap& RulesLanePositionAttributeSetMap::operator=(const RulesLanePositionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeSetMap::RulesLanePositionAttributeSetMap(RulesLanePositionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeSetMap& RulesLanePositionAttributeSetMap::operator=(RulesLanePositionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeSetMap::RulesLanePositionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesLanePositionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLanePositionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLanePositionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesLanePositionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLanePositionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLanePositionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesLanePositionAttributeSet& RulesLanePositionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesLanePositionAttributeSet& RulesLanePositionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesLanePositionAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesLanePositionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesLanePositionAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesLanePositionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesLanePositionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesLanePositionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RulesLanePositionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& RulesLanePositionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesLanePositionAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesLanePositionAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& RulesLanePositionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& RulesLanePositionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesLanePositionAttributeSetMap::setValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesLanePositionAttributeSetMap::setValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesLanePositionAttributeSetMap::initPackingContext(RulesLanePositionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesLanePositionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeSetMap::bitSizeOf(RulesLanePositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLanePositionAttributeSetMap::initializeOffsets(RulesLanePositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLanePositionAttributeSetMap::operator==(const RulesLanePositionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesLanePositionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesLanePositionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesLanePositionAttributeSetMap::write(RulesLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesLanePositionAttributeSetMap::ZserioElementFactory_references::create(RulesLanePositionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLanePositionAttributeSetMap::ZserioElementFactory_references::create(RulesLanePositionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesLanePositionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesLanePositionAttributeSetMap& owner,
        ::nds::lane::reference::types::LaneGroupPositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLanePositionAttributeSetMap::ZserioElementFactory_validities::create(RulesLanePositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLanePositionAttributeSetMap::ZserioElementFactory_validities::create(RulesLanePositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& array,
        ::nds::lane::reference::types::LaneGroupPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesLanePositionAttributeSet RulesLanePositionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLanePositionAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesLanePositionAttributeSet RulesLanePositionAttributeSetMap::readAttributeSet(RulesLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLanePositionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesLanePositionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesLanePositionAttributeSetMap::readFeature(RulesLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLanePositionAttributeSetMap::ZserioArrayType_references RulesLanePositionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLanePositionAttributeSetMap::ZserioArrayType_references RulesLanePositionAttributeSetMap::readReferences(RulesLanePositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesLanePositionAttributeSetMap::ZserioArrayType_validities RulesLanePositionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLanePositionAttributeSetMap::ZserioArrayType_validities RulesLanePositionAttributeSetMap::readValidities(RulesLanePositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectLanePositionAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectLanePositionAttributeSetMap::RulesIndirectLanePositionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesIndirectLanePositionAttributeSetMap::RulesIndirectLanePositionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesIndirectLanePositionAttributeSetMap::RulesIndirectLanePositionAttributeSetMap(RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesIndirectLanePositionAttributeSetMap::RulesIndirectLanePositionAttributeSetMap(const RulesIndirectLanePositionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLanePositionAttributeSetMap& RulesIndirectLanePositionAttributeSetMap::operator=(const RulesIndirectLanePositionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLanePositionAttributeSetMap::RulesIndirectLanePositionAttributeSetMap(RulesIndirectLanePositionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLanePositionAttributeSetMap& RulesIndirectLanePositionAttributeSetMap::operator=(RulesIndirectLanePositionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLanePositionAttributeSetMap::RulesIndirectLanePositionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesIndirectLanePositionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectLanePositionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectLanePositionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectLanePositionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectLanePositionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectLanePositionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesLanePositionAttributeSet& RulesIndirectLanePositionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesLanePositionAttributeSet& RulesIndirectLanePositionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesIndirectLanePositionAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesLanePositionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesIndirectLanePositionAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesLanePositionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesIndirectLanePositionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesIndirectLanePositionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& RulesIndirectLanePositionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& RulesIndirectLanePositionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesIndirectLanePositionAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesIndirectLanePositionAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& RulesIndirectLanePositionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& RulesIndirectLanePositionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesIndirectLanePositionAttributeSetMap::setValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesIndirectLanePositionAttributeSetMap::setValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesIndirectLanePositionAttributeSetMap::initPackingContext(RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesIndirectLanePositionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLanePositionAttributeSetMap::bitSizeOf(RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLanePositionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectLanePositionAttributeSetMap::initializeOffsets(RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectLanePositionAttributeSetMap::operator==(const RulesIndirectLanePositionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesIndirectLanePositionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesIndirectLanePositionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesIndirectLanePositionAttributeSetMap::write(RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesIndirectLanePositionAttributeSetMap::ZserioArrayExpressions_references::initializeElement(RulesIndirectLanePositionAttributeSetMap&,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect& element, size_t)
{
    element.initializeChildren();
}

void RulesIndirectLanePositionAttributeSetMap::ZserioElementFactory_references::create(RulesIndirectLanePositionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesIndirectLanePositionAttributeSetMap::ZserioElementFactory_references::create(RulesIndirectLanePositionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupReferenceIndirect>& array,
        ::nds::lane::reference::types::LaneGroupReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesIndirectLanePositionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesIndirectLanePositionAttributeSetMap& owner,
        ::nds::lane::reference::types::LaneGroupPositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectLanePositionAttributeSetMap::ZserioElementFactory_validities::create(RulesIndirectLanePositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLanePositionAttributeSetMap::ZserioElementFactory_validities::create(RulesIndirectLanePositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupPositionValidity>& array,
        ::nds::lane::reference::types::LaneGroupPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesLanePositionAttributeSet RulesIndirectLanePositionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLanePositionAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesLanePositionAttributeSet RulesIndirectLanePositionAttributeSetMap::readAttributeSet(RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLanePositionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesIndirectLanePositionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesIndirectLanePositionAttributeSetMap::readFeature(RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectLanePositionAttributeSetMap::ZserioArrayType_references RulesIndirectLanePositionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLanePositionAttributeSetMap::ZserioArrayType_references RulesIndirectLanePositionAttributeSetMap::readReferences(RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesIndirectLanePositionAttributeSetMap::ZserioArrayType_validities RulesIndirectLanePositionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesIndirectLanePositionAttributeSetMap::ZserioArrayType_validities RulesIndirectLanePositionAttributeSetMap::readValidities(RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneTransitionAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneTransitionAttributeSetMap::RulesLaneTransitionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesLaneTransitionAttributeSetMap::RulesLaneTransitionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesLaneTransitionAttributeSetMap::RulesLaneTransitionAttributeSetMap(RulesLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesLaneTransitionAttributeSetMap::RulesLaneTransitionAttributeSetMap(const RulesLaneTransitionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeSetMap& RulesLaneTransitionAttributeSetMap::operator=(const RulesLaneTransitionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeSetMap::RulesLaneTransitionAttributeSetMap(RulesLaneTransitionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeSetMap& RulesLaneTransitionAttributeSetMap::operator=(RulesLaneTransitionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeSetMap::RulesLaneTransitionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLaneTransitionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneTransitionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneTransitionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLaneTransitionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLaneTransitionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesLaneTransitionAttributeSet& RulesLaneTransitionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesLaneTransitionAttributeSet& RulesLaneTransitionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesLaneTransitionAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesLaneTransitionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesLaneTransitionAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesLaneTransitionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesLaneTransitionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesLaneTransitionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& RulesLaneTransitionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& RulesLaneTransitionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesLaneTransitionAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesLaneTransitionAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RulesLaneTransitionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RulesLaneTransitionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesLaneTransitionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesLaneTransitionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesLaneTransitionAttributeSetMap::initPackingContext(RulesLaneTransitionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesLaneTransitionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeSetMap::bitSizeOf(RulesLaneTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneTransitionAttributeSetMap::initializeOffsets(RulesLaneTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneTransitionAttributeSetMap::operator==(const RulesLaneTransitionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesLaneTransitionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesLaneTransitionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RulesLaneTransitionAttributeSetMap::write(RulesLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RulesLaneTransitionAttributeSetMap::ZserioArrayExpressions_references::initializeElement(RulesLaneTransitionAttributeSetMap&,
        ::nds::lane::reference::types::LaneGroupTransitionReference& element, size_t)
{
    element.initializeChildren();
}

void RulesLaneTransitionAttributeSetMap::ZserioElementFactory_references::create(RulesLaneTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesLaneTransitionAttributeSetMap::ZserioElementFactory_references::create(RulesLaneTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransitionReference>& array,
        ::nds::lane::reference::types::LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesLaneTransitionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesLaneTransitionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLaneTransitionAttributeSetMap::ZserioElementFactory_validities::create(RulesLaneTransitionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesLaneTransitionAttributeSet RulesLaneTransitionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneTransitionAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesLaneTransitionAttributeSet RulesLaneTransitionAttributeSetMap::readAttributeSet(RulesLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesLaneTransitionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesLaneTransitionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesLaneTransitionAttributeSetMap::readFeature(RulesLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneTransitionAttributeSetMap::ZserioArrayType_references RulesLaneTransitionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesLaneTransitionAttributeSetMap::ZserioArrayType_references RulesLaneTransitionAttributeSetMap::readReferences(RulesLaneTransitionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesLaneTransitionAttributeSetMap::ZserioArrayType_validities RulesLaneTransitionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesTransitionAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesTransitionAttributeSetMap::RulesTransitionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesTransitionAttributeSetMap::RulesTransitionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesTransitionAttributeSetMap::RulesTransitionAttributeSetMap(RulesTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesTransitionAttributeSetMap::RulesTransitionAttributeSetMap(const RulesTransitionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeSetMap& RulesTransitionAttributeSetMap::operator=(const RulesTransitionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeSetMap::RulesTransitionAttributeSetMap(RulesTransitionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeSetMap& RulesTransitionAttributeSetMap::operator=(RulesTransitionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeSetMap::RulesTransitionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesTransitionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesTransitionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesTransitionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesTransitionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_references_.initializeElements(*this);
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesTransitionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesTransitionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesTransitionAttributeSet& RulesTransitionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesTransitionAttributeSet& RulesTransitionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesTransitionAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesTransitionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesTransitionAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesTransitionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesTransitionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesTransitionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::TransitionReference>& RulesTransitionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::TransitionReference>& RulesTransitionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesTransitionAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::TransitionReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesTransitionAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::TransitionReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RulesTransitionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RulesTransitionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesTransitionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesTransitionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesTransitionAttributeSetMap::initPackingContext(RulesTransitionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesTransitionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeSetMap::bitSizeOf(RulesTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesTransitionAttributeSetMap::initializeOffsets(RulesTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool RulesTransitionAttributeSetMap::operator==(const RulesTransitionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesTransitionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesTransitionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RulesTransitionAttributeSetMap::write(RulesTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RulesTransitionAttributeSetMap::ZserioArrayExpressions_references::initializeElement(RulesTransitionAttributeSetMap&,
        ::nds::road::reference::types::TransitionReference& element, size_t)
{
    element.initializeChildren();
}

void RulesTransitionAttributeSetMap::ZserioElementFactory_references::create(RulesTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesTransitionAttributeSetMap::ZserioElementFactory_references::create(RulesTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::TransitionReference>& array,
        ::nds::road::reference::types::TransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesTransitionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesTransitionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesTransitionAttributeSetMap::ZserioElementFactory_validities::create(RulesTransitionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesTransitionAttributeSet RulesTransitionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesTransitionAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesTransitionAttributeSet RulesTransitionAttributeSetMap::readAttributeSet(RulesTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesTransitionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesTransitionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesTransitionAttributeSetMap::readFeature(RulesTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesTransitionAttributeSetMap::ZserioArrayType_references RulesTransitionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesTransitionAttributeSetMap::ZserioArrayType_references RulesTransitionAttributeSetMap::readReferences(RulesTransitionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesTransitionAttributeSetMap::ZserioArrayType_validities RulesTransitionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadLocationTransitionAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadLocationTransitionAttributeSetMap::RulesRoadLocationTransitionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesRoadLocationTransitionAttributeSetMap::RulesRoadLocationTransitionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesRoadLocationTransitionAttributeSetMap::RulesRoadLocationTransitionAttributeSetMap(RulesRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesRoadLocationTransitionAttributeSetMap::RulesRoadLocationTransitionAttributeSetMap(const RulesRoadLocationTransitionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationTransitionAttributeSetMap& RulesRoadLocationTransitionAttributeSetMap::operator=(const RulesRoadLocationTransitionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationTransitionAttributeSetMap::RulesRoadLocationTransitionAttributeSetMap(RulesRoadLocationTransitionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationTransitionAttributeSetMap& RulesRoadLocationTransitionAttributeSetMap::operator=(RulesRoadLocationTransitionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationTransitionAttributeSetMap::RulesRoadLocationTransitionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesRoadLocationTransitionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadLocationTransitionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadLocationTransitionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadLocationTransitionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadLocationTransitionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadLocationTransitionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesTransitionAttributeSet& RulesRoadLocationTransitionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesTransitionAttributeSet& RulesRoadLocationTransitionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesRoadLocationTransitionAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesTransitionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesRoadLocationTransitionAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesTransitionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesRoadLocationTransitionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesRoadLocationTransitionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& RulesRoadLocationTransitionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& RulesRoadLocationTransitionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesRoadLocationTransitionAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesRoadLocationTransitionAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::core::attributemap::Validity>& RulesRoadLocationTransitionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& RulesRoadLocationTransitionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesRoadLocationTransitionAttributeSetMap::setValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesRoadLocationTransitionAttributeSetMap::setValidities(::zserio::vector<::nds::core::attributemap::Validity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesRoadLocationTransitionAttributeSetMap::initPackingContext(RulesRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesRoadLocationTransitionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationTransitionAttributeSetMap::bitSizeOf(RulesRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationTransitionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadLocationTransitionAttributeSetMap::initializeOffsets(RulesRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadLocationTransitionAttributeSetMap::operator==(const RulesRoadLocationTransitionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesRoadLocationTransitionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesRoadLocationTransitionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RulesRoadLocationTransitionAttributeSetMap::write(RulesRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.write(*this, out);
}

void RulesRoadLocationTransitionAttributeSetMap::ZserioElementFactory_references::create(RulesRoadLocationTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesRoadLocationTransitionAttributeSetMap::ZserioElementFactory_references::create(RulesRoadLocationTransitionAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::location::RoadLocationTransitionReference>& array,
        ::nds::road::reference::location::RoadLocationTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesRoadLocationTransitionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesRoadLocationTransitionAttributeSetMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadLocationTransitionAttributeSetMap::ZserioElementFactory_validities::create(RulesRoadLocationTransitionAttributeSetMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesTransitionAttributeSet RulesRoadLocationTransitionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesTransitionAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesTransitionAttributeSet RulesRoadLocationTransitionAttributeSetMap::readAttributeSet(RulesRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesTransitionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesRoadLocationTransitionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRoadLocationTransitionAttributeSetMap::readFeature(RulesRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadLocationTransitionAttributeSetMap::ZserioArrayType_references RulesRoadLocationTransitionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRoadLocationTransitionAttributeSetMap::ZserioArrayType_references RulesRoadLocationTransitionAttributeSetMap::readReferences(RulesRoadLocationTransitionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRoadLocationTransitionAttributeSetMap::ZserioArrayType_validities RulesRoadLocationTransitionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRegionAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRegionAttributeSetMap::RulesRegionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesRegionAttributeSetMap::RulesRegionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesRegionAttributeSetMap::RulesRegionAttributeSetMap(RulesRegionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesRegionAttributeSetMap::RulesRegionAttributeSetMap(const RulesRegionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeSetMap& RulesRegionAttributeSetMap::operator=(const RulesRegionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeSetMap::RulesRegionAttributeSetMap(RulesRegionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeSetMap& RulesRegionAttributeSetMap::operator=(RulesRegionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeSetMap::RulesRegionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesRegionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRegionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRegionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesRegionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRegionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRegionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesRegionAttributeSet& RulesRegionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesRegionAttributeSet& RulesRegionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesRegionAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesRegionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesRegionAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesRegionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesRegionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesRegionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::core::types::RegionId>& RulesRegionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::core::types::RegionId>& RulesRegionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesRegionAttributeSetMap::setReferences(const ::zserio::vector<::nds::core::types::RegionId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesRegionAttributeSetMap::setReferences(::zserio::vector<::nds::core::types::RegionId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::rules::types::RegionValidity>& RulesRegionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::rules::types::RegionValidity>& RulesRegionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesRegionAttributeSetMap::setValidities(const ::zserio::vector<::nds::rules::types::RegionValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesRegionAttributeSetMap::setValidities(::zserio::vector<::nds::rules::types::RegionValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesRegionAttributeSetMap::initPackingContext(RulesRegionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesRegionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeSetMap::bitSizeOf(RulesRegionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRegionAttributeSetMap::initializeOffsets(RulesRegionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRegionAttributeSetMap::operator==(const RulesRegionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesRegionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesRegionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesRegionAttributeSetMap::write(RulesRegionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesRegionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesRegionAttributeSetMap& owner,
        ::nds::rules::types::RegionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRegionAttributeSetMap::ZserioElementFactory_validities::create(RulesRegionAttributeSetMap&         owner,
        ::zserio::vector<::nds::rules::types::RegionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRegionAttributeSetMap::ZserioElementFactory_validities::create(RulesRegionAttributeSetMap&         owner,
        ::zserio::vector<::nds::rules::types::RegionValidity>& array,
        ::nds::rules::types::RegionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesRegionAttributeSet RulesRegionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRegionAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesRegionAttributeSet RulesRegionAttributeSetMap::readAttributeSet(RulesRegionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesRegionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesRegionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesRegionAttributeSetMap::readFeature(RulesRegionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRegionAttributeSetMap::ZserioArrayType_references RulesRegionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRegionAttributeSetMap::ZserioArrayType_references RulesRegionAttributeSetMap::readReferences(RulesRegionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesRegionAttributeSetMap::ZserioArrayType_validities RulesRegionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesRegionAttributeSetMap::ZserioArrayType_validities RulesRegionAttributeSetMap::readValidities(RulesRegionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLineRangeAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLineRangeAttributeSetMap::RulesDisplayLineRangeAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesDisplayLineRangeAttributeSetMap::RulesDisplayLineRangeAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesDisplayLineRangeAttributeSetMap::RulesDisplayLineRangeAttributeSetMap(RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesDisplayLineRangeAttributeSetMap::RulesDisplayLineRangeAttributeSetMap(const RulesDisplayLineRangeAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeSetMap& RulesDisplayLineRangeAttributeSetMap::operator=(const RulesDisplayLineRangeAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeSetMap::RulesDisplayLineRangeAttributeSetMap(RulesDisplayLineRangeAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeSetMap& RulesDisplayLineRangeAttributeSetMap::operator=(RulesDisplayLineRangeAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeSetMap::RulesDisplayLineRangeAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesDisplayLineRangeAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLineRangeAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLineRangeAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesDisplayLineRangeAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesDisplayLineRangeAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesDisplayLineRangeAttributeSet& RulesDisplayLineRangeAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesDisplayLineRangeAttributeSet& RulesDisplayLineRangeAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesDisplayLineRangeAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesDisplayLineRangeAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesDisplayLineRangeAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesDisplayLineRangeAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesDisplayLineRangeAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesDisplayLineRangeAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::display::reference::types::DisplayLineReference>& RulesDisplayLineRangeAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& RulesDisplayLineRangeAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesDisplayLineRangeAttributeSetMap::setReferences(const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesDisplayLineRangeAttributeSetMap::setReferences(::zserio::vector<::nds::display::reference::types::DisplayLineReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& RulesDisplayLineRangeAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& RulesDisplayLineRangeAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesDisplayLineRangeAttributeSetMap::setValidities(const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesDisplayLineRangeAttributeSetMap::setValidities(::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesDisplayLineRangeAttributeSetMap::initPackingContext(RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesDisplayLineRangeAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeSetMap::bitSizeOf(RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLineRangeAttributeSetMap::initializeOffsets(RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLineRangeAttributeSetMap::operator==(const RulesDisplayLineRangeAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesDisplayLineRangeAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesDisplayLineRangeAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeSetMap::write(RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeSetMap::ZserioElementFactory_references::create(RulesDisplayLineRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeSetMap::ZserioElementFactory_references::create(RulesDisplayLineRangeAttributeSetMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::nds::display::reference::types::DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesDisplayLineRangeAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesDisplayLineRangeAttributeSetMap& owner,
        ::nds::display::reference::types::DisplayLineRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesDisplayLineRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesDisplayLineRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLineRangeAttributeSetMap::ZserioElementFactory_validities::create(RulesDisplayLineRangeAttributeSetMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeValidity>& array,
        ::nds::display::reference::types::DisplayLineRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesDisplayLineRangeAttributeSet RulesDisplayLineRangeAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesDisplayLineRangeAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesDisplayLineRangeAttributeSet RulesDisplayLineRangeAttributeSetMap::readAttributeSet(RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesDisplayLineRangeAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesDisplayLineRangeAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesDisplayLineRangeAttributeSetMap::readFeature(RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLineRangeAttributeSetMap::ZserioArrayType_references RulesDisplayLineRangeAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLineRangeAttributeSetMap::ZserioArrayType_references RulesDisplayLineRangeAttributeSetMap::readReferences(RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesDisplayLineRangeAttributeSetMap::ZserioArrayType_validities RulesDisplayLineRangeAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLineRangeAttributeSetMap::ZserioArrayType_validities RulesDisplayLineRangeAttributeSetMap::readValidities(RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLinePositionAttributeSetMap.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLinePositionAttributeSetMap::RulesDisplayLinePositionAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

RulesDisplayLinePositionAttributeSetMap::RulesDisplayLinePositionAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

RulesDisplayLinePositionAttributeSetMap::RulesDisplayLinePositionAttributeSetMap(RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

RulesDisplayLinePositionAttributeSetMap::RulesDisplayLinePositionAttributeSetMap(const RulesDisplayLinePositionAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeSetMap& RulesDisplayLinePositionAttributeSetMap::operator=(const RulesDisplayLinePositionAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeSetMap::RulesDisplayLinePositionAttributeSetMap(RulesDisplayLinePositionAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeSetMap& RulesDisplayLinePositionAttributeSetMap::operator=(RulesDisplayLinePositionAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeSetMap::RulesDisplayLinePositionAttributeSetMap(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesDisplayLinePositionAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLinePositionAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLinePositionAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesDisplayLinePositionAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesDisplayLinePositionAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::rules::instantiations::RulesDisplayLinePositionAttributeSet& RulesDisplayLinePositionAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::rules::instantiations::RulesDisplayLinePositionAttributeSet& RulesDisplayLinePositionAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void RulesDisplayLinePositionAttributeSetMap::setAttributeSet(const ::nds::rules::instantiations::RulesDisplayLinePositionAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void RulesDisplayLinePositionAttributeSetMap::setAttributeSet(::nds::rules::instantiations::RulesDisplayLinePositionAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator RulesDisplayLinePositionAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void RulesDisplayLinePositionAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::display::reference::types::DisplayLineReference>& RulesDisplayLinePositionAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& RulesDisplayLinePositionAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void RulesDisplayLinePositionAttributeSetMap::setReferences(const ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void RulesDisplayLinePositionAttributeSetMap::setReferences(::zserio::vector<::nds::display::reference::types::DisplayLineReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& RulesDisplayLinePositionAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& RulesDisplayLinePositionAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void RulesDisplayLinePositionAttributeSetMap::setValidities(const ::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void RulesDisplayLinePositionAttributeSetMap::setValidities(::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void RulesDisplayLinePositionAttributeSetMap::initPackingContext(RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t RulesDisplayLinePositionAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeSetMap::bitSizeOf(RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLinePositionAttributeSetMap::initializeOffsets(RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLinePositionAttributeSetMap::operator==(const RulesDisplayLinePositionAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t RulesDisplayLinePositionAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void RulesDisplayLinePositionAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeSetMap::write(RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeSetMap::ZserioElementFactory_references::create(RulesDisplayLinePositionAttributeSetMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeSetMap::ZserioElementFactory_references::create(RulesDisplayLinePositionAttributeSetMap&        ,
        ::zserio::vector<::nds::display::reference::types::DisplayLineReference>& array,
        ::nds::display::reference::types::DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RulesDisplayLinePositionAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(RulesDisplayLinePositionAttributeSetMap& owner,
        ::nds::display::reference::types::DisplayLinePositionValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesDisplayLinePositionAttributeSetMap::ZserioElementFactory_validities::create(RulesDisplayLinePositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLinePositionAttributeSetMap::ZserioElementFactory_validities::create(RulesDisplayLinePositionAttributeSetMap&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLinePositionValidity>& array,
        ::nds::display::reference::types::DisplayLinePositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::rules::instantiations::RulesDisplayLinePositionAttributeSet RulesDisplayLinePositionAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesDisplayLinePositionAttributeSet(in, allocator);
}

::nds::rules::instantiations::RulesDisplayLinePositionAttributeSet RulesDisplayLinePositionAttributeSetMap::readAttributeSet(RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::rules::instantiations::RulesDisplayLinePositionAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator RulesDisplayLinePositionAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator RulesDisplayLinePositionAttributeSetMap::readFeature(RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLinePositionAttributeSetMap::ZserioArrayType_references RulesDisplayLinePositionAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLinePositionAttributeSetMap::ZserioArrayType_references RulesDisplayLinePositionAttributeSetMap::readReferences(RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
RulesDisplayLinePositionAttributeSetMap::ZserioArrayType_validities RulesDisplayLinePositionAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

RulesDisplayLinePositionAttributeSetMap::ZserioArrayType_validities RulesDisplayLinePositionAttributeSetMap::readValidities(RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadRangeAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadRangeAttributeSetList::RulesRoadRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesRoadRangeAttributeSetList::RulesRoadRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesRoadRangeAttributeSetList::RulesRoadRangeAttributeSetList(RulesRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesRoadRangeAttributeSetList::RulesRoadRangeAttributeSetList(const RulesRoadRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeSetList& RulesRoadRangeAttributeSetList::operator=(const RulesRoadRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeSetList::RulesRoadRangeAttributeSetList(RulesRoadRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadRangeAttributeSetList& RulesRoadRangeAttributeSetList::operator=(RulesRoadRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadRangeAttributeSetList::RulesRoadRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesRoadRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRoadRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesRoadRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeSetMap>& RulesRoadRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeSetMap>& RulesRoadRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesRoadRangeAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesRoadRangeAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesRoadRangeAttributeSetList::initPackingContext(RulesRoadRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesRoadRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeSetList::bitSizeOf(RulesRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadRangeAttributeSetList::initializeOffsets(RulesRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadRangeAttributeSetList::operator==(const RulesRoadRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesRoadRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesRoadRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRoadRangeAttributeSetList::write(RulesRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRoadRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesRoadRangeAttributeSetList& owner,
        ::nds::rules::instantiations::RulesRoadRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadRangeAttributeSetList::ZserioElementFactory_sets::create(RulesRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadRangeAttributeSetList::ZserioElementFactory_sets::create(RulesRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadRangeAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRoadRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadRangeAttributeSetList::readNumAttributeSets(RulesRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadRangeAttributeSetList::ZserioArrayType_sets RulesRoadRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesRoadRangeAttributeSetList::ZserioArrayType_sets RulesRoadRangeAttributeSetList::readSets(RulesRoadRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectRoadRangeAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectRoadRangeAttributeSetList::RulesIndirectRoadRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesIndirectRoadRangeAttributeSetList::RulesIndirectRoadRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesIndirectRoadRangeAttributeSetList::RulesIndirectRoadRangeAttributeSetList(RulesIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesIndirectRoadRangeAttributeSetList::RulesIndirectRoadRangeAttributeSetList(const RulesIndirectRoadRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadRangeAttributeSetList& RulesIndirectRoadRangeAttributeSetList::operator=(const RulesIndirectRoadRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadRangeAttributeSetList::RulesIndirectRoadRangeAttributeSetList(RulesIndirectRoadRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadRangeAttributeSetList& RulesIndirectRoadRangeAttributeSetList::operator=(RulesIndirectRoadRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadRangeAttributeSetList::RulesIndirectRoadRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesIndirectRoadRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectRoadRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectRoadRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectRoadRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectRoadRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectRoadRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesIndirectRoadRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesIndirectRoadRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeSetMap>& RulesIndirectRoadRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeSetMap>& RulesIndirectRoadRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesIndirectRoadRangeAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesIndirectRoadRangeAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesIndirectRoadRangeAttributeSetList::initPackingContext(RulesIndirectRoadRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesIndirectRoadRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadRangeAttributeSetList::bitSizeOf(RulesIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectRoadRangeAttributeSetList::initializeOffsets(RulesIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectRoadRangeAttributeSetList::operator==(const RulesIndirectRoadRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesIndirectRoadRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesIndirectRoadRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesIndirectRoadRangeAttributeSetList::write(RulesIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesIndirectRoadRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesIndirectRoadRangeAttributeSetList& owner,
        ::nds::rules::instantiations::RulesIndirectRoadRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectRoadRangeAttributeSetList::ZserioElementFactory_sets::create(RulesIndirectRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadRangeAttributeSetList::ZserioElementFactory_sets::create(RulesIndirectRoadRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadRangeAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesIndirectRoadRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesIndirectRoadRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesIndirectRoadRangeAttributeSetList::readNumAttributeSets(RulesIndirectRoadRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectRoadRangeAttributeSetList::ZserioArrayType_sets RulesIndirectRoadRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesIndirectRoadRangeAttributeSetList::ZserioArrayType_sets RulesIndirectRoadRangeAttributeSetList::readSets(RulesIndirectRoadRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadLocationRangeAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadLocationRangeAttributeSetList::RulesRoadLocationRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesRoadLocationRangeAttributeSetList::RulesRoadLocationRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesRoadLocationRangeAttributeSetList::RulesRoadLocationRangeAttributeSetList(RulesRoadLocationRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesRoadLocationRangeAttributeSetList::RulesRoadLocationRangeAttributeSetList(const RulesRoadLocationRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationRangeAttributeSetList& RulesRoadLocationRangeAttributeSetList::operator=(const RulesRoadLocationRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationRangeAttributeSetList::RulesRoadLocationRangeAttributeSetList(RulesRoadLocationRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationRangeAttributeSetList& RulesRoadLocationRangeAttributeSetList::operator=(RulesRoadLocationRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationRangeAttributeSetList::RulesRoadLocationRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesRoadLocationRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadLocationRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadLocationRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadLocationRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadLocationRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadLocationRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRoadLocationRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesRoadLocationRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeSetMap>& RulesRoadLocationRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeSetMap>& RulesRoadLocationRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesRoadLocationRangeAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesRoadLocationRangeAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesRoadLocationRangeAttributeSetList::initPackingContext(RulesRoadLocationRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesRoadLocationRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationRangeAttributeSetList::bitSizeOf(RulesRoadLocationRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadLocationRangeAttributeSetList::initializeOffsets(RulesRoadLocationRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadLocationRangeAttributeSetList::operator==(const RulesRoadLocationRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesRoadLocationRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesRoadLocationRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRoadLocationRangeAttributeSetList::write(RulesRoadLocationRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRoadLocationRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesRoadLocationRangeAttributeSetList& owner,
        ::nds::rules::instantiations::RulesRoadLocationRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadLocationRangeAttributeSetList::ZserioElementFactory_sets::create(RulesRoadLocationRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadLocationRangeAttributeSetList::ZserioElementFactory_sets::create(RulesRoadLocationRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationRangeAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesRoadLocationRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRoadLocationRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadLocationRangeAttributeSetList::readNumAttributeSets(RulesRoadLocationRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadLocationRangeAttributeSetList::ZserioArrayType_sets RulesRoadLocationRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesRoadLocationRangeAttributeSetList::ZserioArrayType_sets RulesRoadLocationRangeAttributeSetList::readSets(RulesRoadLocationRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadPositionAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadPositionAttributeSetList::RulesRoadPositionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesRoadPositionAttributeSetList::RulesRoadPositionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesRoadPositionAttributeSetList::RulesRoadPositionAttributeSetList(RulesRoadPositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesRoadPositionAttributeSetList::RulesRoadPositionAttributeSetList(const RulesRoadPositionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeSetList& RulesRoadPositionAttributeSetList::operator=(const RulesRoadPositionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeSetList::RulesRoadPositionAttributeSetList(RulesRoadPositionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadPositionAttributeSetList& RulesRoadPositionAttributeSetList::operator=(RulesRoadPositionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadPositionAttributeSetList::RulesRoadPositionAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesRoadPositionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadPositionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadPositionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadPositionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadPositionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadPositionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRoadPositionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesRoadPositionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeSetMap>& RulesRoadPositionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeSetMap>& RulesRoadPositionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesRoadPositionAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesRoadPositionAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesRoadPositionAttributeSetList::initPackingContext(RulesRoadPositionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesRoadPositionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeSetList::bitSizeOf(RulesRoadPositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadPositionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadPositionAttributeSetList::initializeOffsets(RulesRoadPositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadPositionAttributeSetList::operator==(const RulesRoadPositionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesRoadPositionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesRoadPositionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRoadPositionAttributeSetList::write(RulesRoadPositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadPositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRoadPositionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesRoadPositionAttributeSetList& owner,
        ::nds::rules::instantiations::RulesRoadPositionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadPositionAttributeSetList::ZserioElementFactory_sets::create(RulesRoadPositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadPositionAttributeSetList::ZserioElementFactory_sets::create(RulesRoadPositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadPositionAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRoadPositionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadPositionAttributeSetList::readNumAttributeSets(RulesRoadPositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadPositionAttributeSetList::ZserioArrayType_sets RulesRoadPositionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesRoadPositionAttributeSetList::ZserioArrayType_sets RulesRoadPositionAttributeSetList::readSets(RulesRoadPositionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectRoadPositionAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectRoadPositionAttributeSetList::RulesIndirectRoadPositionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesIndirectRoadPositionAttributeSetList::RulesIndirectRoadPositionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesIndirectRoadPositionAttributeSetList::RulesIndirectRoadPositionAttributeSetList(RulesIndirectRoadPositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesIndirectRoadPositionAttributeSetList::RulesIndirectRoadPositionAttributeSetList(const RulesIndirectRoadPositionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadPositionAttributeSetList& RulesIndirectRoadPositionAttributeSetList::operator=(const RulesIndirectRoadPositionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadPositionAttributeSetList::RulesIndirectRoadPositionAttributeSetList(RulesIndirectRoadPositionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectRoadPositionAttributeSetList& RulesIndirectRoadPositionAttributeSetList::operator=(RulesIndirectRoadPositionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectRoadPositionAttributeSetList::RulesIndirectRoadPositionAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesIndirectRoadPositionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectRoadPositionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectRoadPositionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectRoadPositionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectRoadPositionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectRoadPositionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesIndirectRoadPositionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesIndirectRoadPositionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeSetMap>& RulesIndirectRoadPositionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeSetMap>& RulesIndirectRoadPositionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesIndirectRoadPositionAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesIndirectRoadPositionAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesIndirectRoadPositionAttributeSetList::initPackingContext(RulesIndirectRoadPositionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesIndirectRoadPositionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadPositionAttributeSetList::bitSizeOf(RulesIndirectRoadPositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectRoadPositionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectRoadPositionAttributeSetList::initializeOffsets(RulesIndirectRoadPositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectRoadPositionAttributeSetList::operator==(const RulesIndirectRoadPositionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesIndirectRoadPositionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesIndirectRoadPositionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesIndirectRoadPositionAttributeSetList::write(RulesIndirectRoadPositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectRoadPositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesIndirectRoadPositionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesIndirectRoadPositionAttributeSetList& owner,
        ::nds::rules::instantiations::RulesIndirectRoadPositionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectRoadPositionAttributeSetList::ZserioElementFactory_sets::create(RulesIndirectRoadPositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectRoadPositionAttributeSetList::ZserioElementFactory_sets::create(RulesIndirectRoadPositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectRoadPositionAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesIndirectRoadPositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesIndirectRoadPositionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesIndirectRoadPositionAttributeSetList::readNumAttributeSets(RulesIndirectRoadPositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectRoadPositionAttributeSetList::ZserioArrayType_sets RulesIndirectRoadPositionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesIndirectRoadPositionAttributeSetList::ZserioArrayType_sets RulesIndirectRoadPositionAttributeSetList::readSets(RulesIndirectRoadPositionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLanePositionAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLanePositionAttributeSetList::RulesLanePositionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesLanePositionAttributeSetList::RulesLanePositionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesLanePositionAttributeSetList::RulesLanePositionAttributeSetList(RulesLanePositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesLanePositionAttributeSetList::RulesLanePositionAttributeSetList(const RulesLanePositionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeSetList& RulesLanePositionAttributeSetList::operator=(const RulesLanePositionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeSetList::RulesLanePositionAttributeSetList(RulesLanePositionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLanePositionAttributeSetList& RulesLanePositionAttributeSetList::operator=(RulesLanePositionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLanePositionAttributeSetList::RulesLanePositionAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesLanePositionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLanePositionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLanePositionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesLanePositionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLanePositionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLanePositionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesLanePositionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesLanePositionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeSetMap>& RulesLanePositionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeSetMap>& RulesLanePositionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesLanePositionAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesLanePositionAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesLanePositionAttributeSetList::initPackingContext(RulesLanePositionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesLanePositionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeSetList::bitSizeOf(RulesLanePositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLanePositionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLanePositionAttributeSetList::initializeOffsets(RulesLanePositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLanePositionAttributeSetList::operator==(const RulesLanePositionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesLanePositionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesLanePositionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesLanePositionAttributeSetList::write(RulesLanePositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLanePositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesLanePositionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesLanePositionAttributeSetList& owner,
        ::nds::rules::instantiations::RulesLanePositionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLanePositionAttributeSetList::ZserioElementFactory_sets::create(RulesLanePositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLanePositionAttributeSetList::ZserioElementFactory_sets::create(RulesLanePositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLanePositionAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesLanePositionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesLanePositionAttributeSetList::readNumAttributeSets(RulesLanePositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLanePositionAttributeSetList::ZserioArrayType_sets RulesLanePositionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesLanePositionAttributeSetList::ZserioArrayType_sets RulesLanePositionAttributeSetList::readSets(RulesLanePositionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectLanePositionAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectLanePositionAttributeSetList::RulesIndirectLanePositionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesIndirectLanePositionAttributeSetList::RulesIndirectLanePositionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesIndirectLanePositionAttributeSetList::RulesIndirectLanePositionAttributeSetList(RulesIndirectLanePositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesIndirectLanePositionAttributeSetList::RulesIndirectLanePositionAttributeSetList(const RulesIndirectLanePositionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLanePositionAttributeSetList& RulesIndirectLanePositionAttributeSetList::operator=(const RulesIndirectLanePositionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLanePositionAttributeSetList::RulesIndirectLanePositionAttributeSetList(RulesIndirectLanePositionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLanePositionAttributeSetList& RulesIndirectLanePositionAttributeSetList::operator=(RulesIndirectLanePositionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLanePositionAttributeSetList::RulesIndirectLanePositionAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesIndirectLanePositionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectLanePositionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectLanePositionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectLanePositionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectLanePositionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectLanePositionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesIndirectLanePositionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesIndirectLanePositionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeSetMap>& RulesIndirectLanePositionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeSetMap>& RulesIndirectLanePositionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesIndirectLanePositionAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesIndirectLanePositionAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesIndirectLanePositionAttributeSetList::initPackingContext(RulesIndirectLanePositionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesIndirectLanePositionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLanePositionAttributeSetList::bitSizeOf(RulesIndirectLanePositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLanePositionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectLanePositionAttributeSetList::initializeOffsets(RulesIndirectLanePositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectLanePositionAttributeSetList::operator==(const RulesIndirectLanePositionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesIndirectLanePositionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesIndirectLanePositionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesIndirectLanePositionAttributeSetList::write(RulesIndirectLanePositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLanePositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesIndirectLanePositionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesIndirectLanePositionAttributeSetList& owner,
        ::nds::rules::instantiations::RulesIndirectLanePositionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectLanePositionAttributeSetList::ZserioElementFactory_sets::create(RulesIndirectLanePositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLanePositionAttributeSetList::ZserioElementFactory_sets::create(RulesIndirectLanePositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectLanePositionAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesIndirectLanePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesIndirectLanePositionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesIndirectLanePositionAttributeSetList::readNumAttributeSets(RulesIndirectLanePositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectLanePositionAttributeSetList::ZserioArrayType_sets RulesIndirectLanePositionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesIndirectLanePositionAttributeSetList::ZserioArrayType_sets RulesIndirectLanePositionAttributeSetList::readSets(RulesIndirectLanePositionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneRangeAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneRangeAttributeSetList::RulesLaneRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesLaneRangeAttributeSetList::RulesLaneRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesLaneRangeAttributeSetList::RulesLaneRangeAttributeSetList(RulesLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesLaneRangeAttributeSetList::RulesLaneRangeAttributeSetList(const RulesLaneRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeSetList& RulesLaneRangeAttributeSetList::operator=(const RulesLaneRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeSetList::RulesLaneRangeAttributeSetList(RulesLaneRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneRangeAttributeSetList& RulesLaneRangeAttributeSetList::operator=(RulesLaneRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneRangeAttributeSetList::RulesLaneRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesLaneRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLaneRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLaneRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLaneRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesLaneRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesLaneRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeSetMap>& RulesLaneRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeSetMap>& RulesLaneRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesLaneRangeAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesLaneRangeAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesLaneRangeAttributeSetList::initPackingContext(RulesLaneRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesLaneRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeSetList::bitSizeOf(RulesLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneRangeAttributeSetList::initializeOffsets(RulesLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneRangeAttributeSetList::operator==(const RulesLaneRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesLaneRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesLaneRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesLaneRangeAttributeSetList::write(RulesLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesLaneRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesLaneRangeAttributeSetList& owner,
        ::nds::rules::instantiations::RulesLaneRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLaneRangeAttributeSetList::ZserioElementFactory_sets::create(RulesLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLaneRangeAttributeSetList::ZserioElementFactory_sets::create(RulesLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneRangeAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesLaneRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesLaneRangeAttributeSetList::readNumAttributeSets(RulesLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneRangeAttributeSetList::ZserioArrayType_sets RulesLaneRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesLaneRangeAttributeSetList::ZserioArrayType_sets RulesLaneRangeAttributeSetList::readSets(RulesLaneRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesIndirectLaneRangeAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesIndirectLaneRangeAttributeSetList::RulesIndirectLaneRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesIndirectLaneRangeAttributeSetList::RulesIndirectLaneRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesIndirectLaneRangeAttributeSetList::RulesIndirectLaneRangeAttributeSetList(RulesIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesIndirectLaneRangeAttributeSetList::RulesIndirectLaneRangeAttributeSetList(const RulesIndirectLaneRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLaneRangeAttributeSetList& RulesIndirectLaneRangeAttributeSetList::operator=(const RulesIndirectLaneRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLaneRangeAttributeSetList::RulesIndirectLaneRangeAttributeSetList(RulesIndirectLaneRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesIndirectLaneRangeAttributeSetList& RulesIndirectLaneRangeAttributeSetList::operator=(RulesIndirectLaneRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesIndirectLaneRangeAttributeSetList::RulesIndirectLaneRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesIndirectLaneRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesIndirectLaneRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesIndirectLaneRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesIndirectLaneRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesIndirectLaneRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesIndirectLaneRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesIndirectLaneRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesIndirectLaneRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeSetMap>& RulesIndirectLaneRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeSetMap>& RulesIndirectLaneRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesIndirectLaneRangeAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesIndirectLaneRangeAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesIndirectLaneRangeAttributeSetList::initPackingContext(RulesIndirectLaneRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesIndirectLaneRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLaneRangeAttributeSetList::bitSizeOf(RulesIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesIndirectLaneRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesIndirectLaneRangeAttributeSetList::initializeOffsets(RulesIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesIndirectLaneRangeAttributeSetList::operator==(const RulesIndirectLaneRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesIndirectLaneRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesIndirectLaneRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesIndirectLaneRangeAttributeSetList::write(RulesIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesIndirectLaneRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesIndirectLaneRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesIndirectLaneRangeAttributeSetList& owner,
        ::nds::rules::instantiations::RulesIndirectLaneRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesIndirectLaneRangeAttributeSetList::ZserioElementFactory_sets::create(RulesIndirectLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesIndirectLaneRangeAttributeSetList::ZserioElementFactory_sets::create(RulesIndirectLaneRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesIndirectLaneRangeAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesIndirectLaneRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesIndirectLaneRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesIndirectLaneRangeAttributeSetList::readNumAttributeSets(RulesIndirectLaneRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesIndirectLaneRangeAttributeSetList::ZserioArrayType_sets RulesIndirectLaneRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesIndirectLaneRangeAttributeSetList::ZserioArrayType_sets RulesIndirectLaneRangeAttributeSetList::readSets(RulesIndirectLaneRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesLaneTransitionAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesLaneTransitionAttributeSetList::RulesLaneTransitionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesLaneTransitionAttributeSetList::RulesLaneTransitionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesLaneTransitionAttributeSetList::RulesLaneTransitionAttributeSetList(RulesLaneTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesLaneTransitionAttributeSetList::RulesLaneTransitionAttributeSetList(const RulesLaneTransitionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeSetList& RulesLaneTransitionAttributeSetList::operator=(const RulesLaneTransitionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeSetList::RulesLaneTransitionAttributeSetList(RulesLaneTransitionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesLaneTransitionAttributeSetList& RulesLaneTransitionAttributeSetList::operator=(RulesLaneTransitionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesLaneTransitionAttributeSetList::RulesLaneTransitionAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesLaneTransitionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesLaneTransitionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesLaneTransitionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesLaneTransitionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesLaneTransitionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesLaneTransitionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesLaneTransitionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesLaneTransitionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeSetMap>& RulesLaneTransitionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeSetMap>& RulesLaneTransitionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesLaneTransitionAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesLaneTransitionAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesLaneTransitionAttributeSetList::initPackingContext(RulesLaneTransitionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesLaneTransitionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeSetList::bitSizeOf(RulesLaneTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesLaneTransitionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesLaneTransitionAttributeSetList::initializeOffsets(RulesLaneTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesLaneTransitionAttributeSetList::operator==(const RulesLaneTransitionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesLaneTransitionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesLaneTransitionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeSetList::write(RulesLaneTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesLaneTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesLaneTransitionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesLaneTransitionAttributeSetList& owner,
        ::nds::rules::instantiations::RulesLaneTransitionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesLaneTransitionAttributeSetList::ZserioElementFactory_sets::create(RulesLaneTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesLaneTransitionAttributeSetList::ZserioElementFactory_sets::create(RulesLaneTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesLaneTransitionAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesLaneTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesLaneTransitionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesLaneTransitionAttributeSetList::readNumAttributeSets(RulesLaneTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesLaneTransitionAttributeSetList::ZserioArrayType_sets RulesLaneTransitionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesLaneTransitionAttributeSetList::ZserioArrayType_sets RulesLaneTransitionAttributeSetList::readSets(RulesLaneTransitionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesTransitionAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesTransitionAttributeSetList::RulesTransitionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesTransitionAttributeSetList::RulesTransitionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesTransitionAttributeSetList::RulesTransitionAttributeSetList(RulesTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesTransitionAttributeSetList::RulesTransitionAttributeSetList(const RulesTransitionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeSetList& RulesTransitionAttributeSetList::operator=(const RulesTransitionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeSetList::RulesTransitionAttributeSetList(RulesTransitionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesTransitionAttributeSetList& RulesTransitionAttributeSetList::operator=(RulesTransitionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesTransitionAttributeSetList::RulesTransitionAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesTransitionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesTransitionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesTransitionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesTransitionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesTransitionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesTransitionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesTransitionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesTransitionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeSetMap>& RulesTransitionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeSetMap>& RulesTransitionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesTransitionAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesTransitionAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesTransitionAttributeSetList::initPackingContext(RulesTransitionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesTransitionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeSetList::bitSizeOf(RulesTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesTransitionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesTransitionAttributeSetList::initializeOffsets(RulesTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesTransitionAttributeSetList::operator==(const RulesTransitionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesTransitionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesTransitionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesTransitionAttributeSetList::write(RulesTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesTransitionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesTransitionAttributeSetList& owner,
        ::nds::rules::instantiations::RulesTransitionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesTransitionAttributeSetList::ZserioElementFactory_sets::create(RulesTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesTransitionAttributeSetList::ZserioElementFactory_sets::create(RulesTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesTransitionAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesTransitionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesTransitionAttributeSetList::readNumAttributeSets(RulesTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesTransitionAttributeSetList::ZserioArrayType_sets RulesTransitionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesTransitionAttributeSetList::ZserioArrayType_sets RulesTransitionAttributeSetList::readSets(RulesTransitionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRoadLocationTransitionAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRoadLocationTransitionAttributeSetList::RulesRoadLocationTransitionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesRoadLocationTransitionAttributeSetList::RulesRoadLocationTransitionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesRoadLocationTransitionAttributeSetList::RulesRoadLocationTransitionAttributeSetList(RulesRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesRoadLocationTransitionAttributeSetList::RulesRoadLocationTransitionAttributeSetList(const RulesRoadLocationTransitionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationTransitionAttributeSetList& RulesRoadLocationTransitionAttributeSetList::operator=(const RulesRoadLocationTransitionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationTransitionAttributeSetList::RulesRoadLocationTransitionAttributeSetList(RulesRoadLocationTransitionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRoadLocationTransitionAttributeSetList& RulesRoadLocationTransitionAttributeSetList::operator=(RulesRoadLocationTransitionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRoadLocationTransitionAttributeSetList::RulesRoadLocationTransitionAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesRoadLocationTransitionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRoadLocationTransitionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRoadLocationTransitionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRoadLocationTransitionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRoadLocationTransitionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRoadLocationTransitionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRoadLocationTransitionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesRoadLocationTransitionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeSetMap>& RulesRoadLocationTransitionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeSetMap>& RulesRoadLocationTransitionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesRoadLocationTransitionAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesRoadLocationTransitionAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesRoadLocationTransitionAttributeSetList::initPackingContext(RulesRoadLocationTransitionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesRoadLocationTransitionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationTransitionAttributeSetList::bitSizeOf(RulesRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRoadLocationTransitionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRoadLocationTransitionAttributeSetList::initializeOffsets(RulesRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRoadLocationTransitionAttributeSetList::operator==(const RulesRoadLocationTransitionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesRoadLocationTransitionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesRoadLocationTransitionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRoadLocationTransitionAttributeSetList::write(RulesRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRoadLocationTransitionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRoadLocationTransitionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesRoadLocationTransitionAttributeSetList& owner,
        ::nds::rules::instantiations::RulesRoadLocationTransitionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRoadLocationTransitionAttributeSetList::ZserioElementFactory_sets::create(RulesRoadLocationTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRoadLocationTransitionAttributeSetList::ZserioElementFactory_sets::create(RulesRoadLocationTransitionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRoadLocationTransitionAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesRoadLocationTransitionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRoadLocationTransitionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRoadLocationTransitionAttributeSetList::readNumAttributeSets(RulesRoadLocationTransitionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRoadLocationTransitionAttributeSetList::ZserioArrayType_sets RulesRoadLocationTransitionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesRoadLocationTransitionAttributeSetList::ZserioArrayType_sets RulesRoadLocationTransitionAttributeSetList::readSets(RulesRoadLocationTransitionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesRegionAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesRegionAttributeSetList::RulesRegionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesRegionAttributeSetList::RulesRegionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesRegionAttributeSetList::RulesRegionAttributeSetList(RulesRegionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesRegionAttributeSetList::RulesRegionAttributeSetList(const RulesRegionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeSetList& RulesRegionAttributeSetList::operator=(const RulesRegionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeSetList::RulesRegionAttributeSetList(RulesRegionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesRegionAttributeSetList& RulesRegionAttributeSetList::operator=(RulesRegionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesRegionAttributeSetList::RulesRegionAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesRegionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesRegionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesRegionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesRegionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesRegionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesRegionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesRegionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesRegionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeSetMap>& RulesRegionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeSetMap>& RulesRegionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesRegionAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesRegionAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesRegionAttributeSetList::initPackingContext(RulesRegionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesRegionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeSetList::bitSizeOf(RulesRegionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesRegionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesRegionAttributeSetList::initializeOffsets(RulesRegionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesRegionAttributeSetList::operator==(const RulesRegionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesRegionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesRegionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRegionAttributeSetList::write(RulesRegionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesRegionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesRegionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesRegionAttributeSetList& owner,
        ::nds::rules::instantiations::RulesRegionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesRegionAttributeSetList::ZserioElementFactory_sets::create(RulesRegionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesRegionAttributeSetList::ZserioElementFactory_sets::create(RulesRegionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesRegionAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesRegionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesRegionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesRegionAttributeSetList::readNumAttributeSets(RulesRegionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesRegionAttributeSetList::ZserioArrayType_sets RulesRegionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesRegionAttributeSetList::ZserioArrayType_sets RulesRegionAttributeSetList::readSets(RulesRegionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLineRangeAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLineRangeAttributeSetList::RulesDisplayLineRangeAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesDisplayLineRangeAttributeSetList::RulesDisplayLineRangeAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesDisplayLineRangeAttributeSetList::RulesDisplayLineRangeAttributeSetList(RulesDisplayLineRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesDisplayLineRangeAttributeSetList::RulesDisplayLineRangeAttributeSetList(const RulesDisplayLineRangeAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeSetList& RulesDisplayLineRangeAttributeSetList::operator=(const RulesDisplayLineRangeAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeSetList::RulesDisplayLineRangeAttributeSetList(RulesDisplayLineRangeAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLineRangeAttributeSetList& RulesDisplayLineRangeAttributeSetList::operator=(RulesDisplayLineRangeAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLineRangeAttributeSetList::RulesDisplayLineRangeAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesDisplayLineRangeAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesDisplayLineRangeAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLineRangeAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLineRangeAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesDisplayLineRangeAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesDisplayLineRangeAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesDisplayLineRangeAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesDisplayLineRangeAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeSetMap>& RulesDisplayLineRangeAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeSetMap>& RulesDisplayLineRangeAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesDisplayLineRangeAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesDisplayLineRangeAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesDisplayLineRangeAttributeSetList::initPackingContext(RulesDisplayLineRangeAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesDisplayLineRangeAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeSetList::bitSizeOf(RulesDisplayLineRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLineRangeAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLineRangeAttributeSetList::initializeOffsets(RulesDisplayLineRangeAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLineRangeAttributeSetList::operator==(const RulesDisplayLineRangeAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesDisplayLineRangeAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesDisplayLineRangeAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeSetList::write(RulesDisplayLineRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLineRangeAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesDisplayLineRangeAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesDisplayLineRangeAttributeSetList& owner,
        ::nds::rules::instantiations::RulesDisplayLineRangeAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesDisplayLineRangeAttributeSetList::ZserioElementFactory_sets::create(RulesDisplayLineRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLineRangeAttributeSetList::ZserioElementFactory_sets::create(RulesDisplayLineRangeAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLineRangeAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesDisplayLineRangeAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesDisplayLineRangeAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesDisplayLineRangeAttributeSetList::readNumAttributeSets(RulesDisplayLineRangeAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLineRangeAttributeSetList::ZserioArrayType_sets RulesDisplayLineRangeAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesDisplayLineRangeAttributeSetList::ZserioArrayType_sets RulesDisplayLineRangeAttributeSetList::readSets(RulesDisplayLineRangeAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/rules/instantiations/RulesDisplayLinePositionAttributeSetList.h>

namespace nds
{
namespace rules
{
namespace instantiations
{

RulesDisplayLinePositionAttributeSetList::RulesDisplayLinePositionAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

RulesDisplayLinePositionAttributeSetList::RulesDisplayLinePositionAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

RulesDisplayLinePositionAttributeSetList::RulesDisplayLinePositionAttributeSetList(RulesDisplayLinePositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

RulesDisplayLinePositionAttributeSetList::RulesDisplayLinePositionAttributeSetList(const RulesDisplayLinePositionAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeSetList& RulesDisplayLinePositionAttributeSetList::operator=(const RulesDisplayLinePositionAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeSetList::RulesDisplayLinePositionAttributeSetList(RulesDisplayLinePositionAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

RulesDisplayLinePositionAttributeSetList& RulesDisplayLinePositionAttributeSetList::operator=(RulesDisplayLinePositionAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

RulesDisplayLinePositionAttributeSetList::RulesDisplayLinePositionAttributeSetList(::zserio::PropagateAllocatorT,
        const RulesDisplayLinePositionAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void RulesDisplayLinePositionAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool RulesDisplayLinePositionAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void RulesDisplayLinePositionAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift RulesDisplayLinePositionAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'RulesDisplayLinePositionAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t RulesDisplayLinePositionAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void RulesDisplayLinePositionAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeSetMap>& RulesDisplayLinePositionAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeSetMap>& RulesDisplayLinePositionAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void RulesDisplayLinePositionAttributeSetList::setSets(const ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void RulesDisplayLinePositionAttributeSetList::setSets(::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void RulesDisplayLinePositionAttributeSetList::initPackingContext(RulesDisplayLinePositionAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t RulesDisplayLinePositionAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeSetList::bitSizeOf(RulesDisplayLinePositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RulesDisplayLinePositionAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RulesDisplayLinePositionAttributeSetList::initializeOffsets(RulesDisplayLinePositionAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RulesDisplayLinePositionAttributeSetList::operator==(const RulesDisplayLinePositionAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t RulesDisplayLinePositionAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void RulesDisplayLinePositionAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeSetList::write(RulesDisplayLinePositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RulesDisplayLinePositionAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void RulesDisplayLinePositionAttributeSetList::ZserioArrayExpressions_sets::initializeElement(RulesDisplayLinePositionAttributeSetList& owner,
        ::nds::rules::instantiations::RulesDisplayLinePositionAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void RulesDisplayLinePositionAttributeSetList::ZserioElementFactory_sets::create(RulesDisplayLinePositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void RulesDisplayLinePositionAttributeSetList::ZserioElementFactory_sets::create(RulesDisplayLinePositionAttributeSetList&         owner,
        ::zserio::vector<::nds::rules::instantiations::RulesDisplayLinePositionAttributeSetMap>& array,
        ::nds::rules::instantiations::RulesDisplayLinePositionAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t RulesDisplayLinePositionAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RulesDisplayLinePositionAttributeSetList::readNumAttributeSets(RulesDisplayLinePositionAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
RulesDisplayLinePositionAttributeSetList::ZserioArrayType_sets RulesDisplayLinePositionAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

RulesDisplayLinePositionAttributeSetList::ZserioArrayType_sets RulesDisplayLinePositionAttributeSetList::readSets(RulesDisplayLinePositionAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace rules
} // namespace nds
