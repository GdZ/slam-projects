/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/lanes/LaneConnectionType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneConnectionType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::lane::lanes::LaneConnectionType>::names;
constexpr ::std::array<::nds::lane::lanes::LaneConnectionType, 4> EnumTraits<::nds::lane::lanes::LaneConnectionType>::values;
constexpr const char* EnumTraits<::nds::lane::lanes::LaneConnectionType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::lanes::LaneConnectionType value)
{
    switch (value)
    {
    case ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER:
        return 0;
    case ::nds::lane::lanes::LaneConnectionType::UNKNOWN:
        return 1;
    case ::nds::lane::lanes::LaneConnectionType::TERMINATES:
        return 2;
    case ::nds::lane::lanes::LaneConnectionType::CONNECTED_OTHER_TILE:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneConnectionType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::lanes::LaneConnectionType>::type>(value) << "!";
    }
}

template <>
::nds::lane::lanes::LaneConnectionType valueToEnum(
        typename ::std::underlying_type<::nds::lane::lanes::LaneConnectionType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::lane::lanes::LaneConnectionType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneConnectionType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::lanes::LaneConnectionType>(::nds::lane::lanes::LaneConnectionType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::lanes::LaneConnectionType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneConnectionType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::lanes::LaneConnectionType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::lanes::LaneConnectionType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneConnectionType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::lanes::LaneConnectionType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::lanes::LaneConnectionType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::lanes::LaneConnectionType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::lanes::LaneConnectionType>(
            static_cast<typename ::std::underlying_type<::nds::lane::lanes::LaneConnectionType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::lane::lanes::LaneConnectionType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::lanes::LaneConnectionType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneConnectionType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::lanes::LaneConnectionType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::lanes::LaneConnectionType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneConnectionType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/lanes/LaneSplitMergePriority.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneSplitMergePriority enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::lane::lanes::LaneSplitMergePriority>::names;
constexpr ::std::array<::nds::lane::lanes::LaneSplitMergePriority, 3> EnumTraits<::nds::lane::lanes::LaneSplitMergePriority>::values;
constexpr const char* EnumTraits<::nds::lane::lanes::LaneSplitMergePriority>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::lanes::LaneSplitMergePriority value)
{
    switch (value)
    {
    case ::nds::lane::lanes::LaneSplitMergePriority::MAJOR:
        return 0;
    case ::nds::lane::lanes::LaneSplitMergePriority::EQUAL:
        return 1;
    case ::nds::lane::lanes::LaneSplitMergePriority::MINOR:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneSplitMergePriority: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::lanes::LaneSplitMergePriority>::type>(value) << "!";
    }
}

template <>
::nds::lane::lanes::LaneSplitMergePriority valueToEnum(
        typename ::std::underlying_type<::nds::lane::lanes::LaneSplitMergePriority>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::lane::lanes::LaneSplitMergePriority>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneSplitMergePriority: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::lanes::LaneSplitMergePriority>(::nds::lane::lanes::LaneSplitMergePriority value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::lanes::LaneSplitMergePriority value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneSplitMergePriority>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::lanes::LaneSplitMergePriority)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::lanes::LaneSplitMergePriority value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneSplitMergePriority>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::lanes::LaneSplitMergePriority value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::lanes::LaneSplitMergePriority value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::lanes::LaneSplitMergePriority read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::lanes::LaneSplitMergePriority>(
            static_cast<typename ::std::underlying_type<::nds::lane::lanes::LaneSplitMergePriority>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::lane::lanes::LaneSplitMergePriority read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::lanes::LaneSplitMergePriority>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneSplitMergePriority>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::lanes::LaneSplitMergePriority value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::lanes::LaneSplitMergePriority value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneSplitMergePriority>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/lanes/LaneRelationType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneRelationType enumeration.
constexpr ::std::array<const char*, 8> EnumTraits<::nds::lane::lanes::LaneRelationType>::names;
constexpr ::std::array<::nds::lane::lanes::LaneRelationType, 8> EnumTraits<::nds::lane::lanes::LaneRelationType>::values;
constexpr const char* EnumTraits<::nds::lane::lanes::LaneRelationType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::lanes::LaneRelationType value)
{
    switch (value)
    {
    case ::nds::lane::lanes::LaneRelationType::CROSSING:
        return 0;
    case ::nds::lane::lanes::LaneRelationType::ADJACENT_LEFT:
        return 1;
    case ::nds::lane::lanes::LaneRelationType::ADJACENT_RIGHT:
        return 2;
    case ::nds::lane::lanes::LaneRelationType::SPLIT_MERGE_LEFT:
        return 3;
    case ::nds::lane::lanes::LaneRelationType::SPLIT_MERGE_RIGHT:
        return 4;
    case ::nds::lane::lanes::LaneRelationType::FORK_LEFT:
        return 5;
    case ::nds::lane::lanes::LaneRelationType::FORK_RIGHT:
        return 6;
    case ::nds::lane::lanes::LaneRelationType::OVERLAP:
        return 7;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneRelationType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::lanes::LaneRelationType>::type>(value) << "!";
    }
}

template <>
::nds::lane::lanes::LaneRelationType valueToEnum(
        typename ::std::underlying_type<::nds::lane::lanes::LaneRelationType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
        return static_cast<::nds::lane::lanes::LaneRelationType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneRelationType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::lanes::LaneRelationType>(::nds::lane::lanes::LaneRelationType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::lanes::LaneRelationType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::lanes::LaneRelationType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::lanes::LaneRelationType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::lanes::LaneRelationType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::lanes::LaneRelationType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::lanes::LaneRelationType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::lanes::LaneRelationType>(
            static_cast<typename ::std::underlying_type<::nds::lane::lanes::LaneRelationType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::lanes::LaneRelationType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::lanes::LaneRelationType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneRelationType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::lanes::LaneRelationType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::lanes::LaneRelationType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::lanes::LaneRelationType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/lanes/Lane.h>
#include <nds/lane/types/LaneLayoutType.h>

namespace nds
{
namespace lane
{
namespace lanes
{

Lane::Lane(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_directedLaneId_(::zserio::NullOpt),
        m_laneId_(::zserio::NullOpt),
        m_previousLanes_(allocator),
        m_nextLanes_(allocator),
        m_length_(::nds::lane::reference::types::LaneLength()),
        m_centerLineGeometryRef_(::nds::lane::lanes::LaneCenterLineGeometryId()),
        m_laneRelations_(::zserio::NullOpt),
        m_openToLeft_(allocator),
        m_openToRight_(allocator),
        m_boundariesLeft_(allocator),
        m_boundariesRight_(allocator)
{
}

Lane::Lane(::zserio::BitStreamReader& in,
        ::nds::lane::types::LaneLayoutType layout_,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_layout_(layout_),
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_directedLaneId_(readDirectedLaneId(in, allocator)),
        m_laneId_(readLaneId(in, allocator)),
        m_previousLanes_(readPreviousLanes(in, allocator)),
        m_nextLanes_(readNextLanes(in, allocator)),
        m_length_(readLength(in)),
        m_centerLineGeometryRef_(readCenterLineGeometryRef(in)),
        m_laneRelations_(readLaneRelations(in, allocator)),
        m_openToLeft_(readOpenToLeft(in, allocator)),
        m_openToRight_(readOpenToRight(in, allocator)),
        m_boundariesLeft_(readBoundariesLeft(in, allocator)),
        m_boundariesRight_(readBoundariesRight(in, allocator))
{
}

Lane::Lane(Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::lane::types::LaneLayoutType layout_,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_layout_(layout_),
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_directedLaneId_(readDirectedLaneId(context, in, allocator)),
        m_laneId_(readLaneId(context, in, allocator)),
        m_previousLanes_(readPreviousLanes(context, in, allocator)),
        m_nextLanes_(readNextLanes(context, in, allocator)),
        m_length_(readLength(context, in)),
        m_centerLineGeometryRef_(readCenterLineGeometryRef(context, in)),
        m_laneRelations_(readLaneRelations(context, in, allocator)),
        m_openToLeft_(readOpenToLeft(context, in, allocator)),
        m_openToRight_(readOpenToRight(context, in, allocator)),
        m_boundariesLeft_(readBoundariesLeft(context, in, allocator)),
        m_boundariesRight_(readBoundariesRight(context, in, allocator))
{
}

Lane::Lane(const Lane& other) :
        m_directedLaneId_(other.m_directedLaneId_),
        m_laneId_(other.m_laneId_),
        m_previousLanes_(other.m_previousLanes_),
        m_nextLanes_(other.m_nextLanes_),
        m_length_(other.m_length_),
        m_centerLineGeometryRef_(other.m_centerLineGeometryRef_),
        m_laneRelations_(other.m_laneRelations_),
        m_openToLeft_(other.m_openToLeft_),
        m_openToRight_(other.m_openToRight_),
        m_boundariesLeft_(other.m_boundariesLeft_),
        m_boundariesRight_(other.m_boundariesRight_)
{
    if (other.m_isInitialized)
        initialize(other.m_layout_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

Lane& Lane::operator=(const Lane& other)
{
    m_directedLaneId_ = other.m_directedLaneId_;
    m_laneId_ = other.m_laneId_;
    m_previousLanes_ = other.m_previousLanes_;
    m_nextLanes_ = other.m_nextLanes_;
    m_length_ = other.m_length_;
    m_centerLineGeometryRef_ = other.m_centerLineGeometryRef_;
    m_laneRelations_ = other.m_laneRelations_;
    m_openToLeft_ = other.m_openToLeft_;
    m_openToRight_ = other.m_openToRight_;
    m_boundariesLeft_ = other.m_boundariesLeft_;
    m_boundariesRight_ = other.m_boundariesRight_;
    if (other.m_isInitialized)
        initialize(other.m_layout_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

Lane::Lane(Lane&& other) :
        m_directedLaneId_(::std::move(other.m_directedLaneId_)),
        m_laneId_(::std::move(other.m_laneId_)),
        m_previousLanes_(::std::move(other.m_previousLanes_)),
        m_nextLanes_(::std::move(other.m_nextLanes_)),
        m_length_(::std::move(other.m_length_)),
        m_centerLineGeometryRef_(::std::move(other.m_centerLineGeometryRef_)),
        m_laneRelations_(::std::move(other.m_laneRelations_)),
        m_openToLeft_(::std::move(other.m_openToLeft_)),
        m_openToRight_(::std::move(other.m_openToRight_)),
        m_boundariesLeft_(::std::move(other.m_boundariesLeft_)),
        m_boundariesRight_(::std::move(other.m_boundariesRight_))
{
    if (other.m_isInitialized)
        initialize(other.m_layout_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

Lane& Lane::operator=(Lane&& other)
{
    m_directedLaneId_ = ::std::move(other.m_directedLaneId_);
    m_laneId_ = ::std::move(other.m_laneId_);
    m_previousLanes_ = ::std::move(other.m_previousLanes_);
    m_nextLanes_ = ::std::move(other.m_nextLanes_);
    m_length_ = ::std::move(other.m_length_);
    m_centerLineGeometryRef_ = ::std::move(other.m_centerLineGeometryRef_);
    m_laneRelations_ = ::std::move(other.m_laneRelations_);
    m_openToLeft_ = ::std::move(other.m_openToLeft_);
    m_openToRight_ = ::std::move(other.m_openToRight_);
    m_boundariesLeft_ = ::std::move(other.m_boundariesLeft_);
    m_boundariesRight_ = ::std::move(other.m_boundariesRight_);
    if (other.m_isInitialized)
        initialize(other.m_layout_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

Lane::Lane(::zserio::PropagateAllocatorT,
        const Lane& other, const allocator_type& allocator) :
        m_directedLaneId_(::zserio::allocatorPropagatingCopy(other.m_directedLaneId_, allocator)),
        m_laneId_(::zserio::allocatorPropagatingCopy(other.m_laneId_, allocator)),
        m_previousLanes_(::zserio::allocatorPropagatingCopy(other.m_previousLanes_, allocator)),
        m_nextLanes_(::zserio::allocatorPropagatingCopy(other.m_nextLanes_, allocator)),
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator)),
        m_centerLineGeometryRef_(::zserio::allocatorPropagatingCopy(other.m_centerLineGeometryRef_, allocator)),
        m_laneRelations_(::zserio::allocatorPropagatingCopy(other.m_laneRelations_, allocator)),
        m_openToLeft_(::zserio::allocatorPropagatingCopy(other.m_openToLeft_, allocator)),
        m_openToRight_(::zserio::allocatorPropagatingCopy(other.m_openToRight_, allocator)),
        m_boundariesLeft_(::zserio::allocatorPropagatingCopy(other.m_boundariesLeft_, allocator)),
        m_boundariesRight_(::zserio::allocatorPropagatingCopy(other.m_boundariesRight_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_layout_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

void Lane::initialize(
        ::nds::lane::types::LaneLayoutType layout_,
        bool hasBoundaryGeometry_)
{
    m_layout_ = layout_;
    m_hasBoundaryGeometry_ = hasBoundaryGeometry_;
    m_isInitialized = true;

    initializeChildren();
}

bool Lane::isInitialized() const
{
    return m_isInitialized;
}

void Lane::initializeChildren()
{
    m_boundariesLeft_.initializeElements(*this);
    m_boundariesRight_.initializeElements(*this);
}

::nds::lane::types::LaneLayoutType Lane::getLayout() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'layout' of compound 'Lane' is not initialized!");

    return m_layout_;
}

bool Lane::getHasBoundaryGeometry() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasBoundaryGeometry' of compound 'Lane' is not initialized!");

    return m_hasBoundaryGeometry_;
}

::nds::lane::lanes::DirectedLaneId& Lane::getDirectedLaneId()
{
    return m_directedLaneId_.value();
}

const ::nds::lane::lanes::DirectedLaneId& Lane::getDirectedLaneId() const
{
    return m_directedLaneId_.value();
}

void Lane::setDirectedLaneId(const ::nds::lane::lanes::DirectedLaneId& directedLaneId_)
{
    m_directedLaneId_ = directedLaneId_;
}

void Lane::setDirectedLaneId(::nds::lane::lanes::DirectedLaneId&& directedLaneId_)
{
    m_directedLaneId_ = ::std::move(directedLaneId_);
}

bool Lane::isDirectedLaneIdUsed() const
{
    return (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED);
}

bool Lane::isDirectedLaneIdSet() const
{
    return m_directedLaneId_.hasValue();
}

void Lane::resetDirectedLaneId()
{
    m_directedLaneId_.reset();
}

::nds::lane::reference::types::LaneId& Lane::getLaneId()
{
    return m_laneId_.value();
}

const ::nds::lane::reference::types::LaneId& Lane::getLaneId() const
{
    return m_laneId_.value();
}

void Lane::setLaneId(const ::nds::lane::reference::types::LaneId& laneId_)
{
    m_laneId_ = laneId_;
}

void Lane::setLaneId(::nds::lane::reference::types::LaneId&& laneId_)
{
    m_laneId_ = ::std::move(laneId_);
}

bool Lane::isLaneIdUsed() const
{
    return (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED);
}

bool Lane::isLaneIdSet() const
{
    return m_laneId_.hasValue();
}

void Lane::resetLaneId()
{
    m_laneId_.reset();
}

::zserio::vector<::nds::lane::lanes::LaneConnector>& Lane::getPreviousLanes()
{
    return m_previousLanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::LaneConnector>& Lane::getPreviousLanes() const
{
    return m_previousLanes_.getRawArray();
}

void Lane::setPreviousLanes(const ::zserio::vector<::nds::lane::lanes::LaneConnector>& previousLanes_)
{
    m_previousLanes_ = ZserioArrayType_previousLanes(previousLanes_);
}

void Lane::setPreviousLanes(::zserio::vector<::nds::lane::lanes::LaneConnector>&& previousLanes_)
{
    m_previousLanes_ = ZserioArrayType_previousLanes(std::move(previousLanes_));
}

::zserio::vector<::nds::lane::lanes::LaneConnector>& Lane::getNextLanes()
{
    return m_nextLanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::LaneConnector>& Lane::getNextLanes() const
{
    return m_nextLanes_.getRawArray();
}

void Lane::setNextLanes(const ::zserio::vector<::nds::lane::lanes::LaneConnector>& nextLanes_)
{
    m_nextLanes_ = ZserioArrayType_nextLanes(nextLanes_);
}

void Lane::setNextLanes(::zserio::vector<::nds::lane::lanes::LaneConnector>&& nextLanes_)
{
    m_nextLanes_ = ZserioArrayType_nextLanes(std::move(nextLanes_));
}

::nds::lane::reference::types::LaneLength Lane::getLength() const
{
    return m_length_;
}

void Lane::setLength(::nds::lane::reference::types::LaneLength length_)
{
    m_length_ = length_;
}

::nds::lane::lanes::LaneCenterLineGeometryId Lane::getCenterLineGeometryRef() const
{
    return m_centerLineGeometryRef_;
}

void Lane::setCenterLineGeometryRef(::nds::lane::lanes::LaneCenterLineGeometryId centerLineGeometryRef_)
{
    m_centerLineGeometryRef_ = centerLineGeometryRef_;
}

::zserio::vector<::nds::lane::lanes::LaneRelation>& Lane::getLaneRelations()
{
    return m_laneRelations_.value().getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::LaneRelation>& Lane::getLaneRelations() const
{
    return m_laneRelations_.value().getRawArray();
}

void Lane::setLaneRelations(const ::zserio::vector<::nds::lane::lanes::LaneRelation>& laneRelations_)
{
    m_laneRelations_ = ZserioArrayType_laneRelations(laneRelations_);
}

void Lane::setLaneRelations(::zserio::vector<::nds::lane::lanes::LaneRelation>&& laneRelations_)
{
    m_laneRelations_ = ZserioArrayType_laneRelations(std::move(laneRelations_));
}

bool Lane::isLaneRelationsUsed() const
{
    return (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED);
}

bool Lane::isLaneRelationsSet() const
{
    return m_laneRelations_.hasValue();
}

void Lane::resetLaneRelations()
{
    m_laneRelations_.reset();
}

::nds::lane::lanes::LaneTraversability& Lane::getOpenToLeft()
{
    return m_openToLeft_;
}

const ::nds::lane::lanes::LaneTraversability& Lane::getOpenToLeft() const
{
    return m_openToLeft_;
}

void Lane::setOpenToLeft(const ::nds::lane::lanes::LaneTraversability& openToLeft_)
{
    m_openToLeft_ = openToLeft_;
}

void Lane::setOpenToLeft(::nds::lane::lanes::LaneTraversability&& openToLeft_)
{
    m_openToLeft_ = ::std::move(openToLeft_);
}

::nds::lane::lanes::LaneTraversability& Lane::getOpenToRight()
{
    return m_openToRight_;
}

const ::nds::lane::lanes::LaneTraversability& Lane::getOpenToRight() const
{
    return m_openToRight_;
}

void Lane::setOpenToRight(const ::nds::lane::lanes::LaneTraversability& openToRight_)
{
    m_openToRight_ = openToRight_;
}

void Lane::setOpenToRight(::nds::lane::lanes::LaneTraversability&& openToRight_)
{
    m_openToRight_ = ::std::move(openToRight_);
}

::zserio::vector<::nds::lane::boundaries::BoundarySet>& Lane::getBoundariesLeft()
{
    return m_boundariesLeft_.getRawArray();
}

const ::zserio::vector<::nds::lane::boundaries::BoundarySet>& Lane::getBoundariesLeft() const
{
    return m_boundariesLeft_.getRawArray();
}

void Lane::setBoundariesLeft(const ::zserio::vector<::nds::lane::boundaries::BoundarySet>& boundariesLeft_)
{
    m_boundariesLeft_ = ZserioArrayType_boundariesLeft(boundariesLeft_);
}

void Lane::setBoundariesLeft(::zserio::vector<::nds::lane::boundaries::BoundarySet>&& boundariesLeft_)
{
    m_boundariesLeft_ = ZserioArrayType_boundariesLeft(std::move(boundariesLeft_));
}

::zserio::vector<::nds::lane::boundaries::BoundarySet>& Lane::getBoundariesRight()
{
    return m_boundariesRight_.getRawArray();
}

const ::zserio::vector<::nds::lane::boundaries::BoundarySet>& Lane::getBoundariesRight() const
{
    return m_boundariesRight_.getRawArray();
}

void Lane::setBoundariesRight(const ::zserio::vector<::nds::lane::boundaries::BoundarySet>& boundariesRight_)
{
    m_boundariesRight_ = ZserioArrayType_boundariesRight(boundariesRight_);
}

void Lane::setBoundariesRight(::zserio::vector<::nds::lane::boundaries::BoundarySet>&& boundariesRight_)
{
    m_boundariesRight_ = ZserioArrayType_boundariesRight(std::move(boundariesRight_));
}

void Lane::initPackingContext(Lane::ZserioPackingContext& context) const
{
    if (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED)
    {
        m_directedLaneId_.value().initPackingContext(context.getDirectedLaneId());
    }
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        m_laneId_.value().initPackingContext(context.getLaneId());
    }
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(m_length_);
    context.getCenterLineGeometryRef().init<::zserio::VarIntNNArrayTraits<::nds::lane::lanes::LaneCenterLineGeometryId>>(m_centerLineGeometryRef_);
    m_openToLeft_.initPackingContext(context.getOpenToLeft());
    m_openToRight_.initPackingContext(context.getOpenToRight());
}

size_t Lane::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    if (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED)
    {
        endBitPosition += m_directedLaneId_.value().bitSizeOf(endBitPosition);
    }
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        endBitPosition += m_laneId_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += m_previousLanes_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_nextLanes_.bitSizeOf(*this, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_centerLineGeometryRef_);
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        endBitPosition += m_laneRelations_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += m_openToLeft_.bitSizeOf(endBitPosition);
    endBitPosition += m_openToRight_.bitSizeOf(endBitPosition);
    endBitPosition += m_boundariesLeft_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_boundariesRight_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Lane::bitSizeOf(Lane::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    if (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED)
    {
        endBitPosition += m_directedLaneId_.value().bitSizeOf(context.getDirectedLaneId(), endBitPosition);
    }
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        endBitPosition += m_laneId_.value().bitSizeOf(context.getLaneId(), endBitPosition);
    }
    endBitPosition += m_previousLanes_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_nextLanes_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(m_length_);
    endBitPosition += context.getCenterLineGeometryRef().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::lanes::LaneCenterLineGeometryId>>(m_centerLineGeometryRef_);
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        endBitPosition += m_laneRelations_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += m_openToLeft_.bitSizeOf(context.getOpenToLeft(), endBitPosition);
    endBitPosition += m_openToRight_.bitSizeOf(context.getOpenToRight(), endBitPosition);
    endBitPosition += m_boundariesLeft_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_boundariesRight_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Lane::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    if (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED)
    {
        endBitPosition = m_directedLaneId_.value().initializeOffsets(endBitPosition);
    }
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        endBitPosition = m_laneId_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = m_previousLanes_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_nextLanes_.initializeOffsets(*this, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_centerLineGeometryRef_);
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        endBitPosition = m_laneRelations_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition = m_openToLeft_.initializeOffsets(endBitPosition);
    endBitPosition = m_openToRight_.initializeOffsets(endBitPosition);
    endBitPosition = m_boundariesLeft_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_boundariesRight_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t Lane::initializeOffsets(Lane::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    if (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED)
    {
        endBitPosition = m_directedLaneId_.value().initializeOffsets(context.getDirectedLaneId(), endBitPosition);
    }
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        endBitPosition = m_laneId_.value().initializeOffsets(context.getLaneId(), endBitPosition);
    }
    endBitPosition = m_previousLanes_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_nextLanes_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(m_length_);
    endBitPosition += context.getCenterLineGeometryRef().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::lanes::LaneCenterLineGeometryId>>(m_centerLineGeometryRef_);
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        endBitPosition = m_laneRelations_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = m_openToLeft_.initializeOffsets(context.getOpenToLeft(), endBitPosition);
    endBitPosition = m_openToRight_.initializeOffsets(context.getOpenToRight(), endBitPosition);
    endBitPosition = m_boundariesLeft_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_boundariesRight_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Lane::operator==(const Lane& other) const
{
    if (this != &other)
    {
        return
                (getLayout() == other.getLayout()) &&
                (getHasBoundaryGeometry() == other.getHasBoundaryGeometry()) &&
                (!isDirectedLaneIdUsed() ? !other.isDirectedLaneIdUsed() : (m_directedLaneId_ == other.m_directedLaneId_)) &&
                (!isLaneIdUsed() ? !other.isLaneIdUsed() : (m_laneId_ == other.m_laneId_)) &&
                (m_previousLanes_ == other.m_previousLanes_) &&
                (m_nextLanes_ == other.m_nextLanes_) &&
                (m_length_ == other.m_length_) &&
                (m_centerLineGeometryRef_ == other.m_centerLineGeometryRef_) &&
                (!isLaneRelationsUsed() ? !other.isLaneRelationsUsed() : (m_laneRelations_ == other.m_laneRelations_)) &&
                (m_openToLeft_ == other.m_openToLeft_) &&
                (m_openToRight_ == other.m_openToRight_) &&
                (m_boundariesLeft_ == other.m_boundariesLeft_) &&
                (m_boundariesRight_ == other.m_boundariesRight_);
    }

    return true;
}

uint32_t Lane::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getLayout());
    result = ::zserio::calcHashCode(result, getHasBoundaryGeometry());
    if (isDirectedLaneIdUsed())
        result = ::zserio::calcHashCode(result, m_directedLaneId_);
    if (isLaneIdUsed())
        result = ::zserio::calcHashCode(result, m_laneId_);
    result = ::zserio::calcHashCode(result, m_previousLanes_);
    result = ::zserio::calcHashCode(result, m_nextLanes_);
    result = ::zserio::calcHashCode(result, m_length_);
    result = ::zserio::calcHashCode(result, m_centerLineGeometryRef_);
    if (isLaneRelationsUsed())
        result = ::zserio::calcHashCode(result, m_laneRelations_);
    result = ::zserio::calcHashCode(result, m_openToLeft_);
    result = ::zserio::calcHashCode(result, m_openToRight_);
    result = ::zserio::calcHashCode(result, m_boundariesLeft_);
    result = ::zserio::calcHashCode(result, m_boundariesRight_);

    return result;
}

void Lane::write(::zserio::BitStreamWriter& out) const
{
    if (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED)
    {
        m_directedLaneId_.value().write(out);
    }
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        m_laneId_.value().write(out);
    }
    m_previousLanes_.write(*this, out);
    m_nextLanes_.write(*this, out);
    out.writeVarUInt32(m_length_);
    out.writeVarUInt32(m_centerLineGeometryRef_);
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        m_laneRelations_.value().write(*this, out);
    }
    m_openToLeft_.write(out);
    m_openToRight_.write(out);
    m_boundariesLeft_.write(*this, out);
    m_boundariesRight_.write(*this, out);
}

void Lane::write(Lane::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    if (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED)
    {
        m_directedLaneId_.value().write(context.getDirectedLaneId(), out);
    }
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        m_laneId_.value().write(context.getLaneId(), out);
    }
    m_previousLanes_.writePacked(*this, out);
    m_nextLanes_.writePacked(*this, out);
    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(out, m_length_);
    context.getCenterLineGeometryRef().write<::zserio::VarIntNNArrayTraits<::nds::lane::lanes::LaneCenterLineGeometryId>>(out, m_centerLineGeometryRef_);
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        m_laneRelations_.value().writePacked(*this, out);
    }
    m_openToLeft_.write(context.getOpenToLeft(), out);
    m_openToRight_.write(context.getOpenToRight(), out);
    m_boundariesLeft_.writePacked(*this, out);
    m_boundariesRight_.writePacked(*this, out);
}

void Lane::ZserioElementFactory_previousLanes::create(Lane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Lane::ZserioElementFactory_previousLanes::create(Lane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneConnector>& array,
        ::nds::lane::lanes::LaneConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void Lane::ZserioElementFactory_nextLanes::create(Lane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Lane::ZserioElementFactory_nextLanes::create(Lane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneConnector>& array,
        ::nds::lane::lanes::LaneConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void Lane::ZserioElementFactory_laneRelations::create(Lane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneRelation>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Lane::ZserioElementFactory_laneRelations::create(Lane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneRelation>& array,
        ::nds::lane::lanes::LaneRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void Lane::ZserioArrayExpressions_boundariesLeft::initializeElement(Lane& owner,
        ::nds::lane::boundaries::BoundarySet& element, size_t)
{
    element.initialize(static_cast<bool>(owner.getHasBoundaryGeometry()));
}

void Lane::ZserioElementFactory_boundariesLeft::create(Lane&         owner,
        ::zserio::vector<::nds::lane::boundaries::BoundarySet>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

void Lane::ZserioElementFactory_boundariesLeft::create(Lane&         owner,
        ::zserio::vector<::nds::lane::boundaries::BoundarySet>& array,
        ::nds::lane::boundaries::BoundarySet::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

void Lane::ZserioArrayExpressions_boundariesRight::initializeElement(Lane& owner,
        ::nds::lane::boundaries::BoundarySet& element, size_t)
{
    element.initialize(static_cast<bool>(owner.getHasBoundaryGeometry()));
}

void Lane::ZserioElementFactory_boundariesRight::create(Lane&         owner,
        ::zserio::vector<::nds::lane::boundaries::BoundarySet>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

void Lane::ZserioElementFactory_boundariesRight::create(Lane&         owner,
        ::zserio::vector<::nds::lane::boundaries::BoundarySet>& array,
        ::nds::lane::boundaries::BoundarySet::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

::zserio::InplaceOptionalHolder<::nds::lane::lanes::DirectedLaneId> Lane::readDirectedLaneId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::lanes::DirectedLaneId>(::nds::lane::lanes::DirectedLaneId(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::lanes::DirectedLaneId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::lanes::DirectedLaneId> Lane::readDirectedLaneId(Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getLayout() == ::nds::lane::types::LaneLayoutType::ORDERED)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::lanes::DirectedLaneId>(::nds::lane::lanes::DirectedLaneId(context.getDirectedLaneId(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::lanes::DirectedLaneId>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneId> Lane::readLaneId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneId>(::nds::lane::reference::types::LaneId(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneId> Lane::readLaneId(Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneId>(::nds::lane::reference::types::LaneId(context.getLaneId(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneId>(::zserio::NullOpt);
}
Lane::ZserioArrayType_previousLanes Lane::readPreviousLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_previousLanes readField(allocator);
    readField.read(*this, in);

    return readField;
}

Lane::ZserioArrayType_previousLanes Lane::readPreviousLanes(Lane::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_previousLanes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
Lane::ZserioArrayType_nextLanes Lane::readNextLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_nextLanes readField(allocator);
    readField.read(*this, in);

    return readField;
}

Lane::ZserioArrayType_nextLanes Lane::readNextLanes(Lane::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_nextLanes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::lane::reference::types::LaneLength Lane::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::reference::types::LaneLength>(in.readVarUInt32());
}

::nds::lane::reference::types::LaneLength Lane::readLength(Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(in);
}
::nds::lane::lanes::LaneCenterLineGeometryId Lane::readCenterLineGeometryRef(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::lanes::LaneCenterLineGeometryId>(in.readVarUInt32());
}

::nds::lane::lanes::LaneCenterLineGeometryId Lane::readCenterLineGeometryRef(Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCenterLineGeometryRef().read<::zserio::VarIntNNArrayTraits<::nds::lane::lanes::LaneCenterLineGeometryId>>(in);
}
::zserio::InplaceOptionalHolder<Lane::ZserioArrayType_laneRelations> Lane::readLaneRelations(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        ZserioArrayType_laneRelations readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneRelations>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneRelations>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<Lane::ZserioArrayType_laneRelations> Lane::readLaneRelations(Lane::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getLayout() == ::nds::lane::types::LaneLayoutType::UNORDERED)
    {
        ZserioArrayType_laneRelations readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneRelations>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneRelations>(::zserio::NullOpt);
}
::nds::lane::lanes::LaneTraversability Lane::readOpenToLeft(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::lanes::LaneTraversability(in, allocator);
}

::nds::lane::lanes::LaneTraversability Lane::readOpenToLeft(Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::lanes::LaneTraversability(context.getOpenToLeft(), in, allocator);
}
::nds::lane::lanes::LaneTraversability Lane::readOpenToRight(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::lanes::LaneTraversability(in, allocator);
}

::nds::lane::lanes::LaneTraversability Lane::readOpenToRight(Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::lanes::LaneTraversability(context.getOpenToRight(), in, allocator);
}
Lane::ZserioArrayType_boundariesLeft Lane::readBoundariesLeft(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_boundariesLeft readField(allocator);
    readField.read(*this, in);

    return readField;
}

Lane::ZserioArrayType_boundariesLeft Lane::readBoundariesLeft(Lane::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_boundariesLeft readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
Lane::ZserioArrayType_boundariesRight Lane::readBoundariesRight(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_boundariesRight readField(allocator);
    readField.read(*this, in);

    return readField;
}

Lane::ZserioArrayType_boundariesRight Lane::readBoundariesRight(Lane::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_boundariesRight readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace lanes
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/lane/lanes/ZeroLengthLane.h>

namespace nds
{
namespace lane
{
namespace lanes
{

ZeroLengthLane::ZeroLengthLane(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_laneId_(allocator),
        m_previousLanes_(allocator),
        m_nextLanes_(::zserio::NullOpt)
{
}

ZeroLengthLane::ZeroLengthLane(::zserio::BitStreamReader& in,
        bool onBorder_, const allocator_type& allocator) :
        m_onBorder_(onBorder_),
        m_isInitialized(true),
        m_laneId_(readLaneId(in, allocator)),
        m_previousLanes_(readPreviousLanes(in, allocator)),
        m_nextLanes_(readNextLanes(in, allocator))
{
}

ZeroLengthLane::ZeroLengthLane(ZeroLengthLane::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool onBorder_, const allocator_type& allocator) :
        m_onBorder_(onBorder_),
        m_isInitialized(true),
        m_laneId_(readLaneId(context, in, allocator)),
        m_previousLanes_(readPreviousLanes(context, in, allocator)),
        m_nextLanes_(readNextLanes(context, in, allocator))
{
}

ZeroLengthLane::ZeroLengthLane(const ZeroLengthLane& other) :
        m_laneId_(other.m_laneId_),
        m_previousLanes_(other.m_previousLanes_),
        m_nextLanes_(other.m_nextLanes_)
{
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;
}

ZeroLengthLane& ZeroLengthLane::operator=(const ZeroLengthLane& other)
{
    m_laneId_ = other.m_laneId_;
    m_previousLanes_ = other.m_previousLanes_;
    m_nextLanes_ = other.m_nextLanes_;
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;

    return *this;
}

ZeroLengthLane::ZeroLengthLane(ZeroLengthLane&& other) :
        m_laneId_(::std::move(other.m_laneId_)),
        m_previousLanes_(::std::move(other.m_previousLanes_)),
        m_nextLanes_(::std::move(other.m_nextLanes_))
{
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;
}

ZeroLengthLane& ZeroLengthLane::operator=(ZeroLengthLane&& other)
{
    m_laneId_ = ::std::move(other.m_laneId_);
    m_previousLanes_ = ::std::move(other.m_previousLanes_);
    m_nextLanes_ = ::std::move(other.m_nextLanes_);
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;

    return *this;
}

ZeroLengthLane::ZeroLengthLane(::zserio::PropagateAllocatorT,
        const ZeroLengthLane& other, const allocator_type& allocator) :
        m_laneId_(::zserio::allocatorPropagatingCopy(other.m_laneId_, allocator)),
        m_previousLanes_(::zserio::allocatorPropagatingCopy(other.m_previousLanes_, allocator)),
        m_nextLanes_(::zserio::allocatorPropagatingCopy(other.m_nextLanes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;
}

void ZeroLengthLane::initialize(
        bool onBorder_)
{
    m_onBorder_ = onBorder_;
    m_isInitialized = true;
}

bool ZeroLengthLane::isInitialized() const
{
    return m_isInitialized;
}

bool ZeroLengthLane::getOnBorder() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'onBorder' of compound 'ZeroLengthLane' is not initialized!");

    return m_onBorder_;
}

::nds::lane::reference::types::LaneId& ZeroLengthLane::getLaneId()
{
    return m_laneId_;
}

const ::nds::lane::reference::types::LaneId& ZeroLengthLane::getLaneId() const
{
    return m_laneId_;
}

void ZeroLengthLane::setLaneId(const ::nds::lane::reference::types::LaneId& laneId_)
{
    m_laneId_ = laneId_;
}

void ZeroLengthLane::setLaneId(::nds::lane::reference::types::LaneId&& laneId_)
{
    m_laneId_ = ::std::move(laneId_);
}

::zserio::vector<::nds::lane::lanes::LaneConnector>& ZeroLengthLane::getPreviousLanes()
{
    return m_previousLanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::LaneConnector>& ZeroLengthLane::getPreviousLanes() const
{
    return m_previousLanes_.getRawArray();
}

void ZeroLengthLane::setPreviousLanes(const ::zserio::vector<::nds::lane::lanes::LaneConnector>& previousLanes_)
{
    m_previousLanes_ = ZserioArrayType_previousLanes(previousLanes_);
}

void ZeroLengthLane::setPreviousLanes(::zserio::vector<::nds::lane::lanes::LaneConnector>&& previousLanes_)
{
    m_previousLanes_ = ZserioArrayType_previousLanes(std::move(previousLanes_));
}

::zserio::vector<::nds::lane::lanes::LaneConnector>& ZeroLengthLane::getNextLanes()
{
    return m_nextLanes_.value().getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::LaneConnector>& ZeroLengthLane::getNextLanes() const
{
    return m_nextLanes_.value().getRawArray();
}

void ZeroLengthLane::setNextLanes(const ::zserio::vector<::nds::lane::lanes::LaneConnector>& nextLanes_)
{
    m_nextLanes_ = ZserioArrayType_nextLanes(nextLanes_);
}

void ZeroLengthLane::setNextLanes(::zserio::vector<::nds::lane::lanes::LaneConnector>&& nextLanes_)
{
    m_nextLanes_ = ZserioArrayType_nextLanes(std::move(nextLanes_));
}

bool ZeroLengthLane::isNextLanesUsed() const
{
    return (!getOnBorder());
}

bool ZeroLengthLane::isNextLanesSet() const
{
    return m_nextLanes_.hasValue();
}

void ZeroLengthLane::resetNextLanes()
{
    m_nextLanes_.reset();
}

void ZeroLengthLane::initPackingContext(ZeroLengthLane::ZserioPackingContext& context) const
{
    m_laneId_.initPackingContext(context.getLaneId());
}

size_t ZeroLengthLane::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneId_.bitSizeOf(endBitPosition);
    endBitPosition += m_previousLanes_.bitSizeOf(*this, endBitPosition);
    if (!getOnBorder())
    {
        endBitPosition += m_nextLanes_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ZeroLengthLane::bitSizeOf(ZeroLengthLane::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneId_.bitSizeOf(context.getLaneId(), endBitPosition);
    endBitPosition += m_previousLanes_.bitSizeOfPacked(*this, endBitPosition);
    if (!getOnBorder())
    {
        endBitPosition += m_nextLanes_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t ZeroLengthLane::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneId_.initializeOffsets(endBitPosition);
    endBitPosition = m_previousLanes_.initializeOffsets(*this, endBitPosition);
    if (!getOnBorder())
    {
        endBitPosition = m_nextLanes_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t ZeroLengthLane::initializeOffsets(ZeroLengthLane::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneId_.initializeOffsets(context.getLaneId(), endBitPosition);
    endBitPosition = m_previousLanes_.initializeOffsetsPacked(*this, endBitPosition);
    if (!getOnBorder())
    {
        endBitPosition = m_nextLanes_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool ZeroLengthLane::operator==(const ZeroLengthLane& other) const
{
    if (this != &other)
    {
        return
                (getOnBorder() == other.getOnBorder()) &&
                (m_laneId_ == other.m_laneId_) &&
                (m_previousLanes_ == other.m_previousLanes_) &&
                (!isNextLanesUsed() ? !other.isNextLanesUsed() : (m_nextLanes_ == other.m_nextLanes_));
    }

    return true;
}

uint32_t ZeroLengthLane::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getOnBorder());
    result = ::zserio::calcHashCode(result, m_laneId_);
    result = ::zserio::calcHashCode(result, m_previousLanes_);
    if (isNextLanesUsed())
        result = ::zserio::calcHashCode(result, m_nextLanes_);

    return result;
}

void ZeroLengthLane::write(::zserio::BitStreamWriter& out) const
{
    m_laneId_.write(out);

    // check constraint
    if (!(getPreviousLanes().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ZeroLengthLane.previousLanes!");
    m_previousLanes_.write(*this, out);

    if (!getOnBorder())
    {
        // check constraint
        if (!(getNextLanes().size() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at ZeroLengthLane.nextLanes!");
        m_nextLanes_.value().write(*this, out);
    }
}

void ZeroLengthLane::write(ZeroLengthLane::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_laneId_.write(context.getLaneId(), out);

    // check constraint
    if (!(getPreviousLanes().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ZeroLengthLane.previousLanes!");
    m_previousLanes_.writePacked(*this, out);

    if (!getOnBorder())
    {
        // check constraint
        if (!(getNextLanes().size() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at ZeroLengthLane.nextLanes!");
        m_nextLanes_.value().writePacked(*this, out);
    }
}

void ZeroLengthLane::ZserioElementFactory_previousLanes::create(ZeroLengthLane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ZeroLengthLane::ZserioElementFactory_previousLanes::create(ZeroLengthLane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneConnector>& array,
        ::nds::lane::lanes::LaneConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ZeroLengthLane::ZserioElementFactory_nextLanes::create(ZeroLengthLane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ZeroLengthLane::ZserioElementFactory_nextLanes::create(ZeroLengthLane&        ,
        ::zserio::vector<::nds::lane::lanes::LaneConnector>& array,
        ::nds::lane::lanes::LaneConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::lane::reference::types::LaneId ZeroLengthLane::readLaneId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneId(in, allocator);
}

::nds::lane::reference::types::LaneId ZeroLengthLane::readLaneId(ZeroLengthLane::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneId(context.getLaneId(), in, allocator);
}
ZeroLengthLane::ZserioArrayType_previousLanes ZeroLengthLane::readPreviousLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_previousLanes readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ZeroLengthLane.previousLanes!");

    return readField;
}

ZeroLengthLane::ZserioArrayType_previousLanes ZeroLengthLane::readPreviousLanes(ZeroLengthLane::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_previousLanes readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ZeroLengthLane.previousLanes!");

    return readField;
}
::zserio::InplaceOptionalHolder<ZeroLengthLane::ZserioArrayType_nextLanes> ZeroLengthLane::readNextLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getOnBorder())
    {
        ZserioArrayType_nextLanes readField(allocator);
        readField.read(*this, in);
        // check constraint
        if (!(readField.getRawArray().size() > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at ZeroLengthLane.nextLanes!");

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_nextLanes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_nextLanes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<ZeroLengthLane::ZserioArrayType_nextLanes> ZeroLengthLane::readNextLanes(ZeroLengthLane::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getOnBorder())
    {
        ZserioArrayType_nextLanes readField(allocator);
        readField.readPacked(*this, in);
        // check constraint
        if (!(readField.getRawArray().size() > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at ZeroLengthLane.nextLanes!");

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_nextLanes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_nextLanes>(::zserio::NullOpt);
}

} // namespace lanes
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/lanes/LaneConnector.h>
#include <nds/lane/lanes/LaneConnectionType.h>
#include <nds/lane/lanes/LaneSplitMergePriority.h>

namespace nds
{
namespace lane
{
namespace lanes
{

LaneConnector::LaneConnector(const allocator_type&) noexcept :
        m_type_(::nds::lane::lanes::LaneConnectionType()),
        m_priority_(static_cast<::nds::lane::lanes::LaneSplitMergePriority>(::nds::lane::lanes::LaneSplitMergePriority::MAJOR)),
        m_connectedLaneId_(::zserio::NullOpt)
{
}

LaneConnector::LaneConnector(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_priority_(readPriority(in)),
        m_connectedLaneId_(readConnectedLaneId(in, allocator))
{
}

LaneConnector::LaneConnector(LaneConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_priority_(readPriority(context, in)),
        m_connectedLaneId_(readConnectedLaneId(context, in, allocator))
{
}

LaneConnector::LaneConnector(::zserio::PropagateAllocatorT,
        const LaneConnector& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_priority_(::zserio::allocatorPropagatingCopy(other.m_priority_, allocator)),
        m_connectedLaneId_(::zserio::allocatorPropagatingCopy(other.m_connectedLaneId_, allocator))
{
}

::nds::lane::lanes::LaneConnectionType LaneConnector::getType() const
{
    return m_type_;
}

void LaneConnector::setType(::nds::lane::lanes::LaneConnectionType type_)
{
    m_type_ = type_;
}

::nds::lane::lanes::LaneSplitMergePriority LaneConnector::getPriority() const
{
    return m_priority_;
}

void LaneConnector::setPriority(::nds::lane::lanes::LaneSplitMergePriority priority_)
{
    m_priority_ = priority_;
}

::nds::lane::reference::types::DirectedLaneReference& LaneConnector::getConnectedLaneId()
{
    return m_connectedLaneId_.value();
}

const ::nds::lane::reference::types::DirectedLaneReference& LaneConnector::getConnectedLaneId() const
{
    return m_connectedLaneId_.value();
}

void LaneConnector::setConnectedLaneId(const ::nds::lane::reference::types::DirectedLaneReference& connectedLaneId_)
{
    m_connectedLaneId_ = connectedLaneId_;
}

void LaneConnector::setConnectedLaneId(::nds::lane::reference::types::DirectedLaneReference&& connectedLaneId_)
{
    m_connectedLaneId_ = ::std::move(connectedLaneId_);
}

bool LaneConnector::isConnectedLaneIdUsed() const
{
    return (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER);
}

bool LaneConnector::isConnectedLaneIdSet() const
{
    return m_connectedLaneId_.hasValue();
}

void LaneConnector::resetConnectedLaneId()
{
    m_connectedLaneId_.reset();
}

void LaneConnector::initPackingContext(LaneConnector::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    ::zserio::initPackingContext(context.getPriority(), m_priority_);
    if (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER)
    {
        m_connectedLaneId_.value().initPackingContext(context.getConnectedLaneId());
    }
}

size_t LaneConnector::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += ::zserio::bitSizeOf(m_priority_);
    if (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER)
    {
        endBitPosition += m_connectedLaneId_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneConnector::bitSizeOf(LaneConnector::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += ::zserio::bitSizeOf(context.getPriority(), m_priority_);
    if (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER)
    {
        endBitPosition += m_connectedLaneId_.value().bitSizeOf(context.getConnectedLaneId(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneConnector::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_priority_);
    if (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER)
    {
        endBitPosition = m_connectedLaneId_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LaneConnector::initializeOffsets(LaneConnector::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = ::zserio::initializeOffsets(context.getPriority(), endBitPosition,
        m_priority_);
    if (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER)
    {
        endBitPosition = m_connectedLaneId_.value().initializeOffsets(context.getConnectedLaneId(), endBitPosition);
    }

    return endBitPosition;
}

bool LaneConnector::operator==(const LaneConnector& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_priority_ == other.m_priority_) &&
                (!isConnectedLaneIdUsed() ? !other.isConnectedLaneIdUsed() : (m_connectedLaneId_ == other.m_connectedLaneId_));
    }

    return true;
}

uint32_t LaneConnector::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_priority_);
    if (isConnectedLaneIdUsed())
        result = ::zserio::calcHashCode(result, m_connectedLaneId_);

    return result;
}

void LaneConnector::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    ::zserio::write(out, m_priority_);
    if (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER)
    {
        m_connectedLaneId_.value().write(out);
    }
}

void LaneConnector::write(LaneConnector::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    ::zserio::write(context.getPriority(), out, m_priority_);
    if (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER)
    {
        m_connectedLaneId_.value().write(context.getConnectedLaneId(), out);
    }
}

::nds::lane::lanes::LaneConnectionType LaneConnector::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::lanes::LaneConnectionType>(in);
}

::nds::lane::lanes::LaneConnectionType LaneConnector::readType(LaneConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::lanes::LaneConnectionType>(context.getType(), in);
}
::nds::lane::lanes::LaneSplitMergePriority LaneConnector::readPriority(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::lanes::LaneSplitMergePriority>(in);
}

::nds::lane::lanes::LaneSplitMergePriority LaneConnector::readPriority(LaneConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::lanes::LaneSplitMergePriority>(context.getPriority(), in);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::DirectedLaneReference> LaneConnector::readConnectedLaneId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::DirectedLaneReference>(::nds::lane::reference::types::DirectedLaneReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::DirectedLaneReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::DirectedLaneReference> LaneConnector::readConnectedLaneId(LaneConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::lane::lanes::LaneConnectionType::BY_IDENTIFIER)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::DirectedLaneReference>(::nds::lane::reference::types::DirectedLaneReference(context.getConnectedLaneId(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::DirectedLaneReference>(::zserio::NullOpt);
}

} // namespace lanes
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/lanes/LaneTraversability.h>

namespace nds
{
namespace lane
{
namespace lanes
{

LaneTraversability::LaneTraversability(const allocator_type& allocator) noexcept :
        m_ranges_(allocator)
{
}

LaneTraversability::LaneTraversability(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_ranges_(readRanges(in, allocator))
{
}

LaneTraversability::LaneTraversability(LaneTraversability::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_ranges_(readRanges(context, in, allocator))
{
}

LaneTraversability::LaneTraversability(::zserio::PropagateAllocatorT,
        const LaneTraversability& other, const allocator_type& allocator) :
        m_ranges_(::zserio::allocatorPropagatingCopy(other.m_ranges_, allocator))
{
}

::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& LaneTraversability::getRanges()
{
    return m_ranges_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& LaneTraversability::getRanges() const
{
    return m_ranges_.getRawArray();
}

void LaneTraversability::setRanges(const ::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(ranges_);
}

void LaneTraversability::setRanges(::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>&& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(std::move(ranges_));
}

void LaneTraversability::initPackingContext(LaneTraversability::ZserioPackingContext&) const
{
}

size_t LaneTraversability::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_ranges_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneTraversability::bitSizeOf(LaneTraversability::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_ranges_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneTraversability::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_ranges_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t LaneTraversability::initializeOffsets(LaneTraversability::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_ranges_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LaneTraversability::operator==(const LaneTraversability& other) const
{
    if (this != &other)
    {
        return
                (m_ranges_ == other.m_ranges_);
    }

    return true;
}

uint32_t LaneTraversability::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_ranges_);

    return result;
}

void LaneTraversability::write(::zserio::BitStreamWriter& out) const
{
    m_ranges_.write(*this, out);
}

void LaneTraversability::write(LaneTraversability::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_ranges_.writePacked(*this, out);
}

void LaneTraversability::ZserioElementFactory_ranges::create(LaneTraversability&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneTraversability::ZserioElementFactory_ranges::create(LaneTraversability&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGeometryRange>& array,
        ::nds::lane::reference::types::LaneGeometryRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

LaneTraversability::ZserioArrayType_ranges LaneTraversability::readRanges(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_ranges readField(allocator);
    readField.read(*this, in);

    return readField;
}

LaneTraversability::ZserioArrayType_ranges LaneTraversability::readRanges(LaneTraversability::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_ranges readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace lanes
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/lanes/LaneRelation.h>
#include <nds/lane/lanes/LaneRelationType.h>

namespace nds
{
namespace lane
{
namespace lanes
{

LaneRelation::LaneRelation(const allocator_type& allocator) noexcept :
        m_laneRelationType_(::nds::lane::lanes::LaneRelationType()),
        m_range_(allocator),
        m_otherLane_(allocator),
        m_otherLaneRange_(allocator),
        m_otherLaneSameDigitizationDirection_(::zserio::NullOpt)
{
}

LaneRelation::LaneRelation(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_laneRelationType_(readLaneRelationType(in)),
        m_range_(readRange(in, allocator)),
        m_otherLane_(readOtherLane(in, allocator)),
        m_otherLaneRange_(readOtherLaneRange(in, allocator)),
        m_otherLaneSameDigitizationDirection_(readOtherLaneSameDigitizationDirection(in))
{
}

LaneRelation::LaneRelation(LaneRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_laneRelationType_(readLaneRelationType(context, in)),
        m_range_(readRange(context, in, allocator)),
        m_otherLane_(readOtherLane(context, in, allocator)),
        m_otherLaneRange_(readOtherLaneRange(context, in, allocator)),
        m_otherLaneSameDigitizationDirection_(readOtherLaneSameDigitizationDirection(in))
{
}

LaneRelation::LaneRelation(::zserio::PropagateAllocatorT,
        const LaneRelation& other, const allocator_type& allocator) :
        m_laneRelationType_(::zserio::allocatorPropagatingCopy(other.m_laneRelationType_, allocator)),
        m_range_(::zserio::allocatorPropagatingCopy(other.m_range_, allocator)),
        m_otherLane_(::zserio::allocatorPropagatingCopy(other.m_otherLane_, allocator)),
        m_otherLaneRange_(::zserio::allocatorPropagatingCopy(other.m_otherLaneRange_, allocator)),
        m_otherLaneSameDigitizationDirection_(::zserio::allocatorPropagatingCopy(other.m_otherLaneSameDigitizationDirection_, allocator))
{
}

::nds::lane::lanes::LaneRelationType LaneRelation::getLaneRelationType() const
{
    return m_laneRelationType_;
}

void LaneRelation::setLaneRelationType(::nds::lane::lanes::LaneRelationType laneRelationType_)
{
    m_laneRelationType_ = laneRelationType_;
}

::nds::lane::reference::types::LaneGeometryRange& LaneRelation::getRange()
{
    return m_range_;
}

const ::nds::lane::reference::types::LaneGeometryRange& LaneRelation::getRange() const
{
    return m_range_;
}

void LaneRelation::setRange(const ::nds::lane::reference::types::LaneGeometryRange& range_)
{
    m_range_ = range_;
}

void LaneRelation::setRange(::nds::lane::reference::types::LaneGeometryRange&& range_)
{
    m_range_ = ::std::move(range_);
}

::nds::lane::reference::types::LaneId& LaneRelation::getOtherLane()
{
    return m_otherLane_;
}

const ::nds::lane::reference::types::LaneId& LaneRelation::getOtherLane() const
{
    return m_otherLane_;
}

void LaneRelation::setOtherLane(const ::nds::lane::reference::types::LaneId& otherLane_)
{
    m_otherLane_ = otherLane_;
}

void LaneRelation::setOtherLane(::nds::lane::reference::types::LaneId&& otherLane_)
{
    m_otherLane_ = ::std::move(otherLane_);
}

::nds::lane::reference::types::LaneGeometryRange& LaneRelation::getOtherLaneRange()
{
    return m_otherLaneRange_;
}

const ::nds::lane::reference::types::LaneGeometryRange& LaneRelation::getOtherLaneRange() const
{
    return m_otherLaneRange_;
}

void LaneRelation::setOtherLaneRange(const ::nds::lane::reference::types::LaneGeometryRange& otherLaneRange_)
{
    m_otherLaneRange_ = otherLaneRange_;
}

void LaneRelation::setOtherLaneRange(::nds::lane::reference::types::LaneGeometryRange&& otherLaneRange_)
{
    m_otherLaneRange_ = ::std::move(otherLaneRange_);
}

bool LaneRelation::getOtherLaneSameDigitizationDirection() const
{
    return m_otherLaneSameDigitizationDirection_.value();
}

void LaneRelation::setOtherLaneSameDigitizationDirection(bool otherLaneSameDigitizationDirection_)
{
    m_otherLaneSameDigitizationDirection_ = otherLaneSameDigitizationDirection_;
}

bool LaneRelation::isOtherLaneSameDigitizationDirectionUsed() const
{
    return (getLaneRelationType() != ::nds::lane::lanes::LaneRelationType::CROSSING);
}

bool LaneRelation::isOtherLaneSameDigitizationDirectionSet() const
{
    return m_otherLaneSameDigitizationDirection_.hasValue();
}

void LaneRelation::resetOtherLaneSameDigitizationDirection()
{
    m_otherLaneSameDigitizationDirection_.reset();
}

void LaneRelation::initPackingContext(LaneRelation::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getLaneRelationType(), m_laneRelationType_);
    m_range_.initPackingContext(context.getRange());
    m_otherLane_.initPackingContext(context.getOtherLane());
    m_otherLaneRange_.initPackingContext(context.getOtherLaneRange());
}

size_t LaneRelation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_laneRelationType_);
    endBitPosition += m_range_.bitSizeOf(endBitPosition);
    endBitPosition += m_otherLane_.bitSizeOf(endBitPosition);
    endBitPosition += m_otherLaneRange_.bitSizeOf(endBitPosition);
    if (getLaneRelationType() != ::nds::lane::lanes::LaneRelationType::CROSSING)
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition - bitPosition;
}

size_t LaneRelation::bitSizeOf(LaneRelation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getLaneRelationType(), m_laneRelationType_);
    endBitPosition += m_range_.bitSizeOf(context.getRange(), endBitPosition);
    endBitPosition += m_otherLane_.bitSizeOf(context.getOtherLane(), endBitPosition);
    endBitPosition += m_otherLaneRange_.bitSizeOf(context.getOtherLaneRange(), endBitPosition);
    if (getLaneRelationType() != ::nds::lane::lanes::LaneRelationType::CROSSING)
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition - bitPosition;
}

size_t LaneRelation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_laneRelationType_);
    endBitPosition = m_range_.initializeOffsets(endBitPosition);
    endBitPosition = m_otherLane_.initializeOffsets(endBitPosition);
    endBitPosition = m_otherLaneRange_.initializeOffsets(endBitPosition);
    if (getLaneRelationType() != ::nds::lane::lanes::LaneRelationType::CROSSING)
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition;
}

size_t LaneRelation::initializeOffsets(LaneRelation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getLaneRelationType(), endBitPosition,
        m_laneRelationType_);
    endBitPosition = m_range_.initializeOffsets(context.getRange(), endBitPosition);
    endBitPosition = m_otherLane_.initializeOffsets(context.getOtherLane(), endBitPosition);
    endBitPosition = m_otherLaneRange_.initializeOffsets(context.getOtherLaneRange(), endBitPosition);
    if (getLaneRelationType() != ::nds::lane::lanes::LaneRelationType::CROSSING)
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition;
}

bool LaneRelation::operator==(const LaneRelation& other) const
{
    if (this != &other)
    {
        return
                (m_laneRelationType_ == other.m_laneRelationType_) &&
                (m_range_ == other.m_range_) &&
                (m_otherLane_ == other.m_otherLane_) &&
                (m_otherLaneRange_ == other.m_otherLaneRange_) &&
                (!isOtherLaneSameDigitizationDirectionUsed() ? !other.isOtherLaneSameDigitizationDirectionUsed() : (m_otherLaneSameDigitizationDirection_ == other.m_otherLaneSameDigitizationDirection_));
    }

    return true;
}

uint32_t LaneRelation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_laneRelationType_);
    result = ::zserio::calcHashCode(result, m_range_);
    result = ::zserio::calcHashCode(result, m_otherLane_);
    result = ::zserio::calcHashCode(result, m_otherLaneRange_);
    if (isOtherLaneSameDigitizationDirectionUsed())
        result = ::zserio::calcHashCode(result, m_otherLaneSameDigitizationDirection_);

    return result;
}

void LaneRelation::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_laneRelationType_);
    m_range_.write(out);
    m_otherLane_.write(out);
    m_otherLaneRange_.write(out);
    if (getLaneRelationType() != ::nds::lane::lanes::LaneRelationType::CROSSING)
    {
        out.writeBool(m_otherLaneSameDigitizationDirection_.value());
    }
}

void LaneRelation::write(LaneRelation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getLaneRelationType(), out, m_laneRelationType_);
    m_range_.write(context.getRange(), out);
    m_otherLane_.write(context.getOtherLane(), out);
    m_otherLaneRange_.write(context.getOtherLaneRange(), out);
    if (getLaneRelationType() != ::nds::lane::lanes::LaneRelationType::CROSSING)
    {
        out.writeBool(m_otherLaneSameDigitizationDirection_.value());
    }
}

::nds::lane::lanes::LaneRelationType LaneRelation::readLaneRelationType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::lanes::LaneRelationType>(in);
}

::nds::lane::lanes::LaneRelationType LaneRelation::readLaneRelationType(LaneRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::lanes::LaneRelationType>(context.getLaneRelationType(), in);
}
::nds::lane::reference::types::LaneGeometryRange LaneRelation::readRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGeometryRange(in, allocator);
}

::nds::lane::reference::types::LaneGeometryRange LaneRelation::readRange(LaneRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGeometryRange(context.getRange(), in, allocator);
}
::nds::lane::reference::types::LaneId LaneRelation::readOtherLane(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneId(in, allocator);
}

::nds::lane::reference::types::LaneId LaneRelation::readOtherLane(LaneRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneId(context.getOtherLane(), in, allocator);
}
::nds::lane::reference::types::LaneGeometryRange LaneRelation::readOtherLaneRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGeometryRange(in, allocator);
}

::nds::lane::reference::types::LaneGeometryRange LaneRelation::readOtherLaneRange(LaneRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGeometryRange(context.getOtherLaneRange(), in, allocator);
}
::zserio::InplaceOptionalHolder<bool> LaneRelation::readOtherLaneSameDigitizationDirection(::zserio::BitStreamReader& in)
{
    if (getLaneRelationType() != ::nds::lane::lanes::LaneRelationType::CROSSING)
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}

} // namespace lanes
} // namespace lane
} // namespace nds
