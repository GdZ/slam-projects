/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/roadsurface/RoadSurfacePolygonPhysicalType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadSurfacePolygonPhysicalType enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::names;
constexpr ::std::array<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType, 7> EnumTraits<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::values;
constexpr const char* EnumTraits<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType value)
{
    switch (value)
    {
    case ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType::UNKNOWN:
        return 0;
    case ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType::PAVED:
        return 1;
    case ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType::UNPAVED:
        return 2;
    case ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType::GRAVEL:
        return 3;
    case ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType::MANHOLE:
        return 4;
    case ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType::POTHOLE:
        return 5;
    case ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType::DITCH:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfacePolygonPhysicalType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::type>(value) << "!";
    }
}

template <>
::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType valueToEnum(
        typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT32_C(0):
    case UINT32_C(1):
    case UINT32_C(2):
    case UINT32_C(3):
    case UINT32_C(4):
    case UINT32_C(5):
    case UINT32_C(6):
        return static_cast<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfacePolygonPhysicalType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>(::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType value)
{
    return ::zserio::bitSizeOfVarUInt32(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>(
            static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::type>(
                    in.readVarUInt32()));
}

template <>
::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType value)
{
    out.writeVarUInt32(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/roadsurface/RoadSurfaceLinePhysicalType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadSurfaceLinePhysicalType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::names;
constexpr ::std::array<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType, 4> EnumTraits<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::values;
constexpr const char* EnumTraits<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::roadsurface::RoadSurfaceLinePhysicalType value)
{
    switch (value)
    {
    case ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType::UNKNOWN:
        return 0;
    case ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType::PAVED:
        return 1;
    case ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType::RAIL:
        return 2;
    case ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType::CURB:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfaceLinePhysicalType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::type>(value) << "!";
    }
}

template <>
::nds::lane::roadsurface::RoadSurfaceLinePhysicalType valueToEnum(
        typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT32_C(0):
    case UINT32_C(1):
    case UINT32_C(2):
    case UINT32_C(3):
        return static_cast<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfaceLinePhysicalType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>(::nds::lane::roadsurface::RoadSurfaceLinePhysicalType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::roadsurface::RoadSurfaceLinePhysicalType value)
{
    return ::zserio::bitSizeOfVarUInt32(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::roadsurface::RoadSurfaceLinePhysicalType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>(
            static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::type>(
                    in.readVarUInt32()));
}

template <>
::nds::lane::roadsurface::RoadSurfaceLinePhysicalType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType value)
{
    out.writeVarUInt32(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfaceLinePhysicalType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/roadsurface/RoadSurfacePolygonLogicalType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadSurfacePolygonLogicalType enumeration.
constexpr ::std::array<const char*, 21> EnumTraits<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::names;
constexpr ::std::array<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType, 21> EnumTraits<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::values;
constexpr const char* EnumTraits<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::roadsurface::RoadSurfacePolygonLogicalType value)
{
    switch (value)
    {
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::UNKNOWN:
        return 0;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::CROSSWALK:
        return 1;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::BICYCLE_CROSSING:
        return 2;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::INTERSECTION:
        return 3;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON:
        return 4;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::GORE:
        return 5;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::WALKING_AREA:
        return 6;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::DRIVEWAY:
        return 7;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::ROUNDABOUT:
        return 8;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::PEDESTRIAN_WAITING_AREA:
        return 9;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::BICYCLE_WAITING_AREA:
        return 10;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::PARKING:
        return 11;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::CONSTRUCTION_AREA:
        return 12;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::BUS_STOP:
        return 13;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::TRAM_STOP:
        return 14;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::TRAM_CROSSING:
        return 15;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::TRAM_TRACK:
        return 16;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::NO_STOP_ZONE:
        return 17;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::DRIVABLE:
        return 18;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::NON_DRIVABLE:
        return 19;
    case ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::UNDESIRABLE:
        return 20;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfacePolygonLogicalType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::type>(value) << "!";
    }
}

template <>
::nds::lane::roadsurface::RoadSurfacePolygonLogicalType valueToEnum(
        typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT32_C(0):
    case UINT32_C(1):
    case UINT32_C(2):
    case UINT32_C(3):
    case UINT32_C(4):
    case UINT32_C(5):
    case UINT32_C(6):
    case UINT32_C(7):
    case UINT32_C(8):
    case UINT32_C(9):
    case UINT32_C(10):
    case UINT32_C(11):
    case UINT32_C(12):
    case UINT32_C(13):
    case UINT32_C(14):
    case UINT32_C(15):
    case UINT32_C(16):
    case UINT32_C(17):
    case UINT32_C(18):
    case UINT32_C(19):
    case UINT32_C(20):
        return static_cast<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfacePolygonLogicalType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>(::nds::lane::roadsurface::RoadSurfacePolygonLogicalType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::roadsurface::RoadSurfacePolygonLogicalType value)
{
    return ::zserio::bitSizeOfVarUInt32(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::roadsurface::RoadSurfacePolygonLogicalType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>(
            static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::type>(
                    in.readVarUInt32()));
}

template <>
::nds::lane::roadsurface::RoadSurfacePolygonLogicalType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType value)
{
    out.writeVarUInt32(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/roadsurface/RoadSurfaceLineLogicalType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadSurfaceLineLogicalType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::names;
constexpr ::std::array<::nds::lane::roadsurface::RoadSurfaceLineLogicalType, 3> EnumTraits<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::values;
constexpr const char* EnumTraits<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::roadsurface::RoadSurfaceLineLogicalType value)
{
    switch (value)
    {
    case ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::UNKNOWN:
        return 0;
    case ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE:
        return 1;
    case ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::CURB_TRAVERSABLE:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfaceLineLogicalType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::type>(value) << "!";
    }
}

template <>
::nds::lane::roadsurface::RoadSurfaceLineLogicalType valueToEnum(
        typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT32_C(0):
    case UINT32_C(1):
    case UINT32_C(2):
        return static_cast<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfaceLineLogicalType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>(::nds::lane::roadsurface::RoadSurfaceLineLogicalType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfaceLineLogicalType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::roadsurface::RoadSurfaceLineLogicalType value)
{
    return ::zserio::bitSizeOfVarUInt32(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfaceLineLogicalType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::roadsurface::RoadSurfaceLineLogicalType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::roadsurface::RoadSurfaceLineLogicalType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::roadsurface::RoadSurfaceLineLogicalType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>(
            static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::type>(
                    in.readVarUInt32()));
}

template <>
::nds::lane::roadsurface::RoadSurfaceLineLogicalType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfaceLineLogicalType value)
{
    out.writeVarUInt32(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfaceLineLogicalType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/roadsurface/RoadSurfacePolygonMarkingType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadSurfacePolygonMarkingType enumeration.
constexpr ::std::array<const char*, 19> EnumTraits<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::names;
constexpr ::std::array<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType, 19> EnumTraits<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::values;
constexpr const char* EnumTraits<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::roadsurface::RoadSurfacePolygonMarkingType value)
{
    switch (value)
    {
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::UNKNOWN:
        return 0;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::DASH:
        return 1;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::TEXT:
        return 2;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_STRAIGHT:
        return 3;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_LEFT:
        return 4;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_RIGHT:
        return 5;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_STRAIGHT_AND_LEFT:
        return 6;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_STRAIGHT_AND_RIGHT:
        return 7;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_LEFT_AND_RIGHT:
        return 8;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_SLIGHT_LEFT:
        return 9;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_SLIGHT_RIGHT:
        return 10;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_U_TURN:
        return 11;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_STRAIGHT_AND_U_TURN:
        return 12;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_LEFT_AND_U_TURN:
        return 13;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::ARROW_RIGHT_AND_U_TURN:
        return 14;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::SIGN:
        return 15;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::YIELD_INDICATION:
        return 16;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::VISUAL_SPEED_BUMP:
        return 17;
    case ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType::SHADED_AREA:
        return 18;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfacePolygonMarkingType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::type>(value) << "!";
    }
}

template <>
::nds::lane::roadsurface::RoadSurfacePolygonMarkingType valueToEnum(
        typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT32_C(0):
    case UINT32_C(1):
    case UINT32_C(2):
    case UINT32_C(3):
    case UINT32_C(4):
    case UINT32_C(5):
    case UINT32_C(6):
    case UINT32_C(7):
    case UINT32_C(8):
    case UINT32_C(9):
    case UINT32_C(10):
    case UINT32_C(11):
    case UINT32_C(12):
    case UINT32_C(13):
    case UINT32_C(14):
    case UINT32_C(15):
    case UINT32_C(16):
    case UINT32_C(17):
    case UINT32_C(18):
        return static_cast<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfacePolygonMarkingType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>(::nds::lane::roadsurface::RoadSurfacePolygonMarkingType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::roadsurface::RoadSurfacePolygonMarkingType value)
{
    return ::zserio::bitSizeOfVarUInt32(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::roadsurface::RoadSurfacePolygonMarkingType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>(
            static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::type>(
                    in.readVarUInt32()));
}

template <>
::nds::lane::roadsurface::RoadSurfacePolygonMarkingType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType value)
{
    out.writeVarUInt32(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfacePolygonMarkingType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/roadsurface/RoadSurfaceLineMarkingType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadSurfaceLineMarkingType enumeration.
constexpr ::std::array<const char*, 6> EnumTraits<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::names;
constexpr ::std::array<::nds::lane::roadsurface::RoadSurfaceLineMarkingType, 6> EnumTraits<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::values;
constexpr const char* EnumTraits<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::roadsurface::RoadSurfaceLineMarkingType value)
{
    switch (value)
    {
    case ::nds::lane::roadsurface::RoadSurfaceLineMarkingType::UNKNOWN:
        return 0;
    case ::nds::lane::roadsurface::RoadSurfaceLineMarkingType::LINE:
        return 1;
    case ::nds::lane::roadsurface::RoadSurfaceLineMarkingType::SOLID_LINE:
        return 2;
    case ::nds::lane::roadsurface::RoadSurfaceLineMarkingType::DASHED_LINE:
        return 3;
    case ::nds::lane::roadsurface::RoadSurfaceLineMarkingType::STOP_LINE:
        return 4;
    case ::nds::lane::roadsurface::RoadSurfaceLineMarkingType::WAITING_LINE:
        return 5;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfaceLineMarkingType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::type>(value) << "!";
    }
}

template <>
::nds::lane::roadsurface::RoadSurfaceLineMarkingType valueToEnum(
        typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT32_C(0):
    case UINT32_C(1):
    case UINT32_C(2):
    case UINT32_C(3):
    case UINT32_C(4):
    case UINT32_C(5):
        return static_cast<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadSurfaceLineMarkingType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>(::nds::lane::roadsurface::RoadSurfaceLineMarkingType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfaceLineMarkingType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::roadsurface::RoadSurfaceLineMarkingType value)
{
    return ::zserio::bitSizeOfVarUInt32(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::roadsurface::RoadSurfaceLineMarkingType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::roadsurface::RoadSurfaceLineMarkingType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::roadsurface::RoadSurfaceLineMarkingType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::roadsurface::RoadSurfaceLineMarkingType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>(
            static_cast<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::type>(
                    in.readVarUInt32()));
}

template <>
::nds::lane::roadsurface::RoadSurfaceLineMarkingType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfaceLineMarkingType value)
{
    out.writeVarUInt32(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::roadsurface::RoadSurfaceLineMarkingType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/roadsurface/RoadSurfacePolygonType.h>
#include <nds/lane/roadsurface/RoadSurfacePolygonLogicalType.h>

namespace nds
{
namespace lane
{
namespace roadsurface
{

RoadSurfacePolygonType::RoadSurfacePolygonType(const allocator_type&) noexcept :
        m_physicalType_(::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType()),
        m_logicalType_(::nds::lane::roadsurface::RoadSurfacePolygonLogicalType()),
        m_markingDetails_(::zserio::NullOpt)
{
}

RoadSurfacePolygonType::RoadSurfacePolygonType(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_physicalType_(readPhysicalType(in)),
        m_logicalType_(readLogicalType(in)),
        m_markingDetails_(readMarkingDetails(in, allocator))
{
}

RoadSurfacePolygonType::RoadSurfacePolygonType(RoadSurfacePolygonType::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_physicalType_(readPhysicalType(context, in)),
        m_logicalType_(readLogicalType(context, in)),
        m_markingDetails_(readMarkingDetails(context, in, allocator))
{
}

RoadSurfacePolygonType::RoadSurfacePolygonType(::zserio::PropagateAllocatorT,
        const RoadSurfacePolygonType& other, const allocator_type& allocator) :
        m_physicalType_(::zserio::allocatorPropagatingCopy(other.m_physicalType_, allocator)),
        m_logicalType_(::zserio::allocatorPropagatingCopy(other.m_logicalType_, allocator)),
        m_markingDetails_(::zserio::allocatorPropagatingCopy(other.m_markingDetails_, allocator))
{
}

::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType RoadSurfacePolygonType::getPhysicalType() const
{
    return m_physicalType_;
}

void RoadSurfacePolygonType::setPhysicalType(::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType physicalType_)
{
    m_physicalType_ = physicalType_;
}

::nds::lane::roadsurface::RoadSurfacePolygonLogicalType RoadSurfacePolygonType::getLogicalType() const
{
    return m_logicalType_;
}

void RoadSurfacePolygonType::setLogicalType(::nds::lane::roadsurface::RoadSurfacePolygonLogicalType logicalType_)
{
    m_logicalType_ = logicalType_;
}

::nds::lane::roadsurface::RoadSurfacePolygonMarking& RoadSurfacePolygonType::getMarkingDetails()
{
    return m_markingDetails_.value();
}

const ::nds::lane::roadsurface::RoadSurfacePolygonMarking& RoadSurfacePolygonType::getMarkingDetails() const
{
    return m_markingDetails_.value();
}

void RoadSurfacePolygonType::setMarkingDetails(const ::nds::lane::roadsurface::RoadSurfacePolygonMarking& markingDetails_)
{
    m_markingDetails_ = markingDetails_;
}

void RoadSurfacePolygonType::setMarkingDetails(::nds::lane::roadsurface::RoadSurfacePolygonMarking&& markingDetails_)
{
    m_markingDetails_ = ::std::move(markingDetails_);
}

bool RoadSurfacePolygonType::isMarkingDetailsUsed() const
{
    return (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON);
}

bool RoadSurfacePolygonType::isMarkingDetailsSet() const
{
    return m_markingDetails_.hasValue();
}

void RoadSurfacePolygonType::resetMarkingDetails()
{
    m_markingDetails_.reset();
}

void RoadSurfacePolygonType::initPackingContext(RoadSurfacePolygonType::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getPhysicalType(), m_physicalType_);
    ::zserio::initPackingContext(context.getLogicalType(), m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON)
    {
        m_markingDetails_.value().initPackingContext(context.getMarkingDetails());
    }
}

size_t RoadSurfacePolygonType::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_physicalType_);
    endBitPosition += ::zserio::bitSizeOf(m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON)
    {
        endBitPosition += m_markingDetails_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadSurfacePolygonType::bitSizeOf(RoadSurfacePolygonType::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getPhysicalType(), m_physicalType_);
    endBitPosition += ::zserio::bitSizeOf(context.getLogicalType(), m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON)
    {
        endBitPosition += m_markingDetails_.value().bitSizeOf(context.getMarkingDetails(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadSurfacePolygonType::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_physicalType_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON)
    {
        endBitPosition = m_markingDetails_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RoadSurfacePolygonType::initializeOffsets(RoadSurfacePolygonType::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getPhysicalType(), endBitPosition,
        m_physicalType_);
    endBitPosition = ::zserio::initializeOffsets(context.getLogicalType(), endBitPosition,
        m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON)
    {
        endBitPosition = m_markingDetails_.value().initializeOffsets(context.getMarkingDetails(), endBitPosition);
    }

    return endBitPosition;
}

bool RoadSurfacePolygonType::operator==(const RoadSurfacePolygonType& other) const
{
    if (this != &other)
    {
        return
                (m_physicalType_ == other.m_physicalType_) &&
                (m_logicalType_ == other.m_logicalType_) &&
                (!isMarkingDetailsUsed() ? !other.isMarkingDetailsUsed() : (m_markingDetails_ == other.m_markingDetails_));
    }

    return true;
}

uint32_t RoadSurfacePolygonType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_physicalType_);
    result = ::zserio::calcHashCode(result, m_logicalType_);
    if (isMarkingDetailsUsed())
        result = ::zserio::calcHashCode(result, m_markingDetails_);

    return result;
}

void RoadSurfacePolygonType::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_physicalType_);
    ::zserio::write(out, m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON)
    {
        m_markingDetails_.value().write(out);
    }
}

void RoadSurfacePolygonType::write(RoadSurfacePolygonType::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getPhysicalType(), out, m_physicalType_);
    ::zserio::write(context.getLogicalType(), out, m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON)
    {
        m_markingDetails_.value().write(context.getMarkingDetails(), out);
    }
}

::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType RoadSurfacePolygonType::readPhysicalType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>(in);
}

::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType RoadSurfacePolygonType::readPhysicalType(RoadSurfacePolygonType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfacePolygonPhysicalType>(context.getPhysicalType(), in);
}
::nds::lane::roadsurface::RoadSurfacePolygonLogicalType RoadSurfacePolygonType::readLogicalType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>(in);
}

::nds::lane::roadsurface::RoadSurfacePolygonLogicalType RoadSurfacePolygonType::readLogicalType(RoadSurfacePolygonType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfacePolygonLogicalType>(context.getLogicalType(), in);
}
::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfacePolygonMarking> RoadSurfacePolygonType::readMarkingDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfacePolygonMarking>(::nds::lane::roadsurface::RoadSurfacePolygonMarking(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfacePolygonMarking>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfacePolygonMarking> RoadSurfacePolygonType::readMarkingDetails(RoadSurfacePolygonType::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfacePolygonLogicalType::MARKING_POLYGON)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfacePolygonMarking>(::nds::lane::roadsurface::RoadSurfacePolygonMarking(context.getMarkingDetails(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfacePolygonMarking>(::zserio::NullOpt);
}

} // namespace roadsurface
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/roadsurface/RoadSurfacePolygonMarking.h>

namespace nds
{
namespace lane
{
namespace roadsurface
{

RoadSurfacePolygonMarking::RoadSurfacePolygonMarking(const allocator_type&) noexcept :
        m_markingType_(::nds::lane::roadsurface::RoadSurfacePolygonMarkingType()),
        m_markingColor_(::nds::lane::reference::types::MarkingColor()),
        m_markingMaterial_(::nds::lane::types::MarkingMaterial())
{
}

RoadSurfacePolygonMarking::RoadSurfacePolygonMarking(::zserio::BitStreamReader& in, const allocator_type&) :
        m_markingType_(readMarkingType(in)),
        m_markingColor_(readMarkingColor(in)),
        m_markingMaterial_(readMarkingMaterial(in))
{
}

RoadSurfacePolygonMarking::RoadSurfacePolygonMarking(RoadSurfacePolygonMarking::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_markingType_(readMarkingType(context, in)),
        m_markingColor_(readMarkingColor(context, in)),
        m_markingMaterial_(readMarkingMaterial(context, in))
{
}

RoadSurfacePolygonMarking::RoadSurfacePolygonMarking(::zserio::PropagateAllocatorT,
        const RoadSurfacePolygonMarking& other, const allocator_type& allocator) :
        m_markingType_(::zserio::allocatorPropagatingCopy(other.m_markingType_, allocator)),
        m_markingColor_(::zserio::allocatorPropagatingCopy(other.m_markingColor_, allocator)),
        m_markingMaterial_(::zserio::allocatorPropagatingCopy(other.m_markingMaterial_, allocator))
{
}

::nds::lane::roadsurface::RoadSurfacePolygonMarkingType RoadSurfacePolygonMarking::getMarkingType() const
{
    return m_markingType_;
}

void RoadSurfacePolygonMarking::setMarkingType(::nds::lane::roadsurface::RoadSurfacePolygonMarkingType markingType_)
{
    m_markingType_ = markingType_;
}

::nds::lane::reference::types::MarkingColor RoadSurfacePolygonMarking::getMarkingColor() const
{
    return m_markingColor_;
}

void RoadSurfacePolygonMarking::setMarkingColor(::nds::lane::reference::types::MarkingColor markingColor_)
{
    m_markingColor_ = markingColor_;
}

::nds::lane::types::MarkingMaterial RoadSurfacePolygonMarking::getMarkingMaterial() const
{
    return m_markingMaterial_;
}

void RoadSurfacePolygonMarking::setMarkingMaterial(::nds::lane::types::MarkingMaterial markingMaterial_)
{
    m_markingMaterial_ = markingMaterial_;
}

void RoadSurfacePolygonMarking::initPackingContext(RoadSurfacePolygonMarking::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getMarkingType(), m_markingType_);
    ::zserio::initPackingContext(context.getMarkingColor(), m_markingColor_);
    ::zserio::initPackingContext(context.getMarkingMaterial(), m_markingMaterial_);
}

size_t RoadSurfacePolygonMarking::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_markingType_);
    endBitPosition += ::zserio::bitSizeOf(m_markingColor_);
    endBitPosition += ::zserio::bitSizeOf(m_markingMaterial_);

    return endBitPosition - bitPosition;
}

size_t RoadSurfacePolygonMarking::bitSizeOf(RoadSurfacePolygonMarking::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getMarkingType(), m_markingType_);
    endBitPosition += ::zserio::bitSizeOf(context.getMarkingColor(), m_markingColor_);
    endBitPosition += ::zserio::bitSizeOf(context.getMarkingMaterial(), m_markingMaterial_);

    return endBitPosition - bitPosition;
}

size_t RoadSurfacePolygonMarking::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_markingType_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_markingColor_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_markingMaterial_);

    return endBitPosition;
}

size_t RoadSurfacePolygonMarking::initializeOffsets(RoadSurfacePolygonMarking::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getMarkingType(), endBitPosition,
        m_markingType_);
    endBitPosition = ::zserio::initializeOffsets(context.getMarkingColor(), endBitPosition,
        m_markingColor_);
    endBitPosition = ::zserio::initializeOffsets(context.getMarkingMaterial(), endBitPosition,
        m_markingMaterial_);

    return endBitPosition;
}

bool RoadSurfacePolygonMarking::operator==(const RoadSurfacePolygonMarking& other) const
{
    if (this != &other)
    {
        return
                (m_markingType_ == other.m_markingType_) &&
                (m_markingColor_ == other.m_markingColor_) &&
                (m_markingMaterial_ == other.m_markingMaterial_);
    }

    return true;
}

uint32_t RoadSurfacePolygonMarking::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_markingType_);
    result = ::zserio::calcHashCode(result, m_markingColor_);
    result = ::zserio::calcHashCode(result, m_markingMaterial_);

    return result;
}

void RoadSurfacePolygonMarking::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_markingType_);
    ::zserio::write(out, m_markingColor_);
    ::zserio::write(out, m_markingMaterial_);
}

void RoadSurfacePolygonMarking::write(RoadSurfacePolygonMarking::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getMarkingType(), out, m_markingType_);
    ::zserio::write(context.getMarkingColor(), out, m_markingColor_);
    ::zserio::write(context.getMarkingMaterial(), out, m_markingMaterial_);
}

::nds::lane::roadsurface::RoadSurfacePolygonMarkingType RoadSurfacePolygonMarking::readMarkingType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>(in);
}

::nds::lane::roadsurface::RoadSurfacePolygonMarkingType RoadSurfacePolygonMarking::readMarkingType(RoadSurfacePolygonMarking::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfacePolygonMarkingType>(context.getMarkingType(), in);
}
::nds::lane::reference::types::MarkingColor RoadSurfacePolygonMarking::readMarkingColor(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::MarkingColor>(in);
}

::nds::lane::reference::types::MarkingColor RoadSurfacePolygonMarking::readMarkingColor(RoadSurfacePolygonMarking::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::MarkingColor>(context.getMarkingColor(), in);
}
::nds::lane::types::MarkingMaterial RoadSurfacePolygonMarking::readMarkingMaterial(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::MarkingMaterial>(in);
}

::nds::lane::types::MarkingMaterial RoadSurfacePolygonMarking::readMarkingMaterial(RoadSurfacePolygonMarking::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::MarkingMaterial>(context.getMarkingMaterial(), in);
}

} // namespace roadsurface
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/roadsurface/RoadSurfaceLineType.h>
#include <nds/lane/roadsurface/RoadSurfaceLineLogicalType.h>

namespace nds
{
namespace lane
{
namespace roadsurface
{

RoadSurfaceLineType::RoadSurfaceLineType(const allocator_type&) noexcept :
        m_physicalType_(::nds::lane::roadsurface::RoadSurfaceLinePhysicalType()),
        m_logicalType_(::nds::lane::roadsurface::RoadSurfaceLineLogicalType()),
        m_markingDetails_(::zserio::NullOpt)
{
}

RoadSurfaceLineType::RoadSurfaceLineType(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_physicalType_(readPhysicalType(in)),
        m_logicalType_(readLogicalType(in)),
        m_markingDetails_(readMarkingDetails(in, allocator))
{
}

RoadSurfaceLineType::RoadSurfaceLineType(RoadSurfaceLineType::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_physicalType_(readPhysicalType(context, in)),
        m_logicalType_(readLogicalType(context, in)),
        m_markingDetails_(readMarkingDetails(context, in, allocator))
{
}

RoadSurfaceLineType::RoadSurfaceLineType(::zserio::PropagateAllocatorT,
        const RoadSurfaceLineType& other, const allocator_type& allocator) :
        m_physicalType_(::zserio::allocatorPropagatingCopy(other.m_physicalType_, allocator)),
        m_logicalType_(::zserio::allocatorPropagatingCopy(other.m_logicalType_, allocator)),
        m_markingDetails_(::zserio::allocatorPropagatingCopy(other.m_markingDetails_, allocator))
{
}

::nds::lane::roadsurface::RoadSurfaceLinePhysicalType RoadSurfaceLineType::getPhysicalType() const
{
    return m_physicalType_;
}

void RoadSurfaceLineType::setPhysicalType(::nds::lane::roadsurface::RoadSurfaceLinePhysicalType physicalType_)
{
    m_physicalType_ = physicalType_;
}

::nds::lane::roadsurface::RoadSurfaceLineLogicalType RoadSurfaceLineType::getLogicalType() const
{
    return m_logicalType_;
}

void RoadSurfaceLineType::setLogicalType(::nds::lane::roadsurface::RoadSurfaceLineLogicalType logicalType_)
{
    m_logicalType_ = logicalType_;
}

::nds::lane::roadsurface::RoadSurfaceLineMarking& RoadSurfaceLineType::getMarkingDetails()
{
    return m_markingDetails_.value();
}

const ::nds::lane::roadsurface::RoadSurfaceLineMarking& RoadSurfaceLineType::getMarkingDetails() const
{
    return m_markingDetails_.value();
}

void RoadSurfaceLineType::setMarkingDetails(const ::nds::lane::roadsurface::RoadSurfaceLineMarking& markingDetails_)
{
    m_markingDetails_ = markingDetails_;
}

void RoadSurfaceLineType::setMarkingDetails(::nds::lane::roadsurface::RoadSurfaceLineMarking&& markingDetails_)
{
    m_markingDetails_ = ::std::move(markingDetails_);
}

bool RoadSurfaceLineType::isMarkingDetailsUsed() const
{
    return (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE);
}

bool RoadSurfaceLineType::isMarkingDetailsSet() const
{
    return m_markingDetails_.hasValue();
}

void RoadSurfaceLineType::resetMarkingDetails()
{
    m_markingDetails_.reset();
}

void RoadSurfaceLineType::initPackingContext(RoadSurfaceLineType::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getPhysicalType(), m_physicalType_);
    ::zserio::initPackingContext(context.getLogicalType(), m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE)
    {
        m_markingDetails_.value().initPackingContext(context.getMarkingDetails());
    }
}

size_t RoadSurfaceLineType::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_physicalType_);
    endBitPosition += ::zserio::bitSizeOf(m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE)
    {
        endBitPosition += m_markingDetails_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLineType::bitSizeOf(RoadSurfaceLineType::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getPhysicalType(), m_physicalType_);
    endBitPosition += ::zserio::bitSizeOf(context.getLogicalType(), m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE)
    {
        endBitPosition += m_markingDetails_.value().bitSizeOf(context.getMarkingDetails(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLineType::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_physicalType_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE)
    {
        endBitPosition = m_markingDetails_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RoadSurfaceLineType::initializeOffsets(RoadSurfaceLineType::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getPhysicalType(), endBitPosition,
        m_physicalType_);
    endBitPosition = ::zserio::initializeOffsets(context.getLogicalType(), endBitPosition,
        m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE)
    {
        endBitPosition = m_markingDetails_.value().initializeOffsets(context.getMarkingDetails(), endBitPosition);
    }

    return endBitPosition;
}

bool RoadSurfaceLineType::operator==(const RoadSurfaceLineType& other) const
{
    if (this != &other)
    {
        return
                (m_physicalType_ == other.m_physicalType_) &&
                (m_logicalType_ == other.m_logicalType_) &&
                (!isMarkingDetailsUsed() ? !other.isMarkingDetailsUsed() : (m_markingDetails_ == other.m_markingDetails_));
    }

    return true;
}

uint32_t RoadSurfaceLineType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_physicalType_);
    result = ::zserio::calcHashCode(result, m_logicalType_);
    if (isMarkingDetailsUsed())
        result = ::zserio::calcHashCode(result, m_markingDetails_);

    return result;
}

void RoadSurfaceLineType::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_physicalType_);
    ::zserio::write(out, m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE)
    {
        m_markingDetails_.value().write(out);
    }
}

void RoadSurfaceLineType::write(RoadSurfaceLineType::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getPhysicalType(), out, m_physicalType_);
    ::zserio::write(context.getLogicalType(), out, m_logicalType_);
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE)
    {
        m_markingDetails_.value().write(context.getMarkingDetails(), out);
    }
}

::nds::lane::roadsurface::RoadSurfaceLinePhysicalType RoadSurfaceLineType::readPhysicalType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>(in);
}

::nds::lane::roadsurface::RoadSurfaceLinePhysicalType RoadSurfaceLineType::readPhysicalType(RoadSurfaceLineType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfaceLinePhysicalType>(context.getPhysicalType(), in);
}
::nds::lane::roadsurface::RoadSurfaceLineLogicalType RoadSurfaceLineType::readLogicalType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>(in);
}

::nds::lane::roadsurface::RoadSurfaceLineLogicalType RoadSurfaceLineType::readLogicalType(RoadSurfaceLineType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfaceLineLogicalType>(context.getLogicalType(), in);
}
::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfaceLineMarking> RoadSurfaceLineType::readMarkingDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfaceLineMarking>(::nds::lane::roadsurface::RoadSurfaceLineMarking(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfaceLineMarking>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfaceLineMarking> RoadSurfaceLineType::readMarkingDetails(RoadSurfaceLineType::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getLogicalType() == ::nds::lane::roadsurface::RoadSurfaceLineLogicalType::MARKING_LINE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfaceLineMarking>(::nds::lane::roadsurface::RoadSurfaceLineMarking(context.getMarkingDetails(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::roadsurface::RoadSurfaceLineMarking>(::zserio::NullOpt);
}

} // namespace roadsurface
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/roadsurface/RoadSurfaceLineMarking.h>

namespace nds
{
namespace lane
{
namespace roadsurface
{

RoadSurfaceLineMarking::RoadSurfaceLineMarking(const allocator_type&) noexcept :
        m_markingType_(::nds::lane::roadsurface::RoadSurfaceLineMarkingType()),
        m_markingColor_(::nds::lane::reference::types::MarkingColor()),
        m_markingMaterial_(::nds::lane::types::MarkingMaterial()),
        m_markingWidth_(::nds::lane::roadsurface::MarkingWidth())
{
}

RoadSurfaceLineMarking::RoadSurfaceLineMarking(::zserio::BitStreamReader& in, const allocator_type&) :
        m_markingType_(readMarkingType(in)),
        m_markingColor_(readMarkingColor(in)),
        m_markingMaterial_(readMarkingMaterial(in)),
        m_markingWidth_(readMarkingWidth(in))
{
}

RoadSurfaceLineMarking::RoadSurfaceLineMarking(RoadSurfaceLineMarking::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_markingType_(readMarkingType(context, in)),
        m_markingColor_(readMarkingColor(context, in)),
        m_markingMaterial_(readMarkingMaterial(context, in)),
        m_markingWidth_(readMarkingWidth(context, in))
{
}

RoadSurfaceLineMarking::RoadSurfaceLineMarking(::zserio::PropagateAllocatorT,
        const RoadSurfaceLineMarking& other, const allocator_type& allocator) :
        m_markingType_(::zserio::allocatorPropagatingCopy(other.m_markingType_, allocator)),
        m_markingColor_(::zserio::allocatorPropagatingCopy(other.m_markingColor_, allocator)),
        m_markingMaterial_(::zserio::allocatorPropagatingCopy(other.m_markingMaterial_, allocator)),
        m_markingWidth_(::zserio::allocatorPropagatingCopy(other.m_markingWidth_, allocator))
{
}

::nds::lane::roadsurface::RoadSurfaceLineMarkingType RoadSurfaceLineMarking::getMarkingType() const
{
    return m_markingType_;
}

void RoadSurfaceLineMarking::setMarkingType(::nds::lane::roadsurface::RoadSurfaceLineMarkingType markingType_)
{
    m_markingType_ = markingType_;
}

::nds::lane::reference::types::MarkingColor RoadSurfaceLineMarking::getMarkingColor() const
{
    return m_markingColor_;
}

void RoadSurfaceLineMarking::setMarkingColor(::nds::lane::reference::types::MarkingColor markingColor_)
{
    m_markingColor_ = markingColor_;
}

::nds::lane::types::MarkingMaterial RoadSurfaceLineMarking::getMarkingMaterial() const
{
    return m_markingMaterial_;
}

void RoadSurfaceLineMarking::setMarkingMaterial(::nds::lane::types::MarkingMaterial markingMaterial_)
{
    m_markingMaterial_ = markingMaterial_;
}

::nds::lane::roadsurface::MarkingWidth RoadSurfaceLineMarking::getMarkingWidth() const
{
    return m_markingWidth_;
}

void RoadSurfaceLineMarking::setMarkingWidth(::nds::lane::roadsurface::MarkingWidth markingWidth_)
{
    m_markingWidth_ = markingWidth_;
}

void RoadSurfaceLineMarking::initPackingContext(RoadSurfaceLineMarking::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getMarkingType(), m_markingType_);
    ::zserio::initPackingContext(context.getMarkingColor(), m_markingColor_);
    ::zserio::initPackingContext(context.getMarkingMaterial(), m_markingMaterial_);
    context.getMarkingWidth().init<::zserio::VarIntNNArrayTraits<::nds::lane::roadsurface::MarkingWidth>>(m_markingWidth_);
}

size_t RoadSurfaceLineMarking::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_markingType_);
    endBitPosition += ::zserio::bitSizeOf(m_markingColor_);
    endBitPosition += ::zserio::bitSizeOf(m_markingMaterial_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_markingWidth_);

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLineMarking::bitSizeOf(RoadSurfaceLineMarking::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getMarkingType(), m_markingType_);
    endBitPosition += ::zserio::bitSizeOf(context.getMarkingColor(), m_markingColor_);
    endBitPosition += ::zserio::bitSizeOf(context.getMarkingMaterial(), m_markingMaterial_);
    endBitPosition += context.getMarkingWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::roadsurface::MarkingWidth>>(m_markingWidth_);

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLineMarking::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_markingType_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_markingColor_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_markingMaterial_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_markingWidth_);

    return endBitPosition;
}

size_t RoadSurfaceLineMarking::initializeOffsets(RoadSurfaceLineMarking::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getMarkingType(), endBitPosition,
        m_markingType_);
    endBitPosition = ::zserio::initializeOffsets(context.getMarkingColor(), endBitPosition,
        m_markingColor_);
    endBitPosition = ::zserio::initializeOffsets(context.getMarkingMaterial(), endBitPosition,
        m_markingMaterial_);
    endBitPosition += context.getMarkingWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::roadsurface::MarkingWidth>>(m_markingWidth_);

    return endBitPosition;
}

bool RoadSurfaceLineMarking::operator==(const RoadSurfaceLineMarking& other) const
{
    if (this != &other)
    {
        return
                (m_markingType_ == other.m_markingType_) &&
                (m_markingColor_ == other.m_markingColor_) &&
                (m_markingMaterial_ == other.m_markingMaterial_) &&
                (m_markingWidth_ == other.m_markingWidth_);
    }

    return true;
}

uint32_t RoadSurfaceLineMarking::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_markingType_);
    result = ::zserio::calcHashCode(result, m_markingColor_);
    result = ::zserio::calcHashCode(result, m_markingMaterial_);
    result = ::zserio::calcHashCode(result, m_markingWidth_);

    return result;
}

void RoadSurfaceLineMarking::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_markingType_);
    ::zserio::write(out, m_markingColor_);
    ::zserio::write(out, m_markingMaterial_);
    out.writeVarUInt32(m_markingWidth_);
}

void RoadSurfaceLineMarking::write(RoadSurfaceLineMarking::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getMarkingType(), out, m_markingType_);
    ::zserio::write(context.getMarkingColor(), out, m_markingColor_);
    ::zserio::write(context.getMarkingMaterial(), out, m_markingMaterial_);
    context.getMarkingWidth().write<::zserio::VarIntNNArrayTraits<::nds::lane::roadsurface::MarkingWidth>>(out, m_markingWidth_);
}

::nds::lane::roadsurface::RoadSurfaceLineMarkingType RoadSurfaceLineMarking::readMarkingType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>(in);
}

::nds::lane::roadsurface::RoadSurfaceLineMarkingType RoadSurfaceLineMarking::readMarkingType(RoadSurfaceLineMarking::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::roadsurface::RoadSurfaceLineMarkingType>(context.getMarkingType(), in);
}
::nds::lane::reference::types::MarkingColor RoadSurfaceLineMarking::readMarkingColor(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::MarkingColor>(in);
}

::nds::lane::reference::types::MarkingColor RoadSurfaceLineMarking::readMarkingColor(RoadSurfaceLineMarking::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::MarkingColor>(context.getMarkingColor(), in);
}
::nds::lane::types::MarkingMaterial RoadSurfaceLineMarking::readMarkingMaterial(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::MarkingMaterial>(in);
}

::nds::lane::types::MarkingMaterial RoadSurfaceLineMarking::readMarkingMaterial(RoadSurfaceLineMarking::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::MarkingMaterial>(context.getMarkingMaterial(), in);
}
::nds::lane::roadsurface::MarkingWidth RoadSurfaceLineMarking::readMarkingWidth(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::roadsurface::MarkingWidth>(in.readVarUInt32());
}

::nds::lane::roadsurface::MarkingWidth RoadSurfaceLineMarking::readMarkingWidth(RoadSurfaceLineMarking::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getMarkingWidth().read<::zserio::VarIntNNArrayTraits<::nds::lane::roadsurface::MarkingWidth>>(in);
}

} // namespace roadsurface
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/roadsurface/RoadSurfaceLaneGroupRelation.h>

namespace nds
{
namespace lane
{
namespace roadsurface
{

RoadSurfaceLaneGroupRelation::RoadSurfaceLaneGroupRelation(const allocator_type& allocator) noexcept :
        m_laneGroupId_(allocator),
        m_hasLaneRelation_(bool()),
        m_laneId_(::zserio::NullOpt),
        m_numSurfaces_(uint32_t()),
        m_relatedSurfaces_(allocator)
{
}

RoadSurfaceLaneGroupRelation::RoadSurfaceLaneGroupRelation(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_laneGroupId_(readLaneGroupId(in, allocator)),
        m_hasLaneRelation_(readHasLaneRelation(in)),
        m_laneId_(readLaneId(in, allocator)),
        m_numSurfaces_(readNumSurfaces(in)),
        m_relatedSurfaces_(readRelatedSurfaces(in, allocator))
{
}

RoadSurfaceLaneGroupRelation::RoadSurfaceLaneGroupRelation(RoadSurfaceLaneGroupRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_laneGroupId_(readLaneGroupId(context, in, allocator)),
        m_hasLaneRelation_(readHasLaneRelation(in)),
        m_laneId_(readLaneId(context, in, allocator)),
        m_numSurfaces_(readNumSurfaces(context, in)),
        m_relatedSurfaces_(readRelatedSurfaces(context, in, allocator))
{
}

RoadSurfaceLaneGroupRelation::RoadSurfaceLaneGroupRelation(::zserio::PropagateAllocatorT,
        const RoadSurfaceLaneGroupRelation& other, const allocator_type& allocator) :
        m_laneGroupId_(::zserio::allocatorPropagatingCopy(other.m_laneGroupId_, allocator)),
        m_hasLaneRelation_(::zserio::allocatorPropagatingCopy(other.m_hasLaneRelation_, allocator)),
        m_laneId_(::zserio::allocatorPropagatingCopy(other.m_laneId_, allocator)),
        m_numSurfaces_(::zserio::allocatorPropagatingCopy(other.m_numSurfaces_, allocator)),
        m_relatedSurfaces_(::zserio::allocatorPropagatingCopy(other.m_relatedSurfaces_, allocator))
{
}

::nds::lane::reference::types::LaneGroupId& RoadSurfaceLaneGroupRelation::getLaneGroupId()
{
    return m_laneGroupId_;
}

const ::nds::lane::reference::types::LaneGroupId& RoadSurfaceLaneGroupRelation::getLaneGroupId() const
{
    return m_laneGroupId_;
}

void RoadSurfaceLaneGroupRelation::setLaneGroupId(const ::nds::lane::reference::types::LaneGroupId& laneGroupId_)
{
    m_laneGroupId_ = laneGroupId_;
}

void RoadSurfaceLaneGroupRelation::setLaneGroupId(::nds::lane::reference::types::LaneGroupId&& laneGroupId_)
{
    m_laneGroupId_ = ::std::move(laneGroupId_);
}

bool RoadSurfaceLaneGroupRelation::getHasLaneRelation() const
{
    return m_hasLaneRelation_;
}

void RoadSurfaceLaneGroupRelation::setHasLaneRelation(bool hasLaneRelation_)
{
    m_hasLaneRelation_ = hasLaneRelation_;
}

::zserio::vector<::nds::lane::reference::types::LaneId>& RoadSurfaceLaneGroupRelation::getLaneId()
{
    return m_laneId_.value().getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneId>& RoadSurfaceLaneGroupRelation::getLaneId() const
{
    return m_laneId_.value().getRawArray();
}

void RoadSurfaceLaneGroupRelation::setLaneId(const ::zserio::vector<::nds::lane::reference::types::LaneId>& laneId_)
{
    m_laneId_ = ZserioArrayType_laneId(laneId_);
}

void RoadSurfaceLaneGroupRelation::setLaneId(::zserio::vector<::nds::lane::reference::types::LaneId>&& laneId_)
{
    m_laneId_ = ZserioArrayType_laneId(std::move(laneId_));
}

bool RoadSurfaceLaneGroupRelation::isLaneIdUsed() const
{
    return (getHasLaneRelation());
}

bool RoadSurfaceLaneGroupRelation::isLaneIdSet() const
{
    return m_laneId_.hasValue();
}

void RoadSurfaceLaneGroupRelation::resetLaneId()
{
    m_laneId_.reset();
}

uint32_t RoadSurfaceLaneGroupRelation::getNumSurfaces() const
{
    return m_numSurfaces_;
}

void RoadSurfaceLaneGroupRelation::setNumSurfaces(uint32_t numSurfaces_)
{
    m_numSurfaces_ = numSurfaces_;
}

::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& RoadSurfaceLaneGroupRelation::getRelatedSurfaces()
{
    return m_relatedSurfaces_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& RoadSurfaceLaneGroupRelation::getRelatedSurfaces() const
{
    return m_relatedSurfaces_.getRawArray();
}

void RoadSurfaceLaneGroupRelation::setRelatedSurfaces(const ::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& relatedSurfaces_)
{
    m_relatedSurfaces_ = ZserioArrayType_relatedSurfaces(relatedSurfaces_);
}

void RoadSurfaceLaneGroupRelation::setRelatedSurfaces(::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>&& relatedSurfaces_)
{
    m_relatedSurfaces_ = ZserioArrayType_relatedSurfaces(std::move(relatedSurfaces_));
}

void RoadSurfaceLaneGroupRelation::initPackingContext(RoadSurfaceLaneGroupRelation::ZserioPackingContext& context) const
{
    m_laneGroupId_.initPackingContext(context.getLaneGroupId());
    context.getNumSurfaces().init<::zserio::VarSizeArrayTraits>(m_numSurfaces_);
}

size_t RoadSurfaceLaneGroupRelation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneGroupId_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasLaneRelation())
    {
        endBitPosition += m_laneId_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numSurfaces_);
    endBitPosition += m_relatedSurfaces_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLaneGroupRelation::bitSizeOf(RoadSurfaceLaneGroupRelation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneGroupId_.bitSizeOf(context.getLaneGroupId(), endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasLaneRelation())
    {
        endBitPosition += m_laneId_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += context.getNumSurfaces().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numSurfaces_);
    endBitPosition += m_relatedSurfaces_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLaneGroupRelation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneGroupId_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasLaneRelation())
    {
        endBitPosition = m_laneId_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numSurfaces_);
    endBitPosition = m_relatedSurfaces_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RoadSurfaceLaneGroupRelation::initializeOffsets(RoadSurfaceLaneGroupRelation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneGroupId_.initializeOffsets(context.getLaneGroupId(), endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasLaneRelation())
    {
        endBitPosition = m_laneId_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition += context.getNumSurfaces().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numSurfaces_);
    endBitPosition = m_relatedSurfaces_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoadSurfaceLaneGroupRelation::operator==(const RoadSurfaceLaneGroupRelation& other) const
{
    if (this != &other)
    {
        return
                (m_laneGroupId_ == other.m_laneGroupId_) &&
                (m_hasLaneRelation_ == other.m_hasLaneRelation_) &&
                (!isLaneIdUsed() ? !other.isLaneIdUsed() : (m_laneId_ == other.m_laneId_)) &&
                (m_numSurfaces_ == other.m_numSurfaces_) &&
                (m_relatedSurfaces_ == other.m_relatedSurfaces_);
    }

    return true;
}

uint32_t RoadSurfaceLaneGroupRelation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_laneGroupId_);
    result = ::zserio::calcHashCode(result, m_hasLaneRelation_);
    if (isLaneIdUsed())
        result = ::zserio::calcHashCode(result, m_laneId_);
    result = ::zserio::calcHashCode(result, m_numSurfaces_);
    result = ::zserio::calcHashCode(result, m_relatedSurfaces_);

    return result;
}

void RoadSurfaceLaneGroupRelation::write(::zserio::BitStreamWriter& out) const
{
    m_laneGroupId_.write(out);

    out.writeBool(m_hasLaneRelation_);

    if (getHasLaneRelation())
    {
        m_laneId_.value().write(*this, out);
    }

    out.writeVarSize(m_numSurfaces_);

    // check array length
    if (m_relatedSurfaces_.getRawArray().size() != static_cast<size_t>(getNumSurfaces()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadSurfaceLaneGroupRelation.relatedSurfaces: ") <<
                m_relatedSurfaces_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSurfaces()) << "!";
    }
    m_relatedSurfaces_.write(*this, out);
}

void RoadSurfaceLaneGroupRelation::write(RoadSurfaceLaneGroupRelation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_laneGroupId_.write(context.getLaneGroupId(), out);

    out.writeBool(m_hasLaneRelation_);

    if (getHasLaneRelation())
    {
        m_laneId_.value().writePacked(*this, out);
    }

    context.getNumSurfaces().write<::zserio::VarSizeArrayTraits>(out, m_numSurfaces_);

    // check array length
    if (m_relatedSurfaces_.getRawArray().size() != static_cast<size_t>(getNumSurfaces()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadSurfaceLaneGroupRelation.relatedSurfaces: ") <<
                m_relatedSurfaces_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSurfaces()) << "!";
    }
    m_relatedSurfaces_.writePacked(*this, out);
}

void RoadSurfaceLaneGroupRelation::ZserioElementFactory_laneId::create(RoadSurfaceLaneGroupRelation&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoadSurfaceLaneGroupRelation::ZserioElementFactory_laneId::create(RoadSurfaceLaneGroupRelation&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneId>& array,
        ::nds::lane::reference::types::LaneId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoadSurfaceLaneGroupRelation::ZserioElementFactory_relatedSurfaces::create(RoadSurfaceLaneGroupRelation&        ,
        ::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoadSurfaceLaneGroupRelation::ZserioElementFactory_relatedSurfaces::create(RoadSurfaceLaneGroupRelation&        ,
        ::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& array,
        ::nds::lane::reference::types::RoadSurfaceId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::lane::reference::types::LaneGroupId RoadSurfaceLaneGroupRelation::readLaneGroupId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupId(in, allocator);
}

::nds::lane::reference::types::LaneGroupId RoadSurfaceLaneGroupRelation::readLaneGroupId(RoadSurfaceLaneGroupRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupId(context.getLaneGroupId(), in, allocator);
}
bool RoadSurfaceLaneGroupRelation::readHasLaneRelation(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<RoadSurfaceLaneGroupRelation::ZserioArrayType_laneId> RoadSurfaceLaneGroupRelation::readLaneId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasLaneRelation())
    {
        ZserioArrayType_laneId readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneId>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoadSurfaceLaneGroupRelation::ZserioArrayType_laneId> RoadSurfaceLaneGroupRelation::readLaneId(RoadSurfaceLaneGroupRelation::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasLaneRelation())
    {
        ZserioArrayType_laneId readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneId>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneId>(::zserio::NullOpt);
}
uint32_t RoadSurfaceLaneGroupRelation::readNumSurfaces(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t RoadSurfaceLaneGroupRelation::readNumSurfaces(RoadSurfaceLaneGroupRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumSurfaces().read<::zserio::VarSizeArrayTraits>(in);
}
RoadSurfaceLaneGroupRelation::ZserioArrayType_relatedSurfaces RoadSurfaceLaneGroupRelation::readRelatedSurfaces(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_relatedSurfaces readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumSurfaces()));

    return readField;
}

RoadSurfaceLaneGroupRelation::ZserioArrayType_relatedSurfaces RoadSurfaceLaneGroupRelation::readRelatedSurfaces(RoadSurfaceLaneGroupRelation::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_relatedSurfaces readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumSurfaces()));

    return readField;
}

} // namespace roadsurface
} // namespace lane
} // namespace nds
