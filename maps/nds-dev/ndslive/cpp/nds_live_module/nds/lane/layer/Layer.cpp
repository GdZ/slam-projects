/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/layer/LaneLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace lane
{
namespace layer
{

LaneLayer::LaneLayer(const allocator_type& allocator) noexcept :
        m_boundaryDefinitions_(allocator),
        m_boundaryList_(allocator),
        m_laneGroupList_(allocator)
{
}

LaneLayer::LaneLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_boundaryDefinitions_(readBoundaryDefinitions(in, allocator)),
        m_boundaryList_(readBoundaryList(in, allocator)),
        m_laneGroupList_(readLaneGroupList(in, allocator))
{
}

LaneLayer::LaneLayer(LaneLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_boundaryDefinitions_(readBoundaryDefinitions(context, in, allocator)),
        m_boundaryList_(readBoundaryList(context, in, allocator)),
        m_laneGroupList_(readLaneGroupList(context, in, allocator))
{
}

LaneLayer::LaneLayer(::zserio::PropagateAllocatorT,
        const LaneLayer& other, const allocator_type& allocator) :
        m_boundaryDefinitions_(::zserio::allocatorPropagatingCopy(other.m_boundaryDefinitions_, allocator)),
        m_boundaryList_(::zserio::allocatorPropagatingCopy(other.m_boundaryList_, allocator)),
        m_laneGroupList_(::zserio::allocatorPropagatingCopy(other.m_laneGroupList_, allocator))
{
}

void LaneLayer::initializeChildren()
{
    m_boundaryDefinitions_.initializeChildren();
    m_laneGroupList_.initializeElements(*this);
}

::nds::lane::boundaries::BoundaryElementDefinitions& LaneLayer::getBoundaryDefinitions()
{
    return m_boundaryDefinitions_;
}

const ::nds::lane::boundaries::BoundaryElementDefinitions& LaneLayer::getBoundaryDefinitions() const
{
    return m_boundaryDefinitions_;
}

void LaneLayer::setBoundaryDefinitions(const ::nds::lane::boundaries::BoundaryElementDefinitions& boundaryDefinitions_)
{
    m_boundaryDefinitions_ = boundaryDefinitions_;
}

void LaneLayer::setBoundaryDefinitions(::nds::lane::boundaries::BoundaryElementDefinitions&& boundaryDefinitions_)
{
    m_boundaryDefinitions_ = ::std::move(boundaryDefinitions_);
}

::zserio::vector<::nds::lane::boundaries::Boundary>& LaneLayer::getBoundaryList()
{
    return m_boundaryList_.getRawArray();
}

const ::zserio::vector<::nds::lane::boundaries::Boundary>& LaneLayer::getBoundaryList() const
{
    return m_boundaryList_.getRawArray();
}

void LaneLayer::setBoundaryList(const ::zserio::vector<::nds::lane::boundaries::Boundary>& boundaryList_)
{
    m_boundaryList_ = ZserioArrayType_boundaryList(boundaryList_);
}

void LaneLayer::setBoundaryList(::zserio::vector<::nds::lane::boundaries::Boundary>&& boundaryList_)
{
    m_boundaryList_ = ZserioArrayType_boundaryList(std::move(boundaryList_));
}

::zserio::vector<::nds::lane::lanegroups::LaneGroup>& LaneLayer::getLaneGroupList()
{
    return m_laneGroupList_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanegroups::LaneGroup>& LaneLayer::getLaneGroupList() const
{
    return m_laneGroupList_.getRawArray();
}

void LaneLayer::setLaneGroupList(const ::zserio::vector<::nds::lane::lanegroups::LaneGroup>& laneGroupList_)
{
    m_laneGroupList_ = ZserioArrayType_laneGroupList(laneGroupList_);
}

void LaneLayer::setLaneGroupList(::zserio::vector<::nds::lane::lanegroups::LaneGroup>&& laneGroupList_)
{
    m_laneGroupList_ = ZserioArrayType_laneGroupList(std::move(laneGroupList_));
}

::nds::system::types::LayerType LaneLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::FEATURE);
}

void LaneLayer::initPackingContext(LaneLayer::ZserioPackingContext& context) const
{
    m_boundaryDefinitions_.initPackingContext(context.getBoundaryDefinitions());
}

size_t LaneLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_boundaryDefinitions_.bitSizeOf(endBitPosition);
    endBitPosition += m_boundaryList_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_laneGroupList_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLayer::bitSizeOf(LaneLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_boundaryDefinitions_.bitSizeOf(context.getBoundaryDefinitions(), endBitPosition);
    endBitPosition += m_boundaryList_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_laneGroupList_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_boundaryDefinitions_.initializeOffsets(endBitPosition);
    endBitPosition = m_boundaryList_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_laneGroupList_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LaneLayer::initializeOffsets(LaneLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_boundaryDefinitions_.initializeOffsets(context.getBoundaryDefinitions(), endBitPosition);
    endBitPosition = m_boundaryList_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_laneGroupList_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LaneLayer::operator==(const LaneLayer& other) const
{
    if (this != &other)
    {
        return
                (m_boundaryDefinitions_ == other.m_boundaryDefinitions_) &&
                (m_boundaryList_ == other.m_boundaryList_) &&
                (m_laneGroupList_ == other.m_laneGroupList_);
    }

    return true;
}

uint32_t LaneLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_boundaryDefinitions_);
    result = ::zserio::calcHashCode(result, m_boundaryList_);
    result = ::zserio::calcHashCode(result, m_laneGroupList_);

    return result;
}

void LaneLayer::write(::zserio::BitStreamWriter& out) const
{
    m_boundaryDefinitions_.write(out);
    m_boundaryList_.writePacked(*this, out);
    m_laneGroupList_.writePacked(*this, out);
}

void LaneLayer::write(LaneLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_boundaryDefinitions_.write(context.getBoundaryDefinitions(), out);
    m_boundaryList_.writePacked(*this, out);
    m_laneGroupList_.writePacked(*this, out);
}

void LaneLayer::ZserioElementFactory_boundaryList::create(LaneLayer&        ,
        ::zserio::vector<::nds::lane::boundaries::Boundary>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneLayer::ZserioElementFactory_boundaryList::create(LaneLayer&        ,
        ::zserio::vector<::nds::lane::boundaries::Boundary>& array,
        ::nds::lane::boundaries::Boundary::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LaneLayer::ZserioArrayExpressions_laneGroupList::initializeElement(LaneLayer&,
        ::nds::lane::lanegroups::LaneGroup& element, size_t)
{
    element.initializeChildren();
}

void LaneLayer::ZserioElementFactory_laneGroupList::create(LaneLayer&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroup>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneLayer::ZserioElementFactory_laneGroupList::create(LaneLayer&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroup>& array,
        ::nds::lane::lanegroups::LaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::lane::boundaries::BoundaryElementDefinitions LaneLayer::readBoundaryDefinitions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryElementDefinitions(in, allocator);
}

::nds::lane::boundaries::BoundaryElementDefinitions LaneLayer::readBoundaryDefinitions(LaneLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryElementDefinitions(context.getBoundaryDefinitions(), in, allocator);
}
LaneLayer::ZserioArrayType_boundaryList LaneLayer::readBoundaryList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_boundaryList readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

LaneLayer::ZserioArrayType_boundaryList LaneLayer::readBoundaryList(LaneLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_boundaryList readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
LaneLayer::ZserioArrayType_laneGroupList LaneLayer::readLaneGroupList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_laneGroupList readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

LaneLayer::ZserioArrayType_laneGroupList LaneLayer::readLaneGroupList(LaneLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_laneGroupList readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace layer
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/layer/LaneGeometryLayer.h>
#include <nds/core/geometry/GeometryLayerType.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace lane
{
namespace layer
{

LaneGeometryLayer::LaneGeometryLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_centerLineGeometryLayer_(allocator),
        m_boundaryGeometryLayer_(allocator)
{
}

LaneGeometryLayer::LaneGeometryLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_centerLineGeometryLayer_(readCenterLineGeometryLayer(in, allocator)),
        m_boundaryGeometryLayer_(readBoundaryGeometryLayer(in, allocator))
{
}

LaneGeometryLayer::LaneGeometryLayer(LaneGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_centerLineGeometryLayer_(readCenterLineGeometryLayer(context, in, allocator)),
        m_boundaryGeometryLayer_(readBoundaryGeometryLayer(context, in, allocator))
{
}

LaneGeometryLayer::LaneGeometryLayer(const LaneGeometryLayer& other) :
        m_centerLineGeometryLayer_(other.m_centerLineGeometryLayer_),
        m_boundaryGeometryLayer_(other.m_boundaryGeometryLayer_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneGeometryLayer& LaneGeometryLayer::operator=(const LaneGeometryLayer& other)
{
    m_centerLineGeometryLayer_ = other.m_centerLineGeometryLayer_;
    m_boundaryGeometryLayer_ = other.m_boundaryGeometryLayer_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneGeometryLayer::LaneGeometryLayer(LaneGeometryLayer&& other) :
        m_centerLineGeometryLayer_(::std::move(other.m_centerLineGeometryLayer_)),
        m_boundaryGeometryLayer_(::std::move(other.m_boundaryGeometryLayer_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneGeometryLayer& LaneGeometryLayer::operator=(LaneGeometryLayer&& other)
{
    m_centerLineGeometryLayer_ = ::std::move(other.m_centerLineGeometryLayer_);
    m_boundaryGeometryLayer_ = ::std::move(other.m_boundaryGeometryLayer_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneGeometryLayer::LaneGeometryLayer(::zserio::PropagateAllocatorT,
        const LaneGeometryLayer& other, const allocator_type& allocator) :
        m_centerLineGeometryLayer_(::zserio::allocatorPropagatingCopy(other.m_centerLineGeometryLayer_, allocator)),
        m_boundaryGeometryLayer_(::zserio::allocatorPropagatingCopy(other.m_boundaryGeometryLayer_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneGeometryLayer::initializeChildren()
{
    m_centerLineGeometryLayer_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(true), static_cast<bool>(false));
    m_boundaryGeometryLayer_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(true), static_cast<bool>(false));

    m_areChildrenInitialized = true;
}

::nds::lane::instantiations::CenterLineGeometryLayer& LaneGeometryLayer::getCenterLineGeometryLayer()
{
    return m_centerLineGeometryLayer_;
}

const ::nds::lane::instantiations::CenterLineGeometryLayer& LaneGeometryLayer::getCenterLineGeometryLayer() const
{
    return m_centerLineGeometryLayer_;
}

void LaneGeometryLayer::setCenterLineGeometryLayer(const ::nds::lane::instantiations::CenterLineGeometryLayer& centerLineGeometryLayer_)
{
    m_centerLineGeometryLayer_ = centerLineGeometryLayer_;
}

void LaneGeometryLayer::setCenterLineGeometryLayer(::nds::lane::instantiations::CenterLineGeometryLayer&& centerLineGeometryLayer_)
{
    m_centerLineGeometryLayer_ = ::std::move(centerLineGeometryLayer_);
}

::nds::lane::instantiations::BoundaryGeometryLayer& LaneGeometryLayer::getBoundaryGeometryLayer()
{
    return m_boundaryGeometryLayer_;
}

const ::nds::lane::instantiations::BoundaryGeometryLayer& LaneGeometryLayer::getBoundaryGeometryLayer() const
{
    return m_boundaryGeometryLayer_;
}

void LaneGeometryLayer::setBoundaryGeometryLayer(const ::nds::lane::instantiations::BoundaryGeometryLayer& boundaryGeometryLayer_)
{
    m_boundaryGeometryLayer_ = boundaryGeometryLayer_;
}

void LaneGeometryLayer::setBoundaryGeometryLayer(::nds::lane::instantiations::BoundaryGeometryLayer&& boundaryGeometryLayer_)
{
    m_boundaryGeometryLayer_ = ::std::move(boundaryGeometryLayer_);
}

::nds::system::types::LayerType LaneGeometryLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::GEOMETRY);
}

void LaneGeometryLayer::initPackingContext(LaneGeometryLayer::ZserioPackingContext& context) const
{
    m_centerLineGeometryLayer_.initPackingContext(context.getCenterLineGeometryLayer());
    m_boundaryGeometryLayer_.initPackingContext(context.getBoundaryGeometryLayer());
}

size_t LaneGeometryLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_centerLineGeometryLayer_.bitSizeOf(endBitPosition);
    endBitPosition += m_boundaryGeometryLayer_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGeometryLayer::bitSizeOf(LaneGeometryLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_centerLineGeometryLayer_.bitSizeOf(context.getCenterLineGeometryLayer(), endBitPosition);
    endBitPosition += m_boundaryGeometryLayer_.bitSizeOf(context.getBoundaryGeometryLayer(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGeometryLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_centerLineGeometryLayer_.initializeOffsets(endBitPosition);
    endBitPosition = m_boundaryGeometryLayer_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneGeometryLayer::initializeOffsets(LaneGeometryLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_centerLineGeometryLayer_.initializeOffsets(context.getCenterLineGeometryLayer(), endBitPosition);
    endBitPosition = m_boundaryGeometryLayer_.initializeOffsets(context.getBoundaryGeometryLayer(), endBitPosition);

    return endBitPosition;
}

bool LaneGeometryLayer::operator==(const LaneGeometryLayer& other) const
{
    if (this != &other)
    {
        return
                (m_centerLineGeometryLayer_ == other.m_centerLineGeometryLayer_) &&
                (m_boundaryGeometryLayer_ == other.m_boundaryGeometryLayer_);
    }

    return true;
}

uint32_t LaneGeometryLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_centerLineGeometryLayer_);
    result = ::zserio::calcHashCode(result, m_boundaryGeometryLayer_);

    return result;
}

void LaneGeometryLayer::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_centerLineGeometryLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LaneGeometryLayer.centerLineGeometryLayer: ") <<
                m_centerLineGeometryLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
    }
    if (m_centerLineGeometryLayer_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LaneGeometryLayer.centerLineGeometryLayer: ") <<
                m_centerLineGeometryLayer_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_centerLineGeometryLayer_.getHasTypes() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LaneGeometryLayer.centerLineGeometryLayer: ") <<
                m_centerLineGeometryLayer_.getHasTypes() << " != " << static_cast<bool>(false) << "!";
    }
    m_centerLineGeometryLayer_.write(out);

    // check parameters
    if (m_boundaryGeometryLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LaneGeometryLayer.boundaryGeometryLayer: ") <<
                m_boundaryGeometryLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
    }
    if (m_boundaryGeometryLayer_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LaneGeometryLayer.boundaryGeometryLayer: ") <<
                m_boundaryGeometryLayer_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_boundaryGeometryLayer_.getHasTypes() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LaneGeometryLayer.boundaryGeometryLayer: ") <<
                m_boundaryGeometryLayer_.getHasTypes() << " != " << static_cast<bool>(false) << "!";
    }
    m_boundaryGeometryLayer_.write(out);
}

void LaneGeometryLayer::write(LaneGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_centerLineGeometryLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LaneGeometryLayer.centerLineGeometryLayer: ") <<
                m_centerLineGeometryLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
    }
    if (m_centerLineGeometryLayer_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LaneGeometryLayer.centerLineGeometryLayer: ") <<
                m_centerLineGeometryLayer_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_centerLineGeometryLayer_.getHasTypes() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LaneGeometryLayer.centerLineGeometryLayer: ") <<
                m_centerLineGeometryLayer_.getHasTypes() << " != " << static_cast<bool>(false) << "!";
    }
    m_centerLineGeometryLayer_.write(context.getCenterLineGeometryLayer(), out);

    // check parameters
    if (m_boundaryGeometryLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LaneGeometryLayer.boundaryGeometryLayer: ") <<
                m_boundaryGeometryLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
    }
    if (m_boundaryGeometryLayer_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LaneGeometryLayer.boundaryGeometryLayer: ") <<
                m_boundaryGeometryLayer_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_boundaryGeometryLayer_.getHasTypes() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LaneGeometryLayer.boundaryGeometryLayer: ") <<
                m_boundaryGeometryLayer_.getHasTypes() << " != " << static_cast<bool>(false) << "!";
    }
    m_boundaryGeometryLayer_.write(context.getBoundaryGeometryLayer(), out);
}

::nds::lane::instantiations::CenterLineGeometryLayer LaneGeometryLayer::readCenterLineGeometryLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::instantiations::CenterLineGeometryLayer(in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(true), static_cast<bool>(false), allocator);
}

::nds::lane::instantiations::CenterLineGeometryLayer LaneGeometryLayer::readCenterLineGeometryLayer(LaneGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::instantiations::CenterLineGeometryLayer(context.getCenterLineGeometryLayer(), in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(true), static_cast<bool>(false), allocator);
}
::nds::lane::instantiations::BoundaryGeometryLayer LaneGeometryLayer::readBoundaryGeometryLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::instantiations::BoundaryGeometryLayer(in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(true), static_cast<bool>(false), allocator);
}

::nds::lane::instantiations::BoundaryGeometryLayer LaneGeometryLayer::readBoundaryGeometryLayer(LaneGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::instantiations::BoundaryGeometryLayer(context.getBoundaryGeometryLayer(), in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(true), static_cast<bool>(false), allocator);
}

} // namespace layer
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/layer/RoadSurfaceLayer.h>
#include <nds/core/geometry/GeometryLayerType.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace lane
{
namespace layer
{

RoadSurfaceLayer::RoadSurfaceLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_roadSurfacePolygonLayer_(allocator),
        m_roadSurfaceLinesLayer_(allocator),
        m_lanegroupRelations_(allocator)
{
}

RoadSurfaceLayer::RoadSurfaceLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_roadSurfacePolygonLayer_(readRoadSurfacePolygonLayer(in, allocator)),
        m_roadSurfaceLinesLayer_(readRoadSurfaceLinesLayer(in, allocator)),
        m_lanegroupRelations_(readLanegroupRelations(in, allocator))
{
}

RoadSurfaceLayer::RoadSurfaceLayer(RoadSurfaceLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_roadSurfacePolygonLayer_(readRoadSurfacePolygonLayer(context, in, allocator)),
        m_roadSurfaceLinesLayer_(readRoadSurfaceLinesLayer(context, in, allocator)),
        m_lanegroupRelations_(readLanegroupRelations(context, in, allocator))
{
}

RoadSurfaceLayer::RoadSurfaceLayer(const RoadSurfaceLayer& other) :
        m_roadSurfacePolygonLayer_(other.m_roadSurfacePolygonLayer_),
        m_roadSurfaceLinesLayer_(other.m_roadSurfaceLinesLayer_),
        m_lanegroupRelations_(other.m_lanegroupRelations_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadSurfaceLayer& RoadSurfaceLayer::operator=(const RoadSurfaceLayer& other)
{
    m_roadSurfacePolygonLayer_ = other.m_roadSurfacePolygonLayer_;
    m_roadSurfaceLinesLayer_ = other.m_roadSurfaceLinesLayer_;
    m_lanegroupRelations_ = other.m_lanegroupRelations_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadSurfaceLayer::RoadSurfaceLayer(RoadSurfaceLayer&& other) :
        m_roadSurfacePolygonLayer_(::std::move(other.m_roadSurfacePolygonLayer_)),
        m_roadSurfaceLinesLayer_(::std::move(other.m_roadSurfaceLinesLayer_)),
        m_lanegroupRelations_(::std::move(other.m_lanegroupRelations_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadSurfaceLayer& RoadSurfaceLayer::operator=(RoadSurfaceLayer&& other)
{
    m_roadSurfacePolygonLayer_ = ::std::move(other.m_roadSurfacePolygonLayer_);
    m_roadSurfaceLinesLayer_ = ::std::move(other.m_roadSurfaceLinesLayer_);
    m_lanegroupRelations_ = ::std::move(other.m_lanegroupRelations_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadSurfaceLayer::RoadSurfaceLayer(::zserio::PropagateAllocatorT,
        const RoadSurfaceLayer& other, const allocator_type& allocator) :
        m_roadSurfacePolygonLayer_(::zserio::allocatorPropagatingCopy(other.m_roadSurfacePolygonLayer_, allocator)),
        m_roadSurfaceLinesLayer_(::zserio::allocatorPropagatingCopy(other.m_roadSurfaceLinesLayer_, allocator)),
        m_lanegroupRelations_(::zserio::allocatorPropagatingCopy(other.m_lanegroupRelations_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadSurfaceLayer::initializeChildren()
{
    m_roadSurfacePolygonLayer_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D), static_cast<bool>(true), static_cast<bool>(true));
    m_roadSurfaceLinesLayer_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(true), static_cast<bool>(true));

    m_areChildrenInitialized = true;
}

::nds::lane::instantiations::RoadSurfacePolygonGeometryLayer& RoadSurfaceLayer::getRoadSurfacePolygonLayer()
{
    return m_roadSurfacePolygonLayer_;
}

const ::nds::lane::instantiations::RoadSurfacePolygonGeometryLayer& RoadSurfaceLayer::getRoadSurfacePolygonLayer() const
{
    return m_roadSurfacePolygonLayer_;
}

void RoadSurfaceLayer::setRoadSurfacePolygonLayer(const ::nds::lane::instantiations::RoadSurfacePolygonGeometryLayer& roadSurfacePolygonLayer_)
{
    m_roadSurfacePolygonLayer_ = roadSurfacePolygonLayer_;
}

void RoadSurfaceLayer::setRoadSurfacePolygonLayer(::nds::lane::instantiations::RoadSurfacePolygonGeometryLayer&& roadSurfacePolygonLayer_)
{
    m_roadSurfacePolygonLayer_ = ::std::move(roadSurfacePolygonLayer_);
}

::nds::lane::instantiations::RoadSurfaceLineGeometryLayer& RoadSurfaceLayer::getRoadSurfaceLinesLayer()
{
    return m_roadSurfaceLinesLayer_;
}

const ::nds::lane::instantiations::RoadSurfaceLineGeometryLayer& RoadSurfaceLayer::getRoadSurfaceLinesLayer() const
{
    return m_roadSurfaceLinesLayer_;
}

void RoadSurfaceLayer::setRoadSurfaceLinesLayer(const ::nds::lane::instantiations::RoadSurfaceLineGeometryLayer& roadSurfaceLinesLayer_)
{
    m_roadSurfaceLinesLayer_ = roadSurfaceLinesLayer_;
}

void RoadSurfaceLayer::setRoadSurfaceLinesLayer(::nds::lane::instantiations::RoadSurfaceLineGeometryLayer&& roadSurfaceLinesLayer_)
{
    m_roadSurfaceLinesLayer_ = ::std::move(roadSurfaceLinesLayer_);
}

::zserio::vector<::nds::lane::roadsurface::RoadSurfaceLaneGroupRelation>& RoadSurfaceLayer::getLanegroupRelations()
{
    return m_lanegroupRelations_.getRawArray();
}

const ::zserio::vector<::nds::lane::roadsurface::RoadSurfaceLaneGroupRelation>& RoadSurfaceLayer::getLanegroupRelations() const
{
    return m_lanegroupRelations_.getRawArray();
}

void RoadSurfaceLayer::setLanegroupRelations(const ::zserio::vector<::nds::lane::roadsurface::RoadSurfaceLaneGroupRelation>& lanegroupRelations_)
{
    m_lanegroupRelations_ = ZserioArrayType_lanegroupRelations(lanegroupRelations_);
}

void RoadSurfaceLayer::setLanegroupRelations(::zserio::vector<::nds::lane::roadsurface::RoadSurfaceLaneGroupRelation>&& lanegroupRelations_)
{
    m_lanegroupRelations_ = ZserioArrayType_lanegroupRelations(std::move(lanegroupRelations_));
}

::nds::system::types::LayerType RoadSurfaceLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::GEOMETRY);
}

void RoadSurfaceLayer::initPackingContext(RoadSurfaceLayer::ZserioPackingContext& context) const
{
    m_roadSurfacePolygonLayer_.initPackingContext(context.getRoadSurfacePolygonLayer());
    m_roadSurfaceLinesLayer_.initPackingContext(context.getRoadSurfaceLinesLayer());
}

size_t RoadSurfaceLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roadSurfacePolygonLayer_.bitSizeOf(endBitPosition);
    endBitPosition += m_roadSurfaceLinesLayer_.bitSizeOf(endBitPosition);
    endBitPosition += m_lanegroupRelations_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLayer::bitSizeOf(RoadSurfaceLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roadSurfacePolygonLayer_.bitSizeOf(context.getRoadSurfacePolygonLayer(), endBitPosition);
    endBitPosition += m_roadSurfaceLinesLayer_.bitSizeOf(context.getRoadSurfaceLinesLayer(), endBitPosition);
    endBitPosition += m_lanegroupRelations_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roadSurfacePolygonLayer_.initializeOffsets(endBitPosition);
    endBitPosition = m_roadSurfaceLinesLayer_.initializeOffsets(endBitPosition);
    endBitPosition = m_lanegroupRelations_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoadSurfaceLayer::initializeOffsets(RoadSurfaceLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roadSurfacePolygonLayer_.initializeOffsets(context.getRoadSurfacePolygonLayer(), endBitPosition);
    endBitPosition = m_roadSurfaceLinesLayer_.initializeOffsets(context.getRoadSurfaceLinesLayer(), endBitPosition);
    endBitPosition = m_lanegroupRelations_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoadSurfaceLayer::operator==(const RoadSurfaceLayer& other) const
{
    if (this != &other)
    {
        return
                (m_roadSurfacePolygonLayer_ == other.m_roadSurfacePolygonLayer_) &&
                (m_roadSurfaceLinesLayer_ == other.m_roadSurfaceLinesLayer_) &&
                (m_lanegroupRelations_ == other.m_lanegroupRelations_);
    }

    return true;
}

uint32_t RoadSurfaceLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_roadSurfacePolygonLayer_);
    result = ::zserio::calcHashCode(result, m_roadSurfaceLinesLayer_);
    result = ::zserio::calcHashCode(result, m_lanegroupRelations_);

    return result;
}

void RoadSurfaceLayer::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_roadSurfacePolygonLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoadSurfaceLayer.roadSurfacePolygonLayer: ") <<
                m_roadSurfacePolygonLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D) << "!";
    }
    if (m_roadSurfacePolygonLayer_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field RoadSurfaceLayer.roadSurfacePolygonLayer: ") <<
                m_roadSurfacePolygonLayer_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_roadSurfacePolygonLayer_.getHasTypes() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field RoadSurfaceLayer.roadSurfacePolygonLayer: ") <<
                m_roadSurfacePolygonLayer_.getHasTypes() << " != " << static_cast<bool>(true) << "!";
    }
    m_roadSurfacePolygonLayer_.write(out);

    // check parameters
    if (m_roadSurfaceLinesLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoadSurfaceLayer.roadSurfaceLinesLayer: ") <<
                m_roadSurfaceLinesLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
    }
    if (m_roadSurfaceLinesLayer_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field RoadSurfaceLayer.roadSurfaceLinesLayer: ") <<
                m_roadSurfaceLinesLayer_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_roadSurfaceLinesLayer_.getHasTypes() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field RoadSurfaceLayer.roadSurfaceLinesLayer: ") <<
                m_roadSurfaceLinesLayer_.getHasTypes() << " != " << static_cast<bool>(true) << "!";
    }
    m_roadSurfaceLinesLayer_.write(out);

    m_lanegroupRelations_.writePacked(*this, out);
}

void RoadSurfaceLayer::write(RoadSurfaceLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_roadSurfacePolygonLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoadSurfaceLayer.roadSurfacePolygonLayer: ") <<
                m_roadSurfacePolygonLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D) << "!";
    }
    if (m_roadSurfacePolygonLayer_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field RoadSurfaceLayer.roadSurfacePolygonLayer: ") <<
                m_roadSurfacePolygonLayer_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_roadSurfacePolygonLayer_.getHasTypes() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field RoadSurfaceLayer.roadSurfacePolygonLayer: ") <<
                m_roadSurfacePolygonLayer_.getHasTypes() << " != " << static_cast<bool>(true) << "!";
    }
    m_roadSurfacePolygonLayer_.write(context.getRoadSurfacePolygonLayer(), out);

    // check parameters
    if (m_roadSurfaceLinesLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoadSurfaceLayer.roadSurfaceLinesLayer: ") <<
                m_roadSurfaceLinesLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
    }
    if (m_roadSurfaceLinesLayer_.getHasIds() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field RoadSurfaceLayer.roadSurfaceLinesLayer: ") <<
                m_roadSurfaceLinesLayer_.getHasIds() << " != " << static_cast<bool>(true) << "!";
    }
    if (m_roadSurfaceLinesLayer_.getHasTypes() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field RoadSurfaceLayer.roadSurfaceLinesLayer: ") <<
                m_roadSurfaceLinesLayer_.getHasTypes() << " != " << static_cast<bool>(true) << "!";
    }
    m_roadSurfaceLinesLayer_.write(context.getRoadSurfaceLinesLayer(), out);

    m_lanegroupRelations_.writePacked(*this, out);
}

void RoadSurfaceLayer::ZserioElementFactory_lanegroupRelations::create(RoadSurfaceLayer&        ,
        ::zserio::vector<::nds::lane::roadsurface::RoadSurfaceLaneGroupRelation>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoadSurfaceLayer::ZserioElementFactory_lanegroupRelations::create(RoadSurfaceLayer&        ,
        ::zserio::vector<::nds::lane::roadsurface::RoadSurfaceLaneGroupRelation>& array,
        ::nds::lane::roadsurface::RoadSurfaceLaneGroupRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::lane::instantiations::RoadSurfacePolygonGeometryLayer RoadSurfaceLayer::readRoadSurfacePolygonLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::instantiations::RoadSurfacePolygonGeometryLayer(in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D), static_cast<bool>(true), static_cast<bool>(true), allocator);
}

::nds::lane::instantiations::RoadSurfacePolygonGeometryLayer RoadSurfaceLayer::readRoadSurfacePolygonLayer(RoadSurfaceLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::instantiations::RoadSurfacePolygonGeometryLayer(context.getRoadSurfacePolygonLayer(), in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D), static_cast<bool>(true), static_cast<bool>(true), allocator);
}
::nds::lane::instantiations::RoadSurfaceLineGeometryLayer RoadSurfaceLayer::readRoadSurfaceLinesLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::instantiations::RoadSurfaceLineGeometryLayer(in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(true), static_cast<bool>(true), allocator);
}

::nds::lane::instantiations::RoadSurfaceLineGeometryLayer RoadSurfaceLayer::readRoadSurfaceLinesLayer(RoadSurfaceLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::instantiations::RoadSurfaceLineGeometryLayer(context.getRoadSurfaceLinesLayer(), in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(true), static_cast<bool>(true), allocator);
}
RoadSurfaceLayer::ZserioArrayType_lanegroupRelations RoadSurfaceLayer::readLanegroupRelations(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lanegroupRelations readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RoadSurfaceLayer::ZserioArrayType_lanegroupRelations RoadSurfaceLayer::readLanegroupRelations(RoadSurfaceLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lanegroupRelations readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace layer
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/layer/MatchedLaneGroupPathLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace lane
{
namespace layer
{

MatchedLaneGroupPathLayer::MatchedLaneGroupPathLayer(const allocator_type& allocator) noexcept :
        m_numSegments_(uint16_t()),
        m_segments_(allocator),
        m_pathEnds_(bool())
{
}

MatchedLaneGroupPathLayer::MatchedLaneGroupPathLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numSegments_(readNumSegments(in)),
        m_segments_(readSegments(in, allocator)),
        m_pathEnds_(readPathEnds(in))
{
}

MatchedLaneGroupPathLayer::MatchedLaneGroupPathLayer(MatchedLaneGroupPathLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numSegments_(readNumSegments(context, in)),
        m_segments_(readSegments(context, in, allocator)),
        m_pathEnds_(readPathEnds(in))
{
}

MatchedLaneGroupPathLayer::MatchedLaneGroupPathLayer(::zserio::PropagateAllocatorT,
        const MatchedLaneGroupPathLayer& other, const allocator_type& allocator) :
        m_numSegments_(::zserio::allocatorPropagatingCopy(other.m_numSegments_, allocator)),
        m_segments_(::zserio::allocatorPropagatingCopy(other.m_segments_, allocator)),
        m_pathEnds_(::zserio::allocatorPropagatingCopy(other.m_pathEnds_, allocator))
{
}

uint16_t MatchedLaneGroupPathLayer::getNumSegments() const
{
    return m_numSegments_;
}

void MatchedLaneGroupPathLayer::setNumSegments(uint16_t numSegments_)
{
    m_numSegments_ = numSegments_;
}

::zserio::vector<::nds::lane::lanegroups::MatchedLaneGroupSegment>& MatchedLaneGroupPathLayer::getSegments()
{
    return m_segments_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanegroups::MatchedLaneGroupSegment>& MatchedLaneGroupPathLayer::getSegments() const
{
    return m_segments_.getRawArray();
}

void MatchedLaneGroupPathLayer::setSegments(const ::zserio::vector<::nds::lane::lanegroups::MatchedLaneGroupSegment>& segments_)
{
    m_segments_ = ZserioArrayType_segments(segments_);
}

void MatchedLaneGroupPathLayer::setSegments(::zserio::vector<::nds::lane::lanegroups::MatchedLaneGroupSegment>&& segments_)
{
    m_segments_ = ZserioArrayType_segments(std::move(segments_));
}

bool MatchedLaneGroupPathLayer::getPathEnds() const
{
    return m_pathEnds_;
}

void MatchedLaneGroupPathLayer::setPathEnds(bool pathEnds_)
{
    m_pathEnds_ = pathEnds_;
}

::nds::system::types::LayerType MatchedLaneGroupPathLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::FEATURE);
}

void MatchedLaneGroupPathLayer::initPackingContext(MatchedLaneGroupPathLayer::ZserioPackingContext& context) const
{
    context.getNumSegments().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numSegments_);
}

size_t MatchedLaneGroupPathLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numSegments_);
    endBitPosition += m_segments_.bitSizeOf(*this, endBitPosition);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t MatchedLaneGroupPathLayer::bitSizeOf(MatchedLaneGroupPathLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumSegments().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numSegments_);
    endBitPosition += m_segments_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t MatchedLaneGroupPathLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numSegments_);
    endBitPosition = m_segments_.initializeOffsets(*this, endBitPosition);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t MatchedLaneGroupPathLayer::initializeOffsets(MatchedLaneGroupPathLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumSegments().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numSegments_);
    endBitPosition = m_segments_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool MatchedLaneGroupPathLayer::operator==(const MatchedLaneGroupPathLayer& other) const
{
    if (this != &other)
    {
        return
                (m_numSegments_ == other.m_numSegments_) &&
                (m_segments_ == other.m_segments_) &&
                (m_pathEnds_ == other.m_pathEnds_);
    }

    return true;
}

uint32_t MatchedLaneGroupPathLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numSegments_);
    result = ::zserio::calcHashCode(result, m_segments_);
    result = ::zserio::calcHashCode(result, m_pathEnds_);

    return result;
}

void MatchedLaneGroupPathLayer::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumSegments() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at MatchedLaneGroupPathLayer.numSegments!");
    out.writeVarUInt16(m_numSegments_);

    // check array length
    if (m_segments_.getRawArray().size() != static_cast<size_t>(getNumSegments()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MatchedLaneGroupPathLayer.segments: ") <<
                m_segments_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSegments()) << "!";
    }
    m_segments_.write(*this, out);

    out.writeBool(m_pathEnds_);
}

void MatchedLaneGroupPathLayer::write(MatchedLaneGroupPathLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumSegments() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at MatchedLaneGroupPathLayer.numSegments!");
    context.getNumSegments().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numSegments_);

    // check array length
    if (m_segments_.getRawArray().size() != static_cast<size_t>(getNumSegments()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field MatchedLaneGroupPathLayer.segments: ") <<
                m_segments_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSegments()) << "!";
    }
    m_segments_.writePacked(*this, out);

    out.writeBool(m_pathEnds_);
}

void MatchedLaneGroupPathLayer::ZserioElementFactory_segments::create(MatchedLaneGroupPathLayer&        ,
        ::zserio::vector<::nds::lane::lanegroups::MatchedLaneGroupSegment>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void MatchedLaneGroupPathLayer::ZserioElementFactory_segments::create(MatchedLaneGroupPathLayer&        ,
        ::zserio::vector<::nds::lane::lanegroups::MatchedLaneGroupSegment>& array,
        ::nds::lane::lanegroups::MatchedLaneGroupSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint16_t MatchedLaneGroupPathLayer::readNumSegments(::zserio::BitStreamReader& in)
{
    uint16_t readField = static_cast<uint16_t>(in.readVarUInt16());
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at MatchedLaneGroupPathLayer.numSegments!");

    return readField;
}

uint16_t MatchedLaneGroupPathLayer::readNumSegments(MatchedLaneGroupPathLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint16_t readField = context.getNumSegments().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at MatchedLaneGroupPathLayer.numSegments!");

    return readField;
}
MatchedLaneGroupPathLayer::ZserioArrayType_segments MatchedLaneGroupPathLayer::readSegments(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumSegments()));

    return readField;
}

MatchedLaneGroupPathLayer::ZserioArrayType_segments MatchedLaneGroupPathLayer::readSegments(MatchedLaneGroupPathLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumSegments()));

    return readField;
}
bool MatchedLaneGroupPathLayer::readPathEnds(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace layer
} // namespace lane
} // namespace nds
