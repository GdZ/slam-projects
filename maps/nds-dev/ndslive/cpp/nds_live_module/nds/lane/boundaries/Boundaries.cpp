/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/lane/boundaries/Boundary.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

Boundary::Boundary(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_geometryReference_(allocator),
        m_boundaryElementRanges_(allocator)
{
}

Boundary::Boundary(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_geometryReference_(readGeometryReference(in, allocator)),
        m_boundaryElementRanges_(readBoundaryElementRanges(in, allocator))
{
}

Boundary::Boundary(Boundary::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator)),
        m_geometryReference_(readGeometryReference(context, in, allocator)),
        m_boundaryElementRanges_(readBoundaryElementRanges(context, in, allocator))
{
}

Boundary::Boundary(::zserio::PropagateAllocatorT,
        const Boundary& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_geometryReference_(::zserio::allocatorPropagatingCopy(other.m_geometryReference_, allocator)),
        m_boundaryElementRanges_(::zserio::allocatorPropagatingCopy(other.m_boundaryElementRanges_, allocator))
{
}

::nds::lane::boundaries::BoundaryId& Boundary::getId()
{
    return m_id_;
}

const ::nds::lane::boundaries::BoundaryId& Boundary::getId() const
{
    return m_id_;
}

void Boundary::setId(const ::nds::lane::boundaries::BoundaryId& id_)
{
    m_id_ = id_;
}

void Boundary::setId(::nds::lane::boundaries::BoundaryId&& id_)
{
    m_id_ = ::std::move(id_);
}

::nds::lane::boundaries::BoundaryGeometryReference& Boundary::getGeometryReference()
{
    return m_geometryReference_;
}

const ::nds::lane::boundaries::BoundaryGeometryReference& Boundary::getGeometryReference() const
{
    return m_geometryReference_;
}

void Boundary::setGeometryReference(const ::nds::lane::boundaries::BoundaryGeometryReference& geometryReference_)
{
    m_geometryReference_ = geometryReference_;
}

void Boundary::setGeometryReference(::nds::lane::boundaries::BoundaryGeometryReference&& geometryReference_)
{
    m_geometryReference_ = ::std::move(geometryReference_);
}

::zserio::vector<::nds::lane::boundaries::BoundaryElementRange>& Boundary::getBoundaryElementRanges()
{
    return m_boundaryElementRanges_.getRawArray();
}

const ::zserio::vector<::nds::lane::boundaries::BoundaryElementRange>& Boundary::getBoundaryElementRanges() const
{
    return m_boundaryElementRanges_.getRawArray();
}

void Boundary::setBoundaryElementRanges(const ::zserio::vector<::nds::lane::boundaries::BoundaryElementRange>& boundaryElementRanges_)
{
    m_boundaryElementRanges_ = ZserioArrayType_boundaryElementRanges(boundaryElementRanges_);
}

void Boundary::setBoundaryElementRanges(::zserio::vector<::nds::lane::boundaries::BoundaryElementRange>&& boundaryElementRanges_)
{
    m_boundaryElementRanges_ = ZserioArrayType_boundaryElementRanges(std::move(boundaryElementRanges_));
}

void Boundary::initPackingContext(Boundary::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
    m_geometryReference_.initPackingContext(context.getGeometryReference());
}

size_t Boundary::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += m_geometryReference_.bitSizeOf(endBitPosition);
    endBitPosition += m_boundaryElementRanges_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Boundary::bitSizeOf(Boundary::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += m_geometryReference_.bitSizeOf(context.getGeometryReference(), endBitPosition);
    endBitPosition += m_boundaryElementRanges_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Boundary::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition = m_geometryReference_.initializeOffsets(endBitPosition);
    endBitPosition = m_boundaryElementRanges_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t Boundary::initializeOffsets(Boundary::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition = m_geometryReference_.initializeOffsets(context.getGeometryReference(), endBitPosition);
    endBitPosition = m_boundaryElementRanges_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Boundary::operator==(const Boundary& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_geometryReference_ == other.m_geometryReference_) &&
                (m_boundaryElementRanges_ == other.m_boundaryElementRanges_);
    }

    return true;
}

uint32_t Boundary::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_geometryReference_);
    result = ::zserio::calcHashCode(result, m_boundaryElementRanges_);

    return result;
}

void Boundary::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);

    m_geometryReference_.write(out);

    // check constraint
    if (!(getBoundaryElementRanges().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at Boundary.boundaryElementRanges!");
    m_boundaryElementRanges_.write(*this, out);
}

void Boundary::write(Boundary::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);

    m_geometryReference_.write(context.getGeometryReference(), out);

    // check constraint
    if (!(getBoundaryElementRanges().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at Boundary.boundaryElementRanges!");
    m_boundaryElementRanges_.writePacked(*this, out);
}

void Boundary::ZserioElementFactory_boundaryElementRanges::create(Boundary&        ,
        ::zserio::vector<::nds::lane::boundaries::BoundaryElementRange>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Boundary::ZserioElementFactory_boundaryElementRanges::create(Boundary&        ,
        ::zserio::vector<::nds::lane::boundaries::BoundaryElementRange>& array,
        ::nds::lane::boundaries::BoundaryElementRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::lane::boundaries::BoundaryId Boundary::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryId(in, allocator);
}

::nds::lane::boundaries::BoundaryId Boundary::readId(Boundary::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryId(context.getId(), in, allocator);
}
::nds::lane::boundaries::BoundaryGeometryReference Boundary::readGeometryReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryGeometryReference(in, allocator);
}

::nds::lane::boundaries::BoundaryGeometryReference Boundary::readGeometryReference(Boundary::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryGeometryReference(context.getGeometryReference(), in, allocator);
}
Boundary::ZserioArrayType_boundaryElementRanges Boundary::readBoundaryElementRanges(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_boundaryElementRanges readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at Boundary.boundaryElementRanges!");

    return readField;
}

Boundary::ZserioArrayType_boundaryElementRanges Boundary::readBoundaryElementRanges(Boundary::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_boundaryElementRanges readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at Boundary.boundaryElementRanges!");

    return readField;
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/BoundaryElementDefinitions.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

BoundaryElementDefinitions::BoundaryElementDefinitions(const allocator_type& allocator) noexcept :
        m_boundaryElementList_(allocator)
{
}

BoundaryElementDefinitions::BoundaryElementDefinitions(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_boundaryElementList_(readBoundaryElementList(in, allocator))
{
}

BoundaryElementDefinitions::BoundaryElementDefinitions(BoundaryElementDefinitions::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_boundaryElementList_(readBoundaryElementList(context, in, allocator))
{
}

BoundaryElementDefinitions::BoundaryElementDefinitions(::zserio::PropagateAllocatorT,
        const BoundaryElementDefinitions& other, const allocator_type& allocator) :
        m_boundaryElementList_(::zserio::allocatorPropagatingCopy(other.m_boundaryElementList_, allocator))
{
}

void BoundaryElementDefinitions::initializeChildren()
{
    m_boundaryElementList_.initializeElements(*this);
}

::zserio::vector<::nds::lane::boundaries::BoundaryElement>& BoundaryElementDefinitions::getBoundaryElementList()
{
    return m_boundaryElementList_.getRawArray();
}

const ::zserio::vector<::nds::lane::boundaries::BoundaryElement>& BoundaryElementDefinitions::getBoundaryElementList() const
{
    return m_boundaryElementList_.getRawArray();
}

void BoundaryElementDefinitions::setBoundaryElementList(const ::zserio::vector<::nds::lane::boundaries::BoundaryElement>& boundaryElementList_)
{
    m_boundaryElementList_ = ZserioArrayType_boundaryElementList(boundaryElementList_);
}

void BoundaryElementDefinitions::setBoundaryElementList(::zserio::vector<::nds::lane::boundaries::BoundaryElement>&& boundaryElementList_)
{
    m_boundaryElementList_ = ZserioArrayType_boundaryElementList(std::move(boundaryElementList_));
}

void BoundaryElementDefinitions::initPackingContext(BoundaryElementDefinitions::ZserioPackingContext&) const
{
}

size_t BoundaryElementDefinitions::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_boundaryElementList_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BoundaryElementDefinitions::bitSizeOf(BoundaryElementDefinitions::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_boundaryElementList_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BoundaryElementDefinitions::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_boundaryElementList_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t BoundaryElementDefinitions::initializeOffsets(BoundaryElementDefinitions::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_boundaryElementList_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool BoundaryElementDefinitions::operator==(const BoundaryElementDefinitions& other) const
{
    if (this != &other)
    {
        return
                (m_boundaryElementList_ == other.m_boundaryElementList_);
    }

    return true;
}

uint32_t BoundaryElementDefinitions::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_boundaryElementList_);

    return result;
}

void BoundaryElementDefinitions::write(::zserio::BitStreamWriter& out) const
{
    m_boundaryElementList_.write(*this, out);
}

void BoundaryElementDefinitions::write(BoundaryElementDefinitions::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_boundaryElementList_.writePacked(*this, out);
}

void BoundaryElementDefinitions::ZserioArrayExpressions_boundaryElementList::initializeElement(BoundaryElementDefinitions&,
        ::nds::lane::boundaries::BoundaryElement& element, size_t)
{
    element.initializeChildren();
}

void BoundaryElementDefinitions::ZserioElementFactory_boundaryElementList::create(BoundaryElementDefinitions&        ,
        ::zserio::vector<::nds::lane::boundaries::BoundaryElement>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void BoundaryElementDefinitions::ZserioElementFactory_boundaryElementList::create(BoundaryElementDefinitions&        ,
        ::zserio::vector<::nds::lane::boundaries::BoundaryElement>& array,
        ::nds::lane::boundaries::BoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

BoundaryElementDefinitions::ZserioArrayType_boundaryElementList BoundaryElementDefinitions::readBoundaryElementList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_boundaryElementList readField(allocator);
    readField.read(*this, in);

    return readField;
}

BoundaryElementDefinitions::ZserioArrayType_boundaryElementList BoundaryElementDefinitions::readBoundaryElementList(BoundaryElementDefinitions::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_boundaryElementList readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/BoundaryElement.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

BoundaryElement::BoundaryElement(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_id_(::nds::lane::boundaries::BoundaryElementId()),
        m_type_(::nds::lane::types::BoundaryElementType()),
        m_details_(allocator)
{
}

BoundaryElement::BoundaryElement(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_id_(readId(in)),
        m_type_(readType(in)),
        m_details_(readDetails(in, allocator))
{
}

BoundaryElement::BoundaryElement(BoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_id_(readId(context, in)),
        m_type_(readType(context, in)),
        m_details_(readDetails(context, in, allocator))
{
}

BoundaryElement::BoundaryElement(const BoundaryElement& other) :
        m_id_(other.m_id_),
        m_type_(other.m_type_),
        m_details_(other.m_details_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

BoundaryElement& BoundaryElement::operator=(const BoundaryElement& other)
{
    m_id_ = other.m_id_;
    m_type_ = other.m_type_;
    m_details_ = other.m_details_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

BoundaryElement::BoundaryElement(BoundaryElement&& other) :
        m_id_(::std::move(other.m_id_)),
        m_type_(::std::move(other.m_type_)),
        m_details_(::std::move(other.m_details_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

BoundaryElement& BoundaryElement::operator=(BoundaryElement&& other)
{
    m_id_ = ::std::move(other.m_id_);
    m_type_ = ::std::move(other.m_type_);
    m_details_ = ::std::move(other.m_details_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

BoundaryElement::BoundaryElement(::zserio::PropagateAllocatorT,
        const BoundaryElement& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_details_(::zserio::allocatorPropagatingCopy(other.m_details_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void BoundaryElement::initializeChildren()
{
    m_details_.initialize(static_cast<::nds::lane::types::BoundaryElementType>(getType()));

    m_areChildrenInitialized = true;
}

::nds::lane::boundaries::BoundaryElementId BoundaryElement::getId() const
{
    return m_id_;
}

void BoundaryElement::setId(::nds::lane::boundaries::BoundaryElementId id_)
{
    m_id_ = id_;
}

::nds::lane::types::BoundaryElementType BoundaryElement::getType() const
{
    return m_type_;
}

void BoundaryElement::setType(::nds::lane::types::BoundaryElementType type_)
{
    m_type_ = type_;
}

::nds::lane::boundaries::BoundaryElementDetails& BoundaryElement::getDetails()
{
    return m_details_;
}

const ::nds::lane::boundaries::BoundaryElementDetails& BoundaryElement::getDetails() const
{
    return m_details_;
}

void BoundaryElement::setDetails(const ::nds::lane::boundaries::BoundaryElementDetails& details_)
{
    m_details_ = details_;
}

void BoundaryElement::setDetails(::nds::lane::boundaries::BoundaryElementDetails&& details_)
{
    m_details_ = ::std::move(details_);
}

void BoundaryElement::initPackingContext(BoundaryElement::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(m_id_);
    ::zserio::initPackingContext(context.getType(), m_type_);
    m_details_.initPackingContext(context.getDetails());
}

size_t BoundaryElement::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_id_);
    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += m_details_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BoundaryElement::bitSizeOf(BoundaryElement::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(m_id_);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += m_details_.bitSizeOf(context.getDetails(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BoundaryElement::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_id_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = m_details_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t BoundaryElement::initializeOffsets(BoundaryElement::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(m_id_);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = m_details_.initializeOffsets(context.getDetails(), endBitPosition);

    return endBitPosition;
}

bool BoundaryElement::operator==(const BoundaryElement& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_type_ == other.m_type_) &&
                (m_details_ == other.m_details_);
    }

    return true;
}

uint32_t BoundaryElement::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_details_);

    return result;
}

void BoundaryElement::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_id_);

    ::zserio::write(out, m_type_);

    // check parameters
    if (m_details_.getType() != static_cast<::nds::lane::types::BoundaryElementType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field BoundaryElement.details: ") <<
                m_details_.getType() << " != " << static_cast<::nds::lane::types::BoundaryElementType>(getType()) << "!";
    }
    m_details_.write(out);
}

void BoundaryElement::write(BoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(out, m_id_);

    ::zserio::write(context.getType(), out, m_type_);

    // check parameters
    if (m_details_.getType() != static_cast<::nds::lane::types::BoundaryElementType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field BoundaryElement.details: ") <<
                m_details_.getType() << " != " << static_cast<::nds::lane::types::BoundaryElementType>(getType()) << "!";
    }
    m_details_.write(context.getDetails(), out);
}

::nds::lane::boundaries::BoundaryElementId BoundaryElement::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::boundaries::BoundaryElementId>(in.readVarUInt16());
}

::nds::lane::boundaries::BoundaryElementId BoundaryElement::readId(BoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(in);
}
::nds::lane::types::BoundaryElementType BoundaryElement::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::BoundaryElementType>(in);
}

::nds::lane::types::BoundaryElementType BoundaryElement::readType(BoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::BoundaryElementType>(context.getType(), in);
}
::nds::lane::boundaries::BoundaryElementDetails BoundaryElement::readDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryElementDetails(in, static_cast<::nds::lane::types::BoundaryElementType>(getType()), allocator);
}

::nds::lane::boundaries::BoundaryElementDetails BoundaryElement::readDetails(BoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryElementDetails(context.getDetails(), in, static_cast<::nds::lane::types::BoundaryElementType>(getType()), allocator);
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/BoundaryElementRange.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

BoundaryElementRange::BoundaryElementRange(const allocator_type& allocator) noexcept :
        m_boundaryElementId_(::nds::lane::boundaries::BoundaryElementId()),
        m_range_(allocator)
{
}

BoundaryElementRange::BoundaryElementRange(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_boundaryElementId_(readBoundaryElementId(in)),
        m_range_(readRange(in, allocator))
{
}

BoundaryElementRange::BoundaryElementRange(BoundaryElementRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_boundaryElementId_(readBoundaryElementId(context, in)),
        m_range_(readRange(context, in, allocator))
{
}

BoundaryElementRange::BoundaryElementRange(::zserio::PropagateAllocatorT,
        const BoundaryElementRange& other, const allocator_type& allocator) :
        m_boundaryElementId_(::zserio::allocatorPropagatingCopy(other.m_boundaryElementId_, allocator)),
        m_range_(::zserio::allocatorPropagatingCopy(other.m_range_, allocator))
{
}

::nds::lane::boundaries::BoundaryElementId BoundaryElementRange::getBoundaryElementId() const
{
    return m_boundaryElementId_;
}

void BoundaryElementRange::setBoundaryElementId(::nds::lane::boundaries::BoundaryElementId boundaryElementId_)
{
    m_boundaryElementId_ = boundaryElementId_;
}

::nds::lane::reference::types::BoundaryGeometryRange& BoundaryElementRange::getRange()
{
    return m_range_;
}

const ::nds::lane::reference::types::BoundaryGeometryRange& BoundaryElementRange::getRange() const
{
    return m_range_;
}

void BoundaryElementRange::setRange(const ::nds::lane::reference::types::BoundaryGeometryRange& range_)
{
    m_range_ = range_;
}

void BoundaryElementRange::setRange(::nds::lane::reference::types::BoundaryGeometryRange&& range_)
{
    m_range_ = ::std::move(range_);
}

void BoundaryElementRange::initPackingContext(BoundaryElementRange::ZserioPackingContext& context) const
{
    context.getBoundaryElementId().init<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(m_boundaryElementId_);
    m_range_.initPackingContext(context.getRange());
}

size_t BoundaryElementRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_boundaryElementId_);
    endBitPosition += m_range_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BoundaryElementRange::bitSizeOf(BoundaryElementRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getBoundaryElementId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(m_boundaryElementId_);
    endBitPosition += m_range_.bitSizeOf(context.getRange(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BoundaryElementRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_boundaryElementId_);
    endBitPosition = m_range_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t BoundaryElementRange::initializeOffsets(BoundaryElementRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getBoundaryElementId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(m_boundaryElementId_);
    endBitPosition = m_range_.initializeOffsets(context.getRange(), endBitPosition);

    return endBitPosition;
}

bool BoundaryElementRange::operator==(const BoundaryElementRange& other) const
{
    if (this != &other)
    {
        return
                (m_boundaryElementId_ == other.m_boundaryElementId_) &&
                (m_range_ == other.m_range_);
    }

    return true;
}

uint32_t BoundaryElementRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_boundaryElementId_);
    result = ::zserio::calcHashCode(result, m_range_);

    return result;
}

void BoundaryElementRange::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_boundaryElementId_);
    m_range_.write(out);
}

void BoundaryElementRange::write(BoundaryElementRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getBoundaryElementId().write<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(out, m_boundaryElementId_);
    m_range_.write(context.getRange(), out);
}

::nds::lane::boundaries::BoundaryElementId BoundaryElementRange::readBoundaryElementId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::boundaries::BoundaryElementId>(in.readVarUInt16());
}

::nds::lane::boundaries::BoundaryElementId BoundaryElementRange::readBoundaryElementId(BoundaryElementRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getBoundaryElementId().read<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryElementId>>(in);
}
::nds::lane::reference::types::BoundaryGeometryRange BoundaryElementRange::readRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::BoundaryGeometryRange(in, allocator);
}

::nds::lane::reference::types::BoundaryGeometryRange BoundaryElementRange::readRange(BoundaryElementRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::BoundaryGeometryRange(context.getRange(), in, allocator);
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/LogicalBoundaryElement.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

LogicalBoundaryElement::LogicalBoundaryElement(const allocator_type&) noexcept :
        m_type_(::nds::lane::types::LogicalBoundaryType())
{
}

LogicalBoundaryElement::LogicalBoundaryElement(::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(in))
{
}

LogicalBoundaryElement::LogicalBoundaryElement(LogicalBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(context, in))
{
}

LogicalBoundaryElement::LogicalBoundaryElement(::zserio::PropagateAllocatorT,
        const LogicalBoundaryElement& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator))
{
}

::nds::lane::types::LogicalBoundaryType LogicalBoundaryElement::getType() const
{
    return m_type_;
}

void LogicalBoundaryElement::setType(::nds::lane::types::LogicalBoundaryType type_)
{
    m_type_ = type_;
}

void LogicalBoundaryElement::initPackingContext(LogicalBoundaryElement::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
}

size_t LogicalBoundaryElement::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);

    return endBitPosition - bitPosition;
}

size_t LogicalBoundaryElement::bitSizeOf(LogicalBoundaryElement::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);

    return endBitPosition - bitPosition;
}

size_t LogicalBoundaryElement::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);

    return endBitPosition;
}

size_t LogicalBoundaryElement::initializeOffsets(LogicalBoundaryElement::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);

    return endBitPosition;
}

bool LogicalBoundaryElement::operator==(const LogicalBoundaryElement& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_);
    }

    return true;
}

uint32_t LogicalBoundaryElement::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);

    return result;
}

void LogicalBoundaryElement::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
}

void LogicalBoundaryElement::write(LogicalBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
}

::nds::lane::types::LogicalBoundaryType LogicalBoundaryElement::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::LogicalBoundaryType>(in);
}

::nds::lane::types::LogicalBoundaryType LogicalBoundaryElement::readType(LogicalBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::LogicalBoundaryType>(context.getType(), in);
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/boundaries/MarkingBoundaryElement.h>
#include <nds/lane/types/MarkingBoundaryType.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

MarkingBoundaryElement::MarkingBoundaryElement(const allocator_type&) noexcept :
        m_type_(::nds::lane::types::MarkingBoundaryType()),
        m_material_(::nds::lane::types::MarkingMaterial()),
        m_color_(::nds::lane::reference::types::MarkingColor()),
        m_width_(::nds::lane::boundaries::BoundaryWidth()),
        m_dashDetails_(::zserio::NullOpt)
{
}

MarkingBoundaryElement::MarkingBoundaryElement(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_material_(readMaterial(in)),
        m_color_(readColor(in)),
        m_width_(readWidth(in)),
        m_dashDetails_(readDashDetails(in, allocator))
{
}

MarkingBoundaryElement::MarkingBoundaryElement(MarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_material_(readMaterial(context, in)),
        m_color_(readColor(context, in)),
        m_width_(readWidth(context, in)),
        m_dashDetails_(readDashDetails(context, in, allocator))
{
}

MarkingBoundaryElement::MarkingBoundaryElement(::zserio::PropagateAllocatorT,
        const MarkingBoundaryElement& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_material_(::zserio::allocatorPropagatingCopy(other.m_material_, allocator)),
        m_color_(::zserio::allocatorPropagatingCopy(other.m_color_, allocator)),
        m_width_(::zserio::allocatorPropagatingCopy(other.m_width_, allocator)),
        m_dashDetails_(::zserio::allocatorPropagatingCopy(other.m_dashDetails_, allocator))
{
}

::nds::lane::types::MarkingBoundaryType MarkingBoundaryElement::getType() const
{
    return m_type_;
}

void MarkingBoundaryElement::setType(::nds::lane::types::MarkingBoundaryType type_)
{
    m_type_ = type_;
}

::nds::lane::types::MarkingMaterial MarkingBoundaryElement::getMaterial() const
{
    return m_material_;
}

void MarkingBoundaryElement::setMaterial(::nds::lane::types::MarkingMaterial material_)
{
    m_material_ = material_;
}

::nds::lane::reference::types::MarkingColor MarkingBoundaryElement::getColor() const
{
    return m_color_;
}

void MarkingBoundaryElement::setColor(::nds::lane::reference::types::MarkingColor color_)
{
    m_color_ = color_;
}

::nds::lane::boundaries::BoundaryWidth MarkingBoundaryElement::getWidth() const
{
    return m_width_;
}

void MarkingBoundaryElement::setWidth(::nds::lane::boundaries::BoundaryWidth width_)
{
    m_width_ = width_;
}

::nds::lane::boundaries::BoundaryMarkingDashDetails& MarkingBoundaryElement::getDashDetails()
{
    return m_dashDetails_.value();
}

const ::nds::lane::boundaries::BoundaryMarkingDashDetails& MarkingBoundaryElement::getDashDetails() const
{
    return m_dashDetails_.value();
}

void MarkingBoundaryElement::setDashDetails(const ::nds::lane::boundaries::BoundaryMarkingDashDetails& dashDetails_)
{
    m_dashDetails_ = dashDetails_;
}

void MarkingBoundaryElement::setDashDetails(::nds::lane::boundaries::BoundaryMarkingDashDetails&& dashDetails_)
{
    m_dashDetails_ = ::std::move(dashDetails_);
}

bool MarkingBoundaryElement::isDashDetailsUsed() const
{
    return (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS);
}

bool MarkingBoundaryElement::isDashDetailsSet() const
{
    return m_dashDetails_.hasValue();
}

void MarkingBoundaryElement::resetDashDetails()
{
    m_dashDetails_.reset();
}

void MarkingBoundaryElement::initPackingContext(MarkingBoundaryElement::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    ::zserio::initPackingContext(context.getMaterial(), m_material_);
    ::zserio::initPackingContext(context.getColor(), m_color_);
    context.getWidth().init<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(m_width_);
    if (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS)
    {
        m_dashDetails_.value().initPackingContext(context.getDashDetails());
    }
}

size_t MarkingBoundaryElement::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += ::zserio::bitSizeOf(m_material_);
    endBitPosition += ::zserio::bitSizeOf(m_color_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_width_);
    if (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS)
    {
        endBitPosition += m_dashDetails_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t MarkingBoundaryElement::bitSizeOf(MarkingBoundaryElement::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += ::zserio::bitSizeOf(context.getMaterial(), m_material_);
    endBitPosition += ::zserio::bitSizeOf(context.getColor(), m_color_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(m_width_);
    if (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS)
    {
        endBitPosition += m_dashDetails_.value().bitSizeOf(context.getDashDetails(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t MarkingBoundaryElement::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_material_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_color_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_width_);
    if (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS)
    {
        endBitPosition = m_dashDetails_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t MarkingBoundaryElement::initializeOffsets(MarkingBoundaryElement::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = ::zserio::initializeOffsets(context.getMaterial(), endBitPosition,
        m_material_);
    endBitPosition = ::zserio::initializeOffsets(context.getColor(), endBitPosition,
        m_color_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(m_width_);
    if (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS)
    {
        endBitPosition = m_dashDetails_.value().initializeOffsets(context.getDashDetails(), endBitPosition);
    }

    return endBitPosition;
}

bool MarkingBoundaryElement::operator==(const MarkingBoundaryElement& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_material_ == other.m_material_) &&
                (m_color_ == other.m_color_) &&
                (m_width_ == other.m_width_) &&
                (!isDashDetailsUsed() ? !other.isDashDetailsUsed() : (m_dashDetails_ == other.m_dashDetails_));
    }

    return true;
}

uint32_t MarkingBoundaryElement::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_material_);
    result = ::zserio::calcHashCode(result, m_color_);
    result = ::zserio::calcHashCode(result, m_width_);
    if (isDashDetailsUsed())
        result = ::zserio::calcHashCode(result, m_dashDetails_);

    return result;
}

void MarkingBoundaryElement::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    ::zserio::write(out, m_material_);
    ::zserio::write(out, m_color_);
    out.writeVarUInt32(m_width_);
    if (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS)
    {
        m_dashDetails_.value().write(out);
    }
}

void MarkingBoundaryElement::write(MarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    ::zserio::write(context.getMaterial(), out, m_material_);
    ::zserio::write(context.getColor(), out, m_color_);
    context.getWidth().write<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(out, m_width_);
    if (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS)
    {
        m_dashDetails_.value().write(context.getDashDetails(), out);
    }
}

::nds::lane::types::MarkingBoundaryType MarkingBoundaryElement::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::MarkingBoundaryType>(in);
}

::nds::lane::types::MarkingBoundaryType MarkingBoundaryElement::readType(MarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::MarkingBoundaryType>(context.getType(), in);
}
::nds::lane::types::MarkingMaterial MarkingBoundaryElement::readMaterial(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::MarkingMaterial>(in);
}

::nds::lane::types::MarkingMaterial MarkingBoundaryElement::readMaterial(MarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::MarkingMaterial>(context.getMaterial(), in);
}
::nds::lane::reference::types::MarkingColor MarkingBoundaryElement::readColor(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::MarkingColor>(in);
}

::nds::lane::reference::types::MarkingColor MarkingBoundaryElement::readColor(MarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::MarkingColor>(context.getColor(), in);
}
::nds::lane::boundaries::BoundaryWidth MarkingBoundaryElement::readWidth(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::boundaries::BoundaryWidth>(in.readVarUInt32());
}

::nds::lane::boundaries::BoundaryWidth MarkingBoundaryElement::readWidth(MarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getWidth().read<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(in);
}
::zserio::InplaceOptionalHolder<::nds::lane::boundaries::BoundaryMarkingDashDetails> MarkingBoundaryElement::readDashDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::boundaries::BoundaryMarkingDashDetails>(::nds::lane::boundaries::BoundaryMarkingDashDetails(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::boundaries::BoundaryMarkingDashDetails>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::boundaries::BoundaryMarkingDashDetails> MarkingBoundaryElement::readDashDetails(MarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_LINE || getType() == ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::boundaries::BoundaryMarkingDashDetails>(::nds::lane::boundaries::BoundaryMarkingDashDetails(context.getDashDetails(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::boundaries::BoundaryMarkingDashDetails>(::zserio::NullOpt);
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/BoundaryMarkingDashDetails.h>
#include <nds/lane/boundaries/UNKNOWN_MARKING_DASH_SPACING.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

BoundaryMarkingDashDetails::BoundaryMarkingDashDetails(const allocator_type&) noexcept :
        m_dashLength_(::nds::lane::boundaries::BoundaryMarkingDashLength()),
        m_dashSpacing_(::nds::lane::boundaries::BoundaryMarkingDashSpacing()),
        m_spaceAtStart_(::zserio::NullOpt),
        m_spaceAtEnd_(::zserio::NullOpt)
{
}

BoundaryMarkingDashDetails::BoundaryMarkingDashDetails(::zserio::BitStreamReader& in, const allocator_type&) :
        m_dashLength_(readDashLength(in)),
        m_dashSpacing_(readDashSpacing(in)),
        m_spaceAtStart_(readSpaceAtStart(in)),
        m_spaceAtEnd_(readSpaceAtEnd(in))
{
}

BoundaryMarkingDashDetails::BoundaryMarkingDashDetails(BoundaryMarkingDashDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_dashLength_(readDashLength(context, in)),
        m_dashSpacing_(readDashSpacing(context, in)),
        m_spaceAtStart_(readSpaceAtStart(in)),
        m_spaceAtEnd_(readSpaceAtEnd(in))
{
}

BoundaryMarkingDashDetails::BoundaryMarkingDashDetails(::zserio::PropagateAllocatorT,
        const BoundaryMarkingDashDetails& other, const allocator_type& allocator) :
        m_dashLength_(::zserio::allocatorPropagatingCopy(other.m_dashLength_, allocator)),
        m_dashSpacing_(::zserio::allocatorPropagatingCopy(other.m_dashSpacing_, allocator)),
        m_spaceAtStart_(::zserio::allocatorPropagatingCopy(other.m_spaceAtStart_, allocator)),
        m_spaceAtEnd_(::zserio::allocatorPropagatingCopy(other.m_spaceAtEnd_, allocator))
{
}

::nds::lane::boundaries::BoundaryMarkingDashLength BoundaryMarkingDashDetails::getDashLength() const
{
    return m_dashLength_;
}

void BoundaryMarkingDashDetails::setDashLength(::nds::lane::boundaries::BoundaryMarkingDashLength dashLength_)
{
    m_dashLength_ = dashLength_;
}

::nds::lane::boundaries::BoundaryMarkingDashSpacing BoundaryMarkingDashDetails::getDashSpacing() const
{
    return m_dashSpacing_;
}

void BoundaryMarkingDashDetails::setDashSpacing(::nds::lane::boundaries::BoundaryMarkingDashSpacing dashSpacing_)
{
    m_dashSpacing_ = dashSpacing_;
}

bool BoundaryMarkingDashDetails::getSpaceAtStart() const
{
    return m_spaceAtStart_.value();
}

void BoundaryMarkingDashDetails::setSpaceAtStart(bool spaceAtStart_)
{
    m_spaceAtStart_ = spaceAtStart_;
}

bool BoundaryMarkingDashDetails::isSpaceAtStartUsed() const
{
    return (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING);
}

bool BoundaryMarkingDashDetails::isSpaceAtStartSet() const
{
    return m_spaceAtStart_.hasValue();
}

void BoundaryMarkingDashDetails::resetSpaceAtStart()
{
    m_spaceAtStart_.reset();
}

bool BoundaryMarkingDashDetails::getSpaceAtEnd() const
{
    return m_spaceAtEnd_.value();
}

void BoundaryMarkingDashDetails::setSpaceAtEnd(bool spaceAtEnd_)
{
    m_spaceAtEnd_ = spaceAtEnd_;
}

bool BoundaryMarkingDashDetails::isSpaceAtEndUsed() const
{
    return (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING);
}

bool BoundaryMarkingDashDetails::isSpaceAtEndSet() const
{
    return m_spaceAtEnd_.hasValue();
}

void BoundaryMarkingDashDetails::resetSpaceAtEnd()
{
    m_spaceAtEnd_.reset();
}

void BoundaryMarkingDashDetails::initPackingContext(BoundaryMarkingDashDetails::ZserioPackingContext& context) const
{
    context.getDashLength().init<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashLength>>(m_dashLength_);
    context.getDashSpacing().init<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashSpacing>>(m_dashSpacing_);
}

size_t BoundaryMarkingDashDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_dashLength_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_dashSpacing_);
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        endBitPosition += UINT8_C(1);
    }
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition - bitPosition;
}

size_t BoundaryMarkingDashDetails::bitSizeOf(BoundaryMarkingDashDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDashLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashLength>>(m_dashLength_);
    endBitPosition += context.getDashSpacing().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashSpacing>>(m_dashSpacing_);
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        endBitPosition += UINT8_C(1);
    }
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition - bitPosition;
}

size_t BoundaryMarkingDashDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_dashLength_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_dashSpacing_);
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        endBitPosition += UINT8_C(1);
    }
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition;
}

size_t BoundaryMarkingDashDetails::initializeOffsets(BoundaryMarkingDashDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDashLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashLength>>(m_dashLength_);
    endBitPosition += context.getDashSpacing().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashSpacing>>(m_dashSpacing_);
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        endBitPosition += UINT8_C(1);
    }
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        endBitPosition += UINT8_C(1);
    }

    return endBitPosition;
}

bool BoundaryMarkingDashDetails::operator==(const BoundaryMarkingDashDetails& other) const
{
    if (this != &other)
    {
        return
                (m_dashLength_ == other.m_dashLength_) &&
                (m_dashSpacing_ == other.m_dashSpacing_) &&
                (!isSpaceAtStartUsed() ? !other.isSpaceAtStartUsed() : (m_spaceAtStart_ == other.m_spaceAtStart_)) &&
                (!isSpaceAtEndUsed() ? !other.isSpaceAtEndUsed() : (m_spaceAtEnd_ == other.m_spaceAtEnd_));
    }

    return true;
}

uint32_t BoundaryMarkingDashDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_dashLength_);
    result = ::zserio::calcHashCode(result, m_dashSpacing_);
    if (isSpaceAtStartUsed())
        result = ::zserio::calcHashCode(result, m_spaceAtStart_);
    if (isSpaceAtEndUsed())
        result = ::zserio::calcHashCode(result, m_spaceAtEnd_);

    return result;
}

void BoundaryMarkingDashDetails::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_dashLength_);
    out.writeVarUInt32(m_dashSpacing_);
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        out.writeBool(m_spaceAtStart_.value());
    }
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        out.writeBool(m_spaceAtEnd_.value());
    }
}

void BoundaryMarkingDashDetails::write(BoundaryMarkingDashDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getDashLength().write<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashLength>>(out, m_dashLength_);
    context.getDashSpacing().write<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashSpacing>>(out, m_dashSpacing_);
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        out.writeBool(m_spaceAtStart_.value());
    }
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        out.writeBool(m_spaceAtEnd_.value());
    }
}

::nds::lane::boundaries::BoundaryMarkingDashLength BoundaryMarkingDashDetails::readDashLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::boundaries::BoundaryMarkingDashLength>(in.readVarUInt32());
}

::nds::lane::boundaries::BoundaryMarkingDashLength BoundaryMarkingDashDetails::readDashLength(BoundaryMarkingDashDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDashLength().read<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashLength>>(in);
}
::nds::lane::boundaries::BoundaryMarkingDashSpacing BoundaryMarkingDashDetails::readDashSpacing(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::boundaries::BoundaryMarkingDashSpacing>(in.readVarUInt32());
}

::nds::lane::boundaries::BoundaryMarkingDashSpacing BoundaryMarkingDashDetails::readDashSpacing(BoundaryMarkingDashDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDashSpacing().read<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryMarkingDashSpacing>>(in);
}
::zserio::InplaceOptionalHolder<bool> BoundaryMarkingDashDetails::readSpaceAtStart(::zserio::BitStreamReader& in)
{
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> BoundaryMarkingDashDetails::readSpaceAtEnd(::zserio::BitStreamReader& in)
{
    if (getDashSpacing() != ::nds::lane::boundaries::UNKNOWN_MARKING_DASH_SPACING)
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/PhysicalDividerBoundaryElement.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

PhysicalDividerBoundaryElement::PhysicalDividerBoundaryElement(const allocator_type&) noexcept :
        m_type_(::nds::lane::types::PhysicalDividerBoundaryType()),
        m_material_(::nds::lane::types::PhysicalBoundaryMaterial()),
        m_width_(::nds::lane::boundaries::BoundaryWidth())
{
}

PhysicalDividerBoundaryElement::PhysicalDividerBoundaryElement(::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(in)),
        m_material_(readMaterial(in)),
        m_width_(readWidth(in))
{
}

PhysicalDividerBoundaryElement::PhysicalDividerBoundaryElement(PhysicalDividerBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(context, in)),
        m_material_(readMaterial(context, in)),
        m_width_(readWidth(context, in))
{
}

PhysicalDividerBoundaryElement::PhysicalDividerBoundaryElement(::zserio::PropagateAllocatorT,
        const PhysicalDividerBoundaryElement& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_material_(::zserio::allocatorPropagatingCopy(other.m_material_, allocator)),
        m_width_(::zserio::allocatorPropagatingCopy(other.m_width_, allocator))
{
}

::nds::lane::types::PhysicalDividerBoundaryType PhysicalDividerBoundaryElement::getType() const
{
    return m_type_;
}

void PhysicalDividerBoundaryElement::setType(::nds::lane::types::PhysicalDividerBoundaryType type_)
{
    m_type_ = type_;
}

::nds::lane::types::PhysicalBoundaryMaterial PhysicalDividerBoundaryElement::getMaterial() const
{
    return m_material_;
}

void PhysicalDividerBoundaryElement::setMaterial(::nds::lane::types::PhysicalBoundaryMaterial material_)
{
    m_material_ = material_;
}

::nds::lane::boundaries::BoundaryWidth PhysicalDividerBoundaryElement::getWidth() const
{
    return m_width_;
}

void PhysicalDividerBoundaryElement::setWidth(::nds::lane::boundaries::BoundaryWidth width_)
{
    m_width_ = width_;
}

void PhysicalDividerBoundaryElement::initPackingContext(PhysicalDividerBoundaryElement::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    ::zserio::initPackingContext(context.getMaterial(), m_material_);
    context.getWidth().init<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(m_width_);
}

size_t PhysicalDividerBoundaryElement::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += ::zserio::bitSizeOf(m_material_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_width_);

    return endBitPosition - bitPosition;
}

size_t PhysicalDividerBoundaryElement::bitSizeOf(PhysicalDividerBoundaryElement::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += ::zserio::bitSizeOf(context.getMaterial(), m_material_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(m_width_);

    return endBitPosition - bitPosition;
}

size_t PhysicalDividerBoundaryElement::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_material_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_width_);

    return endBitPosition;
}

size_t PhysicalDividerBoundaryElement::initializeOffsets(PhysicalDividerBoundaryElement::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = ::zserio::initializeOffsets(context.getMaterial(), endBitPosition,
        m_material_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(m_width_);

    return endBitPosition;
}

bool PhysicalDividerBoundaryElement::operator==(const PhysicalDividerBoundaryElement& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_material_ == other.m_material_) &&
                (m_width_ == other.m_width_);
    }

    return true;
}

uint32_t PhysicalDividerBoundaryElement::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_material_);
    result = ::zserio::calcHashCode(result, m_width_);

    return result;
}

void PhysicalDividerBoundaryElement::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    ::zserio::write(out, m_material_);
    out.writeVarUInt32(m_width_);
}

void PhysicalDividerBoundaryElement::write(PhysicalDividerBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    ::zserio::write(context.getMaterial(), out, m_material_);
    context.getWidth().write<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(out, m_width_);
}

::nds::lane::types::PhysicalDividerBoundaryType PhysicalDividerBoundaryElement::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::PhysicalDividerBoundaryType>(in);
}

::nds::lane::types::PhysicalDividerBoundaryType PhysicalDividerBoundaryElement::readType(PhysicalDividerBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::PhysicalDividerBoundaryType>(context.getType(), in);
}
::nds::lane::types::PhysicalBoundaryMaterial PhysicalDividerBoundaryElement::readMaterial(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::PhysicalBoundaryMaterial>(in);
}

::nds::lane::types::PhysicalBoundaryMaterial PhysicalDividerBoundaryElement::readMaterial(PhysicalDividerBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::PhysicalBoundaryMaterial>(context.getMaterial(), in);
}
::nds::lane::boundaries::BoundaryWidth PhysicalDividerBoundaryElement::readWidth(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::boundaries::BoundaryWidth>(in.readVarUInt32());
}

::nds::lane::boundaries::BoundaryWidth PhysicalDividerBoundaryElement::readWidth(PhysicalDividerBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getWidth().read<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(in);
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/PhysicalMarkingBoundaryElement.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

PhysicalMarkingBoundaryElement::PhysicalMarkingBoundaryElement(const allocator_type&) noexcept :
        m_type_(::nds::lane::types::PhysicalMarkingBoundaryType()),
        m_material_(::nds::lane::types::PhysicalBoundaryMaterial()),
        m_width_(::nds::lane::boundaries::BoundaryWidth())
{
}

PhysicalMarkingBoundaryElement::PhysicalMarkingBoundaryElement(::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(in)),
        m_material_(readMaterial(in)),
        m_width_(readWidth(in))
{
}

PhysicalMarkingBoundaryElement::PhysicalMarkingBoundaryElement(PhysicalMarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(context, in)),
        m_material_(readMaterial(context, in)),
        m_width_(readWidth(context, in))
{
}

PhysicalMarkingBoundaryElement::PhysicalMarkingBoundaryElement(::zserio::PropagateAllocatorT,
        const PhysicalMarkingBoundaryElement& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_material_(::zserio::allocatorPropagatingCopy(other.m_material_, allocator)),
        m_width_(::zserio::allocatorPropagatingCopy(other.m_width_, allocator))
{
}

::nds::lane::types::PhysicalMarkingBoundaryType PhysicalMarkingBoundaryElement::getType() const
{
    return m_type_;
}

void PhysicalMarkingBoundaryElement::setType(::nds::lane::types::PhysicalMarkingBoundaryType type_)
{
    m_type_ = type_;
}

::nds::lane::types::PhysicalBoundaryMaterial PhysicalMarkingBoundaryElement::getMaterial() const
{
    return m_material_;
}

void PhysicalMarkingBoundaryElement::setMaterial(::nds::lane::types::PhysicalBoundaryMaterial material_)
{
    m_material_ = material_;
}

::nds::lane::boundaries::BoundaryWidth PhysicalMarkingBoundaryElement::getWidth() const
{
    return m_width_;
}

void PhysicalMarkingBoundaryElement::setWidth(::nds::lane::boundaries::BoundaryWidth width_)
{
    m_width_ = width_;
}

void PhysicalMarkingBoundaryElement::initPackingContext(PhysicalMarkingBoundaryElement::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    ::zserio::initPackingContext(context.getMaterial(), m_material_);
    context.getWidth().init<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(m_width_);
}

size_t PhysicalMarkingBoundaryElement::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += ::zserio::bitSizeOf(m_material_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_width_);

    return endBitPosition - bitPosition;
}

size_t PhysicalMarkingBoundaryElement::bitSizeOf(PhysicalMarkingBoundaryElement::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += ::zserio::bitSizeOf(context.getMaterial(), m_material_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(m_width_);

    return endBitPosition - bitPosition;
}

size_t PhysicalMarkingBoundaryElement::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_material_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_width_);

    return endBitPosition;
}

size_t PhysicalMarkingBoundaryElement::initializeOffsets(PhysicalMarkingBoundaryElement::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = ::zserio::initializeOffsets(context.getMaterial(), endBitPosition,
        m_material_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(m_width_);

    return endBitPosition;
}

bool PhysicalMarkingBoundaryElement::operator==(const PhysicalMarkingBoundaryElement& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_material_ == other.m_material_) &&
                (m_width_ == other.m_width_);
    }

    return true;
}

uint32_t PhysicalMarkingBoundaryElement::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_material_);
    result = ::zserio::calcHashCode(result, m_width_);

    return result;
}

void PhysicalMarkingBoundaryElement::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    ::zserio::write(out, m_material_);
    out.writeVarUInt32(m_width_);
}

void PhysicalMarkingBoundaryElement::write(PhysicalMarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    ::zserio::write(context.getMaterial(), out, m_material_);
    context.getWidth().write<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(out, m_width_);
}

::nds::lane::types::PhysicalMarkingBoundaryType PhysicalMarkingBoundaryElement::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::PhysicalMarkingBoundaryType>(in);
}

::nds::lane::types::PhysicalMarkingBoundaryType PhysicalMarkingBoundaryElement::readType(PhysicalMarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::PhysicalMarkingBoundaryType>(context.getType(), in);
}
::nds::lane::types::PhysicalBoundaryMaterial PhysicalMarkingBoundaryElement::readMaterial(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::PhysicalBoundaryMaterial>(in);
}

::nds::lane::types::PhysicalBoundaryMaterial PhysicalMarkingBoundaryElement::readMaterial(PhysicalMarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::types::PhysicalBoundaryMaterial>(context.getMaterial(), in);
}
::nds::lane::boundaries::BoundaryWidth PhysicalMarkingBoundaryElement::readWidth(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::boundaries::BoundaryWidth>(in.readVarUInt32());
}

::nds::lane::boundaries::BoundaryWidth PhysicalMarkingBoundaryElement::readWidth(PhysicalMarkingBoundaryElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getWidth().read<::zserio::VarIntNNArrayTraits<::nds::lane::boundaries::BoundaryWidth>>(in);
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/BoundarySet.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

BoundarySet::BoundarySet(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_startPosition_(::nds::lane::reference::types::LaneGeometryPosition()),
        m_boundariesWithStartPosition_(::zserio::NullOpt),
        m_boundaryTypes_(::zserio::NullOpt)
{
}

BoundarySet::BoundarySet(::zserio::BitStreamReader& in,
        bool hasGeometry_, const allocator_type& allocator) :
        m_hasGeometry_(hasGeometry_),
        m_isInitialized(true),
        m_startPosition_(readStartPosition(in)),
        m_boundariesWithStartPosition_(readBoundariesWithStartPosition(in, allocator)),
        m_boundaryTypes_(readBoundaryTypes(in, allocator))
{
}

BoundarySet::BoundarySet(BoundarySet::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool hasGeometry_, const allocator_type& allocator) :
        m_hasGeometry_(hasGeometry_),
        m_isInitialized(true),
        m_startPosition_(readStartPosition(context, in)),
        m_boundariesWithStartPosition_(readBoundariesWithStartPosition(context, in, allocator)),
        m_boundaryTypes_(readBoundaryTypes(context, in, allocator))
{
}

BoundarySet::BoundarySet(const BoundarySet& other) :
        m_startPosition_(other.m_startPosition_),
        m_boundariesWithStartPosition_(other.m_boundariesWithStartPosition_),
        m_boundaryTypes_(other.m_boundaryTypes_)
{
    if (other.m_isInitialized)
        initialize(other.m_hasGeometry_);
    else
        m_isInitialized = false;
}

BoundarySet& BoundarySet::operator=(const BoundarySet& other)
{
    m_startPosition_ = other.m_startPosition_;
    m_boundariesWithStartPosition_ = other.m_boundariesWithStartPosition_;
    m_boundaryTypes_ = other.m_boundaryTypes_;
    if (other.m_isInitialized)
        initialize(other.m_hasGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

BoundarySet::BoundarySet(BoundarySet&& other) :
        m_startPosition_(::std::move(other.m_startPosition_)),
        m_boundariesWithStartPosition_(::std::move(other.m_boundariesWithStartPosition_)),
        m_boundaryTypes_(::std::move(other.m_boundaryTypes_))
{
    if (other.m_isInitialized)
        initialize(other.m_hasGeometry_);
    else
        m_isInitialized = false;
}

BoundarySet& BoundarySet::operator=(BoundarySet&& other)
{
    m_startPosition_ = ::std::move(other.m_startPosition_);
    m_boundariesWithStartPosition_ = ::std::move(other.m_boundariesWithStartPosition_);
    m_boundaryTypes_ = ::std::move(other.m_boundaryTypes_);
    if (other.m_isInitialized)
        initialize(other.m_hasGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

BoundarySet::BoundarySet(::zserio::PropagateAllocatorT,
        const BoundarySet& other, const allocator_type& allocator) :
        m_startPosition_(::zserio::allocatorPropagatingCopy(other.m_startPosition_, allocator)),
        m_boundariesWithStartPosition_(::zserio::allocatorPropagatingCopy(other.m_boundariesWithStartPosition_, allocator)),
        m_boundaryTypes_(::zserio::allocatorPropagatingCopy(other.m_boundaryTypes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_hasGeometry_);
    else
        m_isInitialized = false;
}

void BoundarySet::initialize(
        bool hasGeometry_)
{
    m_hasGeometry_ = hasGeometry_;
    m_isInitialized = true;
}

bool BoundarySet::isInitialized() const
{
    return m_isInitialized;
}

bool BoundarySet::getHasGeometry() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasGeometry' of compound 'BoundarySet' is not initialized!");

    return m_hasGeometry_;
}

::nds::lane::reference::types::LaneGeometryPosition BoundarySet::getStartPosition() const
{
    return m_startPosition_;
}

void BoundarySet::setStartPosition(::nds::lane::reference::types::LaneGeometryPosition startPosition_)
{
    m_startPosition_ = startPosition_;
}

::zserio::vector<::nds::lane::boundaries::BoundaryReferenceWithPosition>& BoundarySet::getBoundariesWithStartPosition()
{
    return m_boundariesWithStartPosition_.value().getRawArray();
}

const ::zserio::vector<::nds::lane::boundaries::BoundaryReferenceWithPosition>& BoundarySet::getBoundariesWithStartPosition() const
{
    return m_boundariesWithStartPosition_.value().getRawArray();
}

void BoundarySet::setBoundariesWithStartPosition(const ::zserio::vector<::nds::lane::boundaries::BoundaryReferenceWithPosition>& boundariesWithStartPosition_)
{
    m_boundariesWithStartPosition_ = ZserioArrayType_boundariesWithStartPosition(boundariesWithStartPosition_);
}

void BoundarySet::setBoundariesWithStartPosition(::zserio::vector<::nds::lane::boundaries::BoundaryReferenceWithPosition>&& boundariesWithStartPosition_)
{
    m_boundariesWithStartPosition_ = ZserioArrayType_boundariesWithStartPosition(std::move(boundariesWithStartPosition_));
}

bool BoundarySet::isBoundariesWithStartPositionUsed() const
{
    return (getHasGeometry());
}

bool BoundarySet::isBoundariesWithStartPositionSet() const
{
    return m_boundariesWithStartPosition_.hasValue();
}

void BoundarySet::resetBoundariesWithStartPosition()
{
    m_boundariesWithStartPosition_.reset();
}

::zserio::vector<::nds::lane::boundaries::BoundaryElementId>& BoundarySet::getBoundaryTypes()
{
    return m_boundaryTypes_.value().getRawArray();
}

const ::zserio::vector<::nds::lane::boundaries::BoundaryElementId>& BoundarySet::getBoundaryTypes() const
{
    return m_boundaryTypes_.value().getRawArray();
}

void BoundarySet::setBoundaryTypes(const ::zserio::vector<::nds::lane::boundaries::BoundaryElementId>& boundaryTypes_)
{
    m_boundaryTypes_ = ZserioArrayType_boundaryTypes(boundaryTypes_);
}

void BoundarySet::setBoundaryTypes(::zserio::vector<::nds::lane::boundaries::BoundaryElementId>&& boundaryTypes_)
{
    m_boundaryTypes_ = ZserioArrayType_boundaryTypes(std::move(boundaryTypes_));
}

bool BoundarySet::isBoundaryTypesUsed() const
{
    return (!getHasGeometry());
}

bool BoundarySet::isBoundaryTypesSet() const
{
    return m_boundaryTypes_.hasValue();
}

void BoundarySet::resetBoundaryTypes()
{
    m_boundaryTypes_.reset();
}

void BoundarySet::initPackingContext(BoundarySet::ZserioPackingContext& context) const
{
    context.getStartPosition().init<::zserio::VarSizeArrayTraits>(m_startPosition_);
}

size_t BoundarySet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_startPosition_);
    if (getHasGeometry())
    {
        endBitPosition += m_boundariesWithStartPosition_.value().bitSizeOf(*this, endBitPosition);
    }
    if (!getHasGeometry())
    {
        endBitPosition += m_boundaryTypes_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t BoundarySet::bitSizeOf(BoundarySet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startPosition_);
    if (getHasGeometry())
    {
        endBitPosition += m_boundariesWithStartPosition_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    if (!getHasGeometry())
    {
        endBitPosition += m_boundaryTypes_.value().bitSizeOfPacked(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t BoundarySet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_startPosition_);
    if (getHasGeometry())
    {
        endBitPosition = m_boundariesWithStartPosition_.value().initializeOffsets(*this, endBitPosition);
    }
    if (!getHasGeometry())
    {
        endBitPosition = m_boundaryTypes_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t BoundarySet::initializeOffsets(BoundarySet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startPosition_);
    if (getHasGeometry())
    {
        endBitPosition = m_boundariesWithStartPosition_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    if (!getHasGeometry())
    {
        endBitPosition = m_boundaryTypes_.value().initializeOffsetsPacked(endBitPosition);
    }

    return endBitPosition;
}

bool BoundarySet::operator==(const BoundarySet& other) const
{
    if (this != &other)
    {
        return
                (getHasGeometry() == other.getHasGeometry()) &&
                (m_startPosition_ == other.m_startPosition_) &&
                (!isBoundariesWithStartPositionUsed() ? !other.isBoundariesWithStartPositionUsed() : (m_boundariesWithStartPosition_ == other.m_boundariesWithStartPosition_)) &&
                (!isBoundaryTypesUsed() ? !other.isBoundaryTypesUsed() : (m_boundaryTypes_ == other.m_boundaryTypes_));
    }

    return true;
}

uint32_t BoundarySet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHasGeometry());
    result = ::zserio::calcHashCode(result, m_startPosition_);
    if (isBoundariesWithStartPositionUsed())
        result = ::zserio::calcHashCode(result, m_boundariesWithStartPosition_);
    if (isBoundaryTypesUsed())
        result = ::zserio::calcHashCode(result, m_boundaryTypes_);

    return result;
}

void BoundarySet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_startPosition_);
    if (getHasGeometry())
    {
        m_boundariesWithStartPosition_.value().write(*this, out);
    }
    if (!getHasGeometry())
    {
        m_boundaryTypes_.value().write(out);
    }
}

void BoundarySet::write(BoundarySet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getStartPosition().write<::zserio::VarSizeArrayTraits>(out, m_startPosition_);
    if (getHasGeometry())
    {
        m_boundariesWithStartPosition_.value().writePacked(*this, out);
    }
    if (!getHasGeometry())
    {
        m_boundaryTypes_.value().writePacked(out);
    }
}

void BoundarySet::ZserioElementFactory_boundariesWithStartPosition::create(BoundarySet&        ,
        ::zserio::vector<::nds::lane::boundaries::BoundaryReferenceWithPosition>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void BoundarySet::ZserioElementFactory_boundariesWithStartPosition::create(BoundarySet&        ,
        ::zserio::vector<::nds::lane::boundaries::BoundaryReferenceWithPosition>& array,
        ::nds::lane::boundaries::BoundaryReferenceWithPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::lane::reference::types::LaneGeometryPosition BoundarySet::readStartPosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::reference::types::LaneGeometryPosition>(in.readVarSize());
}

::nds::lane::reference::types::LaneGeometryPosition BoundarySet::readStartPosition(BoundarySet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStartPosition().read<::zserio::VarSizeArrayTraits>(in);
}
::zserio::InplaceOptionalHolder<BoundarySet::ZserioArrayType_boundariesWithStartPosition> BoundarySet::readBoundariesWithStartPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasGeometry())
    {
        ZserioArrayType_boundariesWithStartPosition readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_boundariesWithStartPosition>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_boundariesWithStartPosition>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<BoundarySet::ZserioArrayType_boundariesWithStartPosition> BoundarySet::readBoundariesWithStartPosition(BoundarySet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasGeometry())
    {
        ZserioArrayType_boundariesWithStartPosition readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_boundariesWithStartPosition>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_boundariesWithStartPosition>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<BoundarySet::ZserioArrayType_boundaryTypes> BoundarySet::readBoundaryTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getHasGeometry())
    {
        ZserioArrayType_boundaryTypes readField(allocator);
        readField.read(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_boundaryTypes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_boundaryTypes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<BoundarySet::ZserioArrayType_boundaryTypes> BoundarySet::readBoundaryTypes(BoundarySet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getHasGeometry())
    {
        ZserioArrayType_boundaryTypes readField(allocator);
        readField.readPacked(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_boundaryTypes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_boundaryTypes>(::zserio::NullOpt);
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/BoundaryReferenceWithPosition.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

BoundaryReferenceWithPosition::BoundaryReferenceWithPosition(const allocator_type& allocator) noexcept :
        m_reference_(allocator),
        m_position_(::nds::lane::boundaries::BoundaryGeometryPosition())
{
}

BoundaryReferenceWithPosition::BoundaryReferenceWithPosition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_reference_(readReference(in, allocator)),
        m_position_(readPosition(in))
{
}

BoundaryReferenceWithPosition::BoundaryReferenceWithPosition(BoundaryReferenceWithPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_reference_(readReference(context, in, allocator)),
        m_position_(readPosition(context, in))
{
}

BoundaryReferenceWithPosition::BoundaryReferenceWithPosition(::zserio::PropagateAllocatorT,
        const BoundaryReferenceWithPosition& other, const allocator_type& allocator) :
        m_reference_(::zserio::allocatorPropagatingCopy(other.m_reference_, allocator)),
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator))
{
}

::nds::lane::boundaries::BoundaryReference& BoundaryReferenceWithPosition::getReference()
{
    return m_reference_;
}

const ::nds::lane::boundaries::BoundaryReference& BoundaryReferenceWithPosition::getReference() const
{
    return m_reference_;
}

void BoundaryReferenceWithPosition::setReference(const ::nds::lane::boundaries::BoundaryReference& reference_)
{
    m_reference_ = reference_;
}

void BoundaryReferenceWithPosition::setReference(::nds::lane::boundaries::BoundaryReference&& reference_)
{
    m_reference_ = ::std::move(reference_);
}

::nds::lane::boundaries::BoundaryGeometryPosition BoundaryReferenceWithPosition::getPosition() const
{
    return m_position_;
}

void BoundaryReferenceWithPosition::setPosition(::nds::lane::boundaries::BoundaryGeometryPosition position_)
{
    m_position_ = position_;
}

void BoundaryReferenceWithPosition::initPackingContext(BoundaryReferenceWithPosition::ZserioPackingContext& context) const
{
    m_reference_.initPackingContext(context.getReference());
    context.getPosition().init<::zserio::VarSizeArrayTraits>(m_position_);
}

size_t BoundaryReferenceWithPosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_reference_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_position_);

    return endBitPosition - bitPosition;
}

size_t BoundaryReferenceWithPosition::bitSizeOf(BoundaryReferenceWithPosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_reference_.bitSizeOf(context.getReference(), endBitPosition);
    endBitPosition += context.getPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_position_);

    return endBitPosition - bitPosition;
}

size_t BoundaryReferenceWithPosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_reference_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_position_);

    return endBitPosition;
}

size_t BoundaryReferenceWithPosition::initializeOffsets(BoundaryReferenceWithPosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_reference_.initializeOffsets(context.getReference(), endBitPosition);
    endBitPosition += context.getPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_position_);

    return endBitPosition;
}

bool BoundaryReferenceWithPosition::operator==(const BoundaryReferenceWithPosition& other) const
{
    if (this != &other)
    {
        return
                (m_reference_ == other.m_reference_) &&
                (m_position_ == other.m_position_);
    }

    return true;
}

uint32_t BoundaryReferenceWithPosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_reference_);
    result = ::zserio::calcHashCode(result, m_position_);

    return result;
}

void BoundaryReferenceWithPosition::write(::zserio::BitStreamWriter& out) const
{
    m_reference_.write(out);
    out.writeVarSize(m_position_);
}

void BoundaryReferenceWithPosition::write(BoundaryReferenceWithPosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_reference_.write(context.getReference(), out);
    context.getPosition().write<::zserio::VarSizeArrayTraits>(out, m_position_);
}

::nds::lane::boundaries::BoundaryReference BoundaryReferenceWithPosition::readReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryReference(in, allocator);
}

::nds::lane::boundaries::BoundaryReference BoundaryReferenceWithPosition::readReference(BoundaryReferenceWithPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::boundaries::BoundaryReference(context.getReference(), in, allocator);
}
::nds::lane::boundaries::BoundaryGeometryPosition BoundaryReferenceWithPosition::readPosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::boundaries::BoundaryGeometryPosition>(in.readVarSize());
}

::nds::lane::boundaries::BoundaryGeometryPosition BoundaryReferenceWithPosition::readPosition(BoundaryReferenceWithPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getPosition().read<::zserio::VarSizeArrayTraits>(in);
}

} // namespace boundaries
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/boundaries/BoundaryElementDetails.h>

namespace nds
{
namespace lane
{
namespace boundaries
{

BoundaryElementDetails::BoundaryElementDetails(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

BoundaryElementDetails::BoundaryElementDetails(::zserio::BitStreamReader& in,
        ::nds::lane::types::BoundaryElementType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

BoundaryElementDetails::BoundaryElementDetails(BoundaryElementDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::lane::types::BoundaryElementType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

BoundaryElementDetails::BoundaryElementDetails(const BoundaryElementDetails& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

BoundaryElementDetails& BoundaryElementDetails::operator=(const BoundaryElementDetails& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

BoundaryElementDetails::BoundaryElementDetails(BoundaryElementDetails&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

BoundaryElementDetails& BoundaryElementDetails::operator=(BoundaryElementDetails&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

BoundaryElementDetails::BoundaryElementDetails(::zserio::PropagateAllocatorT,
        const BoundaryElementDetails& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void BoundaryElementDetails::initialize(
        ::nds::lane::types::BoundaryElementType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool BoundaryElementDetails::isInitialized() const
{
    return m_isInitialized;
}

::nds::lane::types::BoundaryElementType BoundaryElementDetails::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'BoundaryElementDetails' is not initialized!");

    return m_type_;
}

::nds::lane::boundaries::LogicalBoundaryElement& BoundaryElementDetails::getLogicalElement()
{
    return m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>();
}

const ::nds::lane::boundaries::LogicalBoundaryElement& BoundaryElementDetails::getLogicalElement() const
{
    return m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>();
}

void BoundaryElementDetails::setLogicalElement(const ::nds::lane::boundaries::LogicalBoundaryElement& logicalElement_)
{
    m_objectChoice = logicalElement_;
}

void BoundaryElementDetails::setLogicalElement(::nds::lane::boundaries::LogicalBoundaryElement&& logicalElement_)
{
    m_objectChoice = ::std::move(logicalElement_);
}

::nds::lane::boundaries::MarkingBoundaryElement& BoundaryElementDetails::getMarkingElement()
{
    return m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>();
}

const ::nds::lane::boundaries::MarkingBoundaryElement& BoundaryElementDetails::getMarkingElement() const
{
    return m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>();
}

void BoundaryElementDetails::setMarkingElement(const ::nds::lane::boundaries::MarkingBoundaryElement& markingElement_)
{
    m_objectChoice = markingElement_;
}

void BoundaryElementDetails::setMarkingElement(::nds::lane::boundaries::MarkingBoundaryElement&& markingElement_)
{
    m_objectChoice = ::std::move(markingElement_);
}

::nds::lane::boundaries::PhysicalDividerBoundaryElement& BoundaryElementDetails::getPhysicalDividerElement()
{
    return m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>();
}

const ::nds::lane::boundaries::PhysicalDividerBoundaryElement& BoundaryElementDetails::getPhysicalDividerElement() const
{
    return m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>();
}

void BoundaryElementDetails::setPhysicalDividerElement(const ::nds::lane::boundaries::PhysicalDividerBoundaryElement& physicalDividerElement_)
{
    m_objectChoice = physicalDividerElement_;
}

void BoundaryElementDetails::setPhysicalDividerElement(::nds::lane::boundaries::PhysicalDividerBoundaryElement&& physicalDividerElement_)
{
    m_objectChoice = ::std::move(physicalDividerElement_);
}

::nds::lane::boundaries::PhysicalMarkingBoundaryElement& BoundaryElementDetails::getPhysicalMarkingElement()
{
    return m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>();
}

const ::nds::lane::boundaries::PhysicalMarkingBoundaryElement& BoundaryElementDetails::getPhysicalMarkingElement() const
{
    return m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>();
}

void BoundaryElementDetails::setPhysicalMarkingElement(const ::nds::lane::boundaries::PhysicalMarkingBoundaryElement& physicalMarkingElement_)
{
    m_objectChoice = physicalMarkingElement_;
}

void BoundaryElementDetails::setPhysicalMarkingElement(::nds::lane::boundaries::PhysicalMarkingBoundaryElement&& physicalMarkingElement_)
{
    m_objectChoice = ::std::move(physicalMarkingElement_);
}

BoundaryElementDetails::ChoiceTag BoundaryElementDetails::choiceTag() const
{
    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        return CHOICE_logicalElement;
    case ::nds::lane::types::BoundaryElementType::MARKING:
        return CHOICE_markingElement;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        return CHOICE_physicalDividerElement;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        return CHOICE_physicalMarkingElement;
    default:
        return UNDEFINED_CHOICE;
    }
}

void BoundaryElementDetails::initPackingContext(BoundaryElementDetails::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>().initPackingContext(context.getLogicalElement());
        break;
    case ::nds::lane::types::BoundaryElementType::MARKING:
        m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>().initPackingContext(context.getMarkingElement());
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>().initPackingContext(context.getPhysicalDividerElement());
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>().initPackingContext(context.getPhysicalMarkingElement());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }
}

size_t BoundaryElementDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        endBitPosition += m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::MARKING:
        endBitPosition += m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        endBitPosition += m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        endBitPosition += m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }

    return endBitPosition - bitPosition;
}

size_t BoundaryElementDetails::bitSizeOf(BoundaryElementDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        endBitPosition += m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>().bitSizeOf(context.getLogicalElement(), endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::MARKING:
        endBitPosition += m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>().bitSizeOf(context.getMarkingElement(), endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        endBitPosition += m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>().bitSizeOf(context.getPhysicalDividerElement(), endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        endBitPosition += m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>().bitSizeOf(context.getPhysicalMarkingElement(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }

    return endBitPosition - bitPosition;
}

size_t BoundaryElementDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        endBitPosition = m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::MARKING:
        endBitPosition = m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        endBitPosition = m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        endBitPosition = m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }

    return endBitPosition;
}

size_t BoundaryElementDetails::initializeOffsets(BoundaryElementDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        endBitPosition = m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>().initializeOffsets(context.getLogicalElement(), endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::MARKING:
        endBitPosition = m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>().initializeOffsets(context.getMarkingElement(), endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        endBitPosition = m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>().initializeOffsets(context.getPhysicalDividerElement(), endBitPosition);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        endBitPosition = m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>().initializeOffsets(context.getPhysicalMarkingElement(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }

    return endBitPosition;
}

bool BoundaryElementDetails::operator==(const BoundaryElementDetails& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>() == other.m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>());
    case ::nds::lane::types::BoundaryElementType::MARKING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>() == other.m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>());
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>() == other.m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>());
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>() == other.m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }
}

uint32_t BoundaryElementDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::lane::types::BoundaryElementType::LOGICAL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>());
            break;
        case ::nds::lane::types::BoundaryElementType::MARKING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>());
            break;
        case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>());
            break;
        case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>());
            break;
        default:
            break;
        }
    }

    return result;
}

void BoundaryElementDetails::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>().write(out);
        break;
    case ::nds::lane::types::BoundaryElementType::MARKING:
        m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>().write(out);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>().write(out);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }
}

void BoundaryElementDetails::write(BoundaryElementDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        m_objectChoice.get<::nds::lane::boundaries::LogicalBoundaryElement>().write(context.getLogicalElement(), out);
        break;
    case ::nds::lane::types::BoundaryElementType::MARKING:
        m_objectChoice.get<::nds::lane::boundaries::MarkingBoundaryElement>().write(context.getMarkingElement(), out);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        m_objectChoice.get<::nds::lane::boundaries::PhysicalDividerBoundaryElement>().write(context.getPhysicalDividerElement(), out);
        break;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        m_objectChoice.get<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>().write(context.getPhysicalMarkingElement(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }
}

::zserio::AnyHolder<> BoundaryElementDetails::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        return ::zserio::AnyHolder<>(::nds::lane::boundaries::LogicalBoundaryElement(in, allocator), allocator);
    case ::nds::lane::types::BoundaryElementType::MARKING:
        return ::zserio::AnyHolder<>(::nds::lane::boundaries::MarkingBoundaryElement(in, allocator), allocator);
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        return ::zserio::AnyHolder<>(::nds::lane::boundaries::PhysicalDividerBoundaryElement(in, allocator), allocator);
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        return ::zserio::AnyHolder<>(::nds::lane::boundaries::PhysicalMarkingBoundaryElement(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }
}

::zserio::AnyHolder<> BoundaryElementDetails::readObject(BoundaryElementDetails::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        return ::zserio::AnyHolder<>(::nds::lane::boundaries::LogicalBoundaryElement(context.getLogicalElement(), in, allocator), allocator);
    case ::nds::lane::types::BoundaryElementType::MARKING:
        return ::zserio::AnyHolder<>(::nds::lane::boundaries::MarkingBoundaryElement(context.getMarkingElement(), in, allocator), allocator);
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        return ::zserio::AnyHolder<>(::nds::lane::boundaries::PhysicalDividerBoundaryElement(context.getPhysicalDividerElement(), in, allocator), allocator);
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        return ::zserio::AnyHolder<>(::nds::lane::boundaries::PhysicalMarkingBoundaryElement(context.getPhysicalMarkingElement(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }
}

::zserio::AnyHolder<> BoundaryElementDetails::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::boundaries::LogicalBoundaryElement>(m_objectChoice, allocator);
    case ::nds::lane::types::BoundaryElementType::MARKING:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::boundaries::MarkingBoundaryElement>(m_objectChoice, allocator);
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::boundaries::PhysicalDividerBoundaryElement>(m_objectChoice, allocator);
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::boundaries::PhysicalMarkingBoundaryElement>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice BoundaryElementDetails!");
    }
}

} // namespace boundaries
} // namespace lane
} // namespace nds
