/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/metadata/GeometryLayerType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for GeometryLayerType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::lane::metadata::GeometryLayerType>::names;
constexpr ::std::array<::nds::lane::metadata::GeometryLayerType, 2> EnumTraits<::nds::lane::metadata::GeometryLayerType>::values;
constexpr const char* EnumTraits<::nds::lane::metadata::GeometryLayerType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::metadata::GeometryLayerType value)
{
    switch (value)
    {
    case ::nds::lane::metadata::GeometryLayerType::LANE_GEOMETRY:
        return 0;
    case ::nds::lane::metadata::GeometryLayerType::ROAD_SURFACE:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GeometryLayerType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::metadata::GeometryLayerType>::type>(value) << "!";
    }
}

template <>
::nds::lane::metadata::GeometryLayerType valueToEnum(
        typename ::std::underlying_type<::nds::lane::metadata::GeometryLayerType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::lane::metadata::GeometryLayerType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GeometryLayerType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::metadata::GeometryLayerType>(::nds::lane::metadata::GeometryLayerType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::metadata::GeometryLayerType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::metadata::GeometryLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::metadata::GeometryLayerType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::metadata::GeometryLayerType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::metadata::GeometryLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::metadata::GeometryLayerType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::metadata::GeometryLayerType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::metadata::GeometryLayerType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::metadata::GeometryLayerType>(
            static_cast<typename ::std::underlying_type<::nds::lane::metadata::GeometryLayerType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::metadata::GeometryLayerType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::metadata::GeometryLayerType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::metadata::GeometryLayerType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::metadata::GeometryLayerType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::metadata::GeometryLayerType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::metadata::GeometryLayerType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/metadata/BoundaryGeometryUsage.h>

namespace nds
{
namespace lane
{
namespace metadata
{

BoundaryGeometryUsage::BoundaryGeometryUsage(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

BoundaryGeometryUsage::BoundaryGeometryUsage(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

BoundaryGeometryUsage::BoundaryGeometryUsage(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'BoundaryGeometryUsage' out of bounds: ") << value << "!";
}

void BoundaryGeometryUsage::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::lane::metadata::BoundaryGeometryUsage::underlying_type>>(m_value);
}

size_t BoundaryGeometryUsage::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t BoundaryGeometryUsage::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::metadata::BoundaryGeometryUsage::underlying_type>>(m_value);
}

size_t BoundaryGeometryUsage::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t BoundaryGeometryUsage::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t BoundaryGeometryUsage::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void BoundaryGeometryUsage::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void BoundaryGeometryUsage::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::lane::metadata::BoundaryGeometryUsage::underlying_type>>(out, m_value);
}

::zserio::string<> BoundaryGeometryUsage::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & BoundaryGeometryUsage::Values::NOT_USED) == BoundaryGeometryUsage::Values::NOT_USED)
        result += result.empty() ? "NOT_USED" : " | NOT_USED";
    if ((*this & BoundaryGeometryUsage::Values::DISTINCT) == BoundaryGeometryUsage::Values::DISTINCT)
        result += result.empty() ? "DISTINCT" : " | DISTINCT";
    if ((*this & BoundaryGeometryUsage::Values::SHARED) == BoundaryGeometryUsage::Values::SHARED)
        result += result.empty() ? "SHARED" : " | SHARED";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

BoundaryGeometryUsage::underlying_type BoundaryGeometryUsage::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

BoundaryGeometryUsage::underlying_type BoundaryGeometryUsage::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::lane::metadata::BoundaryGeometryUsage::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/metadata/LaneLayerMetadata.h>

namespace nds
{
namespace lane
{
namespace metadata
{

LaneLayerMetadata::LaneLayerMetadata(const allocator_type& allocator) noexcept :
        m_includedRoadTypes_(allocator),
        m_includedLaneGroupTypes_(allocator),
        m_includedLogicalBoundaryTypes_(allocator),
        m_includedMarkingBoundaryTypes_(allocator),
        m_includedPhysicalDividerBoundaryTypes_(allocator),
        m_includedPhysicalMarkingBoundaryTypes_(allocator),
        m_boundaryGeometryUsage_(::nds::lane::metadata::BoundaryGeometryUsage())
{
}

LaneLayerMetadata::LaneLayerMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_includedRoadTypes_(readIncludedRoadTypes(in, allocator)),
        m_includedLaneGroupTypes_(readIncludedLaneGroupTypes(in, allocator)),
        m_includedLogicalBoundaryTypes_(readIncludedLogicalBoundaryTypes(in, allocator)),
        m_includedMarkingBoundaryTypes_(readIncludedMarkingBoundaryTypes(in, allocator)),
        m_includedPhysicalDividerBoundaryTypes_(readIncludedPhysicalDividerBoundaryTypes(in, allocator)),
        m_includedPhysicalMarkingBoundaryTypes_(readIncludedPhysicalMarkingBoundaryTypes(in, allocator)),
        m_boundaryGeometryUsage_(readBoundaryGeometryUsage(in))
{
}

LaneLayerMetadata::LaneLayerMetadata(LaneLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_includedRoadTypes_(readIncludedRoadTypes(context, in, allocator)),
        m_includedLaneGroupTypes_(readIncludedLaneGroupTypes(context, in, allocator)),
        m_includedLogicalBoundaryTypes_(readIncludedLogicalBoundaryTypes(context, in, allocator)),
        m_includedMarkingBoundaryTypes_(readIncludedMarkingBoundaryTypes(context, in, allocator)),
        m_includedPhysicalDividerBoundaryTypes_(readIncludedPhysicalDividerBoundaryTypes(context, in, allocator)),
        m_includedPhysicalMarkingBoundaryTypes_(readIncludedPhysicalMarkingBoundaryTypes(context, in, allocator)),
        m_boundaryGeometryUsage_(readBoundaryGeometryUsage(context, in))
{
}

LaneLayerMetadata::LaneLayerMetadata(::zserio::PropagateAllocatorT,
        const LaneLayerMetadata& other, const allocator_type& allocator) :
        m_includedRoadTypes_(::zserio::allocatorPropagatingCopy(other.m_includedRoadTypes_, allocator)),
        m_includedLaneGroupTypes_(::zserio::allocatorPropagatingCopy(other.m_includedLaneGroupTypes_, allocator)),
        m_includedLogicalBoundaryTypes_(::zserio::allocatorPropagatingCopy(other.m_includedLogicalBoundaryTypes_, allocator)),
        m_includedMarkingBoundaryTypes_(::zserio::allocatorPropagatingCopy(other.m_includedMarkingBoundaryTypes_, allocator)),
        m_includedPhysicalDividerBoundaryTypes_(::zserio::allocatorPropagatingCopy(other.m_includedPhysicalDividerBoundaryTypes_, allocator)),
        m_includedPhysicalMarkingBoundaryTypes_(::zserio::allocatorPropagatingCopy(other.m_includedPhysicalMarkingBoundaryTypes_, allocator)),
        m_boundaryGeometryUsage_(::zserio::allocatorPropagatingCopy(other.m_boundaryGeometryUsage_, allocator))
{
}

::zserio::vector<::nds::core::types::RoadType>& LaneLayerMetadata::getIncludedRoadTypes()
{
    return m_includedRoadTypes_.getRawArray();
}

const ::zserio::vector<::nds::core::types::RoadType>& LaneLayerMetadata::getIncludedRoadTypes() const
{
    return m_includedRoadTypes_.getRawArray();
}

void LaneLayerMetadata::setIncludedRoadTypes(const ::zserio::vector<::nds::core::types::RoadType>& includedRoadTypes_)
{
    m_includedRoadTypes_ = ZserioArrayType_includedRoadTypes(includedRoadTypes_);
}

void LaneLayerMetadata::setIncludedRoadTypes(::zserio::vector<::nds::core::types::RoadType>&& includedRoadTypes_)
{
    m_includedRoadTypes_ = ZserioArrayType_includedRoadTypes(std::move(includedRoadTypes_));
}

::zserio::vector<::nds::lane::lanegroups::LaneGroupType>& LaneLayerMetadata::getIncludedLaneGroupTypes()
{
    return m_includedLaneGroupTypes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanegroups::LaneGroupType>& LaneLayerMetadata::getIncludedLaneGroupTypes() const
{
    return m_includedLaneGroupTypes_.getRawArray();
}

void LaneLayerMetadata::setIncludedLaneGroupTypes(const ::zserio::vector<::nds::lane::lanegroups::LaneGroupType>& includedLaneGroupTypes_)
{
    m_includedLaneGroupTypes_ = ZserioArrayType_includedLaneGroupTypes(includedLaneGroupTypes_);
}

void LaneLayerMetadata::setIncludedLaneGroupTypes(::zserio::vector<::nds::lane::lanegroups::LaneGroupType>&& includedLaneGroupTypes_)
{
    m_includedLaneGroupTypes_ = ZserioArrayType_includedLaneGroupTypes(std::move(includedLaneGroupTypes_));
}

::zserio::vector<::nds::lane::types::LogicalBoundaryType>& LaneLayerMetadata::getIncludedLogicalBoundaryTypes()
{
    return m_includedLogicalBoundaryTypes_.getRawArray();
}

const ::zserio::vector<::nds::lane::types::LogicalBoundaryType>& LaneLayerMetadata::getIncludedLogicalBoundaryTypes() const
{
    return m_includedLogicalBoundaryTypes_.getRawArray();
}

void LaneLayerMetadata::setIncludedLogicalBoundaryTypes(const ::zserio::vector<::nds::lane::types::LogicalBoundaryType>& includedLogicalBoundaryTypes_)
{
    m_includedLogicalBoundaryTypes_ = ZserioArrayType_includedLogicalBoundaryTypes(includedLogicalBoundaryTypes_);
}

void LaneLayerMetadata::setIncludedLogicalBoundaryTypes(::zserio::vector<::nds::lane::types::LogicalBoundaryType>&& includedLogicalBoundaryTypes_)
{
    m_includedLogicalBoundaryTypes_ = ZserioArrayType_includedLogicalBoundaryTypes(std::move(includedLogicalBoundaryTypes_));
}

::zserio::vector<::nds::lane::types::MarkingBoundaryType>& LaneLayerMetadata::getIncludedMarkingBoundaryTypes()
{
    return m_includedMarkingBoundaryTypes_.getRawArray();
}

const ::zserio::vector<::nds::lane::types::MarkingBoundaryType>& LaneLayerMetadata::getIncludedMarkingBoundaryTypes() const
{
    return m_includedMarkingBoundaryTypes_.getRawArray();
}

void LaneLayerMetadata::setIncludedMarkingBoundaryTypes(const ::zserio::vector<::nds::lane::types::MarkingBoundaryType>& includedMarkingBoundaryTypes_)
{
    m_includedMarkingBoundaryTypes_ = ZserioArrayType_includedMarkingBoundaryTypes(includedMarkingBoundaryTypes_);
}

void LaneLayerMetadata::setIncludedMarkingBoundaryTypes(::zserio::vector<::nds::lane::types::MarkingBoundaryType>&& includedMarkingBoundaryTypes_)
{
    m_includedMarkingBoundaryTypes_ = ZserioArrayType_includedMarkingBoundaryTypes(std::move(includedMarkingBoundaryTypes_));
}

::zserio::vector<::nds::lane::types::PhysicalDividerBoundaryType>& LaneLayerMetadata::getIncludedPhysicalDividerBoundaryTypes()
{
    return m_includedPhysicalDividerBoundaryTypes_.getRawArray();
}

const ::zserio::vector<::nds::lane::types::PhysicalDividerBoundaryType>& LaneLayerMetadata::getIncludedPhysicalDividerBoundaryTypes() const
{
    return m_includedPhysicalDividerBoundaryTypes_.getRawArray();
}

void LaneLayerMetadata::setIncludedPhysicalDividerBoundaryTypes(const ::zserio::vector<::nds::lane::types::PhysicalDividerBoundaryType>& includedPhysicalDividerBoundaryTypes_)
{
    m_includedPhysicalDividerBoundaryTypes_ = ZserioArrayType_includedPhysicalDividerBoundaryTypes(includedPhysicalDividerBoundaryTypes_);
}

void LaneLayerMetadata::setIncludedPhysicalDividerBoundaryTypes(::zserio::vector<::nds::lane::types::PhysicalDividerBoundaryType>&& includedPhysicalDividerBoundaryTypes_)
{
    m_includedPhysicalDividerBoundaryTypes_ = ZserioArrayType_includedPhysicalDividerBoundaryTypes(std::move(includedPhysicalDividerBoundaryTypes_));
}

::zserio::vector<::nds::lane::types::PhysicalMarkingBoundaryType>& LaneLayerMetadata::getIncludedPhysicalMarkingBoundaryTypes()
{
    return m_includedPhysicalMarkingBoundaryTypes_.getRawArray();
}

const ::zserio::vector<::nds::lane::types::PhysicalMarkingBoundaryType>& LaneLayerMetadata::getIncludedPhysicalMarkingBoundaryTypes() const
{
    return m_includedPhysicalMarkingBoundaryTypes_.getRawArray();
}

void LaneLayerMetadata::setIncludedPhysicalMarkingBoundaryTypes(const ::zserio::vector<::nds::lane::types::PhysicalMarkingBoundaryType>& includedPhysicalMarkingBoundaryTypes_)
{
    m_includedPhysicalMarkingBoundaryTypes_ = ZserioArrayType_includedPhysicalMarkingBoundaryTypes(includedPhysicalMarkingBoundaryTypes_);
}

void LaneLayerMetadata::setIncludedPhysicalMarkingBoundaryTypes(::zserio::vector<::nds::lane::types::PhysicalMarkingBoundaryType>&& includedPhysicalMarkingBoundaryTypes_)
{
    m_includedPhysicalMarkingBoundaryTypes_ = ZserioArrayType_includedPhysicalMarkingBoundaryTypes(std::move(includedPhysicalMarkingBoundaryTypes_));
}

::nds::lane::metadata::BoundaryGeometryUsage LaneLayerMetadata::getBoundaryGeometryUsage() const
{
    return m_boundaryGeometryUsage_;
}

void LaneLayerMetadata::setBoundaryGeometryUsage(::nds::lane::metadata::BoundaryGeometryUsage boundaryGeometryUsage_)
{
    m_boundaryGeometryUsage_ = boundaryGeometryUsage_;
}

void LaneLayerMetadata::initPackingContext(LaneLayerMetadata::ZserioPackingContext& context) const
{
    m_boundaryGeometryUsage_.initPackingContext(context.getBoundaryGeometryUsage());
}

size_t LaneLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_includedRoadTypes_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_includedLaneGroupTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_includedLogicalBoundaryTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_includedMarkingBoundaryTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_includedPhysicalDividerBoundaryTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_includedPhysicalMarkingBoundaryTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_boundaryGeometryUsage_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLayerMetadata::bitSizeOf(LaneLayerMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_includedRoadTypes_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_includedLaneGroupTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_includedLogicalBoundaryTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_includedMarkingBoundaryTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_includedPhysicalDividerBoundaryTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_includedPhysicalMarkingBoundaryTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_boundaryGeometryUsage_.bitSizeOf(context.getBoundaryGeometryUsage(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_includedRoadTypes_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_includedLaneGroupTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_includedLogicalBoundaryTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_includedMarkingBoundaryTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_includedPhysicalDividerBoundaryTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_includedPhysicalMarkingBoundaryTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_boundaryGeometryUsage_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneLayerMetadata::initializeOffsets(LaneLayerMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_includedRoadTypes_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_includedLaneGroupTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_includedLogicalBoundaryTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_includedMarkingBoundaryTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_includedPhysicalDividerBoundaryTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_includedPhysicalMarkingBoundaryTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_boundaryGeometryUsage_.initializeOffsets(context.getBoundaryGeometryUsage(), endBitPosition);

    return endBitPosition;
}

bool LaneLayerMetadata::operator==(const LaneLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_includedRoadTypes_ == other.m_includedRoadTypes_) &&
                (m_includedLaneGroupTypes_ == other.m_includedLaneGroupTypes_) &&
                (m_includedLogicalBoundaryTypes_ == other.m_includedLogicalBoundaryTypes_) &&
                (m_includedMarkingBoundaryTypes_ == other.m_includedMarkingBoundaryTypes_) &&
                (m_includedPhysicalDividerBoundaryTypes_ == other.m_includedPhysicalDividerBoundaryTypes_) &&
                (m_includedPhysicalMarkingBoundaryTypes_ == other.m_includedPhysicalMarkingBoundaryTypes_) &&
                (m_boundaryGeometryUsage_ == other.m_boundaryGeometryUsage_);
    }

    return true;
}

uint32_t LaneLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_includedRoadTypes_);
    result = ::zserio::calcHashCode(result, m_includedLaneGroupTypes_);
    result = ::zserio::calcHashCode(result, m_includedLogicalBoundaryTypes_);
    result = ::zserio::calcHashCode(result, m_includedMarkingBoundaryTypes_);
    result = ::zserio::calcHashCode(result, m_includedPhysicalDividerBoundaryTypes_);
    result = ::zserio::calcHashCode(result, m_includedPhysicalMarkingBoundaryTypes_);
    result = ::zserio::calcHashCode(result, m_boundaryGeometryUsage_);

    return result;
}

void LaneLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_includedRoadTypes_.write(*this, out);
    m_includedLaneGroupTypes_.write(out);
    m_includedLogicalBoundaryTypes_.write(out);
    m_includedMarkingBoundaryTypes_.write(out);
    m_includedPhysicalDividerBoundaryTypes_.write(out);
    m_includedPhysicalMarkingBoundaryTypes_.write(out);
    m_boundaryGeometryUsage_.write(out);
}

void LaneLayerMetadata::write(LaneLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_includedRoadTypes_.writePacked(*this, out);
    m_includedLaneGroupTypes_.writePacked(out);
    m_includedLogicalBoundaryTypes_.writePacked(out);
    m_includedMarkingBoundaryTypes_.writePacked(out);
    m_includedPhysicalDividerBoundaryTypes_.writePacked(out);
    m_includedPhysicalMarkingBoundaryTypes_.writePacked(out);
    m_boundaryGeometryUsage_.write(context.getBoundaryGeometryUsage(), out);
}

void LaneLayerMetadata::ZserioElementFactory_includedRoadTypes::create(LaneLayerMetadata&        ,
        ::zserio::vector<::nds::core::types::RoadType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneLayerMetadata::ZserioElementFactory_includedRoadTypes::create(LaneLayerMetadata&        ,
        ::zserio::vector<::nds::core::types::RoadType>& array,
        ::nds::core::types::RoadType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

LaneLayerMetadata::ZserioArrayType_includedRoadTypes LaneLayerMetadata::readIncludedRoadTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_includedRoadTypes readField(allocator);
    readField.read(*this, in);

    return readField;
}

LaneLayerMetadata::ZserioArrayType_includedRoadTypes LaneLayerMetadata::readIncludedRoadTypes(LaneLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_includedRoadTypes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
LaneLayerMetadata::ZserioArrayType_includedLaneGroupTypes LaneLayerMetadata::readIncludedLaneGroupTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_includedLaneGroupTypes readField(allocator);
    readField.read(in);

    return readField;
}

LaneLayerMetadata::ZserioArrayType_includedLaneGroupTypes LaneLayerMetadata::readIncludedLaneGroupTypes(LaneLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_includedLaneGroupTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
LaneLayerMetadata::ZserioArrayType_includedLogicalBoundaryTypes LaneLayerMetadata::readIncludedLogicalBoundaryTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_includedLogicalBoundaryTypes readField(allocator);
    readField.read(in);

    return readField;
}

LaneLayerMetadata::ZserioArrayType_includedLogicalBoundaryTypes LaneLayerMetadata::readIncludedLogicalBoundaryTypes(LaneLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_includedLogicalBoundaryTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
LaneLayerMetadata::ZserioArrayType_includedMarkingBoundaryTypes LaneLayerMetadata::readIncludedMarkingBoundaryTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_includedMarkingBoundaryTypes readField(allocator);
    readField.read(in);

    return readField;
}

LaneLayerMetadata::ZserioArrayType_includedMarkingBoundaryTypes LaneLayerMetadata::readIncludedMarkingBoundaryTypes(LaneLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_includedMarkingBoundaryTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
LaneLayerMetadata::ZserioArrayType_includedPhysicalDividerBoundaryTypes LaneLayerMetadata::readIncludedPhysicalDividerBoundaryTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_includedPhysicalDividerBoundaryTypes readField(allocator);
    readField.read(in);

    return readField;
}

LaneLayerMetadata::ZserioArrayType_includedPhysicalDividerBoundaryTypes LaneLayerMetadata::readIncludedPhysicalDividerBoundaryTypes(LaneLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_includedPhysicalDividerBoundaryTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
LaneLayerMetadata::ZserioArrayType_includedPhysicalMarkingBoundaryTypes LaneLayerMetadata::readIncludedPhysicalMarkingBoundaryTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_includedPhysicalMarkingBoundaryTypes readField(allocator);
    readField.read(in);

    return readField;
}

LaneLayerMetadata::ZserioArrayType_includedPhysicalMarkingBoundaryTypes LaneLayerMetadata::readIncludedPhysicalMarkingBoundaryTypes(LaneLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_includedPhysicalMarkingBoundaryTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
::nds::lane::metadata::BoundaryGeometryUsage LaneLayerMetadata::readBoundaryGeometryUsage(::zserio::BitStreamReader& in)
{
    return ::nds::lane::metadata::BoundaryGeometryUsage(in);
}

::nds::lane::metadata::BoundaryGeometryUsage LaneLayerMetadata::readBoundaryGeometryUsage(LaneLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::lane::metadata::BoundaryGeometryUsage(context.getBoundaryGeometryUsage(), in);
}

} // namespace metadata
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/metadata/GeometryLayerMetadata.h>

namespace nds
{
namespace lane
{
namespace metadata
{

GeometryLayerMetadata::GeometryLayerMetadata(const allocator_type&) noexcept :
        m_layerType_(::nds::lane::metadata::GeometryLayerType())
{
}

GeometryLayerMetadata::GeometryLayerMetadata(::zserio::BitStreamReader& in, const allocator_type&) :
        m_layerType_(readLayerType(in))
{
}

GeometryLayerMetadata::GeometryLayerMetadata(GeometryLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_layerType_(readLayerType(context, in))
{
}

GeometryLayerMetadata::GeometryLayerMetadata(::zserio::PropagateAllocatorT,
        const GeometryLayerMetadata& other, const allocator_type& allocator) :
        m_layerType_(::zserio::allocatorPropagatingCopy(other.m_layerType_, allocator))
{
}

::nds::lane::metadata::GeometryLayerType GeometryLayerMetadata::getLayerType() const
{
    return m_layerType_;
}

void GeometryLayerMetadata::setLayerType(::nds::lane::metadata::GeometryLayerType layerType_)
{
    m_layerType_ = layerType_;
}

void GeometryLayerMetadata::initPackingContext(GeometryLayerMetadata::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getLayerType(), m_layerType_);
}

size_t GeometryLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_layerType_);

    return endBitPosition - bitPosition;
}

size_t GeometryLayerMetadata::bitSizeOf(GeometryLayerMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getLayerType(), m_layerType_);

    return endBitPosition - bitPosition;
}

size_t GeometryLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_layerType_);

    return endBitPosition;
}

size_t GeometryLayerMetadata::initializeOffsets(GeometryLayerMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getLayerType(), endBitPosition,
        m_layerType_);

    return endBitPosition;
}

bool GeometryLayerMetadata::operator==(const GeometryLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_layerType_ == other.m_layerType_);
    }

    return true;
}

uint32_t GeometryLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_layerType_);

    return result;
}

void GeometryLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_layerType_);
}

void GeometryLayerMetadata::write(GeometryLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getLayerType(), out, m_layerType_);
}

::nds::lane::metadata::GeometryLayerType GeometryLayerMetadata::readLayerType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::metadata::GeometryLayerType>(in);
}

::nds::lane::metadata::GeometryLayerType GeometryLayerMetadata::readLayerType(GeometryLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::metadata::GeometryLayerType>(context.getLayerType(), in);
}

} // namespace metadata
} // namespace lane
} // namespace nds
