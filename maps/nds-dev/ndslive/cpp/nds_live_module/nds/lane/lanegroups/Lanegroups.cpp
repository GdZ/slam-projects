/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/lanegroups/LaneGroupType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneGroupType enumeration.
constexpr ::std::array<const char*, 6> EnumTraits<::nds::lane::lanegroups::LaneGroupType>::names;
constexpr ::std::array<::nds::lane::lanegroups::LaneGroupType, 6> EnumTraits<::nds::lane::lanegroups::LaneGroupType>::values;
constexpr const char* EnumTraits<::nds::lane::lanegroups::LaneGroupType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::lanegroups::LaneGroupType value)
{
    switch (value)
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        return 0;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        return 1;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        return 2;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        return 3;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        return 4;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        return 5;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneGroupType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::lanegroups::LaneGroupType>::type>(value) << "!";
    }
}

template <>
::nds::lane::lanegroups::LaneGroupType valueToEnum(
        typename ::std::underlying_type<::nds::lane::lanegroups::LaneGroupType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
        return static_cast<::nds::lane::lanegroups::LaneGroupType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneGroupType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::lanegroups::LaneGroupType>(::nds::lane::lanegroups::LaneGroupType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::lanegroups::LaneGroupType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::lanegroups::LaneGroupType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::lanegroups::LaneGroupType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::lanegroups::LaneGroupType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::lanegroups::LaneGroupType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::lanegroups::LaneGroupType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::lanegroups::LaneGroupType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::lanegroups::LaneGroupType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::lanegroups::LaneGroupType>(
            static_cast<typename ::std::underlying_type<::nds::lane::lanegroups::LaneGroupType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::lanegroups::LaneGroupType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::lanegroups::LaneGroupType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::lanegroups::LaneGroupType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::lanegroups::LaneGroupType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::lanegroups::LaneGroupType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::lanegroups::LaneGroupType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/lanegroups/LaneGroup.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

LaneGroup::LaneGroup(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_id_(allocator),
        m_type_(::nds::lane::lanegroups::LaneGroupType()),
        m_hasBoundaryGeometry_(bool()),
        m_laneGroup_(allocator)
{
}

LaneGroup::LaneGroup(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_id_(readId(in, allocator)),
        m_type_(readType(in)),
        m_hasBoundaryGeometry_(readHasBoundaryGeometry(in)),
        m_laneGroup_(readLaneGroup(in, allocator))
{
}

LaneGroup::LaneGroup(LaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_id_(readId(context, in, allocator)),
        m_type_(readType(context, in)),
        m_hasBoundaryGeometry_(readHasBoundaryGeometry(in)),
        m_laneGroup_(readLaneGroup(context, in, allocator))
{
}

LaneGroup::LaneGroup(const LaneGroup& other) :
        m_id_(other.m_id_),
        m_type_(other.m_type_),
        m_hasBoundaryGeometry_(other.m_hasBoundaryGeometry_),
        m_laneGroup_(other.m_laneGroup_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneGroup& LaneGroup::operator=(const LaneGroup& other)
{
    m_id_ = other.m_id_;
    m_type_ = other.m_type_;
    m_hasBoundaryGeometry_ = other.m_hasBoundaryGeometry_;
    m_laneGroup_ = other.m_laneGroup_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneGroup::LaneGroup(LaneGroup&& other) :
        m_id_(::std::move(other.m_id_)),
        m_type_(::std::move(other.m_type_)),
        m_hasBoundaryGeometry_(::std::move(other.m_hasBoundaryGeometry_)),
        m_laneGroup_(::std::move(other.m_laneGroup_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneGroup& LaneGroup::operator=(LaneGroup&& other)
{
    m_id_ = ::std::move(other.m_id_);
    m_type_ = ::std::move(other.m_type_);
    m_hasBoundaryGeometry_ = ::std::move(other.m_hasBoundaryGeometry_);
    m_laneGroup_ = ::std::move(other.m_laneGroup_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneGroup::LaneGroup(::zserio::PropagateAllocatorT,
        const LaneGroup& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_hasBoundaryGeometry_(::zserio::allocatorPropagatingCopy(other.m_hasBoundaryGeometry_, allocator)),
        m_laneGroup_(::zserio::allocatorPropagatingCopy(other.m_laneGroup_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneGroup::initializeChildren()
{
    m_laneGroup_.initialize(static_cast<::nds::lane::lanegroups::LaneGroupType>(getType()), static_cast<bool>(getHasBoundaryGeometry()));

    m_areChildrenInitialized = true;
}

::nds::lane::reference::types::LaneGroupId& LaneGroup::getId()
{
    return m_id_;
}

const ::nds::lane::reference::types::LaneGroupId& LaneGroup::getId() const
{
    return m_id_;
}

void LaneGroup::setId(const ::nds::lane::reference::types::LaneGroupId& id_)
{
    m_id_ = id_;
}

void LaneGroup::setId(::nds::lane::reference::types::LaneGroupId&& id_)
{
    m_id_ = ::std::move(id_);
}

::nds::lane::lanegroups::LaneGroupType LaneGroup::getType() const
{
    return m_type_;
}

void LaneGroup::setType(::nds::lane::lanegroups::LaneGroupType type_)
{
    m_type_ = type_;
}

bool LaneGroup::getHasBoundaryGeometry() const
{
    return m_hasBoundaryGeometry_;
}

void LaneGroup::setHasBoundaryGeometry(bool hasBoundaryGeometry_)
{
    m_hasBoundaryGeometry_ = hasBoundaryGeometry_;
}

::nds::lane::lanegroups::LaneGroupChoice& LaneGroup::getLaneGroup()
{
    return m_laneGroup_;
}

const ::nds::lane::lanegroups::LaneGroupChoice& LaneGroup::getLaneGroup() const
{
    return m_laneGroup_;
}

void LaneGroup::setLaneGroup(const ::nds::lane::lanegroups::LaneGroupChoice& laneGroup_)
{
    m_laneGroup_ = laneGroup_;
}

void LaneGroup::setLaneGroup(::nds::lane::lanegroups::LaneGroupChoice&& laneGroup_)
{
    m_laneGroup_ = ::std::move(laneGroup_);
}

void LaneGroup::initPackingContext(LaneGroup::ZserioPackingContext& context) const
{
    m_id_.initPackingContext(context.getId());
    ::zserio::initPackingContext(context.getType(), m_type_);
    m_laneGroup_.initPackingContext(context.getLaneGroup());
}

size_t LaneGroup::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_laneGroup_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroup::bitSizeOf(LaneGroup::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOf(context.getId(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_laneGroup_.bitSizeOf(context.getLaneGroup(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroup::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_laneGroup_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneGroup::initializeOffsets(LaneGroup::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsets(context.getId(), endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_laneGroup_.initializeOffsets(context.getLaneGroup(), endBitPosition);

    return endBitPosition;
}

bool LaneGroup::operator==(const LaneGroup& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_type_ == other.m_type_) &&
                (m_hasBoundaryGeometry_ == other.m_hasBoundaryGeometry_) &&
                (m_laneGroup_ == other.m_laneGroup_);
    }

    return true;
}

uint32_t LaneGroup::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_hasBoundaryGeometry_);
    result = ::zserio::calcHashCode(result, m_laneGroup_);

    return result;
}

void LaneGroup::write(::zserio::BitStreamWriter& out) const
{
    m_id_.write(out);

    ::zserio::write(out, m_type_);

    out.writeBool(m_hasBoundaryGeometry_);

    // check parameters
    if (m_laneGroup_.getType() != static_cast<::nds::lane::lanegroups::LaneGroupType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LaneGroup.laneGroup: ") <<
                m_laneGroup_.getType() << " != " << static_cast<::nds::lane::lanegroups::LaneGroupType>(getType()) << "!";
    }
    if (m_laneGroup_.getHasBoundaryGeometry() != static_cast<bool>(getHasBoundaryGeometry()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasBoundaryGeometry for field LaneGroup.laneGroup: ") <<
                m_laneGroup_.getHasBoundaryGeometry() << " != " << static_cast<bool>(getHasBoundaryGeometry()) << "!";
    }
    m_laneGroup_.write(out);
}

void LaneGroup::write(LaneGroup::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_id_.write(context.getId(), out);

    ::zserio::write(context.getType(), out, m_type_);

    out.writeBool(m_hasBoundaryGeometry_);

    // check parameters
    if (m_laneGroup_.getType() != static_cast<::nds::lane::lanegroups::LaneGroupType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LaneGroup.laneGroup: ") <<
                m_laneGroup_.getType() << " != " << static_cast<::nds::lane::lanegroups::LaneGroupType>(getType()) << "!";
    }
    if (m_laneGroup_.getHasBoundaryGeometry() != static_cast<bool>(getHasBoundaryGeometry()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasBoundaryGeometry for field LaneGroup.laneGroup: ") <<
                m_laneGroup_.getHasBoundaryGeometry() << " != " << static_cast<bool>(getHasBoundaryGeometry()) << "!";
    }
    m_laneGroup_.write(context.getLaneGroup(), out);
}

::nds::lane::reference::types::LaneGroupId LaneGroup::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupId(in, allocator);
}

::nds::lane::reference::types::LaneGroupId LaneGroup::readId(LaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupId(context.getId(), in, allocator);
}
::nds::lane::lanegroups::LaneGroupType LaneGroup::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::lanegroups::LaneGroupType>(in);
}

::nds::lane::lanegroups::LaneGroupType LaneGroup::readType(LaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::lanegroups::LaneGroupType>(context.getType(), in);
}
bool LaneGroup::readHasBoundaryGeometry(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::lane::lanegroups::LaneGroupChoice LaneGroup::readLaneGroup(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupChoice(in, static_cast<::nds::lane::lanegroups::LaneGroupType>(getType()), static_cast<bool>(getHasBoundaryGeometry()), allocator);
}

::nds::lane::lanegroups::LaneGroupChoice LaneGroup::readLaneGroup(LaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupChoice(context.getLaneGroup(), in, static_cast<::nds::lane::lanegroups::LaneGroupType>(getType()), static_cast<bool>(getHasBoundaryGeometry()), allocator);
}

} // namespace lanegroups
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/lanegroups/RoadLaneGroup.h>
#include <nds/lane/types/LaneLayoutType.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

RoadLaneGroup::RoadLaneGroup(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_startOnBorder_(bool()),
        m_endOnBorder_(bool()),
        m_startConnector_(allocator),
        m_endConnector_(allocator),
        m_lanes_(allocator)
{
}

RoadLaneGroup::RoadLaneGroup(::zserio::BitStreamReader& in,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_startOnBorder_(readStartOnBorder(in)),
        m_endOnBorder_(readEndOnBorder(in)),
        m_startConnector_(readStartConnector(in, allocator)),
        m_endConnector_(readEndConnector(in, allocator)),
        m_lanes_(readLanes(in, allocator))
{
}

RoadLaneGroup::RoadLaneGroup(RoadLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_startOnBorder_(readStartOnBorder(in)),
        m_endOnBorder_(readEndOnBorder(in)),
        m_startConnector_(readStartConnector(context, in, allocator)),
        m_endConnector_(readEndConnector(context, in, allocator)),
        m_lanes_(readLanes(context, in, allocator))
{
}

RoadLaneGroup::RoadLaneGroup(const RoadLaneGroup& other) :
        m_startOnBorder_(other.m_startOnBorder_),
        m_endOnBorder_(other.m_endOnBorder_),
        m_startConnector_(other.m_startConnector_),
        m_endConnector_(other.m_endConnector_),
        m_lanes_(other.m_lanes_)
{
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

RoadLaneGroup& RoadLaneGroup::operator=(const RoadLaneGroup& other)
{
    m_startOnBorder_ = other.m_startOnBorder_;
    m_endOnBorder_ = other.m_endOnBorder_;
    m_startConnector_ = other.m_startConnector_;
    m_endConnector_ = other.m_endConnector_;
    m_lanes_ = other.m_lanes_;
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

RoadLaneGroup::RoadLaneGroup(RoadLaneGroup&& other) :
        m_startOnBorder_(::std::move(other.m_startOnBorder_)),
        m_endOnBorder_(::std::move(other.m_endOnBorder_)),
        m_startConnector_(::std::move(other.m_startConnector_)),
        m_endConnector_(::std::move(other.m_endConnector_)),
        m_lanes_(::std::move(other.m_lanes_))
{
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

RoadLaneGroup& RoadLaneGroup::operator=(RoadLaneGroup&& other)
{
    m_startOnBorder_ = ::std::move(other.m_startOnBorder_);
    m_endOnBorder_ = ::std::move(other.m_endOnBorder_);
    m_startConnector_ = ::std::move(other.m_startConnector_);
    m_endConnector_ = ::std::move(other.m_endConnector_);
    m_lanes_ = ::std::move(other.m_lanes_);
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

RoadLaneGroup::RoadLaneGroup(::zserio::PropagateAllocatorT,
        const RoadLaneGroup& other, const allocator_type& allocator) :
        m_startOnBorder_(::zserio::allocatorPropagatingCopy(other.m_startOnBorder_, allocator)),
        m_endOnBorder_(::zserio::allocatorPropagatingCopy(other.m_endOnBorder_, allocator)),
        m_startConnector_(::zserio::allocatorPropagatingCopy(other.m_startConnector_, allocator)),
        m_endConnector_(::zserio::allocatorPropagatingCopy(other.m_endConnector_, allocator)),
        m_lanes_(::zserio::allocatorPropagatingCopy(other.m_lanes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

void RoadLaneGroup::initialize(
        bool hasBoundaryGeometry_)
{
    m_hasBoundaryGeometry_ = hasBoundaryGeometry_;
    m_isInitialized = true;

    initializeChildren();
}

bool RoadLaneGroup::isInitialized() const
{
    return m_isInitialized;
}

void RoadLaneGroup::initializeChildren()
{
    m_startConnector_.initialize(static_cast<bool>(getStartOnBorder()));
    m_endConnector_.initialize(static_cast<bool>(getEndOnBorder()));
    m_lanes_.initializeElements(*this);
}

bool RoadLaneGroup::getHasBoundaryGeometry() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasBoundaryGeometry' of compound 'RoadLaneGroup' is not initialized!");

    return m_hasBoundaryGeometry_;
}

bool RoadLaneGroup::getStartOnBorder() const
{
    return m_startOnBorder_;
}

void RoadLaneGroup::setStartOnBorder(bool startOnBorder_)
{
    m_startOnBorder_ = startOnBorder_;
}

bool RoadLaneGroup::getEndOnBorder() const
{
    return m_endOnBorder_;
}

void RoadLaneGroup::setEndOnBorder(bool endOnBorder_)
{
    m_endOnBorder_ = endOnBorder_;
}

::nds::lane::lanegroups::LaneGroupConnector& RoadLaneGroup::getStartConnector()
{
    return m_startConnector_;
}

const ::nds::lane::lanegroups::LaneGroupConnector& RoadLaneGroup::getStartConnector() const
{
    return m_startConnector_;
}

void RoadLaneGroup::setStartConnector(const ::nds::lane::lanegroups::LaneGroupConnector& startConnector_)
{
    m_startConnector_ = startConnector_;
}

void RoadLaneGroup::setStartConnector(::nds::lane::lanegroups::LaneGroupConnector&& startConnector_)
{
    m_startConnector_ = ::std::move(startConnector_);
}

::nds::lane::lanegroups::LaneGroupConnector& RoadLaneGroup::getEndConnector()
{
    return m_endConnector_;
}

const ::nds::lane::lanegroups::LaneGroupConnector& RoadLaneGroup::getEndConnector() const
{
    return m_endConnector_;
}

void RoadLaneGroup::setEndConnector(const ::nds::lane::lanegroups::LaneGroupConnector& endConnector_)
{
    m_endConnector_ = endConnector_;
}

void RoadLaneGroup::setEndConnector(::nds::lane::lanegroups::LaneGroupConnector&& endConnector_)
{
    m_endConnector_ = ::std::move(endConnector_);
}

::zserio::vector<::nds::lane::lanes::Lane>& RoadLaneGroup::getLanes()
{
    return m_lanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::Lane>& RoadLaneGroup::getLanes() const
{
    return m_lanes_.getRawArray();
}

void RoadLaneGroup::setLanes(const ::zserio::vector<::nds::lane::lanes::Lane>& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(lanes_);
}

void RoadLaneGroup::setLanes(::zserio::vector<::nds::lane::lanes::Lane>&& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(std::move(lanes_));
}

void RoadLaneGroup::initPackingContext(RoadLaneGroup::ZserioPackingContext& context) const
{
    m_startConnector_.initPackingContext(context.getStartConnector());
    m_endConnector_.initPackingContext(context.getEndConnector());
}

size_t RoadLaneGroup::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_startConnector_.bitSizeOf(endBitPosition);
    endBitPosition += m_endConnector_.bitSizeOf(endBitPosition);
    endBitPosition += m_lanes_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLaneGroup::bitSizeOf(RoadLaneGroup::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_startConnector_.bitSizeOf(context.getStartConnector(), endBitPosition);
    endBitPosition += m_endConnector_.bitSizeOf(context.getEndConnector(), endBitPosition);
    endBitPosition += m_lanes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLaneGroup::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_startConnector_.initializeOffsets(endBitPosition);
    endBitPosition = m_endConnector_.initializeOffsets(endBitPosition);
    endBitPosition = m_lanes_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RoadLaneGroup::initializeOffsets(RoadLaneGroup::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_startConnector_.initializeOffsets(context.getStartConnector(), endBitPosition);
    endBitPosition = m_endConnector_.initializeOffsets(context.getEndConnector(), endBitPosition);
    endBitPosition = m_lanes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoadLaneGroup::operator==(const RoadLaneGroup& other) const
{
    if (this != &other)
    {
        return
                (getHasBoundaryGeometry() == other.getHasBoundaryGeometry()) &&
                (m_startOnBorder_ == other.m_startOnBorder_) &&
                (m_endOnBorder_ == other.m_endOnBorder_) &&
                (m_startConnector_ == other.m_startConnector_) &&
                (m_endConnector_ == other.m_endConnector_) &&
                (m_lanes_ == other.m_lanes_);
    }

    return true;
}

uint32_t RoadLaneGroup::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHasBoundaryGeometry());
    result = ::zserio::calcHashCode(result, m_startOnBorder_);
    result = ::zserio::calcHashCode(result, m_endOnBorder_);
    result = ::zserio::calcHashCode(result, m_startConnector_);
    result = ::zserio::calcHashCode(result, m_endConnector_);
    result = ::zserio::calcHashCode(result, m_lanes_);

    return result;
}

void RoadLaneGroup::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_startOnBorder_);

    out.writeBool(m_endOnBorder_);

    // check parameters
    if (m_startConnector_.getOnBorder() != static_cast<bool>(getStartOnBorder()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field RoadLaneGroup.startConnector: ") <<
                m_startConnector_.getOnBorder() << " != " << static_cast<bool>(getStartOnBorder()) << "!";
    }
    m_startConnector_.write(out);

    // check parameters
    if (m_endConnector_.getOnBorder() != static_cast<bool>(getEndOnBorder()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field RoadLaneGroup.endConnector: ") <<
                m_endConnector_.getOnBorder() << " != " << static_cast<bool>(getEndOnBorder()) << "!";
    }
    m_endConnector_.write(out);

    m_lanes_.write(*this, out);
}

void RoadLaneGroup::write(RoadLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_startOnBorder_);

    out.writeBool(m_endOnBorder_);

    // check parameters
    if (m_startConnector_.getOnBorder() != static_cast<bool>(getStartOnBorder()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field RoadLaneGroup.startConnector: ") <<
                m_startConnector_.getOnBorder() << " != " << static_cast<bool>(getStartOnBorder()) << "!";
    }
    m_startConnector_.write(context.getStartConnector(), out);

    // check parameters
    if (m_endConnector_.getOnBorder() != static_cast<bool>(getEndOnBorder()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field RoadLaneGroup.endConnector: ") <<
                m_endConnector_.getOnBorder() << " != " << static_cast<bool>(getEndOnBorder()) << "!";
    }
    m_endConnector_.write(context.getEndConnector(), out);

    m_lanes_.writePacked(*this, out);
}

void RoadLaneGroup::ZserioArrayExpressions_lanes::initializeElement(RoadLaneGroup& owner,
        ::nds::lane::lanes::Lane& element, size_t)
{
    element.initialize(static_cast<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType::ORDERED), static_cast<bool>(owner.getHasBoundaryGeometry()));
}

void RoadLaneGroup::ZserioElementFactory_lanes::create(RoadLaneGroup&         owner,
        ::zserio::vector<::nds::lane::lanes::Lane>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType::ORDERED), static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

void RoadLaneGroup::ZserioElementFactory_lanes::create(RoadLaneGroup&         owner,
        ::zserio::vector<::nds::lane::lanes::Lane>& array,
        ::nds::lane::lanes::Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType::ORDERED), static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

bool RoadLaneGroup::readStartOnBorder(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool RoadLaneGroup::readEndOnBorder(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::lane::lanegroups::LaneGroupConnector RoadLaneGroup::readStartConnector(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(in, static_cast<bool>(getStartOnBorder()), allocator);
}

::nds::lane::lanegroups::LaneGroupConnector RoadLaneGroup::readStartConnector(RoadLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(context.getStartConnector(), in, static_cast<bool>(getStartOnBorder()), allocator);
}
::nds::lane::lanegroups::LaneGroupConnector RoadLaneGroup::readEndConnector(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(in, static_cast<bool>(getEndOnBorder()), allocator);
}

::nds::lane::lanegroups::LaneGroupConnector RoadLaneGroup::readEndConnector(RoadLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(context.getEndConnector(), in, static_cast<bool>(getEndOnBorder()), allocator);
}
RoadLaneGroup::ZserioArrayType_lanes RoadLaneGroup::readLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.read(*this, in);

    return readField;
}

RoadLaneGroup::ZserioArrayType_lanes RoadLaneGroup::readLanes(RoadLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace lanegroups
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/lanegroups/IntersectionLaneGroup.h>
#include <nds/lane/types/LaneLayoutType.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

IntersectionLaneGroup::IntersectionLaneGroup(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_intersectionConnectors_(allocator),
        m_lanes_(allocator)
{
}

IntersectionLaneGroup::IntersectionLaneGroup(::zserio::BitStreamReader& in,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_intersectionConnectors_(readIntersectionConnectors(in, allocator)),
        m_lanes_(readLanes(in, allocator))
{
}

IntersectionLaneGroup::IntersectionLaneGroup(IntersectionLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_intersectionConnectors_(readIntersectionConnectors(context, in, allocator)),
        m_lanes_(readLanes(context, in, allocator))
{
}

IntersectionLaneGroup::IntersectionLaneGroup(const IntersectionLaneGroup& other) :
        m_intersectionConnectors_(other.m_intersectionConnectors_),
        m_lanes_(other.m_lanes_)
{
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

IntersectionLaneGroup& IntersectionLaneGroup::operator=(const IntersectionLaneGroup& other)
{
    m_intersectionConnectors_ = other.m_intersectionConnectors_;
    m_lanes_ = other.m_lanes_;
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

IntersectionLaneGroup::IntersectionLaneGroup(IntersectionLaneGroup&& other) :
        m_intersectionConnectors_(::std::move(other.m_intersectionConnectors_)),
        m_lanes_(::std::move(other.m_lanes_))
{
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

IntersectionLaneGroup& IntersectionLaneGroup::operator=(IntersectionLaneGroup&& other)
{
    m_intersectionConnectors_ = ::std::move(other.m_intersectionConnectors_);
    m_lanes_ = ::std::move(other.m_lanes_);
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

IntersectionLaneGroup::IntersectionLaneGroup(::zserio::PropagateAllocatorT,
        const IntersectionLaneGroup& other, const allocator_type& allocator) :
        m_intersectionConnectors_(::zserio::allocatorPropagatingCopy(other.m_intersectionConnectors_, allocator)),
        m_lanes_(::zserio::allocatorPropagatingCopy(other.m_lanes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

void IntersectionLaneGroup::initialize(
        bool hasBoundaryGeometry_)
{
    m_hasBoundaryGeometry_ = hasBoundaryGeometry_;
    m_isInitialized = true;

    initializeChildren();
}

bool IntersectionLaneGroup::isInitialized() const
{
    return m_isInitialized;
}

void IntersectionLaneGroup::initializeChildren()
{
    m_intersectionConnectors_.initializeElements(*this);
    m_lanes_.initializeElements(*this);
}

bool IntersectionLaneGroup::getHasBoundaryGeometry() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasBoundaryGeometry' of compound 'IntersectionLaneGroup' is not initialized!");

    return m_hasBoundaryGeometry_;
}

::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& IntersectionLaneGroup::getIntersectionConnectors()
{
    return m_intersectionConnectors_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& IntersectionLaneGroup::getIntersectionConnectors() const
{
    return m_intersectionConnectors_.getRawArray();
}

void IntersectionLaneGroup::setIntersectionConnectors(const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& intersectionConnectors_)
{
    m_intersectionConnectors_ = ZserioArrayType_intersectionConnectors(intersectionConnectors_);
}

void IntersectionLaneGroup::setIntersectionConnectors(::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>&& intersectionConnectors_)
{
    m_intersectionConnectors_ = ZserioArrayType_intersectionConnectors(std::move(intersectionConnectors_));
}

::zserio::vector<::nds::lane::lanes::Lane>& IntersectionLaneGroup::getLanes()
{
    return m_lanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::Lane>& IntersectionLaneGroup::getLanes() const
{
    return m_lanes_.getRawArray();
}

void IntersectionLaneGroup::setLanes(const ::zserio::vector<::nds::lane::lanes::Lane>& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(lanes_);
}

void IntersectionLaneGroup::setLanes(::zserio::vector<::nds::lane::lanes::Lane>&& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(std::move(lanes_));
}

void IntersectionLaneGroup::initPackingContext(IntersectionLaneGroup::ZserioPackingContext&) const
{
}

size_t IntersectionLaneGroup::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_intersectionConnectors_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_lanes_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t IntersectionLaneGroup::bitSizeOf(IntersectionLaneGroup::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_intersectionConnectors_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_lanes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t IntersectionLaneGroup::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_intersectionConnectors_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_lanes_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t IntersectionLaneGroup::initializeOffsets(IntersectionLaneGroup::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_intersectionConnectors_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_lanes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool IntersectionLaneGroup::operator==(const IntersectionLaneGroup& other) const
{
    if (this != &other)
    {
        return
                (getHasBoundaryGeometry() == other.getHasBoundaryGeometry()) &&
                (m_intersectionConnectors_ == other.m_intersectionConnectors_) &&
                (m_lanes_ == other.m_lanes_);
    }

    return true;
}

uint32_t IntersectionLaneGroup::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHasBoundaryGeometry());
    result = ::zserio::calcHashCode(result, m_intersectionConnectors_);
    result = ::zserio::calcHashCode(result, m_lanes_);

    return result;
}

void IntersectionLaneGroup::write(::zserio::BitStreamWriter& out) const
{
    m_intersectionConnectors_.write(*this, out);
    m_lanes_.write(*this, out);
}

void IntersectionLaneGroup::write(IntersectionLaneGroup::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_intersectionConnectors_.writePacked(*this, out);
    m_lanes_.writePacked(*this, out);
}

void IntersectionLaneGroup::ZserioArrayExpressions_intersectionConnectors::initializeElement(IntersectionLaneGroup&,
        ::nds::lane::lanegroups::LaneGroupConnector& element, size_t)
{
    element.initialize(static_cast<bool>(false));
}

void IntersectionLaneGroup::ZserioElementFactory_intersectionConnectors::create(IntersectionLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(false), array.get_allocator());
}

void IntersectionLaneGroup::ZserioElementFactory_intersectionConnectors::create(IntersectionLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::nds::lane::lanegroups::LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(false), array.get_allocator());
}

void IntersectionLaneGroup::ZserioArrayExpressions_lanes::initializeElement(IntersectionLaneGroup& owner,
        ::nds::lane::lanes::Lane& element, size_t)
{
    element.initialize(static_cast<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType::UNORDERED), static_cast<bool>(owner.getHasBoundaryGeometry()));
}

void IntersectionLaneGroup::ZserioElementFactory_lanes::create(IntersectionLaneGroup&         owner,
        ::zserio::vector<::nds::lane::lanes::Lane>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType::UNORDERED), static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

void IntersectionLaneGroup::ZserioElementFactory_lanes::create(IntersectionLaneGroup&         owner,
        ::zserio::vector<::nds::lane::lanes::Lane>& array,
        ::nds::lane::lanes::Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType::UNORDERED), static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

IntersectionLaneGroup::ZserioArrayType_intersectionConnectors IntersectionLaneGroup::readIntersectionConnectors(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_intersectionConnectors readField(allocator);
    readField.read(*this, in);

    return readField;
}

IntersectionLaneGroup::ZserioArrayType_intersectionConnectors IntersectionLaneGroup::readIntersectionConnectors(IntersectionLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_intersectionConnectors readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
IntersectionLaneGroup::ZserioArrayType_lanes IntersectionLaneGroup::readLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.read(*this, in);

    return readField;
}

IntersectionLaneGroup::ZserioArrayType_lanes IntersectionLaneGroup::readLanes(IntersectionLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace lanegroups
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/lane/lanegroups/BorderLaneGroup.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

BorderLaneGroup::BorderLaneGroup(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_startConnector_(allocator),
        m_endConnectorBorder_(allocator),
        m_lanes_(allocator)
{
}

BorderLaneGroup::BorderLaneGroup(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_startConnector_(readStartConnector(in, allocator)),
        m_endConnectorBorder_(readEndConnectorBorder(in, allocator)),
        m_lanes_(readLanes(in, allocator))
{
}

BorderLaneGroup::BorderLaneGroup(BorderLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_startConnector_(readStartConnector(context, in, allocator)),
        m_endConnectorBorder_(readEndConnectorBorder(context, in, allocator)),
        m_lanes_(readLanes(context, in, allocator))
{
}

BorderLaneGroup::BorderLaneGroup(const BorderLaneGroup& other) :
        m_startConnector_(other.m_startConnector_),
        m_endConnectorBorder_(other.m_endConnectorBorder_),
        m_lanes_(other.m_lanes_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

BorderLaneGroup& BorderLaneGroup::operator=(const BorderLaneGroup& other)
{
    m_startConnector_ = other.m_startConnector_;
    m_endConnectorBorder_ = other.m_endConnectorBorder_;
    m_lanes_ = other.m_lanes_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

BorderLaneGroup::BorderLaneGroup(BorderLaneGroup&& other) :
        m_startConnector_(::std::move(other.m_startConnector_)),
        m_endConnectorBorder_(::std::move(other.m_endConnectorBorder_)),
        m_lanes_(::std::move(other.m_lanes_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

BorderLaneGroup& BorderLaneGroup::operator=(BorderLaneGroup&& other)
{
    m_startConnector_ = ::std::move(other.m_startConnector_);
    m_endConnectorBorder_ = ::std::move(other.m_endConnectorBorder_);
    m_lanes_ = ::std::move(other.m_lanes_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

BorderLaneGroup::BorderLaneGroup(::zserio::PropagateAllocatorT,
        const BorderLaneGroup& other, const allocator_type& allocator) :
        m_startConnector_(::zserio::allocatorPropagatingCopy(other.m_startConnector_, allocator)),
        m_endConnectorBorder_(::zserio::allocatorPropagatingCopy(other.m_endConnectorBorder_, allocator)),
        m_lanes_(::zserio::allocatorPropagatingCopy(other.m_lanes_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void BorderLaneGroup::initializeChildren()
{
    m_startConnector_.initializeElements(*this);
    m_endConnectorBorder_.initialize(static_cast<bool>(true));
    m_lanes_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& BorderLaneGroup::getStartConnector()
{
    return m_startConnector_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& BorderLaneGroup::getStartConnector() const
{
    return m_startConnector_.getRawArray();
}

void BorderLaneGroup::setStartConnector(const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& startConnector_)
{
    m_startConnector_ = ZserioArrayType_startConnector(startConnector_);
}

void BorderLaneGroup::setStartConnector(::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>&& startConnector_)
{
    m_startConnector_ = ZserioArrayType_startConnector(std::move(startConnector_));
}

::nds::lane::lanegroups::LaneGroupConnector& BorderLaneGroup::getEndConnectorBorder()
{
    return m_endConnectorBorder_;
}

const ::nds::lane::lanegroups::LaneGroupConnector& BorderLaneGroup::getEndConnectorBorder() const
{
    return m_endConnectorBorder_;
}

void BorderLaneGroup::setEndConnectorBorder(const ::nds::lane::lanegroups::LaneGroupConnector& endConnectorBorder_)
{
    m_endConnectorBorder_ = endConnectorBorder_;
}

void BorderLaneGroup::setEndConnectorBorder(::nds::lane::lanegroups::LaneGroupConnector&& endConnectorBorder_)
{
    m_endConnectorBorder_ = ::std::move(endConnectorBorder_);
}

::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& BorderLaneGroup::getLanes()
{
    return m_lanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& BorderLaneGroup::getLanes() const
{
    return m_lanes_.getRawArray();
}

void BorderLaneGroup::setLanes(const ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(lanes_);
}

void BorderLaneGroup::setLanes(::zserio::vector<::nds::lane::lanes::ZeroLengthLane>&& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(std::move(lanes_));
}

void BorderLaneGroup::initPackingContext(BorderLaneGroup::ZserioPackingContext& context) const
{
    m_endConnectorBorder_.initPackingContext(context.getEndConnectorBorder());
}

size_t BorderLaneGroup::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startConnector_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_endConnectorBorder_.bitSizeOf(endBitPosition);
    endBitPosition += m_lanes_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BorderLaneGroup::bitSizeOf(BorderLaneGroup::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startConnector_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_endConnectorBorder_.bitSizeOf(context.getEndConnectorBorder(), endBitPosition);
    endBitPosition += m_lanes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BorderLaneGroup::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startConnector_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_endConnectorBorder_.initializeOffsets(endBitPosition);
    endBitPosition = m_lanes_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t BorderLaneGroup::initializeOffsets(BorderLaneGroup::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startConnector_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_endConnectorBorder_.initializeOffsets(context.getEndConnectorBorder(), endBitPosition);
    endBitPosition = m_lanes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool BorderLaneGroup::operator==(const BorderLaneGroup& other) const
{
    if (this != &other)
    {
        return
                (m_startConnector_ == other.m_startConnector_) &&
                (m_endConnectorBorder_ == other.m_endConnectorBorder_) &&
                (m_lanes_ == other.m_lanes_);
    }

    return true;
}

uint32_t BorderLaneGroup::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_startConnector_);
    result = ::zserio::calcHashCode(result, m_endConnectorBorder_);
    result = ::zserio::calcHashCode(result, m_lanes_);

    return result;
}

void BorderLaneGroup::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getStartConnector().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at BorderLaneGroup.startConnector!");
    m_startConnector_.write(*this, out);

    // check parameters
    if (m_endConnectorBorder_.getOnBorder() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field BorderLaneGroup.endConnectorBorder: ") <<
                m_endConnectorBorder_.getOnBorder() << " != " << static_cast<bool>(true) << "!";
    }
    m_endConnectorBorder_.write(out);

    m_lanes_.write(*this, out);
}

void BorderLaneGroup::write(BorderLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getStartConnector().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at BorderLaneGroup.startConnector!");
    m_startConnector_.writePacked(*this, out);

    // check parameters
    if (m_endConnectorBorder_.getOnBorder() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field BorderLaneGroup.endConnectorBorder: ") <<
                m_endConnectorBorder_.getOnBorder() << " != " << static_cast<bool>(true) << "!";
    }
    m_endConnectorBorder_.write(context.getEndConnectorBorder(), out);

    m_lanes_.writePacked(*this, out);
}

void BorderLaneGroup::ZserioArrayExpressions_startConnector::initializeElement(BorderLaneGroup&,
        ::nds::lane::lanegroups::LaneGroupConnector& element, size_t)
{
    element.initialize(static_cast<bool>(false));
}

void BorderLaneGroup::ZserioElementFactory_startConnector::create(BorderLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(false), array.get_allocator());
}

void BorderLaneGroup::ZserioElementFactory_startConnector::create(BorderLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::nds::lane::lanegroups::LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(false), array.get_allocator());
}

void BorderLaneGroup::ZserioArrayExpressions_lanes::initializeElement(BorderLaneGroup&,
        ::nds::lane::lanes::ZeroLengthLane& element, size_t)
{
    element.initialize(static_cast<bool>(true));
}

void BorderLaneGroup::ZserioElementFactory_lanes::create(BorderLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(true), array.get_allocator());
}

void BorderLaneGroup::ZserioElementFactory_lanes::create(BorderLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& array,
        ::nds::lane::lanes::ZeroLengthLane::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(true), array.get_allocator());
}

BorderLaneGroup::ZserioArrayType_startConnector BorderLaneGroup::readStartConnector(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_startConnector readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at BorderLaneGroup.startConnector!");

    return readField;
}

BorderLaneGroup::ZserioArrayType_startConnector BorderLaneGroup::readStartConnector(BorderLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_startConnector readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at BorderLaneGroup.startConnector!");

    return readField;
}
::nds::lane::lanegroups::LaneGroupConnector BorderLaneGroup::readEndConnectorBorder(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(in, static_cast<bool>(true), allocator);
}

::nds::lane::lanegroups::LaneGroupConnector BorderLaneGroup::readEndConnectorBorder(BorderLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(context.getEndConnectorBorder(), in, static_cast<bool>(true), allocator);
}
BorderLaneGroup::ZserioArrayType_lanes BorderLaneGroup::readLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.read(*this, in);

    return readField;
}

BorderLaneGroup::ZserioArrayType_lanes BorderLaneGroup::readLanes(BorderLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace lanegroups
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/lane/lanegroups/ForkLaneGroup.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

ForkLaneGroup::ForkLaneGroup(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_startConnector_(allocator),
        m_endConnector_(allocator),
        m_lanes_(allocator)
{
}

ForkLaneGroup::ForkLaneGroup(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_startConnector_(readStartConnector(in, allocator)),
        m_endConnector_(readEndConnector(in, allocator)),
        m_lanes_(readLanes(in, allocator))
{
}

ForkLaneGroup::ForkLaneGroup(ForkLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_startConnector_(readStartConnector(context, in, allocator)),
        m_endConnector_(readEndConnector(context, in, allocator)),
        m_lanes_(readLanes(context, in, allocator))
{
}

ForkLaneGroup::ForkLaneGroup(const ForkLaneGroup& other) :
        m_startConnector_(other.m_startConnector_),
        m_endConnector_(other.m_endConnector_),
        m_lanes_(other.m_lanes_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ForkLaneGroup& ForkLaneGroup::operator=(const ForkLaneGroup& other)
{
    m_startConnector_ = other.m_startConnector_;
    m_endConnector_ = other.m_endConnector_;
    m_lanes_ = other.m_lanes_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ForkLaneGroup::ForkLaneGroup(ForkLaneGroup&& other) :
        m_startConnector_(::std::move(other.m_startConnector_)),
        m_endConnector_(::std::move(other.m_endConnector_)),
        m_lanes_(::std::move(other.m_lanes_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ForkLaneGroup& ForkLaneGroup::operator=(ForkLaneGroup&& other)
{
    m_startConnector_ = ::std::move(other.m_startConnector_);
    m_endConnector_ = ::std::move(other.m_endConnector_);
    m_lanes_ = ::std::move(other.m_lanes_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ForkLaneGroup::ForkLaneGroup(::zserio::PropagateAllocatorT,
        const ForkLaneGroup& other, const allocator_type& allocator) :
        m_startConnector_(::zserio::allocatorPropagatingCopy(other.m_startConnector_, allocator)),
        m_endConnector_(::zserio::allocatorPropagatingCopy(other.m_endConnector_, allocator)),
        m_lanes_(::zserio::allocatorPropagatingCopy(other.m_lanes_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ForkLaneGroup::initializeChildren()
{
    m_startConnector_.initializeElements(*this);
    m_endConnector_.initializeElements(*this);
    m_lanes_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& ForkLaneGroup::getStartConnector()
{
    return m_startConnector_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& ForkLaneGroup::getStartConnector() const
{
    return m_startConnector_.getRawArray();
}

void ForkLaneGroup::setStartConnector(const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& startConnector_)
{
    m_startConnector_ = ZserioArrayType_startConnector(startConnector_);
}

void ForkLaneGroup::setStartConnector(::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>&& startConnector_)
{
    m_startConnector_ = ZserioArrayType_startConnector(std::move(startConnector_));
}

::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& ForkLaneGroup::getEndConnector()
{
    return m_endConnector_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& ForkLaneGroup::getEndConnector() const
{
    return m_endConnector_.getRawArray();
}

void ForkLaneGroup::setEndConnector(const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& endConnector_)
{
    m_endConnector_ = ZserioArrayType_endConnector(endConnector_);
}

void ForkLaneGroup::setEndConnector(::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>&& endConnector_)
{
    m_endConnector_ = ZserioArrayType_endConnector(std::move(endConnector_));
}

::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& ForkLaneGroup::getLanes()
{
    return m_lanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& ForkLaneGroup::getLanes() const
{
    return m_lanes_.getRawArray();
}

void ForkLaneGroup::setLanes(const ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(lanes_);
}

void ForkLaneGroup::setLanes(::zserio::vector<::nds::lane::lanes::ZeroLengthLane>&& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(std::move(lanes_));
}

void ForkLaneGroup::initPackingContext(ForkLaneGroup::ZserioPackingContext&) const
{
}

size_t ForkLaneGroup::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startConnector_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_endConnector_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_lanes_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ForkLaneGroup::bitSizeOf(ForkLaneGroup::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startConnector_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_endConnector_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_lanes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ForkLaneGroup::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startConnector_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_endConnector_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_lanes_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ForkLaneGroup::initializeOffsets(ForkLaneGroup::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startConnector_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_endConnector_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_lanes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ForkLaneGroup::operator==(const ForkLaneGroup& other) const
{
    if (this != &other)
    {
        return
                (m_startConnector_ == other.m_startConnector_) &&
                (m_endConnector_ == other.m_endConnector_) &&
                (m_lanes_ == other.m_lanes_);
    }

    return true;
}

uint32_t ForkLaneGroup::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_startConnector_);
    result = ::zserio::calcHashCode(result, m_endConnector_);
    result = ::zserio::calcHashCode(result, m_lanes_);

    return result;
}

void ForkLaneGroup::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getStartConnector().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ForkLaneGroup.startConnector!");
    m_startConnector_.write(*this, out);

    // check constraint
    if (!(getEndConnector().size() > 0 && (getStartConnector().size() > 1 || getEndConnector().size() > 1)))
        throw ::zserio::ConstraintException("Write: Constraint violated at ForkLaneGroup.endConnector!");
    m_endConnector_.write(*this, out);

    m_lanes_.write(*this, out);
}

void ForkLaneGroup::write(ForkLaneGroup::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getStartConnector().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ForkLaneGroup.startConnector!");
    m_startConnector_.writePacked(*this, out);

    // check constraint
    if (!(getEndConnector().size() > 0 && (getStartConnector().size() > 1 || getEndConnector().size() > 1)))
        throw ::zserio::ConstraintException("Write: Constraint violated at ForkLaneGroup.endConnector!");
    m_endConnector_.writePacked(*this, out);

    m_lanes_.writePacked(*this, out);
}

void ForkLaneGroup::ZserioArrayExpressions_startConnector::initializeElement(ForkLaneGroup&,
        ::nds::lane::lanegroups::LaneGroupConnector& element, size_t)
{
    element.initialize(static_cast<bool>(false));
}

void ForkLaneGroup::ZserioElementFactory_startConnector::create(ForkLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(false), array.get_allocator());
}

void ForkLaneGroup::ZserioElementFactory_startConnector::create(ForkLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::nds::lane::lanegroups::LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(false), array.get_allocator());
}

void ForkLaneGroup::ZserioArrayExpressions_endConnector::initializeElement(ForkLaneGroup&,
        ::nds::lane::lanegroups::LaneGroupConnector& element, size_t)
{
    element.initialize(static_cast<bool>(false));
}

void ForkLaneGroup::ZserioElementFactory_endConnector::create(ForkLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(false), array.get_allocator());
}

void ForkLaneGroup::ZserioElementFactory_endConnector::create(ForkLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::nds::lane::lanegroups::LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(false), array.get_allocator());
}

void ForkLaneGroup::ZserioArrayExpressions_lanes::initializeElement(ForkLaneGroup&,
        ::nds::lane::lanes::ZeroLengthLane& element, size_t)
{
    element.initialize(static_cast<bool>(false));
}

void ForkLaneGroup::ZserioElementFactory_lanes::create(ForkLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(false), array.get_allocator());
}

void ForkLaneGroup::ZserioElementFactory_lanes::create(ForkLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& array,
        ::nds::lane::lanes::ZeroLengthLane::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(false), array.get_allocator());
}

ForkLaneGroup::ZserioArrayType_startConnector ForkLaneGroup::readStartConnector(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_startConnector readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ForkLaneGroup.startConnector!");

    return readField;
}

ForkLaneGroup::ZserioArrayType_startConnector ForkLaneGroup::readStartConnector(ForkLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_startConnector readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ForkLaneGroup.startConnector!");

    return readField;
}
ForkLaneGroup::ZserioArrayType_endConnector ForkLaneGroup::readEndConnector(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_endConnector readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0 && (getStartConnector().size() > 1 || readField.getRawArray().size() > 1)))
        throw ::zserio::ConstraintException("Read: Constraint violated at ForkLaneGroup.endConnector!");

    return readField;
}

ForkLaneGroup::ZserioArrayType_endConnector ForkLaneGroup::readEndConnector(ForkLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_endConnector readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0 && (getStartConnector().size() > 1 || readField.getRawArray().size() > 1)))
        throw ::zserio::ConstraintException("Read: Constraint violated at ForkLaneGroup.endConnector!");

    return readField;
}
ForkLaneGroup::ZserioArrayType_lanes ForkLaneGroup::readLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.read(*this, in);

    return readField;
}

ForkLaneGroup::ZserioArrayType_lanes ForkLaneGroup::readLanes(ForkLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace lanegroups
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/lanegroups/ArtificialRoadLaneGroup.h>
#include <nds/lane/types/LaneLayoutType.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

ArtificialRoadLaneGroup::ArtificialRoadLaneGroup(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_startOnBorder_(bool()),
        m_endOnBorder_(bool()),
        m_startConnector_(allocator),
        m_endConnector_(allocator),
        m_lanes_(allocator)
{
}

ArtificialRoadLaneGroup::ArtificialRoadLaneGroup(::zserio::BitStreamReader& in,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_startOnBorder_(readStartOnBorder(in)),
        m_endOnBorder_(readEndOnBorder(in)),
        m_startConnector_(readStartConnector(in, allocator)),
        m_endConnector_(readEndConnector(in, allocator)),
        m_lanes_(readLanes(in, allocator))
{
}

ArtificialRoadLaneGroup::ArtificialRoadLaneGroup(ArtificialRoadLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_startOnBorder_(readStartOnBorder(in)),
        m_endOnBorder_(readEndOnBorder(in)),
        m_startConnector_(readStartConnector(context, in, allocator)),
        m_endConnector_(readEndConnector(context, in, allocator)),
        m_lanes_(readLanes(context, in, allocator))
{
}

ArtificialRoadLaneGroup::ArtificialRoadLaneGroup(const ArtificialRoadLaneGroup& other) :
        m_startOnBorder_(other.m_startOnBorder_),
        m_endOnBorder_(other.m_endOnBorder_),
        m_startConnector_(other.m_startConnector_),
        m_endConnector_(other.m_endConnector_),
        m_lanes_(other.m_lanes_)
{
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

ArtificialRoadLaneGroup& ArtificialRoadLaneGroup::operator=(const ArtificialRoadLaneGroup& other)
{
    m_startOnBorder_ = other.m_startOnBorder_;
    m_endOnBorder_ = other.m_endOnBorder_;
    m_startConnector_ = other.m_startConnector_;
    m_endConnector_ = other.m_endConnector_;
    m_lanes_ = other.m_lanes_;
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

ArtificialRoadLaneGroup::ArtificialRoadLaneGroup(ArtificialRoadLaneGroup&& other) :
        m_startOnBorder_(::std::move(other.m_startOnBorder_)),
        m_endOnBorder_(::std::move(other.m_endOnBorder_)),
        m_startConnector_(::std::move(other.m_startConnector_)),
        m_endConnector_(::std::move(other.m_endConnector_)),
        m_lanes_(::std::move(other.m_lanes_))
{
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

ArtificialRoadLaneGroup& ArtificialRoadLaneGroup::operator=(ArtificialRoadLaneGroup&& other)
{
    m_startOnBorder_ = ::std::move(other.m_startOnBorder_);
    m_endOnBorder_ = ::std::move(other.m_endOnBorder_);
    m_startConnector_ = ::std::move(other.m_startConnector_);
    m_endConnector_ = ::std::move(other.m_endConnector_);
    m_lanes_ = ::std::move(other.m_lanes_);
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

ArtificialRoadLaneGroup::ArtificialRoadLaneGroup(::zserio::PropagateAllocatorT,
        const ArtificialRoadLaneGroup& other, const allocator_type& allocator) :
        m_startOnBorder_(::zserio::allocatorPropagatingCopy(other.m_startOnBorder_, allocator)),
        m_endOnBorder_(::zserio::allocatorPropagatingCopy(other.m_endOnBorder_, allocator)),
        m_startConnector_(::zserio::allocatorPropagatingCopy(other.m_startConnector_, allocator)),
        m_endConnector_(::zserio::allocatorPropagatingCopy(other.m_endConnector_, allocator)),
        m_lanes_(::zserio::allocatorPropagatingCopy(other.m_lanes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

void ArtificialRoadLaneGroup::initialize(
        bool hasBoundaryGeometry_)
{
    m_hasBoundaryGeometry_ = hasBoundaryGeometry_;
    m_isInitialized = true;

    initializeChildren();
}

bool ArtificialRoadLaneGroup::isInitialized() const
{
    return m_isInitialized;
}

void ArtificialRoadLaneGroup::initializeChildren()
{
    m_startConnector_.initialize(static_cast<bool>(getStartOnBorder()));
    m_endConnector_.initialize(static_cast<bool>(getEndOnBorder()));
    m_lanes_.initializeElements(*this);
}

bool ArtificialRoadLaneGroup::getHasBoundaryGeometry() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasBoundaryGeometry' of compound 'ArtificialRoadLaneGroup' is not initialized!");

    return m_hasBoundaryGeometry_;
}

bool ArtificialRoadLaneGroup::getStartOnBorder() const
{
    return m_startOnBorder_;
}

void ArtificialRoadLaneGroup::setStartOnBorder(bool startOnBorder_)
{
    m_startOnBorder_ = startOnBorder_;
}

bool ArtificialRoadLaneGroup::getEndOnBorder() const
{
    return m_endOnBorder_;
}

void ArtificialRoadLaneGroup::setEndOnBorder(bool endOnBorder_)
{
    m_endOnBorder_ = endOnBorder_;
}

::nds::lane::lanegroups::LaneGroupConnector& ArtificialRoadLaneGroup::getStartConnector()
{
    return m_startConnector_;
}

const ::nds::lane::lanegroups::LaneGroupConnector& ArtificialRoadLaneGroup::getStartConnector() const
{
    return m_startConnector_;
}

void ArtificialRoadLaneGroup::setStartConnector(const ::nds::lane::lanegroups::LaneGroupConnector& startConnector_)
{
    m_startConnector_ = startConnector_;
}

void ArtificialRoadLaneGroup::setStartConnector(::nds::lane::lanegroups::LaneGroupConnector&& startConnector_)
{
    m_startConnector_ = ::std::move(startConnector_);
}

::nds::lane::lanegroups::LaneGroupConnector& ArtificialRoadLaneGroup::getEndConnector()
{
    return m_endConnector_;
}

const ::nds::lane::lanegroups::LaneGroupConnector& ArtificialRoadLaneGroup::getEndConnector() const
{
    return m_endConnector_;
}

void ArtificialRoadLaneGroup::setEndConnector(const ::nds::lane::lanegroups::LaneGroupConnector& endConnector_)
{
    m_endConnector_ = endConnector_;
}

void ArtificialRoadLaneGroup::setEndConnector(::nds::lane::lanegroups::LaneGroupConnector&& endConnector_)
{
    m_endConnector_ = ::std::move(endConnector_);
}

::zserio::vector<::nds::lane::lanes::Lane>& ArtificialRoadLaneGroup::getLanes()
{
    return m_lanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::Lane>& ArtificialRoadLaneGroup::getLanes() const
{
    return m_lanes_.getRawArray();
}

void ArtificialRoadLaneGroup::setLanes(const ::zserio::vector<::nds::lane::lanes::Lane>& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(lanes_);
}

void ArtificialRoadLaneGroup::setLanes(::zserio::vector<::nds::lane::lanes::Lane>&& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(std::move(lanes_));
}

void ArtificialRoadLaneGroup::initPackingContext(ArtificialRoadLaneGroup::ZserioPackingContext& context) const
{
    m_startConnector_.initPackingContext(context.getStartConnector());
    m_endConnector_.initPackingContext(context.getEndConnector());
}

size_t ArtificialRoadLaneGroup::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_startConnector_.bitSizeOf(endBitPosition);
    endBitPosition += m_endConnector_.bitSizeOf(endBitPosition);
    endBitPosition += m_lanes_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ArtificialRoadLaneGroup::bitSizeOf(ArtificialRoadLaneGroup::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_startConnector_.bitSizeOf(context.getStartConnector(), endBitPosition);
    endBitPosition += m_endConnector_.bitSizeOf(context.getEndConnector(), endBitPosition);
    endBitPosition += m_lanes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ArtificialRoadLaneGroup::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_startConnector_.initializeOffsets(endBitPosition);
    endBitPosition = m_endConnector_.initializeOffsets(endBitPosition);
    endBitPosition = m_lanes_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ArtificialRoadLaneGroup::initializeOffsets(ArtificialRoadLaneGroup::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_startConnector_.initializeOffsets(context.getStartConnector(), endBitPosition);
    endBitPosition = m_endConnector_.initializeOffsets(context.getEndConnector(), endBitPosition);
    endBitPosition = m_lanes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ArtificialRoadLaneGroup::operator==(const ArtificialRoadLaneGroup& other) const
{
    if (this != &other)
    {
        return
                (getHasBoundaryGeometry() == other.getHasBoundaryGeometry()) &&
                (m_startOnBorder_ == other.m_startOnBorder_) &&
                (m_endOnBorder_ == other.m_endOnBorder_) &&
                (m_startConnector_ == other.m_startConnector_) &&
                (m_endConnector_ == other.m_endConnector_) &&
                (m_lanes_ == other.m_lanes_);
    }

    return true;
}

uint32_t ArtificialRoadLaneGroup::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHasBoundaryGeometry());
    result = ::zserio::calcHashCode(result, m_startOnBorder_);
    result = ::zserio::calcHashCode(result, m_endOnBorder_);
    result = ::zserio::calcHashCode(result, m_startConnector_);
    result = ::zserio::calcHashCode(result, m_endConnector_);
    result = ::zserio::calcHashCode(result, m_lanes_);

    return result;
}

void ArtificialRoadLaneGroup::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_startOnBorder_);

    out.writeBool(m_endOnBorder_);

    // check parameters
    if (m_startConnector_.getOnBorder() != static_cast<bool>(getStartOnBorder()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field ArtificialRoadLaneGroup.startConnector: ") <<
                m_startConnector_.getOnBorder() << " != " << static_cast<bool>(getStartOnBorder()) << "!";
    }
    m_startConnector_.write(out);

    // check parameters
    if (m_endConnector_.getOnBorder() != static_cast<bool>(getEndOnBorder()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field ArtificialRoadLaneGroup.endConnector: ") <<
                m_endConnector_.getOnBorder() << " != " << static_cast<bool>(getEndOnBorder()) << "!";
    }
    m_endConnector_.write(out);

    m_lanes_.write(*this, out);
}

void ArtificialRoadLaneGroup::write(ArtificialRoadLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_startOnBorder_);

    out.writeBool(m_endOnBorder_);

    // check parameters
    if (m_startConnector_.getOnBorder() != static_cast<bool>(getStartOnBorder()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field ArtificialRoadLaneGroup.startConnector: ") <<
                m_startConnector_.getOnBorder() << " != " << static_cast<bool>(getStartOnBorder()) << "!";
    }
    m_startConnector_.write(context.getStartConnector(), out);

    // check parameters
    if (m_endConnector_.getOnBorder() != static_cast<bool>(getEndOnBorder()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter onBorder for field ArtificialRoadLaneGroup.endConnector: ") <<
                m_endConnector_.getOnBorder() << " != " << static_cast<bool>(getEndOnBorder()) << "!";
    }
    m_endConnector_.write(context.getEndConnector(), out);

    m_lanes_.writePacked(*this, out);
}

void ArtificialRoadLaneGroup::ZserioArrayExpressions_lanes::initializeElement(ArtificialRoadLaneGroup& owner,
        ::nds::lane::lanes::Lane& element, size_t)
{
    element.initialize(static_cast<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType::ORDERED), static_cast<bool>(owner.getHasBoundaryGeometry()));
}

void ArtificialRoadLaneGroup::ZserioElementFactory_lanes::create(ArtificialRoadLaneGroup&         owner,
        ::zserio::vector<::nds::lane::lanes::Lane>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType::ORDERED), static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

void ArtificialRoadLaneGroup::ZserioElementFactory_lanes::create(ArtificialRoadLaneGroup&         owner,
        ::zserio::vector<::nds::lane::lanes::Lane>& array,
        ::nds::lane::lanes::Lane::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType::ORDERED), static_cast<bool>(owner.getHasBoundaryGeometry()), array.get_allocator());
}

bool ArtificialRoadLaneGroup::readStartOnBorder(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool ArtificialRoadLaneGroup::readEndOnBorder(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::lane::lanegroups::LaneGroupConnector ArtificialRoadLaneGroup::readStartConnector(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(in, static_cast<bool>(getStartOnBorder()), allocator);
}

::nds::lane::lanegroups::LaneGroupConnector ArtificialRoadLaneGroup::readStartConnector(ArtificialRoadLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(context.getStartConnector(), in, static_cast<bool>(getStartOnBorder()), allocator);
}
::nds::lane::lanegroups::LaneGroupConnector ArtificialRoadLaneGroup::readEndConnector(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(in, static_cast<bool>(getEndOnBorder()), allocator);
}

::nds::lane::lanegroups::LaneGroupConnector ArtificialRoadLaneGroup::readEndConnector(ArtificialRoadLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::lanegroups::LaneGroupConnector(context.getEndConnector(), in, static_cast<bool>(getEndOnBorder()), allocator);
}
ArtificialRoadLaneGroup::ZserioArrayType_lanes ArtificialRoadLaneGroup::readLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.read(*this, in);

    return readField;
}

ArtificialRoadLaneGroup::ZserioArrayType_lanes ArtificialRoadLaneGroup::readLanes(ArtificialRoadLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace lanegroups
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/lane/lanegroups/ArtificialIntersectionLaneGroup.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

ArtificialIntersectionLaneGroup::ArtificialIntersectionLaneGroup(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_intersectionConnectors_(allocator),
        m_lanes_(allocator)
{
}

ArtificialIntersectionLaneGroup::ArtificialIntersectionLaneGroup(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_intersectionConnectors_(readIntersectionConnectors(in, allocator)),
        m_lanes_(readLanes(in, allocator))
{
}

ArtificialIntersectionLaneGroup::ArtificialIntersectionLaneGroup(ArtificialIntersectionLaneGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_intersectionConnectors_(readIntersectionConnectors(context, in, allocator)),
        m_lanes_(readLanes(context, in, allocator))
{
}

ArtificialIntersectionLaneGroup::ArtificialIntersectionLaneGroup(const ArtificialIntersectionLaneGroup& other) :
        m_intersectionConnectors_(other.m_intersectionConnectors_),
        m_lanes_(other.m_lanes_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ArtificialIntersectionLaneGroup& ArtificialIntersectionLaneGroup::operator=(const ArtificialIntersectionLaneGroup& other)
{
    m_intersectionConnectors_ = other.m_intersectionConnectors_;
    m_lanes_ = other.m_lanes_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ArtificialIntersectionLaneGroup::ArtificialIntersectionLaneGroup(ArtificialIntersectionLaneGroup&& other) :
        m_intersectionConnectors_(::std::move(other.m_intersectionConnectors_)),
        m_lanes_(::std::move(other.m_lanes_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ArtificialIntersectionLaneGroup& ArtificialIntersectionLaneGroup::operator=(ArtificialIntersectionLaneGroup&& other)
{
    m_intersectionConnectors_ = ::std::move(other.m_intersectionConnectors_);
    m_lanes_ = ::std::move(other.m_lanes_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ArtificialIntersectionLaneGroup::ArtificialIntersectionLaneGroup(::zserio::PropagateAllocatorT,
        const ArtificialIntersectionLaneGroup& other, const allocator_type& allocator) :
        m_intersectionConnectors_(::zserio::allocatorPropagatingCopy(other.m_intersectionConnectors_, allocator)),
        m_lanes_(::zserio::allocatorPropagatingCopy(other.m_lanes_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ArtificialIntersectionLaneGroup::initializeChildren()
{
    m_intersectionConnectors_.initializeElements(*this);
    m_lanes_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& ArtificialIntersectionLaneGroup::getIntersectionConnectors()
{
    return m_intersectionConnectors_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& ArtificialIntersectionLaneGroup::getIntersectionConnectors() const
{
    return m_intersectionConnectors_.getRawArray();
}

void ArtificialIntersectionLaneGroup::setIntersectionConnectors(const ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& intersectionConnectors_)
{
    m_intersectionConnectors_ = ZserioArrayType_intersectionConnectors(intersectionConnectors_);
}

void ArtificialIntersectionLaneGroup::setIntersectionConnectors(::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>&& intersectionConnectors_)
{
    m_intersectionConnectors_ = ZserioArrayType_intersectionConnectors(std::move(intersectionConnectors_));
}

::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& ArtificialIntersectionLaneGroup::getLanes()
{
    return m_lanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& ArtificialIntersectionLaneGroup::getLanes() const
{
    return m_lanes_.getRawArray();
}

void ArtificialIntersectionLaneGroup::setLanes(const ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(lanes_);
}

void ArtificialIntersectionLaneGroup::setLanes(::zserio::vector<::nds::lane::lanes::ZeroLengthLane>&& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(std::move(lanes_));
}

void ArtificialIntersectionLaneGroup::initPackingContext(ArtificialIntersectionLaneGroup::ZserioPackingContext&) const
{
}

size_t ArtificialIntersectionLaneGroup::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_intersectionConnectors_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_lanes_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ArtificialIntersectionLaneGroup::bitSizeOf(ArtificialIntersectionLaneGroup::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_intersectionConnectors_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_lanes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ArtificialIntersectionLaneGroup::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_intersectionConnectors_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_lanes_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ArtificialIntersectionLaneGroup::initializeOffsets(ArtificialIntersectionLaneGroup::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_intersectionConnectors_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_lanes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ArtificialIntersectionLaneGroup::operator==(const ArtificialIntersectionLaneGroup& other) const
{
    if (this != &other)
    {
        return
                (m_intersectionConnectors_ == other.m_intersectionConnectors_) &&
                (m_lanes_ == other.m_lanes_);
    }

    return true;
}

uint32_t ArtificialIntersectionLaneGroup::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_intersectionConnectors_);
    result = ::zserio::calcHashCode(result, m_lanes_);

    return result;
}

void ArtificialIntersectionLaneGroup::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getIntersectionConnectors().size() > 2))
        throw ::zserio::ConstraintException("Write: Constraint violated at ArtificialIntersectionLaneGroup.intersectionConnectors!");
    m_intersectionConnectors_.write(*this, out);

    m_lanes_.write(*this, out);
}

void ArtificialIntersectionLaneGroup::write(ArtificialIntersectionLaneGroup::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getIntersectionConnectors().size() > 2))
        throw ::zserio::ConstraintException("Write: Constraint violated at ArtificialIntersectionLaneGroup.intersectionConnectors!");
    m_intersectionConnectors_.writePacked(*this, out);

    m_lanes_.writePacked(*this, out);
}

void ArtificialIntersectionLaneGroup::ZserioArrayExpressions_intersectionConnectors::initializeElement(ArtificialIntersectionLaneGroup&,
        ::nds::lane::lanegroups::LaneGroupConnector& element, size_t)
{
    element.initialize(static_cast<bool>(false));
}

void ArtificialIntersectionLaneGroup::ZserioElementFactory_intersectionConnectors::create(ArtificialIntersectionLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(false), array.get_allocator());
}

void ArtificialIntersectionLaneGroup::ZserioElementFactory_intersectionConnectors::create(ArtificialIntersectionLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanegroups::LaneGroupConnector>& array,
        ::nds::lane::lanegroups::LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(false), array.get_allocator());
}

void ArtificialIntersectionLaneGroup::ZserioArrayExpressions_lanes::initializeElement(ArtificialIntersectionLaneGroup&,
        ::nds::lane::lanes::ZeroLengthLane& element, size_t)
{
    element.initialize(static_cast<bool>(false));
}

void ArtificialIntersectionLaneGroup::ZserioElementFactory_lanes::create(ArtificialIntersectionLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<bool>(false), array.get_allocator());
}

void ArtificialIntersectionLaneGroup::ZserioElementFactory_lanes::create(ArtificialIntersectionLaneGroup&        ,
        ::zserio::vector<::nds::lane::lanes::ZeroLengthLane>& array,
        ::nds::lane::lanes::ZeroLengthLane::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<bool>(false), array.get_allocator());
}

ArtificialIntersectionLaneGroup::ZserioArrayType_intersectionConnectors ArtificialIntersectionLaneGroup::readIntersectionConnectors(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_intersectionConnectors readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 2))
        throw ::zserio::ConstraintException("Read: Constraint violated at ArtificialIntersectionLaneGroup.intersectionConnectors!");

    return readField;
}

ArtificialIntersectionLaneGroup::ZserioArrayType_intersectionConnectors ArtificialIntersectionLaneGroup::readIntersectionConnectors(ArtificialIntersectionLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_intersectionConnectors readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 2))
        throw ::zserio::ConstraintException("Read: Constraint violated at ArtificialIntersectionLaneGroup.intersectionConnectors!");

    return readField;
}
ArtificialIntersectionLaneGroup::ZserioArrayType_lanes ArtificialIntersectionLaneGroup::readLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.read(*this, in);

    return readField;
}

ArtificialIntersectionLaneGroup::ZserioArrayType_lanes ArtificialIntersectionLaneGroup::readLanes(ArtificialIntersectionLaneGroup::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace lanegroups
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/lanegroups/LaneGroupConnector.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

LaneGroupConnector::LaneGroupConnector(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_position_(allocator),
        m_connectedLaneGroupId_(::zserio::NullOpt),
        m_borderIndicator_(::zserio::NullOpt)
{
}

LaneGroupConnector::LaneGroupConnector(::zserio::BitStreamReader& in,
        bool onBorder_, const allocator_type& allocator) :
        m_onBorder_(onBorder_),
        m_isInitialized(true),
        m_position_(readPosition(in, allocator)),
        m_connectedLaneGroupId_(readConnectedLaneGroupId(in, allocator)),
        m_borderIndicator_(readBorderIndicator(in))
{
}

LaneGroupConnector::LaneGroupConnector(LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool onBorder_, const allocator_type& allocator) :
        m_onBorder_(onBorder_),
        m_isInitialized(true),
        m_position_(readPosition(context, in, allocator)),
        m_connectedLaneGroupId_(readConnectedLaneGroupId(context, in, allocator)),
        m_borderIndicator_(readBorderIndicator(context, in))
{
}

LaneGroupConnector::LaneGroupConnector(const LaneGroupConnector& other) :
        m_position_(other.m_position_),
        m_connectedLaneGroupId_(other.m_connectedLaneGroupId_),
        m_borderIndicator_(other.m_borderIndicator_)
{
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;
}

LaneGroupConnector& LaneGroupConnector::operator=(const LaneGroupConnector& other)
{
    m_position_ = other.m_position_;
    m_connectedLaneGroupId_ = other.m_connectedLaneGroupId_;
    m_borderIndicator_ = other.m_borderIndicator_;
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupConnector::LaneGroupConnector(LaneGroupConnector&& other) :
        m_position_(::std::move(other.m_position_)),
        m_connectedLaneGroupId_(::std::move(other.m_connectedLaneGroupId_)),
        m_borderIndicator_(::std::move(other.m_borderIndicator_))
{
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;
}

LaneGroupConnector& LaneGroupConnector::operator=(LaneGroupConnector&& other)
{
    m_position_ = ::std::move(other.m_position_);
    m_connectedLaneGroupId_ = ::std::move(other.m_connectedLaneGroupId_);
    m_borderIndicator_ = ::std::move(other.m_borderIndicator_);
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupConnector::LaneGroupConnector(::zserio::PropagateAllocatorT,
        const LaneGroupConnector& other, const allocator_type& allocator) :
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator)),
        m_connectedLaneGroupId_(::zserio::allocatorPropagatingCopy(other.m_connectedLaneGroupId_, allocator)),
        m_borderIndicator_(::zserio::allocatorPropagatingCopy(other.m_borderIndicator_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_onBorder_);
    else
        m_isInitialized = false;
}

void LaneGroupConnector::initialize(
        bool onBorder_)
{
    m_onBorder_ = onBorder_;
    m_isInitialized = true;

    initializeChildren();
}

bool LaneGroupConnector::isInitialized() const
{
    return m_isInitialized;
}

void LaneGroupConnector::initializeChildren()
{
    m_position_.initialize(static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0));
}

bool LaneGroupConnector::getOnBorder() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'onBorder' of compound 'LaneGroupConnector' is not initialized!");

    return m_onBorder_;
}

::nds::core::geometry::Position3D& LaneGroupConnector::getPosition()
{
    return m_position_;
}

const ::nds::core::geometry::Position3D& LaneGroupConnector::getPosition() const
{
    return m_position_;
}

void LaneGroupConnector::setPosition(const ::nds::core::geometry::Position3D& position_)
{
    m_position_ = position_;
}

void LaneGroupConnector::setPosition(::nds::core::geometry::Position3D&& position_)
{
    m_position_ = ::std::move(position_);
}

::nds::lane::reference::types::LaneGroupId& LaneGroupConnector::getConnectedLaneGroupId()
{
    return m_connectedLaneGroupId_.value();
}

const ::nds::lane::reference::types::LaneGroupId& LaneGroupConnector::getConnectedLaneGroupId() const
{
    return m_connectedLaneGroupId_.value();
}

void LaneGroupConnector::setConnectedLaneGroupId(const ::nds::lane::reference::types::LaneGroupId& connectedLaneGroupId_)
{
    m_connectedLaneGroupId_ = connectedLaneGroupId_;
}

void LaneGroupConnector::setConnectedLaneGroupId(::nds::lane::reference::types::LaneGroupId&& connectedLaneGroupId_)
{
    m_connectedLaneGroupId_ = ::std::move(connectedLaneGroupId_);
}

bool LaneGroupConnector::isConnectedLaneGroupIdUsed() const
{
    return (!getOnBorder());
}

bool LaneGroupConnector::isConnectedLaneGroupIdSet() const
{
    return m_connectedLaneGroupId_.hasValue();
}

void LaneGroupConnector::resetConnectedLaneGroupId()
{
    m_connectedLaneGroupId_.reset();
}

::nds::lane::types::TileBorderIndicator LaneGroupConnector::getBorderIndicator() const
{
    return m_borderIndicator_.value();
}

void LaneGroupConnector::setBorderIndicator(::nds::lane::types::TileBorderIndicator borderIndicator_)
{
    m_borderIndicator_ = borderIndicator_;
}

bool LaneGroupConnector::isBorderIndicatorUsed() const
{
    return (getOnBorder());
}

bool LaneGroupConnector::isBorderIndicatorSet() const
{
    return m_borderIndicator_.hasValue();
}

void LaneGroupConnector::resetBorderIndicator()
{
    m_borderIndicator_.reset();
}

void LaneGroupConnector::initPackingContext(LaneGroupConnector::ZserioPackingContext& context) const
{
    m_position_.initPackingContext(context.getPosition());
    if (!getOnBorder())
    {
        m_connectedLaneGroupId_.value().initPackingContext(context.getConnectedLaneGroupId());
    }
    if (getOnBorder())
    {
        ::zserio::initPackingContext(context.getBorderIndicator(), m_borderIndicator_.value());
    }
}

size_t LaneGroupConnector::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(endBitPosition);
    if (!getOnBorder())
    {
        endBitPosition += m_connectedLaneGroupId_.value().bitSizeOf(endBitPosition);
    }
    if (getOnBorder())
    {
        endBitPosition += ::zserio::bitSizeOf(m_borderIndicator_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupConnector::bitSizeOf(LaneGroupConnector::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);
    if (!getOnBorder())
    {
        endBitPosition += m_connectedLaneGroupId_.value().bitSizeOf(context.getConnectedLaneGroupId(), endBitPosition);
    }
    if (getOnBorder())
    {
        endBitPosition += ::zserio::bitSizeOf(context.getBorderIndicator(), m_borderIndicator_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupConnector::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(endBitPosition);
    if (!getOnBorder())
    {
        endBitPosition = m_connectedLaneGroupId_.value().initializeOffsets(endBitPosition);
    }
    if (getOnBorder())
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_borderIndicator_.value());
    }

    return endBitPosition;
}

size_t LaneGroupConnector::initializeOffsets(LaneGroupConnector::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);
    if (!getOnBorder())
    {
        endBitPosition = m_connectedLaneGroupId_.value().initializeOffsets(context.getConnectedLaneGroupId(), endBitPosition);
    }
    if (getOnBorder())
    {
        endBitPosition = ::zserio::initializeOffsets(context.getBorderIndicator(), endBitPosition,
        m_borderIndicator_.value());
    }

    return endBitPosition;
}

bool LaneGroupConnector::operator==(const LaneGroupConnector& other) const
{
    if (this != &other)
    {
        return
                (getOnBorder() == other.getOnBorder()) &&
                (m_position_ == other.m_position_) &&
                (!isConnectedLaneGroupIdUsed() ? !other.isConnectedLaneGroupIdUsed() : (m_connectedLaneGroupId_ == other.m_connectedLaneGroupId_)) &&
                (!isBorderIndicatorUsed() ? !other.isBorderIndicatorUsed() : (m_borderIndicator_ == other.m_borderIndicator_));
    }

    return true;
}

uint32_t LaneGroupConnector::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getOnBorder());
    result = ::zserio::calcHashCode(result, m_position_);
    if (isConnectedLaneGroupIdUsed())
        result = ::zserio::calcHashCode(result, m_connectedLaneGroupId_);
    if (isBorderIndicatorUsed())
        result = ::zserio::calcHashCode(result, m_borderIndicator_);

    return result;
}

void LaneGroupConnector::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LaneGroupConnector.position: ") <<
                m_position_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    if (m_position_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LaneGroupConnector.position: ") <<
                m_position_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(out);

    if (!getOnBorder())
    {
        m_connectedLaneGroupId_.value().write(out);
    }

    if (getOnBorder())
    {
        ::zserio::write(out, m_borderIndicator_.value());
    }
}

void LaneGroupConnector::write(LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LaneGroupConnector.position: ") <<
                m_position_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    if (m_position_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LaneGroupConnector.position: ") <<
                m_position_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(context.getPosition(), out);

    if (!getOnBorder())
    {
        m_connectedLaneGroupId_.value().write(context.getConnectedLaneGroupId(), out);
    }

    if (getOnBorder())
    {
        ::zserio::write(context.getBorderIndicator(), out, m_borderIndicator_.value());
    }
}

::nds::core::geometry::Position3D LaneGroupConnector::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position3D(in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::core::geometry::Position3D LaneGroupConnector::readPosition(LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position3D(context.getPosition(), in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId> LaneGroupConnector::readConnectedLaneGroupId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getOnBorder())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId>(::nds::lane::reference::types::LaneGroupId(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId> LaneGroupConnector::readConnectedLaneGroupId(LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getOnBorder())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId>(::nds::lane::reference::types::LaneGroupId(context.getConnectedLaneGroupId(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupId>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::lane::types::TileBorderIndicator> LaneGroupConnector::readBorderIndicator(::zserio::BitStreamReader& in)
{
    if (getOnBorder())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::types::TileBorderIndicator>(::zserio::read<::nds::lane::types::TileBorderIndicator>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::types::TileBorderIndicator>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::types::TileBorderIndicator> LaneGroupConnector::readBorderIndicator(LaneGroupConnector::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getOnBorder())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::types::TileBorderIndicator>(::zserio::read<::nds::lane::types::TileBorderIndicator>(context.getBorderIndicator(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::types::TileBorderIndicator>(::zserio::NullOpt);
}

} // namespace lanegroups
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/lanegroups/MatchedLaneGroupSegment.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

MatchedLaneGroupSegment::MatchedLaneGroupSegment(const allocator_type& allocator) noexcept :
        m_matchedLaneGroups_(allocator)
{
}

MatchedLaneGroupSegment::MatchedLaneGroupSegment(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_matchedLaneGroups_(readMatchedLaneGroups(in, allocator))
{
}

MatchedLaneGroupSegment::MatchedLaneGroupSegment(MatchedLaneGroupSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_matchedLaneGroups_(readMatchedLaneGroups(context, in, allocator))
{
}

MatchedLaneGroupSegment::MatchedLaneGroupSegment(::zserio::PropagateAllocatorT,
        const MatchedLaneGroupSegment& other, const allocator_type& allocator) :
        m_matchedLaneGroups_(::zserio::allocatorPropagatingCopy(other.m_matchedLaneGroups_, allocator))
{
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& MatchedLaneGroupSegment::getMatchedLaneGroups()
{
    return m_matchedLaneGroups_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& MatchedLaneGroupSegment::getMatchedLaneGroups() const
{
    return m_matchedLaneGroups_.getRawArray();
}

void MatchedLaneGroupSegment::setMatchedLaneGroups(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& matchedLaneGroups_)
{
    m_matchedLaneGroups_ = ZserioArrayType_matchedLaneGroups(matchedLaneGroups_);
}

void MatchedLaneGroupSegment::setMatchedLaneGroups(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& matchedLaneGroups_)
{
    m_matchedLaneGroups_ = ZserioArrayType_matchedLaneGroups(std::move(matchedLaneGroups_));
}

void MatchedLaneGroupSegment::initPackingContext(MatchedLaneGroupSegment::ZserioPackingContext&) const
{
}

size_t MatchedLaneGroupSegment::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_matchedLaneGroups_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MatchedLaneGroupSegment::bitSizeOf(MatchedLaneGroupSegment::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_matchedLaneGroups_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t MatchedLaneGroupSegment::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_matchedLaneGroups_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t MatchedLaneGroupSegment::initializeOffsets(MatchedLaneGroupSegment::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_matchedLaneGroups_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool MatchedLaneGroupSegment::operator==(const MatchedLaneGroupSegment& other) const
{
    if (this != &other)
    {
        return
                (m_matchedLaneGroups_ == other.m_matchedLaneGroups_);
    }

    return true;
}

uint32_t MatchedLaneGroupSegment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_matchedLaneGroups_);

    return result;
}

void MatchedLaneGroupSegment::write(::zserio::BitStreamWriter& out) const
{
    m_matchedLaneGroups_.write(*this, out);
}

void MatchedLaneGroupSegment::write(MatchedLaneGroupSegment::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_matchedLaneGroups_.writePacked(*this, out);
}

void MatchedLaneGroupSegment::ZserioElementFactory_matchedLaneGroups::create(MatchedLaneGroupSegment&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void MatchedLaneGroupSegment::ZserioElementFactory_matchedLaneGroups::create(MatchedLaneGroupSegment&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

MatchedLaneGroupSegment::ZserioArrayType_matchedLaneGroups MatchedLaneGroupSegment::readMatchedLaneGroups(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_matchedLaneGroups readField(allocator);
    readField.read(*this, in);

    return readField;
}

MatchedLaneGroupSegment::ZserioArrayType_matchedLaneGroups MatchedLaneGroupSegment::readMatchedLaneGroups(MatchedLaneGroupSegment::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_matchedLaneGroups readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace lanegroups
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/lanegroups/LaneGroupChoice.h>

namespace nds
{
namespace lane
{
namespace lanegroups
{

LaneGroupChoice::LaneGroupChoice(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

LaneGroupChoice::LaneGroupChoice(::zserio::BitStreamReader& in,
        ::nds::lane::lanegroups::LaneGroupType type_,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

LaneGroupChoice::LaneGroupChoice(LaneGroupChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::lane::lanegroups::LaneGroupType type_,
        bool hasBoundaryGeometry_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasBoundaryGeometry_(hasBoundaryGeometry_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

LaneGroupChoice::LaneGroupChoice(const LaneGroupChoice& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

LaneGroupChoice& LaneGroupChoice::operator=(const LaneGroupChoice& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupChoice::LaneGroupChoice(LaneGroupChoice&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

LaneGroupChoice& LaneGroupChoice::operator=(LaneGroupChoice&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupChoice::LaneGroupChoice(::zserio::PropagateAllocatorT,
        const LaneGroupChoice& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasBoundaryGeometry_);
    else
        m_isInitialized = false;
}

void LaneGroupChoice::initialize(
        ::nds::lane::lanegroups::LaneGroupType type_,
        bool hasBoundaryGeometry_)
{
    m_type_ = type_;
    m_hasBoundaryGeometry_ = hasBoundaryGeometry_;
    m_isInitialized = true;

    initializeChildren();
}

bool LaneGroupChoice::isInitialized() const
{
    return m_isInitialized;
}

void LaneGroupChoice::initializeChildren()
{
    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().initialize(static_cast<bool>(getHasBoundaryGeometry()));
        break;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().initialize(static_cast<bool>(getHasBoundaryGeometry()));
        break;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>().initializeChildren();
        break;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>().initializeChildren();
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().initialize(static_cast<bool>(getHasBoundaryGeometry()));
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>().initializeChildren();
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }
}

::nds::lane::lanegroups::LaneGroupType LaneGroupChoice::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'LaneGroupChoice' is not initialized!");

    return m_type_;
}

bool LaneGroupChoice::getHasBoundaryGeometry() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasBoundaryGeometry' of compound 'LaneGroupChoice' is not initialized!");

    return m_hasBoundaryGeometry_;
}

::nds::lane::lanegroups::RoadLaneGroup& LaneGroupChoice::getRoad()
{
    return m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>();
}

const ::nds::lane::lanegroups::RoadLaneGroup& LaneGroupChoice::getRoad() const
{
    return m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>();
}

void LaneGroupChoice::setRoad(const ::nds::lane::lanegroups::RoadLaneGroup& road_)
{
    m_objectChoice = road_;
}

void LaneGroupChoice::setRoad(::nds::lane::lanegroups::RoadLaneGroup&& road_)
{
    m_objectChoice = ::std::move(road_);
}

::nds::lane::lanegroups::IntersectionLaneGroup& LaneGroupChoice::getIntersection()
{
    return m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>();
}

const ::nds::lane::lanegroups::IntersectionLaneGroup& LaneGroupChoice::getIntersection() const
{
    return m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>();
}

void LaneGroupChoice::setIntersection(const ::nds::lane::lanegroups::IntersectionLaneGroup& intersection_)
{
    m_objectChoice = intersection_;
}

void LaneGroupChoice::setIntersection(::nds::lane::lanegroups::IntersectionLaneGroup&& intersection_)
{
    m_objectChoice = ::std::move(intersection_);
}

::nds::lane::lanegroups::BorderLaneGroup& LaneGroupChoice::getBorder()
{
    return m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>();
}

const ::nds::lane::lanegroups::BorderLaneGroup& LaneGroupChoice::getBorder() const
{
    return m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>();
}

void LaneGroupChoice::setBorder(const ::nds::lane::lanegroups::BorderLaneGroup& border_)
{
    m_objectChoice = border_;
}

void LaneGroupChoice::setBorder(::nds::lane::lanegroups::BorderLaneGroup&& border_)
{
    m_objectChoice = ::std::move(border_);
}

::nds::lane::lanegroups::ForkLaneGroup& LaneGroupChoice::getFork()
{
    return m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>();
}

const ::nds::lane::lanegroups::ForkLaneGroup& LaneGroupChoice::getFork() const
{
    return m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>();
}

void LaneGroupChoice::setFork(const ::nds::lane::lanegroups::ForkLaneGroup& fork_)
{
    m_objectChoice = fork_;
}

void LaneGroupChoice::setFork(::nds::lane::lanegroups::ForkLaneGroup&& fork_)
{
    m_objectChoice = ::std::move(fork_);
}

::nds::lane::lanegroups::ArtificialRoadLaneGroup& LaneGroupChoice::getArtificialRoad()
{
    return m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>();
}

const ::nds::lane::lanegroups::ArtificialRoadLaneGroup& LaneGroupChoice::getArtificialRoad() const
{
    return m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>();
}

void LaneGroupChoice::setArtificialRoad(const ::nds::lane::lanegroups::ArtificialRoadLaneGroup& artificialRoad_)
{
    m_objectChoice = artificialRoad_;
}

void LaneGroupChoice::setArtificialRoad(::nds::lane::lanegroups::ArtificialRoadLaneGroup&& artificialRoad_)
{
    m_objectChoice = ::std::move(artificialRoad_);
}

::nds::lane::lanegroups::ArtificialIntersectionLaneGroup& LaneGroupChoice::getArtificialIntersection()
{
    return m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>();
}

const ::nds::lane::lanegroups::ArtificialIntersectionLaneGroup& LaneGroupChoice::getArtificialIntersection() const
{
    return m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>();
}

void LaneGroupChoice::setArtificialIntersection(const ::nds::lane::lanegroups::ArtificialIntersectionLaneGroup& artificialIntersection_)
{
    m_objectChoice = artificialIntersection_;
}

void LaneGroupChoice::setArtificialIntersection(::nds::lane::lanegroups::ArtificialIntersectionLaneGroup&& artificialIntersection_)
{
    m_objectChoice = ::std::move(artificialIntersection_);
}

LaneGroupChoice::ChoiceTag LaneGroupChoice::choiceTag() const
{
    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        return CHOICE_road;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        return CHOICE_intersection;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        return CHOICE_border;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        return CHOICE_fork;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        return CHOICE_artificialRoad;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        return CHOICE_artificialIntersection;
    default:
        return UNDEFINED_CHOICE;
    }
}

void LaneGroupChoice::initPackingContext(LaneGroupChoice::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().initPackingContext(context.getRoad());
        break;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().initPackingContext(context.getIntersection());
        break;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>().initPackingContext(context.getBorder());
        break;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>().initPackingContext(context.getFork());
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().initPackingContext(context.getArtificialRoad());
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>().initPackingContext(context.getArtificialIntersection());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }
}

size_t LaneGroupChoice::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupChoice::bitSizeOf(LaneGroupChoice::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().bitSizeOf(context.getRoad(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().bitSizeOf(context.getIntersection(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>().bitSizeOf(context.getBorder(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>().bitSizeOf(context.getFork(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().bitSizeOf(context.getArtificialRoad(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        endBitPosition += m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>().bitSizeOf(context.getArtificialIntersection(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupChoice::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }

    return endBitPosition;
}

size_t LaneGroupChoice::initializeOffsets(LaneGroupChoice::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().initializeOffsets(context.getRoad(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().initializeOffsets(context.getIntersection(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>().initializeOffsets(context.getBorder(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>().initializeOffsets(context.getFork(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().initializeOffsets(context.getArtificialRoad(), endBitPosition);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        endBitPosition = m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>().initializeOffsets(context.getArtificialIntersection(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }

    return endBitPosition;
}

bool LaneGroupChoice::operator==(const LaneGroupChoice& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType())||
            !(getHasBoundaryGeometry() == other.getHasBoundaryGeometry()))
        return false;

    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>() == other.m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>());
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>() == other.m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>());
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>() == other.m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>());
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>() == other.m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>());
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>() == other.m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>());
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>() == other.m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }
}

uint32_t LaneGroupChoice::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getHasBoundaryGeometry());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::lane::lanegroups::LaneGroupType::ROAD:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>());
            break;
        case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>());
            break;
        case ::nds::lane::lanegroups::LaneGroupType::BORDER:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>());
            break;
        case ::nds::lane::lanegroups::LaneGroupType::FORK:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>());
            break;
        case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>());
            break;
        case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>());
            break;
        default:
            break;
        }
    }

    return result;
}

void LaneGroupChoice::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        // check parameters
        if (m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().getHasBoundaryGeometry() != static_cast<bool>(getHasBoundaryGeometry()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasBoundaryGeometry for field LaneGroupChoice.road: ") <<
                    m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().getHasBoundaryGeometry() << " != " << static_cast<bool>(getHasBoundaryGeometry()) << "!";
        }
        m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().write(out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        // check parameters
        if (m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().getHasBoundaryGeometry() != static_cast<bool>(getHasBoundaryGeometry()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasBoundaryGeometry for field LaneGroupChoice.intersection: ") <<
                    m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().getHasBoundaryGeometry() << " != " << static_cast<bool>(getHasBoundaryGeometry()) << "!";
        }
        m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().write(out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>().write(out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>().write(out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        // check parameters
        if (m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().getHasBoundaryGeometry() != static_cast<bool>(getHasBoundaryGeometry()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasBoundaryGeometry for field LaneGroupChoice.artificialRoad: ") <<
                    m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().getHasBoundaryGeometry() << " != " << static_cast<bool>(getHasBoundaryGeometry()) << "!";
        }
        m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().write(out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }
}

void LaneGroupChoice::write(LaneGroupChoice::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        // check parameters
        if (m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().getHasBoundaryGeometry() != static_cast<bool>(getHasBoundaryGeometry()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasBoundaryGeometry for field LaneGroupChoice.road: ") <<
                    m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().getHasBoundaryGeometry() << " != " << static_cast<bool>(getHasBoundaryGeometry()) << "!";
        }
        m_objectChoice.get<::nds::lane::lanegroups::RoadLaneGroup>().write(context.getRoad(), out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        // check parameters
        if (m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().getHasBoundaryGeometry() != static_cast<bool>(getHasBoundaryGeometry()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasBoundaryGeometry for field LaneGroupChoice.intersection: ") <<
                    m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().getHasBoundaryGeometry() << " != " << static_cast<bool>(getHasBoundaryGeometry()) << "!";
        }
        m_objectChoice.get<::nds::lane::lanegroups::IntersectionLaneGroup>().write(context.getIntersection(), out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        m_objectChoice.get<::nds::lane::lanegroups::BorderLaneGroup>().write(context.getBorder(), out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        m_objectChoice.get<::nds::lane::lanegroups::ForkLaneGroup>().write(context.getFork(), out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        // check parameters
        if (m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().getHasBoundaryGeometry() != static_cast<bool>(getHasBoundaryGeometry()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasBoundaryGeometry for field LaneGroupChoice.artificialRoad: ") <<
                    m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().getHasBoundaryGeometry() << " != " << static_cast<bool>(getHasBoundaryGeometry()) << "!";
        }
        m_objectChoice.get<::nds::lane::lanegroups::ArtificialRoadLaneGroup>().write(context.getArtificialRoad(), out);
        break;
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        m_objectChoice.get<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>().write(context.getArtificialIntersection(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }
}

::zserio::AnyHolder<> LaneGroupChoice::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::RoadLaneGroup(in, static_cast<bool>(getHasBoundaryGeometry()), allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::IntersectionLaneGroup(in, static_cast<bool>(getHasBoundaryGeometry()), allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::BorderLaneGroup(in, allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::ForkLaneGroup(in, allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::ArtificialRoadLaneGroup(in, static_cast<bool>(getHasBoundaryGeometry()), allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::ArtificialIntersectionLaneGroup(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }
}

::zserio::AnyHolder<> LaneGroupChoice::readObject(LaneGroupChoice::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::RoadLaneGroup(context.getRoad(), in, static_cast<bool>(getHasBoundaryGeometry()), allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::IntersectionLaneGroup(context.getIntersection(), in, static_cast<bool>(getHasBoundaryGeometry()), allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::BorderLaneGroup(context.getBorder(), in, allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::ForkLaneGroup(context.getFork(), in, allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::ArtificialRoadLaneGroup(context.getArtificialRoad(), in, static_cast<bool>(getHasBoundaryGeometry()), allocator), allocator);
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        return ::zserio::AnyHolder<>(::nds::lane::lanegroups::ArtificialIntersectionLaneGroup(context.getArtificialIntersection(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }
}

::zserio::AnyHolder<> LaneGroupChoice::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::lane::lanegroups::LaneGroupType::ROAD:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::lanegroups::RoadLaneGroup>(m_objectChoice, allocator);
    case ::nds::lane::lanegroups::LaneGroupType::INTERSECTION:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::lanegroups::IntersectionLaneGroup>(m_objectChoice, allocator);
    case ::nds::lane::lanegroups::LaneGroupType::BORDER:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::lanegroups::BorderLaneGroup>(m_objectChoice, allocator);
    case ::nds::lane::lanegroups::LaneGroupType::FORK:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::lanegroups::ForkLaneGroup>(m_objectChoice, allocator);
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_ROAD:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::lanegroups::ArtificialRoadLaneGroup>(m_objectChoice, allocator);
    case ::nds::lane::lanegroups::LaneGroupType::ARTIFICIAL_INTERSECTION:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::lanegroups::ArtificialIntersectionLaneGroup>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneGroupChoice!");
    }
}

} // namespace lanegroups
} // namespace lane
} // namespace nds
