/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/types/LaneLayoutType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneLayoutType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::lane::types::LaneLayoutType>::names;
constexpr ::std::array<::nds::lane::types::LaneLayoutType, 2> EnumTraits<::nds::lane::types::LaneLayoutType>::values;
constexpr const char* EnumTraits<::nds::lane::types::LaneLayoutType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::types::LaneLayoutType value)
{
    switch (value)
    {
    case ::nds::lane::types::LaneLayoutType::ORDERED:
        return 0;
    case ::nds::lane::types::LaneLayoutType::UNORDERED:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneLayoutType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::types::LaneLayoutType>::type>(value) << "!";
    }
}

template <>
::nds::lane::types::LaneLayoutType valueToEnum(
        typename ::std::underlying_type<::nds::lane::types::LaneLayoutType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::lane::types::LaneLayoutType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneLayoutType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::types::LaneLayoutType>(::nds::lane::types::LaneLayoutType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::types::LaneLayoutType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::LaneLayoutType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::types::LaneLayoutType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::types::LaneLayoutType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::LaneLayoutType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::types::LaneLayoutType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::types::LaneLayoutType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::types::LaneLayoutType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::LaneLayoutType>(
            static_cast<typename ::std::underlying_type<::nds::lane::types::LaneLayoutType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::types::LaneLayoutType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::LaneLayoutType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::LaneLayoutType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::types::LaneLayoutType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::types::LaneLayoutType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::LaneLayoutType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/types/BoundaryElementType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for BoundaryElementType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::lane::types::BoundaryElementType>::names;
constexpr ::std::array<::nds::lane::types::BoundaryElementType, 4> EnumTraits<::nds::lane::types::BoundaryElementType>::values;
constexpr const char* EnumTraits<::nds::lane::types::BoundaryElementType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::types::BoundaryElementType value)
{
    switch (value)
    {
    case ::nds::lane::types::BoundaryElementType::LOGICAL:
        return 0;
    case ::nds::lane::types::BoundaryElementType::MARKING:
        return 1;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_DIVIDER:
        return 2;
    case ::nds::lane::types::BoundaryElementType::PHYSICAL_MARKING:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration BoundaryElementType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::types::BoundaryElementType>::type>(value) << "!";
    }
}

template <>
::nds::lane::types::BoundaryElementType valueToEnum(
        typename ::std::underlying_type<::nds::lane::types::BoundaryElementType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::lane::types::BoundaryElementType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration BoundaryElementType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::types::BoundaryElementType>(::nds::lane::types::BoundaryElementType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::types::BoundaryElementType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::BoundaryElementType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::types::BoundaryElementType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::types::BoundaryElementType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::BoundaryElementType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::types::BoundaryElementType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::types::BoundaryElementType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::types::BoundaryElementType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::BoundaryElementType>(
            static_cast<typename ::std::underlying_type<::nds::lane::types::BoundaryElementType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::types::BoundaryElementType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::BoundaryElementType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::BoundaryElementType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::types::BoundaryElementType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::types::BoundaryElementType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::BoundaryElementType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/types/PhysicalDividerBoundaryType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PhysicalDividerBoundaryType enumeration.
constexpr ::std::array<const char*, 10> EnumTraits<::nds::lane::types::PhysicalDividerBoundaryType>::names;
constexpr ::std::array<::nds::lane::types::PhysicalDividerBoundaryType, 10> EnumTraits<::nds::lane::types::PhysicalDividerBoundaryType>::values;
constexpr const char* EnumTraits<::nds::lane::types::PhysicalDividerBoundaryType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::types::PhysicalDividerBoundaryType value)
{
    switch (value)
    {
    case ::nds::lane::types::PhysicalDividerBoundaryType::CURB:
        return 0;
    case ::nds::lane::types::PhysicalDividerBoundaryType::WALL_FLAT:
        return 1;
    case ::nds::lane::types::PhysicalDividerBoundaryType::WALL_TUNNEL:
        return 2;
    case ::nds::lane::types::PhysicalDividerBoundaryType::BARRIER_JERSEY:
        return 3;
    case ::nds::lane::types::PhysicalDividerBoundaryType::BARRIER_SOUND:
        return 4;
    case ::nds::lane::types::PhysicalDividerBoundaryType::BARRIER_CABLE:
        return 5;
    case ::nds::lane::types::PhysicalDividerBoundaryType::GUARDRAIL:
        return 6;
    case ::nds::lane::types::PhysicalDividerBoundaryType::FENCE:
        return 7;
    case ::nds::lane::types::PhysicalDividerBoundaryType::DITCH:
        return 8;
    case ::nds::lane::types::PhysicalDividerBoundaryType::UNKNOWN:
        return 9;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhysicalDividerBoundaryType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::types::PhysicalDividerBoundaryType>::type>(value) << "!";
    }
}

template <>
::nds::lane::types::PhysicalDividerBoundaryType valueToEnum(
        typename ::std::underlying_type<::nds::lane::types::PhysicalDividerBoundaryType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(255):
        return static_cast<::nds::lane::types::PhysicalDividerBoundaryType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhysicalDividerBoundaryType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::types::PhysicalDividerBoundaryType>(::nds::lane::types::PhysicalDividerBoundaryType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::types::PhysicalDividerBoundaryType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalDividerBoundaryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::types::PhysicalDividerBoundaryType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::types::PhysicalDividerBoundaryType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalDividerBoundaryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::types::PhysicalDividerBoundaryType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::types::PhysicalDividerBoundaryType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::types::PhysicalDividerBoundaryType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::PhysicalDividerBoundaryType>(
            static_cast<typename ::std::underlying_type<::nds::lane::types::PhysicalDividerBoundaryType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::types::PhysicalDividerBoundaryType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::PhysicalDividerBoundaryType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalDividerBoundaryType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::types::PhysicalDividerBoundaryType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::types::PhysicalDividerBoundaryType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalDividerBoundaryType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/types/PhysicalMarkingBoundaryType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PhysicalMarkingBoundaryType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::lane::types::PhysicalMarkingBoundaryType>::names;
constexpr ::std::array<::nds::lane::types::PhysicalMarkingBoundaryType, 4> EnumTraits<::nds::lane::types::PhysicalMarkingBoundaryType>::values;
constexpr const char* EnumTraits<::nds::lane::types::PhysicalMarkingBoundaryType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::types::PhysicalMarkingBoundaryType value)
{
    switch (value)
    {
    case ::nds::lane::types::PhysicalMarkingBoundaryType::CURB_TRAVERSABLE:
        return 0;
    case ::nds::lane::types::PhysicalMarkingBoundaryType::PYLONS:
        return 1;
    case ::nds::lane::types::PhysicalMarkingBoundaryType::DELINEATOR_POSTS:
        return 2;
    case ::nds::lane::types::PhysicalMarkingBoundaryType::UNKNOWN:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhysicalMarkingBoundaryType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::types::PhysicalMarkingBoundaryType>::type>(value) << "!";
    }
}

template <>
::nds::lane::types::PhysicalMarkingBoundaryType valueToEnum(
        typename ::std::underlying_type<::nds::lane::types::PhysicalMarkingBoundaryType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(255):
        return static_cast<::nds::lane::types::PhysicalMarkingBoundaryType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhysicalMarkingBoundaryType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::types::PhysicalMarkingBoundaryType>(::nds::lane::types::PhysicalMarkingBoundaryType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::types::PhysicalMarkingBoundaryType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalMarkingBoundaryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::types::PhysicalMarkingBoundaryType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::types::PhysicalMarkingBoundaryType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalMarkingBoundaryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::types::PhysicalMarkingBoundaryType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::types::PhysicalMarkingBoundaryType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::types::PhysicalMarkingBoundaryType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::PhysicalMarkingBoundaryType>(
            static_cast<typename ::std::underlying_type<::nds::lane::types::PhysicalMarkingBoundaryType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::types::PhysicalMarkingBoundaryType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::PhysicalMarkingBoundaryType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalMarkingBoundaryType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::types::PhysicalMarkingBoundaryType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::types::PhysicalMarkingBoundaryType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalMarkingBoundaryType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/types/LogicalBoundaryType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LogicalBoundaryType enumeration.
constexpr ::std::array<const char*, 11> EnumTraits<::nds::lane::types::LogicalBoundaryType>::names;
constexpr ::std::array<::nds::lane::types::LogicalBoundaryType, 11> EnumTraits<::nds::lane::types::LogicalBoundaryType>::values;
constexpr const char* EnumTraits<::nds::lane::types::LogicalBoundaryType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::types::LogicalBoundaryType value)
{
    switch (value)
    {
    case ::nds::lane::types::LogicalBoundaryType::PURE_VIRTUAL:
        return 0;
    case ::nds::lane::types::LogicalBoundaryType::GORE:
        return 1;
    case ::nds::lane::types::LogicalBoundaryType::WALKING_AREA:
        return 2;
    case ::nds::lane::types::LogicalBoundaryType::SHADED_AREA:
        return 3;
    case ::nds::lane::types::LogicalBoundaryType::CLIFF:
        return 4;
    case ::nds::lane::types::LogicalBoundaryType::END_OF_ROAD_SURFACE:
        return 5;
    case ::nds::lane::types::LogicalBoundaryType::PARKING_AREA:
        return 6;
    case ::nds::lane::types::LogicalBoundaryType::DRIVEWAY:
        return 7;
    case ::nds::lane::types::LogicalBoundaryType::PUBLIC_TRANSPORT_WAITING_AREA:
        return 8;
    case ::nds::lane::types::LogicalBoundaryType::CONSTRUCTION_AREA:
        return 9;
    case ::nds::lane::types::LogicalBoundaryType::BICYCLE_AREA:
        return 10;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LogicalBoundaryType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::types::LogicalBoundaryType>::type>(value) << "!";
    }
}

template <>
::nds::lane::types::LogicalBoundaryType valueToEnum(
        typename ::std::underlying_type<::nds::lane::types::LogicalBoundaryType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
        return static_cast<::nds::lane::types::LogicalBoundaryType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LogicalBoundaryType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::types::LogicalBoundaryType>(::nds::lane::types::LogicalBoundaryType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::types::LogicalBoundaryType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::LogicalBoundaryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::types::LogicalBoundaryType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::types::LogicalBoundaryType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::LogicalBoundaryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::types::LogicalBoundaryType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::types::LogicalBoundaryType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::types::LogicalBoundaryType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::LogicalBoundaryType>(
            static_cast<typename ::std::underlying_type<::nds::lane::types::LogicalBoundaryType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::types::LogicalBoundaryType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::LogicalBoundaryType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::LogicalBoundaryType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::types::LogicalBoundaryType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::types::LogicalBoundaryType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::LogicalBoundaryType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/types/MarkingBoundaryType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for MarkingBoundaryType enumeration.
constexpr ::std::array<const char*, 6> EnumTraits<::nds::lane::types::MarkingBoundaryType>::names;
constexpr ::std::array<::nds::lane::types::MarkingBoundaryType, 6> EnumTraits<::nds::lane::types::MarkingBoundaryType>::values;
constexpr const char* EnumTraits<::nds::lane::types::MarkingBoundaryType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::types::MarkingBoundaryType value)
{
    switch (value)
    {
    case ::nds::lane::types::MarkingBoundaryType::DASHED_LINE:
        return 0;
    case ::nds::lane::types::MarkingBoundaryType::SOLID_LINE:
        return 1;
    case ::nds::lane::types::MarkingBoundaryType::SHADED_AREA_BORDER:
        return 2;
    case ::nds::lane::types::MarkingBoundaryType::DASHED_BLOCKS:
        return 3;
    case ::nds::lane::types::MarkingBoundaryType::CROSSING_ALERT:
        return 4;
    case ::nds::lane::types::MarkingBoundaryType::UNKNOWN:
        return 5;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration MarkingBoundaryType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::types::MarkingBoundaryType>::type>(value) << "!";
    }
}

template <>
::nds::lane::types::MarkingBoundaryType valueToEnum(
        typename ::std::underlying_type<::nds::lane::types::MarkingBoundaryType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(255):
        return static_cast<::nds::lane::types::MarkingBoundaryType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration MarkingBoundaryType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::types::MarkingBoundaryType>(::nds::lane::types::MarkingBoundaryType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::types::MarkingBoundaryType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::MarkingBoundaryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::types::MarkingBoundaryType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::types::MarkingBoundaryType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::MarkingBoundaryType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::types::MarkingBoundaryType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::types::MarkingBoundaryType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::types::MarkingBoundaryType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::MarkingBoundaryType>(
            static_cast<typename ::std::underlying_type<::nds::lane::types::MarkingBoundaryType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::types::MarkingBoundaryType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::MarkingBoundaryType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::MarkingBoundaryType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::types::MarkingBoundaryType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::types::MarkingBoundaryType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::MarkingBoundaryType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/types/PhysicalBoundaryMaterial.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PhysicalBoundaryMaterial enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::lane::types::PhysicalBoundaryMaterial>::names;
constexpr ::std::array<::nds::lane::types::PhysicalBoundaryMaterial, 7> EnumTraits<::nds::lane::types::PhysicalBoundaryMaterial>::values;
constexpr const char* EnumTraits<::nds::lane::types::PhysicalBoundaryMaterial>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::types::PhysicalBoundaryMaterial value)
{
    switch (value)
    {
    case ::nds::lane::types::PhysicalBoundaryMaterial::UNKNOWN:
        return 0;
    case ::nds::lane::types::PhysicalBoundaryMaterial::METAL:
        return 1;
    case ::nds::lane::types::PhysicalBoundaryMaterial::CONCRETE:
        return 2;
    case ::nds::lane::types::PhysicalBoundaryMaterial::STONE:
        return 3;
    case ::nds::lane::types::PhysicalBoundaryMaterial::WOOD:
        return 4;
    case ::nds::lane::types::PhysicalBoundaryMaterial::PLASTIC:
        return 5;
    case ::nds::lane::types::PhysicalBoundaryMaterial::TRANSPARENT_MATERIAL:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhysicalBoundaryMaterial: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::types::PhysicalBoundaryMaterial>::type>(value) << "!";
    }
}

template <>
::nds::lane::types::PhysicalBoundaryMaterial valueToEnum(
        typename ::std::underlying_type<::nds::lane::types::PhysicalBoundaryMaterial>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::lane::types::PhysicalBoundaryMaterial>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhysicalBoundaryMaterial: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::types::PhysicalBoundaryMaterial>(::nds::lane::types::PhysicalBoundaryMaterial value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::types::PhysicalBoundaryMaterial value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalBoundaryMaterial>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::types::PhysicalBoundaryMaterial)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::types::PhysicalBoundaryMaterial value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalBoundaryMaterial>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::types::PhysicalBoundaryMaterial value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::types::PhysicalBoundaryMaterial value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::types::PhysicalBoundaryMaterial read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::PhysicalBoundaryMaterial>(
            static_cast<typename ::std::underlying_type<::nds::lane::types::PhysicalBoundaryMaterial>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::types::PhysicalBoundaryMaterial read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::PhysicalBoundaryMaterial>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalBoundaryMaterial>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::types::PhysicalBoundaryMaterial value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::types::PhysicalBoundaryMaterial value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::PhysicalBoundaryMaterial>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/types/MarkingMaterial.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for MarkingMaterial enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::lane::types::MarkingMaterial>::names;
constexpr ::std::array<::nds::lane::types::MarkingMaterial, 4> EnumTraits<::nds::lane::types::MarkingMaterial>::values;
constexpr const char* EnumTraits<::nds::lane::types::MarkingMaterial>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::types::MarkingMaterial value)
{
    switch (value)
    {
    case ::nds::lane::types::MarkingMaterial::UNKNOWN:
        return 0;
    case ::nds::lane::types::MarkingMaterial::VIBRATION_MARKINGS:
        return 1;
    case ::nds::lane::types::MarkingMaterial::PAINTED_VIBRATION_DIVIDER:
        return 2;
    case ::nds::lane::types::MarkingMaterial::PAINTED:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration MarkingMaterial: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::types::MarkingMaterial>::type>(value) << "!";
    }
}

template <>
::nds::lane::types::MarkingMaterial valueToEnum(
        typename ::std::underlying_type<::nds::lane::types::MarkingMaterial>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::lane::types::MarkingMaterial>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration MarkingMaterial: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::types::MarkingMaterial>(::nds::lane::types::MarkingMaterial value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::types::MarkingMaterial value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::MarkingMaterial>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::types::MarkingMaterial)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::types::MarkingMaterial value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::MarkingMaterial>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::types::MarkingMaterial value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::types::MarkingMaterial value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::types::MarkingMaterial read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::MarkingMaterial>(
            static_cast<typename ::std::underlying_type<::nds::lane::types::MarkingMaterial>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::types::MarkingMaterial read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::MarkingMaterial>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::MarkingMaterial>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::types::MarkingMaterial value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::types::MarkingMaterial value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::types::MarkingMaterial>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/types/TileBorderIndicator.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TileBorderIndicator enumeration.
constexpr ::std::array<const char*, 8> EnumTraits<::nds::lane::types::TileBorderIndicator>::names;
constexpr ::std::array<::nds::lane::types::TileBorderIndicator, 8> EnumTraits<::nds::lane::types::TileBorderIndicator>::values;
constexpr const char* EnumTraits<::nds::lane::types::TileBorderIndicator>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::types::TileBorderIndicator value)
{
    switch (value)
    {
    case ::nds::lane::types::TileBorderIndicator::NORTH:
        return 0;
    case ::nds::lane::types::TileBorderIndicator::NORTH_EAST:
        return 1;
    case ::nds::lane::types::TileBorderIndicator::EAST:
        return 2;
    case ::nds::lane::types::TileBorderIndicator::SOUTH_EAST:
        return 3;
    case ::nds::lane::types::TileBorderIndicator::SOUTH:
        return 4;
    case ::nds::lane::types::TileBorderIndicator::SOUTH_WEST:
        return 5;
    case ::nds::lane::types::TileBorderIndicator::WEST:
        return 6;
    case ::nds::lane::types::TileBorderIndicator::NORTH_WEST:
        return 7;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TileBorderIndicator: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::types::TileBorderIndicator>::type>(value) << "!";
    }
}

template <>
::nds::lane::types::TileBorderIndicator valueToEnum(
        typename ::std::underlying_type<::nds::lane::types::TileBorderIndicator>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
        return static_cast<::nds::lane::types::TileBorderIndicator>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TileBorderIndicator: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::types::TileBorderIndicator>(::nds::lane::types::TileBorderIndicator value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::types::TileBorderIndicator value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::types::TileBorderIndicator>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::types::TileBorderIndicator)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::types::TileBorderIndicator value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::types::TileBorderIndicator>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::types::TileBorderIndicator value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::types::TileBorderIndicator value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::types::TileBorderIndicator read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::TileBorderIndicator>(
            static_cast<typename ::std::underlying_type<::nds::lane::types::TileBorderIndicator>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::lane::types::TileBorderIndicator read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::types::TileBorderIndicator>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::types::TileBorderIndicator>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::types::TileBorderIndicator value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::types::TileBorderIndicator value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::lane::types::TileBorderIndicator>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio
