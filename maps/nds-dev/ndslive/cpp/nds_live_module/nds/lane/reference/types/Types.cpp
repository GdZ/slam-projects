/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/reference/types/LaneGroupTransitionReferenceType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneGroupTransitionReferenceType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::names;
constexpr ::std::array<::nds::lane::reference::types::LaneGroupTransitionReferenceType, 3> EnumTraits<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::values;
constexpr const char* EnumTraits<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::reference::types::LaneGroupTransitionReferenceType value)
{
    switch (value)
    {
    case ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION:
        return 0;
    case ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH:
        return 1;
    case ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneGroupTransitionReferenceType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::type>(value) << "!";
    }
}

template <>
::nds::lane::reference::types::LaneGroupTransitionReferenceType valueToEnum(
        typename ::std::underlying_type<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::lane::reference::types::LaneGroupTransitionReferenceType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneGroupTransitionReferenceType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::reference::types::LaneGroupTransitionReferenceType>(::nds::lane::reference::types::LaneGroupTransitionReferenceType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::reference::types::LaneGroupTransitionReferenceType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::reference::types::LaneGroupTransitionReferenceType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::reference::types::LaneGroupTransitionReferenceType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::reference::types::LaneGroupTransitionReferenceType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::reference::types::LaneGroupTransitionReferenceType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::reference::types::LaneGroupTransitionReferenceType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::reference::types::LaneGroupTransitionReferenceType>(
            static_cast<typename ::std::underlying_type<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::reference::types::LaneGroupTransitionReferenceType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::reference::types::LaneGroupTransitionReferenceType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::reference::types::LaneGroupTransitionReferenceType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::reference::types::LaneGroupTransitionReferenceType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::LaneGroupTransitionReferenceType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/reference/types/LaneValidityType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneValidityType enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::lane::reference::types::LaneValidityType>::names;
constexpr ::std::array<::nds::lane::reference::types::LaneValidityType, 7> EnumTraits<::nds::lane::reference::types::LaneValidityType>::values;
constexpr const char* EnumTraits<::nds::lane::reference::types::LaneValidityType>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::reference::types::LaneValidityType value)
{
    switch (value)
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return 0;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return 1;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return 2;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return 3;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return 4;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return 5;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneValidityType: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::reference::types::LaneValidityType>::type>(value) << "!";
    }
}

template <>
::nds::lane::reference::types::LaneValidityType valueToEnum(
        typename ::std::underlying_type<::nds::lane::reference::types::LaneValidityType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::lane::reference::types::LaneValidityType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneValidityType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::reference::types::LaneValidityType>(::nds::lane::reference::types::LaneValidityType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::reference::types::LaneValidityType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::LaneValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::reference::types::LaneValidityType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::reference::types::LaneValidityType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::LaneValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::reference::types::LaneValidityType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::reference::types::LaneValidityType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::reference::types::LaneValidityType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::reference::types::LaneValidityType>(
            static_cast<typename ::std::underlying_type<::nds::lane::reference::types::LaneValidityType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::reference::types::LaneValidityType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::reference::types::LaneValidityType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::LaneValidityType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::reference::types::LaneValidityType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::reference::types::LaneValidityType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::LaneValidityType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/lane/reference/types/MarkingColor.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for MarkingColor enumeration.
constexpr ::std::array<const char*, 13> EnumTraits<::nds::lane::reference::types::MarkingColor>::names;
constexpr ::std::array<::nds::lane::reference::types::MarkingColor, 13> EnumTraits<::nds::lane::reference::types::MarkingColor>::values;
constexpr const char* EnumTraits<::nds::lane::reference::types::MarkingColor>::enumName;

template <>
size_t enumToOrdinal(::nds::lane::reference::types::MarkingColor value)
{
    switch (value)
    {
    case ::nds::lane::reference::types::MarkingColor::UNKNOWN:
        return 0;
    case ::nds::lane::reference::types::MarkingColor::WHITE:
        return 1;
    case ::nds::lane::reference::types::MarkingColor::LIGHT_GRAY:
        return 2;
    case ::nds::lane::reference::types::MarkingColor::GRAY:
        return 3;
    case ::nds::lane::reference::types::MarkingColor::DARK_GRAY:
        return 4;
    case ::nds::lane::reference::types::MarkingColor::BLACK:
        return 5;
    case ::nds::lane::reference::types::MarkingColor::RED:
        return 6;
    case ::nds::lane::reference::types::MarkingColor::YELLOW:
        return 7;
    case ::nds::lane::reference::types::MarkingColor::GREEN:
        return 8;
    case ::nds::lane::reference::types::MarkingColor::CYAN:
        return 9;
    case ::nds::lane::reference::types::MarkingColor::BLUE:
        return 10;
    case ::nds::lane::reference::types::MarkingColor::ORANGE:
        return 11;
    case ::nds::lane::reference::types::MarkingColor::PURPLE:
        return 12;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration MarkingColor: ") <<
                static_cast<typename ::std::underlying_type<::nds::lane::reference::types::MarkingColor>::type>(value) << "!";
    }
}

template <>
::nds::lane::reference::types::MarkingColor valueToEnum(
        typename ::std::underlying_type<::nds::lane::reference::types::MarkingColor>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
        return static_cast<::nds::lane::reference::types::MarkingColor>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration MarkingColor: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::lane::reference::types::MarkingColor>(::nds::lane::reference::types::MarkingColor value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::lane::reference::types::MarkingColor value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::MarkingColor>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::lane::reference::types::MarkingColor)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::lane::reference::types::MarkingColor value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::MarkingColor>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::lane::reference::types::MarkingColor value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::lane::reference::types::MarkingColor value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::lane::reference::types::MarkingColor read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::reference::types::MarkingColor>(
            static_cast<typename ::std::underlying_type<::nds::lane::reference::types::MarkingColor>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::lane::reference::types::MarkingColor read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::lane::reference::types::MarkingColor>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::MarkingColor>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::lane::reference::types::MarkingColor value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::lane::reference::types::MarkingColor value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::lane::reference::types::MarkingColor>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneGroupReferenceIndirect.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneGroupReferenceIndirect::LaneGroupReferenceIndirect(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_referenceGeometry_(allocator),
        m_referenceSegments_(allocator)
{
}

LaneGroupReferenceIndirect::LaneGroupReferenceIndirect(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_referenceGeometry_(readReferenceGeometry(in, allocator)),
        m_referenceSegments_(readReferenceSegments(in, allocator))
{
}

LaneGroupReferenceIndirect::LaneGroupReferenceIndirect(LaneGroupReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_referenceGeometry_(readReferenceGeometry(context, in, allocator)),
        m_referenceSegments_(readReferenceSegments(context, in, allocator))
{
}

LaneGroupReferenceIndirect::LaneGroupReferenceIndirect(const LaneGroupReferenceIndirect& other) :
        m_referenceGeometry_(other.m_referenceGeometry_),
        m_referenceSegments_(other.m_referenceSegments_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneGroupReferenceIndirect& LaneGroupReferenceIndirect::operator=(const LaneGroupReferenceIndirect& other)
{
    m_referenceGeometry_ = other.m_referenceGeometry_;
    m_referenceSegments_ = other.m_referenceSegments_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneGroupReferenceIndirect::LaneGroupReferenceIndirect(LaneGroupReferenceIndirect&& other) :
        m_referenceGeometry_(::std::move(other.m_referenceGeometry_)),
        m_referenceSegments_(::std::move(other.m_referenceSegments_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneGroupReferenceIndirect& LaneGroupReferenceIndirect::operator=(LaneGroupReferenceIndirect&& other)
{
    m_referenceGeometry_ = ::std::move(other.m_referenceGeometry_);
    m_referenceSegments_ = ::std::move(other.m_referenceSegments_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneGroupReferenceIndirect::LaneGroupReferenceIndirect(::zserio::PropagateAllocatorT,
        const LaneGroupReferenceIndirect& other, const allocator_type& allocator) :
        m_referenceGeometry_(::zserio::allocatorPropagatingCopy(other.m_referenceGeometry_, allocator)),
        m_referenceSegments_(::zserio::allocatorPropagatingCopy(other.m_referenceSegments_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneGroupReferenceIndirect::initializeChildren()
{
    m_referenceGeometry_.initializeChildren();
    m_referenceSegments_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::nds::core::location::LocationGeometry& LaneGroupReferenceIndirect::getReferenceGeometry()
{
    return m_referenceGeometry_;
}

const ::nds::core::location::LocationGeometry& LaneGroupReferenceIndirect::getReferenceGeometry() const
{
    return m_referenceGeometry_;
}

void LaneGroupReferenceIndirect::setReferenceGeometry(const ::nds::core::location::LocationGeometry& referenceGeometry_)
{
    m_referenceGeometry_ = referenceGeometry_;
}

void LaneGroupReferenceIndirect::setReferenceGeometry(::nds::core::location::LocationGeometry&& referenceGeometry_)
{
    m_referenceGeometry_ = ::std::move(referenceGeometry_);
}

::zserio::vector<::nds::lane::reference::types::LaneGroupLocationSegment>& LaneGroupReferenceIndirect::getReferenceSegments()
{
    return m_referenceSegments_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupLocationSegment>& LaneGroupReferenceIndirect::getReferenceSegments() const
{
    return m_referenceSegments_.getRawArray();
}

void LaneGroupReferenceIndirect::setReferenceSegments(const ::zserio::vector<::nds::lane::reference::types::LaneGroupLocationSegment>& referenceSegments_)
{
    m_referenceSegments_ = ZserioArrayType_referenceSegments(referenceSegments_);
}

void LaneGroupReferenceIndirect::setReferenceSegments(::zserio::vector<::nds::lane::reference::types::LaneGroupLocationSegment>&& referenceSegments_)
{
    m_referenceSegments_ = ZserioArrayType_referenceSegments(std::move(referenceSegments_));
}

void LaneGroupReferenceIndirect::initPackingContext(LaneGroupReferenceIndirect::ZserioPackingContext& context) const
{
    m_referenceGeometry_.initPackingContext(context.getReferenceGeometry());
}

size_t LaneGroupReferenceIndirect::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_referenceGeometry_.bitSizeOf(endBitPosition);
    endBitPosition += m_referenceSegments_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupReferenceIndirect::bitSizeOf(LaneGroupReferenceIndirect::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_referenceGeometry_.bitSizeOf(context.getReferenceGeometry(), endBitPosition);
    endBitPosition += m_referenceSegments_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupReferenceIndirect::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_referenceGeometry_.initializeOffsets(endBitPosition);
    endBitPosition = m_referenceSegments_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t LaneGroupReferenceIndirect::initializeOffsets(LaneGroupReferenceIndirect::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_referenceGeometry_.initializeOffsets(context.getReferenceGeometry(), endBitPosition);
    endBitPosition = m_referenceSegments_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LaneGroupReferenceIndirect::operator==(const LaneGroupReferenceIndirect& other) const
{
    if (this != &other)
    {
        return
                (m_referenceGeometry_ == other.m_referenceGeometry_) &&
                (m_referenceSegments_ == other.m_referenceSegments_);
    }

    return true;
}

uint32_t LaneGroupReferenceIndirect::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_referenceGeometry_);
    result = ::zserio::calcHashCode(result, m_referenceSegments_);

    return result;
}

void LaneGroupReferenceIndirect::write(::zserio::BitStreamWriter& out) const
{
    m_referenceGeometry_.write(out);
    m_referenceSegments_.write(*this, out);
}

void LaneGroupReferenceIndirect::write(LaneGroupReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_referenceGeometry_.write(context.getReferenceGeometry(), out);
    m_referenceSegments_.writePacked(*this, out);
}

void LaneGroupReferenceIndirect::ZserioArrayExpressions_referenceSegments::initializeElement(LaneGroupReferenceIndirect& owner,
        ::nds::lane::reference::types::LaneGroupLocationSegment& element, size_t)
{
    element.initialize(owner.getReferenceGeometry());
}

void LaneGroupReferenceIndirect::ZserioElementFactory_referenceSegments::create(LaneGroupReferenceIndirect&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupLocationSegment>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getReferenceGeometry(), array.get_allocator());
}

void LaneGroupReferenceIndirect::ZserioElementFactory_referenceSegments::create(LaneGroupReferenceIndirect&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupLocationSegment>& array,
        ::nds::lane::reference::types::LaneGroupLocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getReferenceGeometry(), array.get_allocator());
}

::nds::core::location::LocationGeometry LaneGroupReferenceIndirect::readReferenceGeometry(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::LocationGeometry(in, allocator);
}

::nds::core::location::LocationGeometry LaneGroupReferenceIndirect::readReferenceGeometry(LaneGroupReferenceIndirect::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::LocationGeometry(context.getReferenceGeometry(), in, allocator);
}
LaneGroupReferenceIndirect::ZserioArrayType_referenceSegments LaneGroupReferenceIndirect::readReferenceSegments(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_referenceSegments readField(allocator);
    readField.read(*this, in);

    return readField;
}

LaneGroupReferenceIndirect::ZserioArrayType_referenceSegments LaneGroupReferenceIndirect::readReferenceSegments(LaneGroupReferenceIndirect::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_referenceSegments readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneGroupLocationSegment.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneGroupLocationSegment::LaneGroupLocationSegment(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_locationSegment_(allocator),
        m_numLanes_(::nds::lane::reference::types::LanesInMask()),
        m_laneTypes_(::zserio::NullOpt)
{
}

LaneGroupLocationSegment::LaneGroupLocationSegment(::zserio::BitStreamReader& in,
        ::nds::core::location::LocationGeometry& pathGeometry_, const allocator_type& allocator) :
        m_pathGeometry_(&pathGeometry_),
        m_isInitialized(true),
        m_locationSegment_(readLocationSegment(in, allocator)),
        m_numLanes_(readNumLanes(in)),
        m_laneTypes_(readLaneTypes(in, allocator))
{
}

LaneGroupLocationSegment::LaneGroupLocationSegment(LaneGroupLocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::location::LocationGeometry& pathGeometry_, const allocator_type& allocator) :
        m_pathGeometry_(&pathGeometry_),
        m_isInitialized(true),
        m_locationSegment_(readLocationSegment(context, in, allocator)),
        m_numLanes_(readNumLanes(context, in)),
        m_laneTypes_(readLaneTypes(context, in, allocator))
{
}

LaneGroupLocationSegment::LaneGroupLocationSegment(const LaneGroupLocationSegment& other) :
        m_locationSegment_(other.m_locationSegment_),
        m_numLanes_(other.m_numLanes_),
        m_laneTypes_(other.m_laneTypes_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;
}

LaneGroupLocationSegment& LaneGroupLocationSegment::operator=(const LaneGroupLocationSegment& other)
{
    m_locationSegment_ = other.m_locationSegment_;
    m_numLanes_ = other.m_numLanes_;
    m_laneTypes_ = other.m_laneTypes_;
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupLocationSegment::LaneGroupLocationSegment(LaneGroupLocationSegment&& other) :
        m_locationSegment_(::std::move(other.m_locationSegment_)),
        m_numLanes_(::std::move(other.m_numLanes_)),
        m_laneTypes_(::std::move(other.m_laneTypes_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;
}

LaneGroupLocationSegment& LaneGroupLocationSegment::operator=(LaneGroupLocationSegment&& other)
{
    m_locationSegment_ = ::std::move(other.m_locationSegment_);
    m_numLanes_ = ::std::move(other.m_numLanes_);
    m_laneTypes_ = ::std::move(other.m_laneTypes_);
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupLocationSegment::LaneGroupLocationSegment(::zserio::PropagateAllocatorT,
        const LaneGroupLocationSegment& other, const allocator_type& allocator) :
        m_locationSegment_(::zserio::allocatorPropagatingCopy(other.m_locationSegment_, allocator)),
        m_numLanes_(::zserio::allocatorPropagatingCopy(other.m_numLanes_, allocator)),
        m_laneTypes_(::zserio::allocatorPropagatingCopy(other.m_laneTypes_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;
}

void LaneGroupLocationSegment::initialize(
        ::nds::core::location::LocationGeometry& pathGeometry_)
{
    m_pathGeometry_ = &pathGeometry_;
    m_isInitialized = true;

    initializeChildren();
}

bool LaneGroupLocationSegment::isInitialized() const
{
    return m_isInitialized;
}

void LaneGroupLocationSegment::initializeChildren()
{
    m_locationSegment_.initialize(getPathGeometry());
}

::nds::core::location::LocationGeometry& LaneGroupLocationSegment::getPathGeometry()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'pathGeometry' of compound 'LaneGroupLocationSegment' is not initialized!");

    return *m_pathGeometry_;
}

const ::nds::core::location::LocationGeometry& LaneGroupLocationSegment::getPathGeometry() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'pathGeometry' of compound 'LaneGroupLocationSegment' is not initialized!");

    return *m_pathGeometry_;
}

::nds::core::location::LocationSegment& LaneGroupLocationSegment::getLocationSegment()
{
    return m_locationSegment_;
}

const ::nds::core::location::LocationSegment& LaneGroupLocationSegment::getLocationSegment() const
{
    return m_locationSegment_;
}

void LaneGroupLocationSegment::setLocationSegment(const ::nds::core::location::LocationSegment& locationSegment_)
{
    m_locationSegment_ = locationSegment_;
}

void LaneGroupLocationSegment::setLocationSegment(::nds::core::location::LocationSegment&& locationSegment_)
{
    m_locationSegment_ = ::std::move(locationSegment_);
}

::nds::lane::reference::types::LanesInMask LaneGroupLocationSegment::getNumLanes() const
{
    return m_numLanes_;
}

void LaneGroupLocationSegment::setNumLanes(::nds::lane::reference::types::LanesInMask numLanes_)
{
    m_numLanes_ = numLanes_;
}

::zserio::vector<::nds::core::types::LaneType>& LaneGroupLocationSegment::getLaneTypes()
{
    return m_laneTypes_.value().getRawArray();
}

const ::zserio::vector<::nds::core::types::LaneType>& LaneGroupLocationSegment::getLaneTypes() const
{
    return m_laneTypes_.value().getRawArray();
}

void LaneGroupLocationSegment::setLaneTypes(const ::zserio::vector<::nds::core::types::LaneType>& laneTypes_)
{
    m_laneTypes_ = ZserioArrayType_laneTypes(laneTypes_);
}

void LaneGroupLocationSegment::setLaneTypes(::zserio::vector<::nds::core::types::LaneType>&& laneTypes_)
{
    m_laneTypes_ = ZserioArrayType_laneTypes(std::move(laneTypes_));
}

bool LaneGroupLocationSegment::isLaneTypesUsed() const
{
    return (isLaneTypesSet());
}

bool LaneGroupLocationSegment::isLaneTypesSet() const
{
    return m_laneTypes_.hasValue();
}

void LaneGroupLocationSegment::resetLaneTypes()
{
    m_laneTypes_.reset();
}

void LaneGroupLocationSegment::initPackingContext(LaneGroupLocationSegment::ZserioPackingContext& context) const
{
    m_locationSegment_.initPackingContext(context.getLocationSegment());
    context.getNumLanes().init<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(m_numLanes_);
}

size_t LaneGroupLocationSegment::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_locationSegment_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numLanes_);
    endBitPosition += 1;
    if (isLaneTypesSet())
    {
        endBitPosition += m_laneTypes_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupLocationSegment::bitSizeOf(LaneGroupLocationSegment::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_locationSegment_.bitSizeOf(context.getLocationSegment(), endBitPosition);
    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(m_numLanes_);
    endBitPosition += 1;
    if (isLaneTypesSet())
    {
        endBitPosition += m_laneTypes_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupLocationSegment::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_locationSegment_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numLanes_);
    endBitPosition += 1;
    if (isLaneTypesSet())
    {
        endBitPosition = m_laneTypes_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t LaneGroupLocationSegment::initializeOffsets(LaneGroupLocationSegment::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_locationSegment_.initializeOffsets(context.getLocationSegment(), endBitPosition);
    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(m_numLanes_);
    endBitPosition += 1;
    if (isLaneTypesSet())
    {
        endBitPosition = m_laneTypes_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool LaneGroupLocationSegment::operator==(const LaneGroupLocationSegment& other) const
{
    if (this != &other)
    {
        return
                (getPathGeometry() == other.getPathGeometry()) &&
                (m_locationSegment_ == other.m_locationSegment_) &&
                (m_numLanes_ == other.m_numLanes_) &&
                (!isLaneTypesUsed() ? !other.isLaneTypesUsed() : (m_laneTypes_ == other.m_laneTypes_));
    }

    return true;
}

uint32_t LaneGroupLocationSegment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getPathGeometry());
    result = ::zserio::calcHashCode(result, m_locationSegment_);
    result = ::zserio::calcHashCode(result, m_numLanes_);
    if (isLaneTypesUsed())
        result = ::zserio::calcHashCode(result, m_laneTypes_);

    return result;
}

void LaneGroupLocationSegment::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (&(m_locationSegment_.getPathGeometry()) != &(getPathGeometry()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter pathGeometry for field LaneGroupLocationSegment.locationSegment!");
    }
    m_locationSegment_.write(out);

    out.writeVarUInt16(m_numLanes_);

    if (isLaneTypesSet())
    {
        out.writeBool(true);
        // check array length
        if (m_laneTypes_.value().getRawArray().size() != static_cast<size_t>(getNumLanes()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupLocationSegment.laneTypes: ") <<
                    m_laneTypes_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLanes()) << "!";
        }
        m_laneTypes_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void LaneGroupLocationSegment::write(LaneGroupLocationSegment::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (&(m_locationSegment_.getPathGeometry()) != &(getPathGeometry()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter pathGeometry for field LaneGroupLocationSegment.locationSegment!");
    }
    m_locationSegment_.write(context.getLocationSegment(), out);

    context.getNumLanes().write<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(out, m_numLanes_);

    if (isLaneTypesSet())
    {
        out.writeBool(true);
        // check array length
        if (m_laneTypes_.value().getRawArray().size() != static_cast<size_t>(getNumLanes()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupLocationSegment.laneTypes: ") <<
                    m_laneTypes_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLanes()) << "!";
        }
        m_laneTypes_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void LaneGroupLocationSegment::ZserioElementFactory_laneTypes::create(LaneGroupLocationSegment&        ,
        ::zserio::vector<::nds::core::types::LaneType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneGroupLocationSegment::ZserioElementFactory_laneTypes::create(LaneGroupLocationSegment&        ,
        ::zserio::vector<::nds::core::types::LaneType>& array,
        ::nds::core::types::LaneType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::location::LocationSegment LaneGroupLocationSegment::readLocationSegment(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::LocationSegment(in, getPathGeometry(), allocator);
}

::nds::core::location::LocationSegment LaneGroupLocationSegment::readLocationSegment(LaneGroupLocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::LocationSegment(context.getLocationSegment(), in, getPathGeometry(), allocator);
}
::nds::lane::reference::types::LanesInMask LaneGroupLocationSegment::readNumLanes(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::reference::types::LanesInMask>(in.readVarUInt16());
}

::nds::lane::reference::types::LanesInMask LaneGroupLocationSegment::readNumLanes(LaneGroupLocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumLanes().read<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(in);
}
::zserio::InplaceOptionalHolder<LaneGroupLocationSegment::ZserioArrayType_laneTypes> LaneGroupLocationSegment::readLaneTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_laneTypes readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumLanes()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneTypes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneTypes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LaneGroupLocationSegment::ZserioArrayType_laneTypes> LaneGroupLocationSegment::readLaneTypes(LaneGroupLocationSegment::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_laneTypes readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumLanes()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneTypes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_laneTypes>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/reference/types/LaneGroupTransitionReference.h>
#include <nds/lane/reference/types/LaneGroupTransitionReferenceType.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneGroupTransitionReference::LaneGroupTransitionReference(const allocator_type&) noexcept :
        m_type_(::nds::lane::reference::types::LaneGroupTransitionReferenceType()),
        m_intersectionTransition_(::zserio::NullOpt),
        m_pathTransition_(::zserio::NullOpt),
        m_geoPathTransition_(::zserio::NullOpt)
{
}

LaneGroupTransitionReference::LaneGroupTransitionReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_intersectionTransition_(readIntersectionTransition(in, allocator)),
        m_pathTransition_(readPathTransition(in, allocator)),
        m_geoPathTransition_(readGeoPathTransition(in, allocator))
{
}

LaneGroupTransitionReference::LaneGroupTransitionReference(LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_intersectionTransition_(readIntersectionTransition(context, in, allocator)),
        m_pathTransition_(readPathTransition(context, in, allocator)),
        m_geoPathTransition_(readGeoPathTransition(context, in, allocator))
{
}

LaneGroupTransitionReference::LaneGroupTransitionReference(::zserio::PropagateAllocatorT,
        const LaneGroupTransitionReference& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_intersectionTransition_(::zserio::allocatorPropagatingCopy(other.m_intersectionTransition_, allocator)),
        m_pathTransition_(::zserio::allocatorPropagatingCopy(other.m_pathTransition_, allocator)),
        m_geoPathTransition_(::zserio::allocatorPropagatingCopy(other.m_geoPathTransition_, allocator))
{
}

void LaneGroupTransitionReference::initializeChildren()
{
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
        m_geoPathTransition_.value().initializeChildren();
}

::nds::lane::reference::types::LaneGroupTransitionReferenceType LaneGroupTransitionReference::getType() const
{
    return m_type_;
}

void LaneGroupTransitionReference::setType(::nds::lane::reference::types::LaneGroupTransitionReferenceType type_)
{
    m_type_ = type_;
}

::nds::lane::reference::types::LaneGroupTransition& LaneGroupTransitionReference::getIntersectionTransition()
{
    return m_intersectionTransition_.value();
}

const ::nds::lane::reference::types::LaneGroupTransition& LaneGroupTransitionReference::getIntersectionTransition() const
{
    return m_intersectionTransition_.value();
}

void LaneGroupTransitionReference::setIntersectionTransition(const ::nds::lane::reference::types::LaneGroupTransition& intersectionTransition_)
{
    m_intersectionTransition_ = intersectionTransition_;
}

void LaneGroupTransitionReference::setIntersectionTransition(::nds::lane::reference::types::LaneGroupTransition&& intersectionTransition_)
{
    m_intersectionTransition_ = ::std::move(intersectionTransition_);
}

bool LaneGroupTransitionReference::isIntersectionTransitionUsed() const
{
    return (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION);
}

bool LaneGroupTransitionReference::isIntersectionTransitionSet() const
{
    return m_intersectionTransition_.hasValue();
}

void LaneGroupTransitionReference::resetIntersectionTransition()
{
    m_intersectionTransition_.reset();
}

::nds::lane::reference::types::LaneGroupTransitionPath& LaneGroupTransitionReference::getPathTransition()
{
    return m_pathTransition_.value();
}

const ::nds::lane::reference::types::LaneGroupTransitionPath& LaneGroupTransitionReference::getPathTransition() const
{
    return m_pathTransition_.value();
}

void LaneGroupTransitionReference::setPathTransition(const ::nds::lane::reference::types::LaneGroupTransitionPath& pathTransition_)
{
    m_pathTransition_ = pathTransition_;
}

void LaneGroupTransitionReference::setPathTransition(::nds::lane::reference::types::LaneGroupTransitionPath&& pathTransition_)
{
    m_pathTransition_ = ::std::move(pathTransition_);
}

bool LaneGroupTransitionReference::isPathTransitionUsed() const
{
    return (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH);
}

bool LaneGroupTransitionReference::isPathTransitionSet() const
{
    return m_pathTransition_.hasValue();
}

void LaneGroupTransitionReference::resetPathTransition()
{
    m_pathTransition_.reset();
}

::nds::lane::reference::types::LaneGroupTransitionGeoPath& LaneGroupTransitionReference::getGeoPathTransition()
{
    return m_geoPathTransition_.value();
}

const ::nds::lane::reference::types::LaneGroupTransitionGeoPath& LaneGroupTransitionReference::getGeoPathTransition() const
{
    return m_geoPathTransition_.value();
}

void LaneGroupTransitionReference::setGeoPathTransition(const ::nds::lane::reference::types::LaneGroupTransitionGeoPath& geoPathTransition_)
{
    m_geoPathTransition_ = geoPathTransition_;
}

void LaneGroupTransitionReference::setGeoPathTransition(::nds::lane::reference::types::LaneGroupTransitionGeoPath&& geoPathTransition_)
{
    m_geoPathTransition_ = ::std::move(geoPathTransition_);
}

bool LaneGroupTransitionReference::isGeoPathTransitionUsed() const
{
    return (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH);
}

bool LaneGroupTransitionReference::isGeoPathTransitionSet() const
{
    return m_geoPathTransition_.hasValue();
}

void LaneGroupTransitionReference::resetGeoPathTransition()
{
    m_geoPathTransition_.reset();
}

void LaneGroupTransitionReference::initPackingContext(LaneGroupTransitionReference::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION)
    {
        m_intersectionTransition_.value().initPackingContext(context.getIntersectionTransition());
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH)
    {
        m_pathTransition_.value().initPackingContext(context.getPathTransition());
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
    {
        m_geoPathTransition_.value().initPackingContext(context.getGeoPathTransition());
    }
}

size_t LaneGroupTransitionReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION)
    {
        endBitPosition += m_intersectionTransition_.value().bitSizeOf(endBitPosition);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH)
    {
        endBitPosition += m_pathTransition_.value().bitSizeOf(endBitPosition);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
    {
        endBitPosition += m_geoPathTransition_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupTransitionReference::bitSizeOf(LaneGroupTransitionReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION)
    {
        endBitPosition += m_intersectionTransition_.value().bitSizeOf(context.getIntersectionTransition(), endBitPosition);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH)
    {
        endBitPosition += m_pathTransition_.value().bitSizeOf(context.getPathTransition(), endBitPosition);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
    {
        endBitPosition += m_geoPathTransition_.value().bitSizeOf(context.getGeoPathTransition(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupTransitionReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION)
    {
        endBitPosition = m_intersectionTransition_.value().initializeOffsets(endBitPosition);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH)
    {
        endBitPosition = m_pathTransition_.value().initializeOffsets(endBitPosition);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
    {
        endBitPosition = m_geoPathTransition_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LaneGroupTransitionReference::initializeOffsets(LaneGroupTransitionReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION)
    {
        endBitPosition = m_intersectionTransition_.value().initializeOffsets(context.getIntersectionTransition(), endBitPosition);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH)
    {
        endBitPosition = m_pathTransition_.value().initializeOffsets(context.getPathTransition(), endBitPosition);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
    {
        endBitPosition = m_geoPathTransition_.value().initializeOffsets(context.getGeoPathTransition(), endBitPosition);
    }

    return endBitPosition;
}

bool LaneGroupTransitionReference::operator==(const LaneGroupTransitionReference& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isIntersectionTransitionUsed() ? !other.isIntersectionTransitionUsed() : (m_intersectionTransition_ == other.m_intersectionTransition_)) &&
                (!isPathTransitionUsed() ? !other.isPathTransitionUsed() : (m_pathTransition_ == other.m_pathTransition_)) &&
                (!isGeoPathTransitionUsed() ? !other.isGeoPathTransitionUsed() : (m_geoPathTransition_ == other.m_geoPathTransition_));
    }

    return true;
}

uint32_t LaneGroupTransitionReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isIntersectionTransitionUsed())
        result = ::zserio::calcHashCode(result, m_intersectionTransition_);
    if (isPathTransitionUsed())
        result = ::zserio::calcHashCode(result, m_pathTransition_);
    if (isGeoPathTransitionUsed())
        result = ::zserio::calcHashCode(result, m_geoPathTransition_);

    return result;
}

void LaneGroupTransitionReference::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION)
    {
        m_intersectionTransition_.value().write(out);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH)
    {
        m_pathTransition_.value().write(out);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
    {
        m_geoPathTransition_.value().write(out);
    }
}

void LaneGroupTransitionReference::write(LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION)
    {
        m_intersectionTransition_.value().write(context.getIntersectionTransition(), out);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH)
    {
        m_pathTransition_.value().write(context.getPathTransition(), out);
    }
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
    {
        m_geoPathTransition_.value().write(context.getGeoPathTransition(), out);
    }
}

::nds::lane::reference::types::LaneGroupTransitionReferenceType LaneGroupTransitionReference::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::LaneGroupTransitionReferenceType>(in);
}

::nds::lane::reference::types::LaneGroupTransitionReferenceType LaneGroupTransitionReference::readType(LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::LaneGroupTransitionReferenceType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransition> LaneGroupTransitionReference::readIntersectionTransition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransition>(::nds::lane::reference::types::LaneGroupTransition(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransition>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransition> LaneGroupTransitionReference::readIntersectionTransition(LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::INTERSECTION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransition>(::nds::lane::reference::types::LaneGroupTransition(context.getIntersectionTransition(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransition>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionPath> LaneGroupTransitionReference::readPathTransition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionPath>(::nds::lane::reference::types::LaneGroupTransitionPath(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionPath>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionPath> LaneGroupTransitionReference::readPathTransition(LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_PATH)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionPath>(::nds::lane::reference::types::LaneGroupTransitionPath(context.getPathTransition(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionPath>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionGeoPath> LaneGroupTransitionReference::readGeoPathTransition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionGeoPath>(::nds::lane::reference::types::LaneGroupTransitionGeoPath(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionGeoPath>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionGeoPath> LaneGroupTransitionReference::readGeoPathTransition(LaneGroupTransitionReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::lane::reference::types::LaneGroupTransitionReferenceType::TRANSITION_GEO_PATH)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionGeoPath>(::nds::lane::reference::types::LaneGroupTransitionGeoPath(context.getGeoPathTransition(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupTransitionGeoPath>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneGroupTransition.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneGroupTransition::LaneGroupTransition(const allocator_type& allocator) noexcept :
        m_laneGroupId_(allocator),
        m_numLanes_(::nds::lane::reference::types::LanesInTransition()),
        m_transitionLanes_(allocator)
{
}

LaneGroupTransition::LaneGroupTransition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_laneGroupId_(readLaneGroupId(in, allocator)),
        m_numLanes_(readNumLanes(in)),
        m_transitionLanes_(readTransitionLanes(in, allocator))
{
}

LaneGroupTransition::LaneGroupTransition(LaneGroupTransition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_laneGroupId_(readLaneGroupId(context, in, allocator)),
        m_numLanes_(readNumLanes(context, in)),
        m_transitionLanes_(readTransitionLanes(context, in, allocator))
{
}

LaneGroupTransition::LaneGroupTransition(::zserio::PropagateAllocatorT,
        const LaneGroupTransition& other, const allocator_type& allocator) :
        m_laneGroupId_(::zserio::allocatorPropagatingCopy(other.m_laneGroupId_, allocator)),
        m_numLanes_(::zserio::allocatorPropagatingCopy(other.m_numLanes_, allocator)),
        m_transitionLanes_(::zserio::allocatorPropagatingCopy(other.m_transitionLanes_, allocator))
{
}

::nds::lane::reference::types::LaneGroupId& LaneGroupTransition::getLaneGroupId()
{
    return m_laneGroupId_;
}

const ::nds::lane::reference::types::LaneGroupId& LaneGroupTransition::getLaneGroupId() const
{
    return m_laneGroupId_;
}

void LaneGroupTransition::setLaneGroupId(const ::nds::lane::reference::types::LaneGroupId& laneGroupId_)
{
    m_laneGroupId_ = laneGroupId_;
}

void LaneGroupTransition::setLaneGroupId(::nds::lane::reference::types::LaneGroupId&& laneGroupId_)
{
    m_laneGroupId_ = ::std::move(laneGroupId_);
}

::nds::lane::reference::types::LanesInTransition LaneGroupTransition::getNumLanes() const
{
    return m_numLanes_;
}

void LaneGroupTransition::setNumLanes(::nds::lane::reference::types::LanesInTransition numLanes_)
{
    m_numLanes_ = numLanes_;
}

::zserio::vector<::nds::lane::reference::types::LaneId>& LaneGroupTransition::getTransitionLanes()
{
    return m_transitionLanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneId>& LaneGroupTransition::getTransitionLanes() const
{
    return m_transitionLanes_.getRawArray();
}

void LaneGroupTransition::setTransitionLanes(const ::zserio::vector<::nds::lane::reference::types::LaneId>& transitionLanes_)
{
    m_transitionLanes_ = ZserioArrayType_transitionLanes(transitionLanes_);
}

void LaneGroupTransition::setTransitionLanes(::zserio::vector<::nds::lane::reference::types::LaneId>&& transitionLanes_)
{
    m_transitionLanes_ = ZserioArrayType_transitionLanes(std::move(transitionLanes_));
}

void LaneGroupTransition::initPackingContext(LaneGroupTransition::ZserioPackingContext& context) const
{
    m_laneGroupId_.initPackingContext(context.getLaneGroupId());
    context.getNumLanes().init<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInTransition>>(m_numLanes_);
}

size_t LaneGroupTransition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneGroupId_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numLanes_);
    endBitPosition += m_transitionLanes_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupTransition::bitSizeOf(LaneGroupTransition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneGroupId_.bitSizeOf(context.getLaneGroupId(), endBitPosition);
    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInTransition>>(m_numLanes_);
    endBitPosition += m_transitionLanes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupTransition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneGroupId_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numLanes_);
    endBitPosition = m_transitionLanes_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t LaneGroupTransition::initializeOffsets(LaneGroupTransition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneGroupId_.initializeOffsets(context.getLaneGroupId(), endBitPosition);
    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInTransition>>(m_numLanes_);
    endBitPosition = m_transitionLanes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LaneGroupTransition::operator==(const LaneGroupTransition& other) const
{
    if (this != &other)
    {
        return
                (m_laneGroupId_ == other.m_laneGroupId_) &&
                (m_numLanes_ == other.m_numLanes_) &&
                (m_transitionLanes_ == other.m_transitionLanes_);
    }

    return true;
}

uint32_t LaneGroupTransition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_laneGroupId_);
    result = ::zserio::calcHashCode(result, m_numLanes_);
    result = ::zserio::calcHashCode(result, m_transitionLanes_);

    return result;
}

void LaneGroupTransition::write(::zserio::BitStreamWriter& out) const
{
    m_laneGroupId_.write(out);

    out.writeVarUInt16(m_numLanes_);

    // check array length
    if (m_transitionLanes_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupTransition.transitionLanes: ") <<
                m_transitionLanes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_transitionLanes_.write(*this, out);
}

void LaneGroupTransition::write(LaneGroupTransition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_laneGroupId_.write(context.getLaneGroupId(), out);

    context.getNumLanes().write<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInTransition>>(out, m_numLanes_);

    // check array length
    if (m_transitionLanes_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupTransition.transitionLanes: ") <<
                m_transitionLanes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_transitionLanes_.writePacked(*this, out);
}

void LaneGroupTransition::ZserioElementFactory_transitionLanes::create(LaneGroupTransition&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneGroupTransition::ZserioElementFactory_transitionLanes::create(LaneGroupTransition&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneId>& array,
        ::nds::lane::reference::types::LaneId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::lane::reference::types::LaneGroupId LaneGroupTransition::readLaneGroupId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupId(in, allocator);
}

::nds::lane::reference::types::LaneGroupId LaneGroupTransition::readLaneGroupId(LaneGroupTransition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupId(context.getLaneGroupId(), in, allocator);
}
::nds::lane::reference::types::LanesInTransition LaneGroupTransition::readNumLanes(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::reference::types::LanesInTransition>(in.readVarUInt16());
}

::nds::lane::reference::types::LanesInTransition LaneGroupTransition::readNumLanes(LaneGroupTransition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumLanes().read<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInTransition>>(in);
}
LaneGroupTransition::ZserioArrayType_transitionLanes LaneGroupTransition::readTransitionLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_transitionLanes readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumLanes()));

    return readField;
}

LaneGroupTransition::ZserioArrayType_transitionLanes LaneGroupTransition::readTransitionLanes(LaneGroupTransition::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_transitionLanes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumLanes()));

    return readField;
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneGroupTransitionPath.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneGroupTransitionPath::LaneGroupTransitionPath(const allocator_type& allocator) noexcept :
        m_numLaneGroups_(uint8_t()),
        m_laneGroupTransition_(allocator)
{
}

LaneGroupTransitionPath::LaneGroupTransitionPath(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numLaneGroups_(readNumLaneGroups(in)),
        m_laneGroupTransition_(readLaneGroupTransition(in, allocator))
{
}

LaneGroupTransitionPath::LaneGroupTransitionPath(LaneGroupTransitionPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numLaneGroups_(readNumLaneGroups(context, in)),
        m_laneGroupTransition_(readLaneGroupTransition(context, in, allocator))
{
}

LaneGroupTransitionPath::LaneGroupTransitionPath(::zserio::PropagateAllocatorT,
        const LaneGroupTransitionPath& other, const allocator_type& allocator) :
        m_numLaneGroups_(::zserio::allocatorPropagatingCopy(other.m_numLaneGroups_, allocator)),
        m_laneGroupTransition_(::zserio::allocatorPropagatingCopy(other.m_laneGroupTransition_, allocator))
{
}

uint8_t LaneGroupTransitionPath::getNumLaneGroups() const
{
    return m_numLaneGroups_;
}

void LaneGroupTransitionPath::setNumLaneGroups(uint8_t numLaneGroups_)
{
    m_numLaneGroups_ = numLaneGroups_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& LaneGroupTransitionPath::getLaneGroupTransition()
{
    return m_laneGroupTransition_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& LaneGroupTransitionPath::getLaneGroupTransition() const
{
    return m_laneGroupTransition_.getRawArray();
}

void LaneGroupTransitionPath::setLaneGroupTransition(const ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& laneGroupTransition_)
{
    m_laneGroupTransition_ = ZserioArrayType_laneGroupTransition(laneGroupTransition_);
}

void LaneGroupTransitionPath::setLaneGroupTransition(::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>&& laneGroupTransition_)
{
    m_laneGroupTransition_ = ZserioArrayType_laneGroupTransition(std::move(laneGroupTransition_));
}

void LaneGroupTransitionPath::initPackingContext(LaneGroupTransitionPath::ZserioPackingContext& context) const
{
    context.getNumLaneGroups().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numLaneGroups_);
}

size_t LaneGroupTransitionPath::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_laneGroupTransition_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupTransitionPath::bitSizeOf(LaneGroupTransitionPath::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLaneGroups().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numLaneGroups_);
    endBitPosition += m_laneGroupTransition_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupTransitionPath::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_laneGroupTransition_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t LaneGroupTransitionPath::initializeOffsets(LaneGroupTransitionPath::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLaneGroups().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numLaneGroups_);
    endBitPosition = m_laneGroupTransition_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LaneGroupTransitionPath::operator==(const LaneGroupTransitionPath& other) const
{
    if (this != &other)
    {
        return
                (m_numLaneGroups_ == other.m_numLaneGroups_) &&
                (m_laneGroupTransition_ == other.m_laneGroupTransition_);
    }

    return true;
}

uint32_t LaneGroupTransitionPath::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numLaneGroups_);
    result = ::zserio::calcHashCode(result, m_laneGroupTransition_);

    return result;
}

void LaneGroupTransitionPath::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numLaneGroups_, UINT8_C(8));

    // check array length
    if (m_laneGroupTransition_.getRawArray().size() != static_cast<size_t>(getNumLaneGroups()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupTransitionPath.laneGroupTransition: ") <<
                m_laneGroupTransition_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLaneGroups()) << "!";
    }
    m_laneGroupTransition_.write(*this, out);
}

void LaneGroupTransitionPath::write(LaneGroupTransitionPath::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumLaneGroups().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numLaneGroups_);

    // check array length
    if (m_laneGroupTransition_.getRawArray().size() != static_cast<size_t>(getNumLaneGroups()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupTransitionPath.laneGroupTransition: ") <<
                m_laneGroupTransition_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLaneGroups()) << "!";
    }
    m_laneGroupTransition_.writePacked(*this, out);
}

void LaneGroupTransitionPath::ZserioElementFactory_laneGroupTransition::create(LaneGroupTransitionPath&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneGroupTransitionPath::ZserioElementFactory_laneGroupTransition::create(LaneGroupTransitionPath&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupTransition>& array,
        ::nds::lane::reference::types::LaneGroupTransition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t LaneGroupTransitionPath::readNumLaneGroups(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t LaneGroupTransitionPath::readNumLaneGroups(LaneGroupTransitionPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumLaneGroups().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
LaneGroupTransitionPath::ZserioArrayType_laneGroupTransition LaneGroupTransitionPath::readLaneGroupTransition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_laneGroupTransition readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumLaneGroups()));

    return readField;
}

LaneGroupTransitionPath::ZserioArrayType_laneGroupTransition LaneGroupTransitionPath::readLaneGroupTransition(LaneGroupTransitionPath::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_laneGroupTransition readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumLaneGroups()));

    return readField;
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneGroupTransitionGeoPath.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneGroupTransitionGeoPath::LaneGroupTransitionGeoPath(const allocator_type& allocator) noexcept :
        m_startTransition_(allocator),
        m_transitionPath_(allocator)
{
}

LaneGroupTransitionGeoPath::LaneGroupTransitionGeoPath(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_startTransition_(readStartTransition(in, allocator)),
        m_transitionPath_(readTransitionPath(in, allocator))
{
}

LaneGroupTransitionGeoPath::LaneGroupTransitionGeoPath(LaneGroupTransitionGeoPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_startTransition_(readStartTransition(context, in, allocator)),
        m_transitionPath_(readTransitionPath(context, in, allocator))
{
}

LaneGroupTransitionGeoPath::LaneGroupTransitionGeoPath(::zserio::PropagateAllocatorT,
        const LaneGroupTransitionGeoPath& other, const allocator_type& allocator) :
        m_startTransition_(::zserio::allocatorPropagatingCopy(other.m_startTransition_, allocator)),
        m_transitionPath_(::zserio::allocatorPropagatingCopy(other.m_transitionPath_, allocator))
{
}

void LaneGroupTransitionGeoPath::initializeChildren()
{
    m_transitionPath_.initializeChildren();
}

::nds::lane::reference::types::LaneGroupTransition& LaneGroupTransitionGeoPath::getStartTransition()
{
    return m_startTransition_;
}

const ::nds::lane::reference::types::LaneGroupTransition& LaneGroupTransitionGeoPath::getStartTransition() const
{
    return m_startTransition_;
}

void LaneGroupTransitionGeoPath::setStartTransition(const ::nds::lane::reference::types::LaneGroupTransition& startTransition_)
{
    m_startTransition_ = startTransition_;
}

void LaneGroupTransitionGeoPath::setStartTransition(::nds::lane::reference::types::LaneGroupTransition&& startTransition_)
{
    m_startTransition_ = ::std::move(startTransition_);
}

::nds::lane::reference::types::LaneGroupReferenceIndirect& LaneGroupTransitionGeoPath::getTransitionPath()
{
    return m_transitionPath_;
}

const ::nds::lane::reference::types::LaneGroupReferenceIndirect& LaneGroupTransitionGeoPath::getTransitionPath() const
{
    return m_transitionPath_;
}

void LaneGroupTransitionGeoPath::setTransitionPath(const ::nds::lane::reference::types::LaneGroupReferenceIndirect& transitionPath_)
{
    m_transitionPath_ = transitionPath_;
}

void LaneGroupTransitionGeoPath::setTransitionPath(::nds::lane::reference::types::LaneGroupReferenceIndirect&& transitionPath_)
{
    m_transitionPath_ = ::std::move(transitionPath_);
}

void LaneGroupTransitionGeoPath::initPackingContext(LaneGroupTransitionGeoPath::ZserioPackingContext& context) const
{
    m_startTransition_.initPackingContext(context.getStartTransition());
    m_transitionPath_.initPackingContext(context.getTransitionPath());
}

size_t LaneGroupTransitionGeoPath::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startTransition_.bitSizeOf(endBitPosition);
    endBitPosition += m_transitionPath_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupTransitionGeoPath::bitSizeOf(LaneGroupTransitionGeoPath::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startTransition_.bitSizeOf(context.getStartTransition(), endBitPosition);
    endBitPosition += m_transitionPath_.bitSizeOf(context.getTransitionPath(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupTransitionGeoPath::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startTransition_.initializeOffsets(endBitPosition);
    endBitPosition = m_transitionPath_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneGroupTransitionGeoPath::initializeOffsets(LaneGroupTransitionGeoPath::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startTransition_.initializeOffsets(context.getStartTransition(), endBitPosition);
    endBitPosition = m_transitionPath_.initializeOffsets(context.getTransitionPath(), endBitPosition);

    return endBitPosition;
}

bool LaneGroupTransitionGeoPath::operator==(const LaneGroupTransitionGeoPath& other) const
{
    if (this != &other)
    {
        return
                (m_startTransition_ == other.m_startTransition_) &&
                (m_transitionPath_ == other.m_transitionPath_);
    }

    return true;
}

uint32_t LaneGroupTransitionGeoPath::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_startTransition_);
    result = ::zserio::calcHashCode(result, m_transitionPath_);

    return result;
}

void LaneGroupTransitionGeoPath::write(::zserio::BitStreamWriter& out) const
{
    m_startTransition_.write(out);
    m_transitionPath_.write(out);
}

void LaneGroupTransitionGeoPath::write(LaneGroupTransitionGeoPath::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_startTransition_.write(context.getStartTransition(), out);
    m_transitionPath_.write(context.getTransitionPath(), out);
}

::nds::lane::reference::types::LaneGroupTransition LaneGroupTransitionGeoPath::readStartTransition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupTransition(in, allocator);
}

::nds::lane::reference::types::LaneGroupTransition LaneGroupTransitionGeoPath::readStartTransition(LaneGroupTransitionGeoPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupTransition(context.getStartTransition(), in, allocator);
}
::nds::lane::reference::types::LaneGroupReferenceIndirect LaneGroupTransitionGeoPath::readTransitionPath(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupReferenceIndirect(in, allocator);
}

::nds::lane::reference::types::LaneGroupReferenceIndirect LaneGroupTransitionGeoPath::readTransitionPath(LaneGroupTransitionGeoPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneGroupReferenceIndirect(context.getTransitionPath(), in, allocator);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneGroupPositionValidity.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneGroupPositionValidity::LaneGroupPositionValidity(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numLanes_(::nds::lane::reference::types::LanesInMask()),
        m_lanes_(allocator),
        m_directions_(allocator)
{
}

LaneGroupPositionValidity::LaneGroupPositionValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numLanes_(readNumLanes(in)),
        m_lanes_(readLanes(in, allocator)),
        m_directions_(readDirections(in, allocator))
{
}

LaneGroupPositionValidity::LaneGroupPositionValidity(LaneGroupPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numLanes_(readNumLanes(context, in)),
        m_lanes_(readLanes(context, in, allocator)),
        m_directions_(readDirections(context, in, allocator))
{
}

LaneGroupPositionValidity::LaneGroupPositionValidity(const LaneGroupPositionValidity& other) :
        m_numLanes_(other.m_numLanes_),
        m_lanes_(other.m_lanes_),
        m_directions_(other.m_directions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LaneGroupPositionValidity& LaneGroupPositionValidity::operator=(const LaneGroupPositionValidity& other)
{
    m_numLanes_ = other.m_numLanes_;
    m_lanes_ = other.m_lanes_;
    m_directions_ = other.m_directions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupPositionValidity::LaneGroupPositionValidity(LaneGroupPositionValidity&& other) :
        m_numLanes_(::std::move(other.m_numLanes_)),
        m_lanes_(::std::move(other.m_lanes_)),
        m_directions_(::std::move(other.m_directions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LaneGroupPositionValidity& LaneGroupPositionValidity::operator=(LaneGroupPositionValidity&& other)
{
    m_numLanes_ = ::std::move(other.m_numLanes_);
    m_lanes_ = ::std::move(other.m_lanes_);
    m_directions_ = ::std::move(other.m_directions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupPositionValidity::LaneGroupPositionValidity(::zserio::PropagateAllocatorT,
        const LaneGroupPositionValidity& other, const allocator_type& allocator) :
        m_numLanes_(::zserio::allocatorPropagatingCopy(other.m_numLanes_, allocator)),
        m_lanes_(::zserio::allocatorPropagatingCopy(other.m_lanes_, allocator)),
        m_directions_(::zserio::allocatorPropagatingCopy(other.m_directions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LaneGroupPositionValidity::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LaneGroupPositionValidity::isInitialized() const
{
    return m_isInitialized;
}

void LaneGroupPositionValidity::initializeChildren()
{
    m_lanes_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LaneGroupPositionValidity::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LaneGroupPositionValidity' is not initialized!");

    return m_coordShift_;
}

::nds::lane::reference::types::LanesInMask LaneGroupPositionValidity::getNumLanes() const
{
    return m_numLanes_;
}

void LaneGroupPositionValidity::setNumLanes(::nds::lane::reference::types::LanesInMask numLanes_)
{
    m_numLanes_ = numLanes_;
}

::zserio::vector<::nds::lane::reference::types::LanePosition>& LaneGroupPositionValidity::getLanes()
{
    return m_lanes_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LanePosition>& LaneGroupPositionValidity::getLanes() const
{
    return m_lanes_.getRawArray();
}

void LaneGroupPositionValidity::setLanes(const ::zserio::vector<::nds::lane::reference::types::LanePosition>& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(lanes_);
}

void LaneGroupPositionValidity::setLanes(::zserio::vector<::nds::lane::reference::types::LanePosition>&& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(std::move(lanes_));
}

::zserio::vector<::nds::lane::reference::types::LaneValidityDirection>& LaneGroupPositionValidity::getDirections()
{
    return m_directions_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneValidityDirection>& LaneGroupPositionValidity::getDirections() const
{
    return m_directions_.getRawArray();
}

void LaneGroupPositionValidity::setDirections(const ::zserio::vector<::nds::lane::reference::types::LaneValidityDirection>& directions_)
{
    m_directions_ = ZserioArrayType_directions(directions_);
}

void LaneGroupPositionValidity::setDirections(::zserio::vector<::nds::lane::reference::types::LaneValidityDirection>&& directions_)
{
    m_directions_ = ZserioArrayType_directions(std::move(directions_));
}

void LaneGroupPositionValidity::initPackingContext(LaneGroupPositionValidity::ZserioPackingContext& context) const
{
    context.getNumLanes().init<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(m_numLanes_);
}

size_t LaneGroupPositionValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numLanes_);
    endBitPosition += m_lanes_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_directions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupPositionValidity::bitSizeOf(LaneGroupPositionValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(m_numLanes_);
    endBitPosition += m_lanes_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_directions_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneGroupPositionValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numLanes_);
    endBitPosition = m_lanes_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_directions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneGroupPositionValidity::initializeOffsets(LaneGroupPositionValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(m_numLanes_);
    endBitPosition = m_lanes_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_directions_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool LaneGroupPositionValidity::operator==(const LaneGroupPositionValidity& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numLanes_ == other.m_numLanes_) &&
                (m_lanes_ == other.m_lanes_) &&
                (m_directions_ == other.m_directions_);
    }

    return true;
}

uint32_t LaneGroupPositionValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numLanes_);
    result = ::zserio::calcHashCode(result, m_lanes_);
    result = ::zserio::calcHashCode(result, m_directions_);

    return result;
}

void LaneGroupPositionValidity::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numLanes_);

    // check array length
    if (m_lanes_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupPositionValidity.lanes: ") <<
                m_lanes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_lanes_.write(*this, out);

    // check array length
    if (m_directions_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupPositionValidity.directions: ") <<
                m_directions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_directions_.write(out);
}

void LaneGroupPositionValidity::write(LaneGroupPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumLanes().write<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(out, m_numLanes_);

    // check array length
    if (m_lanes_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupPositionValidity.lanes: ") <<
                m_lanes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_lanes_.writePacked(*this, out);

    // check array length
    if (m_directions_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupPositionValidity.directions: ") <<
                m_directions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_directions_.writePacked(out);
}

void LaneGroupPositionValidity::ZserioArrayExpressions_lanes::initializeElement(LaneGroupPositionValidity&,
        ::nds::lane::reference::types::LanePosition& element, size_t)
{
    element.initializeChildren();
}

void LaneGroupPositionValidity::ZserioElementFactory_lanes::create(LaneGroupPositionValidity&        ,
        ::zserio::vector<::nds::lane::reference::types::LanePosition>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneGroupPositionValidity::ZserioElementFactory_lanes::create(LaneGroupPositionValidity&        ,
        ::zserio::vector<::nds::lane::reference::types::LanePosition>& array,
        ::nds::lane::reference::types::LanePosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::lane::reference::types::LanesInMask LaneGroupPositionValidity::readNumLanes(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::reference::types::LanesInMask>(in.readVarUInt16());
}

::nds::lane::reference::types::LanesInMask LaneGroupPositionValidity::readNumLanes(LaneGroupPositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumLanes().read<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(in);
}
LaneGroupPositionValidity::ZserioArrayType_lanes LaneGroupPositionValidity::readLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumLanes()));

    return readField;
}

LaneGroupPositionValidity::ZserioArrayType_lanes LaneGroupPositionValidity::readLanes(LaneGroupPositionValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_lanes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumLanes()));

    return readField;
}
LaneGroupPositionValidity::ZserioArrayType_directions LaneGroupPositionValidity::readDirections(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_directions readField(allocator);
    readField.read(in, static_cast<size_t>(getNumLanes()));

    return readField;
}

LaneGroupPositionValidity::ZserioArrayType_directions LaneGroupPositionValidity::readDirections(LaneGroupPositionValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_directions readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumLanes()));

    return readField;
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneGroupRangeValidity.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneGroupRangeValidity::LaneGroupRangeValidity(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_completeGroup_(bool()),
        m_completeGroupRange_(::zserio::NullOpt),
        m_numLanes_(::zserio::NullOpt),
        m_lanes_(::zserio::NullOpt),
        m_directions_(::zserio::NullOpt)
{
}

LaneGroupRangeValidity::LaneGroupRangeValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_completeGroup_(readCompleteGroup(in)),
        m_completeGroupRange_(readCompleteGroupRange(in, allocator)),
        m_numLanes_(readNumLanes(in)),
        m_lanes_(readLanes(in, allocator)),
        m_directions_(readDirections(in, allocator))
{
}

LaneGroupRangeValidity::LaneGroupRangeValidity(LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_completeGroup_(readCompleteGroup(in)),
        m_completeGroupRange_(readCompleteGroupRange(context, in, allocator)),
        m_numLanes_(readNumLanes(context, in)),
        m_lanes_(readLanes(context, in, allocator)),
        m_directions_(readDirections(context, in, allocator))
{
}

LaneGroupRangeValidity::LaneGroupRangeValidity(const LaneGroupRangeValidity& other) :
        m_completeGroup_(other.m_completeGroup_),
        m_completeGroupRange_(other.m_completeGroupRange_),
        m_numLanes_(other.m_numLanes_),
        m_lanes_(other.m_lanes_),
        m_directions_(other.m_directions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LaneGroupRangeValidity& LaneGroupRangeValidity::operator=(const LaneGroupRangeValidity& other)
{
    m_completeGroup_ = other.m_completeGroup_;
    m_completeGroupRange_ = other.m_completeGroupRange_;
    m_numLanes_ = other.m_numLanes_;
    m_lanes_ = other.m_lanes_;
    m_directions_ = other.m_directions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupRangeValidity::LaneGroupRangeValidity(LaneGroupRangeValidity&& other) :
        m_completeGroup_(::std::move(other.m_completeGroup_)),
        m_completeGroupRange_(::std::move(other.m_completeGroupRange_)),
        m_numLanes_(::std::move(other.m_numLanes_)),
        m_lanes_(::std::move(other.m_lanes_)),
        m_directions_(::std::move(other.m_directions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LaneGroupRangeValidity& LaneGroupRangeValidity::operator=(LaneGroupRangeValidity&& other)
{
    m_completeGroup_ = ::std::move(other.m_completeGroup_);
    m_completeGroupRange_ = ::std::move(other.m_completeGroupRange_);
    m_numLanes_ = ::std::move(other.m_numLanes_);
    m_lanes_ = ::std::move(other.m_lanes_);
    m_directions_ = ::std::move(other.m_directions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LaneGroupRangeValidity::LaneGroupRangeValidity(::zserio::PropagateAllocatorT,
        const LaneGroupRangeValidity& other, const allocator_type& allocator) :
        m_completeGroup_(::zserio::allocatorPropagatingCopy(other.m_completeGroup_, allocator)),
        m_completeGroupRange_(::zserio::allocatorPropagatingCopy(other.m_completeGroupRange_, allocator)),
        m_numLanes_(::zserio::allocatorPropagatingCopy(other.m_numLanes_, allocator)),
        m_lanes_(::zserio::allocatorPropagatingCopy(other.m_lanes_, allocator)),
        m_directions_(::zserio::allocatorPropagatingCopy(other.m_directions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LaneGroupRangeValidity::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LaneGroupRangeValidity::isInitialized() const
{
    return m_isInitialized;
}

void LaneGroupRangeValidity::initializeChildren()
{
    if (getCompleteGroup())
        m_completeGroupRange_.value().initializeChildren();
    if (!getCompleteGroup())
        m_lanes_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift LaneGroupRangeValidity::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LaneGroupRangeValidity' is not initialized!");

    return m_coordShift_;
}

bool LaneGroupRangeValidity::getCompleteGroup() const
{
    return m_completeGroup_;
}

void LaneGroupRangeValidity::setCompleteGroup(bool completeGroup_)
{
    m_completeGroup_ = completeGroup_;
}

::nds::lane::reference::types::LaneGroupRange& LaneGroupRangeValidity::getCompleteGroupRange()
{
    return m_completeGroupRange_.value();
}

const ::nds::lane::reference::types::LaneGroupRange& LaneGroupRangeValidity::getCompleteGroupRange() const
{
    return m_completeGroupRange_.value();
}

void LaneGroupRangeValidity::setCompleteGroupRange(const ::nds::lane::reference::types::LaneGroupRange& completeGroupRange_)
{
    m_completeGroupRange_ = completeGroupRange_;
}

void LaneGroupRangeValidity::setCompleteGroupRange(::nds::lane::reference::types::LaneGroupRange&& completeGroupRange_)
{
    m_completeGroupRange_ = ::std::move(completeGroupRange_);
}

bool LaneGroupRangeValidity::isCompleteGroupRangeUsed() const
{
    return (getCompleteGroup());
}

bool LaneGroupRangeValidity::isCompleteGroupRangeSet() const
{
    return m_completeGroupRange_.hasValue();
}

void LaneGroupRangeValidity::resetCompleteGroupRange()
{
    m_completeGroupRange_.reset();
}

::nds::lane::reference::types::LanesInMask LaneGroupRangeValidity::getNumLanes() const
{
    return m_numLanes_.value();
}

void LaneGroupRangeValidity::setNumLanes(::nds::lane::reference::types::LanesInMask numLanes_)
{
    m_numLanes_ = numLanes_;
}

bool LaneGroupRangeValidity::isNumLanesUsed() const
{
    return (!getCompleteGroup());
}

bool LaneGroupRangeValidity::isNumLanesSet() const
{
    return m_numLanes_.hasValue();
}

void LaneGroupRangeValidity::resetNumLanes()
{
    m_numLanes_.reset();
}

::zserio::vector<::nds::lane::reference::types::LaneRange>& LaneGroupRangeValidity::getLanes()
{
    return m_lanes_.value().getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneRange>& LaneGroupRangeValidity::getLanes() const
{
    return m_lanes_.value().getRawArray();
}

void LaneGroupRangeValidity::setLanes(const ::zserio::vector<::nds::lane::reference::types::LaneRange>& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(lanes_);
}

void LaneGroupRangeValidity::setLanes(::zserio::vector<::nds::lane::reference::types::LaneRange>&& lanes_)
{
    m_lanes_ = ZserioArrayType_lanes(std::move(lanes_));
}

bool LaneGroupRangeValidity::isLanesUsed() const
{
    return (!getCompleteGroup());
}

bool LaneGroupRangeValidity::isLanesSet() const
{
    return m_lanes_.hasValue();
}

void LaneGroupRangeValidity::resetLanes()
{
    m_lanes_.reset();
}

::zserio::vector<::nds::lane::reference::types::LaneValidityDirection>& LaneGroupRangeValidity::getDirections()
{
    return m_directions_.value().getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneValidityDirection>& LaneGroupRangeValidity::getDirections() const
{
    return m_directions_.value().getRawArray();
}

void LaneGroupRangeValidity::setDirections(const ::zserio::vector<::nds::lane::reference::types::LaneValidityDirection>& directions_)
{
    m_directions_ = ZserioArrayType_directions(directions_);
}

void LaneGroupRangeValidity::setDirections(::zserio::vector<::nds::lane::reference::types::LaneValidityDirection>&& directions_)
{
    m_directions_ = ZserioArrayType_directions(std::move(directions_));
}

bool LaneGroupRangeValidity::isDirectionsUsed() const
{
    return (!getCompleteGroup());
}

bool LaneGroupRangeValidity::isDirectionsSet() const
{
    return m_directions_.hasValue();
}

void LaneGroupRangeValidity::resetDirections()
{
    m_directions_.reset();
}

void LaneGroupRangeValidity::initPackingContext(LaneGroupRangeValidity::ZserioPackingContext& context) const
{
    if (getCompleteGroup())
    {
        m_completeGroupRange_.value().initPackingContext(context.getCompleteGroupRange());
    }
    if (!getCompleteGroup())
    {
        context.getNumLanes().init<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(m_numLanes_.value());
    }
}

size_t LaneGroupRangeValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getCompleteGroup())
    {
        endBitPosition += m_completeGroupRange_.value().bitSizeOf(endBitPosition);
    }
    if (!getCompleteGroup())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numLanes_.value());
    }
    if (!getCompleteGroup())
    {
        endBitPosition += m_lanes_.value().bitSizeOf(*this, endBitPosition);
    }
    if (!getCompleteGroup())
    {
        endBitPosition += m_directions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupRangeValidity::bitSizeOf(LaneGroupRangeValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getCompleteGroup())
    {
        endBitPosition += m_completeGroupRange_.value().bitSizeOf(context.getCompleteGroupRange(), endBitPosition);
    }
    if (!getCompleteGroup())
    {
        endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(m_numLanes_.value());
    }
    if (!getCompleteGroup())
    {
        endBitPosition += m_lanes_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    if (!getCompleteGroup())
    {
        endBitPosition += m_directions_.value().bitSizeOfPacked(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupRangeValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getCompleteGroup())
    {
        endBitPosition = m_completeGroupRange_.value().initializeOffsets(endBitPosition);
    }
    if (!getCompleteGroup())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numLanes_.value());
    }
    if (!getCompleteGroup())
    {
        endBitPosition = m_lanes_.value().initializeOffsets(*this, endBitPosition);
    }
    if (!getCompleteGroup())
    {
        endBitPosition = m_directions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LaneGroupRangeValidity::initializeOffsets(LaneGroupRangeValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getCompleteGroup())
    {
        endBitPosition = m_completeGroupRange_.value().initializeOffsets(context.getCompleteGroupRange(), endBitPosition);
    }
    if (!getCompleteGroup())
    {
        endBitPosition += context.getNumLanes().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(m_numLanes_.value());
    }
    if (!getCompleteGroup())
    {
        endBitPosition = m_lanes_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    if (!getCompleteGroup())
    {
        endBitPosition = m_directions_.value().initializeOffsetsPacked(endBitPosition);
    }

    return endBitPosition;
}

bool LaneGroupRangeValidity::operator==(const LaneGroupRangeValidity& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_completeGroup_ == other.m_completeGroup_) &&
                (!isCompleteGroupRangeUsed() ? !other.isCompleteGroupRangeUsed() : (m_completeGroupRange_ == other.m_completeGroupRange_)) &&
                (!isNumLanesUsed() ? !other.isNumLanesUsed() : (m_numLanes_ == other.m_numLanes_)) &&
                (!isLanesUsed() ? !other.isLanesUsed() : (m_lanes_ == other.m_lanes_)) &&
                (!isDirectionsUsed() ? !other.isDirectionsUsed() : (m_directions_ == other.m_directions_));
    }

    return true;
}

uint32_t LaneGroupRangeValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_completeGroup_);
    if (isCompleteGroupRangeUsed())
        result = ::zserio::calcHashCode(result, m_completeGroupRange_);
    if (isNumLanesUsed())
        result = ::zserio::calcHashCode(result, m_numLanes_);
    if (isLanesUsed())
        result = ::zserio::calcHashCode(result, m_lanes_);
    if (isDirectionsUsed())
        result = ::zserio::calcHashCode(result, m_directions_);

    return result;
}

void LaneGroupRangeValidity::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_completeGroup_);

    if (getCompleteGroup())
    {
        m_completeGroupRange_.value().write(out);
    }

    if (!getCompleteGroup())
    {
        out.writeVarUInt16(m_numLanes_.value());
    }

    if (!getCompleteGroup())
    {
        // check array length
        if (m_lanes_.value().getRawArray().size() != static_cast<size_t>(getNumLanes()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupRangeValidity.lanes: ") <<
                    m_lanes_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLanes()) << "!";
        }
        m_lanes_.value().write(*this, out);
    }

    if (!getCompleteGroup())
    {
        // check array length
        if (m_directions_.value().getRawArray().size() != static_cast<size_t>(getNumLanes()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupRangeValidity.directions: ") <<
                    m_directions_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLanes()) << "!";
        }
        m_directions_.value().write(out);
    }
}

void LaneGroupRangeValidity::write(LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_completeGroup_);

    if (getCompleteGroup())
    {
        m_completeGroupRange_.value().write(context.getCompleteGroupRange(), out);
    }

    if (!getCompleteGroup())
    {
        context.getNumLanes().write<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(out, m_numLanes_.value());
    }

    if (!getCompleteGroup())
    {
        // check array length
        if (m_lanes_.value().getRawArray().size() != static_cast<size_t>(getNumLanes()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupRangeValidity.lanes: ") <<
                    m_lanes_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLanes()) << "!";
        }
        m_lanes_.value().writePacked(*this, out);
    }

    if (!getCompleteGroup())
    {
        // check array length
        if (m_directions_.value().getRawArray().size() != static_cast<size_t>(getNumLanes()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneGroupRangeValidity.directions: ") <<
                    m_directions_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLanes()) << "!";
        }
        m_directions_.value().writePacked(out);
    }
}

void LaneGroupRangeValidity::ZserioArrayExpressions_lanes::initializeElement(LaneGroupRangeValidity&,
        ::nds::lane::reference::types::LaneRange& element, size_t)
{
    element.initializeChildren();
}

void LaneGroupRangeValidity::ZserioElementFactory_lanes::create(LaneGroupRangeValidity&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneRange>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LaneGroupRangeValidity::ZserioElementFactory_lanes::create(LaneGroupRangeValidity&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneRange>& array,
        ::nds::lane::reference::types::LaneRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

bool LaneGroupRangeValidity::readCompleteGroup(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupRange> LaneGroupRangeValidity::readCompleteGroupRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getCompleteGroup())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupRange>(::nds::lane::reference::types::LaneGroupRange(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupRange>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupRange> LaneGroupRangeValidity::readCompleteGroupRange(LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getCompleteGroup())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupRange>(::nds::lane::reference::types::LaneGroupRange(context.getCompleteGroupRange(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LaneGroupRange>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInMask> LaneGroupRangeValidity::readNumLanes(::zserio::BitStreamReader& in)
{
    if (!getCompleteGroup())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInMask>(static_cast<::nds::lane::reference::types::LanesInMask>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInMask>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInMask> LaneGroupRangeValidity::readNumLanes(LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (!getCompleteGroup())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInMask>(context.getNumLanes().read<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInMask>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInMask>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LaneGroupRangeValidity::ZserioArrayType_lanes> LaneGroupRangeValidity::readLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getCompleteGroup())
    {
        ZserioArrayType_lanes readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumLanes()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_lanes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_lanes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LaneGroupRangeValidity::ZserioArrayType_lanes> LaneGroupRangeValidity::readLanes(LaneGroupRangeValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getCompleteGroup())
    {
        ZserioArrayType_lanes readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumLanes()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_lanes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_lanes>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LaneGroupRangeValidity::ZserioArrayType_directions> LaneGroupRangeValidity::readDirections(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getCompleteGroup())
    {
        ZserioArrayType_directions readField(allocator);
        readField.read(in, static_cast<size_t>(getNumLanes()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_directions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_directions>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LaneGroupRangeValidity::ZserioArrayType_directions> LaneGroupRangeValidity::readDirections(LaneGroupRangeValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getCompleteGroup())
    {
        ZserioArrayType_directions readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumLanes()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_directions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_directions>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/reference/types/LaneGroupRange.h>
#include <nds/lane/reference/types/LaneValidityType.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneGroupRange::LaneGroupRange(const allocator_type& allocator) noexcept :
        m_range_(allocator),
        m_referenceLaneIdx_(::zserio::NullOpt)
{
}

LaneGroupRange::LaneGroupRange(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_range_(readRange(in, allocator)),
        m_referenceLaneIdx_(readReferenceLaneIdx(in))
{
}

LaneGroupRange::LaneGroupRange(LaneGroupRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_range_(readRange(context, in, allocator)),
        m_referenceLaneIdx_(readReferenceLaneIdx(context, in))
{
}

LaneGroupRange::LaneGroupRange(::zserio::PropagateAllocatorT,
        const LaneGroupRange& other, const allocator_type& allocator) :
        m_range_(::zserio::allocatorPropagatingCopy(other.m_range_, allocator)),
        m_referenceLaneIdx_(::zserio::allocatorPropagatingCopy(other.m_referenceLaneIdx_, allocator))
{
}

void LaneGroupRange::initializeChildren()
{
    m_range_.initializeChildren();
}

::nds::lane::reference::types::LaneRange& LaneGroupRange::getRange()
{
    return m_range_;
}

const ::nds::lane::reference::types::LaneRange& LaneGroupRange::getRange() const
{
    return m_range_;
}

void LaneGroupRange::setRange(const ::nds::lane::reference::types::LaneRange& range_)
{
    m_range_ = range_;
}

void LaneGroupRange::setRange(::nds::lane::reference::types::LaneRange&& range_)
{
    m_range_ = ::std::move(range_);
}

::nds::lane::reference::types::LanesInGroup LaneGroupRange::getReferenceLaneIdx() const
{
    return m_referenceLaneIdx_.value();
}

void LaneGroupRange::setReferenceLaneIdx(::nds::lane::reference::types::LanesInGroup referenceLaneIdx_)
{
    m_referenceLaneIdx_ = referenceLaneIdx_;
}

bool LaneGroupRange::isReferenceLaneIdxUsed() const
{
    return (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE);
}

bool LaneGroupRange::isReferenceLaneIdxSet() const
{
    return m_referenceLaneIdx_.hasValue();
}

void LaneGroupRange::resetReferenceLaneIdx()
{
    m_referenceLaneIdx_.reset();
}

void LaneGroupRange::initPackingContext(LaneGroupRange::ZserioPackingContext& context) const
{
    m_range_.initPackingContext(context.getRange());
    if (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE)
    {
        context.getReferenceLaneIdx().init<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInGroup>>(m_referenceLaneIdx_.value());
    }
}

size_t LaneGroupRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_range_.bitSizeOf(endBitPosition);
    if (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_referenceLaneIdx_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupRange::bitSizeOf(LaneGroupRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_range_.bitSizeOf(context.getRange(), endBitPosition);
    if (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE)
    {
        endBitPosition += context.getReferenceLaneIdx().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInGroup>>(m_referenceLaneIdx_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LaneGroupRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_range_.initializeOffsets(endBitPosition);
    if (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_referenceLaneIdx_.value());
    }

    return endBitPosition;
}

size_t LaneGroupRange::initializeOffsets(LaneGroupRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_range_.initializeOffsets(context.getRange(), endBitPosition);
    if (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE)
    {
        endBitPosition += context.getReferenceLaneIdx().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInGroup>>(m_referenceLaneIdx_.value());
    }

    return endBitPosition;
}

bool LaneGroupRange::operator==(const LaneGroupRange& other) const
{
    if (this != &other)
    {
        return
                (m_range_ == other.m_range_) &&
                (!isReferenceLaneIdxUsed() ? !other.isReferenceLaneIdxUsed() : (m_referenceLaneIdx_ == other.m_referenceLaneIdx_));
    }

    return true;
}

uint32_t LaneGroupRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_range_);
    if (isReferenceLaneIdxUsed())
        result = ::zserio::calcHashCode(result, m_referenceLaneIdx_);

    return result;
}

void LaneGroupRange::write(::zserio::BitStreamWriter& out) const
{
    m_range_.write(out);
    if (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE)
    {
        out.writeVarUInt16(m_referenceLaneIdx_.value());
    }
}

void LaneGroupRange::write(LaneGroupRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_range_.write(context.getRange(), out);
    if (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE)
    {
        context.getReferenceLaneIdx().write<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInGroup>>(out, m_referenceLaneIdx_.value());
    }
}

::nds::lane::reference::types::LaneRange LaneGroupRange::readRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneRange(in, allocator);
}

::nds::lane::reference::types::LaneRange LaneGroupRange::readRange(LaneGroupRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneRange(context.getRange(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInGroup> LaneGroupRange::readReferenceLaneIdx(::zserio::BitStreamReader& in)
{
    if (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInGroup>(static_cast<::nds::lane::reference::types::LanesInGroup>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInGroup>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInGroup> LaneGroupRange::readReferenceLaneIdx(LaneGroupRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getRange().getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInGroup>(context.getReferenceLaneIdx().read<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LanesInGroup>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::LanesInGroup>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneValidityPosition.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneValidityPosition::LaneValidityPosition(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_position_(allocator),
        m_positionIndication_(::zserio::NullOpt)
{
}

LaneValidityPosition::LaneValidityPosition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_position_(readPosition(in, allocator)),
        m_positionIndication_(readPositionIndication(in))
{
}

LaneValidityPosition::LaneValidityPosition(LaneValidityPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_position_(readPosition(context, in, allocator)),
        m_positionIndication_(readPositionIndication(in))
{
}

LaneValidityPosition::LaneValidityPosition(const LaneValidityPosition& other) :
        m_position_(other.m_position_),
        m_positionIndication_(other.m_positionIndication_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneValidityPosition& LaneValidityPosition::operator=(const LaneValidityPosition& other)
{
    m_position_ = other.m_position_;
    m_positionIndication_ = other.m_positionIndication_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneValidityPosition::LaneValidityPosition(LaneValidityPosition&& other) :
        m_position_(::std::move(other.m_position_)),
        m_positionIndication_(::std::move(other.m_positionIndication_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneValidityPosition& LaneValidityPosition::operator=(LaneValidityPosition&& other)
{
    m_position_ = ::std::move(other.m_position_);
    m_positionIndication_ = ::std::move(other.m_positionIndication_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneValidityPosition::LaneValidityPosition(::zserio::PropagateAllocatorT,
        const LaneValidityPosition& other, const allocator_type& allocator) :
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator)),
        m_positionIndication_(::zserio::allocatorPropagatingCopy(other.m_positionIndication_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneValidityPosition::initializeChildren()
{
    m_position_.initialize(static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::core::geometry::Position3D& LaneValidityPosition::getPosition()
{
    return m_position_;
}

const ::nds::core::geometry::Position3D& LaneValidityPosition::getPosition() const
{
    return m_position_;
}

void LaneValidityPosition::setPosition(const ::nds::core::geometry::Position3D& position_)
{
    m_position_ = position_;
}

void LaneValidityPosition::setPosition(::nds::core::geometry::Position3D&& position_)
{
    m_position_ = ::std::move(position_);
}

::nds::lane::reference::types::PercentageIndication LaneValidityPosition::getPositionIndication() const
{
    return m_positionIndication_.value();
}

void LaneValidityPosition::setPositionIndication(::nds::lane::reference::types::PercentageIndication positionIndication_)
{
    m_positionIndication_ = positionIndication_;
}

bool LaneValidityPosition::isPositionIndicationUsed() const
{
    return (isPositionIndicationSet());
}

bool LaneValidityPosition::isPositionIndicationSet() const
{
    return m_positionIndication_.hasValue();
}

void LaneValidityPosition::resetPositionIndication()
{
    m_positionIndication_.reset();
}

void LaneValidityPosition::initPackingContext(LaneValidityPosition::ZserioPackingContext& context) const
{
    m_position_.initPackingContext(context.getPosition());
}

size_t LaneValidityPosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition - bitPosition;
}

size_t LaneValidityPosition::bitSizeOf(LaneValidityPosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition - bitPosition;
}

size_t LaneValidityPosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition;
}

size_t LaneValidityPosition::initializeOffsets(LaneValidityPosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition;
}

bool LaneValidityPosition::operator==(const LaneValidityPosition& other) const
{
    if (this != &other)
    {
        return
                (m_position_ == other.m_position_) &&
                (!isPositionIndicationUsed() ? !other.isPositionIndicationUsed() : (m_positionIndication_ == other.m_positionIndication_));
    }

    return true;
}

uint32_t LaneValidityPosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_position_);
    if (isPositionIndicationUsed())
        result = ::zserio::calcHashCode(result, m_positionIndication_);

    return result;
}

void LaneValidityPosition::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LaneValidityPosition.position: ") <<
                m_position_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    if (m_position_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LaneValidityPosition.position: ") <<
                m_position_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(out);

    if (isPositionIndicationSet())
    {
        out.writeBool(true);
        out.writeFloat16(m_positionIndication_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void LaneValidityPosition::write(LaneValidityPosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LaneValidityPosition.position: ") <<
                m_position_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    if (m_position_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LaneValidityPosition.position: ") <<
                m_position_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(context.getPosition(), out);

    if (isPositionIndicationSet())
    {
        out.writeBool(true);
        out.writeFloat16(m_positionIndication_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::geometry::Position3D LaneValidityPosition::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position3D(in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::core::geometry::Position3D LaneValidityPosition::readPosition(LaneValidityPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position3D(context.getPosition(), in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}
::zserio::InplaceOptionalHolder<::nds::lane::reference::types::PercentageIndication> LaneValidityPosition::readPositionIndication(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::PercentageIndication>(static_cast<::nds::lane::reference::types::PercentageIndication>(in.readFloat16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::lane::reference::types::PercentageIndication>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneValidityRange.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneValidityRange::LaneValidityRange(const allocator_type& allocator) noexcept :
        m_start_(allocator),
        m_end_(allocator)
{
}

LaneValidityRange::LaneValidityRange(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_start_(readStart(in, allocator)),
        m_end_(readEnd(in, allocator))
{
}

LaneValidityRange::LaneValidityRange(LaneValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_start_(readStart(context, in, allocator)),
        m_end_(readEnd(context, in, allocator))
{
}

LaneValidityRange::LaneValidityRange(::zserio::PropagateAllocatorT,
        const LaneValidityRange& other, const allocator_type& allocator) :
        m_start_(::zserio::allocatorPropagatingCopy(other.m_start_, allocator)),
        m_end_(::zserio::allocatorPropagatingCopy(other.m_end_, allocator))
{
}

void LaneValidityRange::initializeChildren()
{
    m_start_.initializeChildren();
    m_end_.initializeChildren();
}

::nds::lane::reference::types::LaneValidityPosition& LaneValidityRange::getStart()
{
    return m_start_;
}

const ::nds::lane::reference::types::LaneValidityPosition& LaneValidityRange::getStart() const
{
    return m_start_;
}

void LaneValidityRange::setStart(const ::nds::lane::reference::types::LaneValidityPosition& start_)
{
    m_start_ = start_;
}

void LaneValidityRange::setStart(::nds::lane::reference::types::LaneValidityPosition&& start_)
{
    m_start_ = ::std::move(start_);
}

::nds::lane::reference::types::LaneValidityPosition& LaneValidityRange::getEnd()
{
    return m_end_;
}

const ::nds::lane::reference::types::LaneValidityPosition& LaneValidityRange::getEnd() const
{
    return m_end_;
}

void LaneValidityRange::setEnd(const ::nds::lane::reference::types::LaneValidityPosition& end_)
{
    m_end_ = end_;
}

void LaneValidityRange::setEnd(::nds::lane::reference::types::LaneValidityPosition&& end_)
{
    m_end_ = ::std::move(end_);
}

void LaneValidityRange::initPackingContext(LaneValidityRange::ZserioPackingContext& context) const
{
    m_start_.initPackingContext(context.getStart());
    m_end_.initPackingContext(context.getEnd());
}

size_t LaneValidityRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_start_.bitSizeOf(endBitPosition);
    endBitPosition += m_end_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneValidityRange::bitSizeOf(LaneValidityRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_start_.bitSizeOf(context.getStart(), endBitPosition);
    endBitPosition += m_end_.bitSizeOf(context.getEnd(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneValidityRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_start_.initializeOffsets(endBitPosition);
    endBitPosition = m_end_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneValidityRange::initializeOffsets(LaneValidityRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_start_.initializeOffsets(context.getStart(), endBitPosition);
    endBitPosition = m_end_.initializeOffsets(context.getEnd(), endBitPosition);

    return endBitPosition;
}

bool LaneValidityRange::operator==(const LaneValidityRange& other) const
{
    if (this != &other)
    {
        return
                (m_start_ == other.m_start_) &&
                (m_end_ == other.m_end_);
    }

    return true;
}

uint32_t LaneValidityRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_start_);
    result = ::zserio::calcHashCode(result, m_end_);

    return result;
}

void LaneValidityRange::write(::zserio::BitStreamWriter& out) const
{
    m_start_.write(out);
    m_end_.write(out);
}

void LaneValidityRange::write(LaneValidityRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_start_.write(context.getStart(), out);
    m_end_.write(context.getEnd(), out);
}

::nds::lane::reference::types::LaneValidityPosition LaneValidityRange::readStart(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneValidityPosition(in, allocator);
}

::nds::lane::reference::types::LaneValidityPosition LaneValidityRange::readStart(LaneValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneValidityPosition(context.getStart(), in, allocator);
}
::nds::lane::reference::types::LaneValidityPosition LaneValidityRange::readEnd(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneValidityPosition(in, allocator);
}

::nds::lane::reference::types::LaneValidityPosition LaneValidityRange::readEnd(LaneValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::lane::reference::types::LaneValidityPosition(context.getEnd(), in, allocator);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/reference/types/LanePosition.h>
#include <nds/lane/reference/types/LaneValidityType.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LanePosition::LanePosition(const allocator_type&) noexcept :
        m_areChildrenInitialized(false),
        m_type_(::nds::lane::reference::types::LaneValidityType()),
        m_numPositions_(::zserio::NullOpt),
        m_positions_(::zserio::NullOpt)
{
}

LanePosition::LanePosition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(in)),
        m_numPositions_(readNumPositions(in)),
        m_positions_(readPositions(in, allocator))
{
}

LanePosition::LanePosition(LanePosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(context, in)),
        m_numPositions_(readNumPositions(context, in)),
        m_positions_(readPositions(context, in, allocator))
{
}

LanePosition::LanePosition(const LanePosition& other) :
        m_type_(other.m_type_),
        m_numPositions_(other.m_numPositions_),
        m_positions_(other.m_positions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LanePosition& LanePosition::operator=(const LanePosition& other)
{
    m_type_ = other.m_type_;
    m_numPositions_ = other.m_numPositions_;
    m_positions_ = other.m_positions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LanePosition::LanePosition(LanePosition&& other) :
        m_type_(::std::move(other.m_type_)),
        m_numPositions_(::std::move(other.m_numPositions_)),
        m_positions_(::std::move(other.m_positions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LanePosition& LanePosition::operator=(LanePosition&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_numPositions_ = ::std::move(other.m_numPositions_);
    m_positions_ = ::std::move(other.m_positions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LanePosition::LanePosition(::zserio::PropagateAllocatorT,
        const LanePosition& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator)),
        m_positions_(::zserio::allocatorPropagatingCopy(other.m_positions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LanePosition::initializeChildren()
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
        m_positions_.value().initializeElements(*this);

    m_areChildrenInitialized = true;
}

::nds::lane::reference::types::LaneValidityType LanePosition::getType() const
{
    return m_type_;
}

void LanePosition::setType(::nds::lane::reference::types::LaneValidityType type_)
{
    m_type_ = type_;
}

uint32_t LanePosition::getNumPositions() const
{
    return m_numPositions_.value();
}

void LanePosition::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

bool LanePosition::isNumPositionsUsed() const
{
    return (getType() != ::nds::lane::reference::types::LaneValidityType::NONE);
}

bool LanePosition::isNumPositionsSet() const
{
    return m_numPositions_.hasValue();
}

void LanePosition::resetNumPositions()
{
    m_numPositions_.reset();
}

::zserio::vector<::nds::lane::reference::types::LanePositionChoice>& LanePosition::getPositions()
{
    return m_positions_.value().getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LanePositionChoice>& LanePosition::getPositions() const
{
    return m_positions_.value().getRawArray();
}

void LanePosition::setPositions(const ::zserio::vector<::nds::lane::reference::types::LanePositionChoice>& positions_)
{
    m_positions_ = ZserioArrayType_positions(positions_);
}

void LanePosition::setPositions(::zserio::vector<::nds::lane::reference::types::LanePositionChoice>&& positions_)
{
    m_positions_ = ZserioArrayType_positions(std::move(positions_));
}

bool LanePosition::isPositionsUsed() const
{
    return (getType() != ::nds::lane::reference::types::LaneValidityType::NONE);
}

bool LanePosition::isPositionsSet() const
{
    return m_positions_.hasValue();
}

void LanePosition::resetPositions()
{
    m_positions_.reset();
}

void LanePosition::initPackingContext(LanePosition::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_.value());
    }
}

size_t LanePosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_.value());
    }
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += m_positions_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LanePosition::bitSizeOf(LanePosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_.value());
    }
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += m_positions_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LanePosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_.value());
    }
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition = m_positions_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t LanePosition::initializeOffsets(LanePosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_.value());
    }
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition = m_positions_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool LanePosition::operator==(const LanePosition& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isNumPositionsUsed() ? !other.isNumPositionsUsed() : (m_numPositions_ == other.m_numPositions_)) &&
                (!isPositionsUsed() ? !other.isPositionsUsed() : (m_positions_ == other.m_positions_));
    }

    return true;
}

uint32_t LanePosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isNumPositionsUsed())
        result = ::zserio::calcHashCode(result, m_numPositions_);
    if (isPositionsUsed())
        result = ::zserio::calcHashCode(result, m_positions_);

    return result;
}

void LanePosition::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Write: Constraint violated at LanePosition.type!");
    ::zserio::write(out, m_type_);

    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        // check constraint
        if (!(getNumPositions() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at LanePosition.numPositions!");
        out.writeVarSize(m_numPositions_.value());
    }

    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        // check array length
        if (m_positions_.value().getRawArray().size() != static_cast<size_t>(getNumPositions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LanePosition.positions: ") <<
                    m_positions_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumPositions()) << "!";
        }
        m_positions_.value().write(*this, out);
    }
}

void LanePosition::write(LanePosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Write: Constraint violated at LanePosition.type!");
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        // check constraint
        if (!(getNumPositions() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at LanePosition.numPositions!");
        context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_.value());
    }

    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        // check array length
        if (m_positions_.value().getRawArray().size() != static_cast<size_t>(getNumPositions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LanePosition.positions: ") <<
                    m_positions_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumPositions()) << "!";
        }
        m_positions_.value().writePacked(*this, out);
    }
}

void LanePosition::ZserioArrayExpressions_positions::initializeElement(LanePosition& owner,
        ::nds::lane::reference::types::LanePositionChoice& element, size_t)
{
    element.initialize(static_cast<::nds::lane::reference::types::LaneValidityType>(owner.getType()));
}

void LanePosition::ZserioElementFactory_positions::create(LanePosition&         owner,
        ::zserio::vector<::nds::lane::reference::types::LanePositionChoice>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::lane::reference::types::LaneValidityType>(owner.getType()), array.get_allocator());
}

void LanePosition::ZserioElementFactory_positions::create(LanePosition&         owner,
        ::zserio::vector<::nds::lane::reference::types::LanePositionChoice>& array,
        ::nds::lane::reference::types::LanePositionChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::lane::reference::types::LaneValidityType>(owner.getType()), array.get_allocator());
}

::nds::lane::reference::types::LaneValidityType LanePosition::readType(::zserio::BitStreamReader& in)
{
    ::nds::lane::reference::types::LaneValidityType readField = ::zserio::read<::nds::lane::reference::types::LaneValidityType>(in);
    // check constraint
    if (!(readField != ::nds::lane::reference::types::LaneValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Read: Constraint violated at LanePosition.type!");

    return readField;
}

::nds::lane::reference::types::LaneValidityType LanePosition::readType(LanePosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::lane::reference::types::LaneValidityType readField = ::zserio::read<::nds::lane::reference::types::LaneValidityType>(context.getType(), in);
    // check constraint
    if (!(readField != ::nds::lane::reference::types::LaneValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Read: Constraint violated at LanePosition.type!");

    return readField;
}
::zserio::InplaceOptionalHolder<uint32_t> LanePosition::readNumPositions(::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at LanePosition.numPositions!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> LanePosition::readNumPositions(LanePosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        uint32_t readField = context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at LanePosition.numPositions!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LanePosition::ZserioArrayType_positions> LanePosition::readPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        ZserioArrayType_positions readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumPositions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LanePosition::ZserioArrayType_positions> LanePosition::readPositions(LanePosition::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        ZserioArrayType_positions readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/lane/reference/types/LaneRange.h>
#include <nds/lane/reference/types/LaneValidityType.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneRange::LaneRange(const allocator_type&) noexcept :
        m_areChildrenInitialized(false),
        m_type_(::nds::lane::reference::types::LaneValidityType()),
        m_numRanges_(::zserio::NullOpt),
        m_range_(::zserio::NullOpt)
{
}

LaneRange::LaneRange(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(in)),
        m_numRanges_(readNumRanges(in)),
        m_range_(readRange(in, allocator))
{
}

LaneRange::LaneRange(LaneRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(context, in)),
        m_numRanges_(readNumRanges(context, in)),
        m_range_(readRange(context, in, allocator))
{
}

LaneRange::LaneRange(const LaneRange& other) :
        m_type_(other.m_type_),
        m_numRanges_(other.m_numRanges_),
        m_range_(other.m_range_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneRange& LaneRange::operator=(const LaneRange& other)
{
    m_type_ = other.m_type_;
    m_numRanges_ = other.m_numRanges_;
    m_range_ = other.m_range_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneRange::LaneRange(LaneRange&& other) :
        m_type_(::std::move(other.m_type_)),
        m_numRanges_(::std::move(other.m_numRanges_)),
        m_range_(::std::move(other.m_range_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneRange& LaneRange::operator=(LaneRange&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_numRanges_ = ::std::move(other.m_numRanges_);
    m_range_ = ::std::move(other.m_range_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneRange::LaneRange(::zserio::PropagateAllocatorT,
        const LaneRange& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_numRanges_(::zserio::allocatorPropagatingCopy(other.m_numRanges_, allocator)),
        m_range_(::zserio::allocatorPropagatingCopy(other.m_range_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneRange::initializeChildren()
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
        m_range_.value().initializeElements(*this);

    m_areChildrenInitialized = true;
}

::nds::lane::reference::types::LaneValidityType LaneRange::getType() const
{
    return m_type_;
}

void LaneRange::setType(::nds::lane::reference::types::LaneValidityType type_)
{
    m_type_ = type_;
}

uint32_t LaneRange::getNumRanges() const
{
    return m_numRanges_.value();
}

void LaneRange::setNumRanges(uint32_t numRanges_)
{
    m_numRanges_ = numRanges_;
}

bool LaneRange::isNumRangesUsed() const
{
    return (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE);
}

bool LaneRange::isNumRangesSet() const
{
    return m_numRanges_.hasValue();
}

void LaneRange::resetNumRanges()
{
    m_numRanges_.reset();
}

::zserio::vector<::nds::lane::reference::types::LaneRangeChoice>& LaneRange::getRange()
{
    return m_range_.value().getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneRangeChoice>& LaneRange::getRange() const
{
    return m_range_.value().getRawArray();
}

void LaneRange::setRange(const ::zserio::vector<::nds::lane::reference::types::LaneRangeChoice>& range_)
{
    m_range_ = ZserioArrayType_range(range_);
}

void LaneRange::setRange(::zserio::vector<::nds::lane::reference::types::LaneRangeChoice>&& range_)
{
    m_range_ = ZserioArrayType_range(std::move(range_));
}

bool LaneRange::isRangeUsed() const
{
    return (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE);
}

bool LaneRange::isRangeSet() const
{
    return m_range_.hasValue();
}

void LaneRange::resetRange()
{
    m_range_.reset();
}

void LaneRange::initPackingContext(LaneRange::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        context.getNumRanges().init<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
}

size_t LaneRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numRanges_.value());
    }
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += m_range_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneRange::bitSizeOf(LaneRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += context.getNumRanges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += m_range_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LaneRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numRanges_.value());
    }
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition = m_range_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t LaneRange::initializeOffsets(LaneRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition += context.getNumRanges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        endBitPosition = m_range_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool LaneRange::operator==(const LaneRange& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isNumRangesUsed() ? !other.isNumRangesUsed() : (m_numRanges_ == other.m_numRanges_)) &&
                (!isRangeUsed() ? !other.isRangeUsed() : (m_range_ == other.m_range_));
    }

    return true;
}

uint32_t LaneRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isNumRangesUsed())
        result = ::zserio::calcHashCode(result, m_numRanges_);
    if (isRangeUsed())
        result = ::zserio::calcHashCode(result, m_range_);

    return result;
}

void LaneRange::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        // check constraint
        if (!(getNumRanges() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at LaneRange.numRanges!");
        out.writeVarSize(m_numRanges_.value());
    }

    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        // check array length
        if (m_range_.value().getRawArray().size() != static_cast<size_t>(getNumRanges()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneRange.range: ") <<
                    m_range_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRanges()) << "!";
        }
        m_range_.value().write(*this, out);
    }
}

void LaneRange::write(LaneRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        // check constraint
        if (!(getNumRanges() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at LaneRange.numRanges!");
        context.getNumRanges().write<::zserio::VarSizeArrayTraits>(out, m_numRanges_.value());
    }

    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        // check array length
        if (m_range_.value().getRawArray().size() != static_cast<size_t>(getNumRanges()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LaneRange.range: ") <<
                    m_range_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRanges()) << "!";
        }
        m_range_.value().writePacked(*this, out);
    }
}

void LaneRange::ZserioArrayExpressions_range::initializeElement(LaneRange& owner,
        ::nds::lane::reference::types::LaneRangeChoice& element, size_t)
{
    element.initialize(static_cast<::nds::lane::reference::types::LaneValidityType>(owner.getType()));
}

void LaneRange::ZserioElementFactory_range::create(LaneRange&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneRangeChoice>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::lane::reference::types::LaneValidityType>(owner.getType()), array.get_allocator());
}

void LaneRange::ZserioElementFactory_range::create(LaneRange&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneRangeChoice>& array,
        ::nds::lane::reference::types::LaneRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::lane::reference::types::LaneValidityType>(owner.getType()), array.get_allocator());
}

::nds::lane::reference::types::LaneValidityType LaneRange::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::LaneValidityType>(in);
}

::nds::lane::reference::types::LaneValidityType LaneRange::readType(LaneRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::lane::reference::types::LaneValidityType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<uint32_t> LaneRange::readNumRanges(::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at LaneRange.numRanges!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> LaneRange::readNumRanges(LaneRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        uint32_t readField = context.getNumRanges().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at LaneRange.numRanges!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LaneRange::ZserioArrayType_range> LaneRange::readRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        ZserioArrayType_range readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumRanges()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_range>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_range>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LaneRange::ZserioArrayType_range> LaneRange::readRange(LaneRange::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() != ::nds::lane::reference::types::LaneValidityType::COMPLETE && getType() != ::nds::lane::reference::types::LaneValidityType::NONE)
    {
        ZserioArrayType_range readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumRanges()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_range>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_range>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneLengthPosition.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneLengthPosition::LaneLengthPosition(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_length_(::nds::lane::reference::types::LaneLength()),
        m_position_(allocator)
{
}

LaneLengthPosition::LaneLengthPosition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_length_(readLength(in)),
        m_position_(readPosition(in, allocator))
{
}

LaneLengthPosition::LaneLengthPosition(LaneLengthPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_length_(readLength(context, in)),
        m_position_(readPosition(context, in, allocator))
{
}

LaneLengthPosition::LaneLengthPosition(const LaneLengthPosition& other) :
        m_length_(other.m_length_),
        m_position_(other.m_position_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneLengthPosition& LaneLengthPosition::operator=(const LaneLengthPosition& other)
{
    m_length_ = other.m_length_;
    m_position_ = other.m_position_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneLengthPosition::LaneLengthPosition(LaneLengthPosition&& other) :
        m_length_(::std::move(other.m_length_)),
        m_position_(::std::move(other.m_position_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneLengthPosition& LaneLengthPosition::operator=(LaneLengthPosition&& other)
{
    m_length_ = ::std::move(other.m_length_);
    m_position_ = ::std::move(other.m_position_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneLengthPosition::LaneLengthPosition(::zserio::PropagateAllocatorT,
        const LaneLengthPosition& other, const allocator_type& allocator) :
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator)),
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneLengthPosition::initializeChildren()
{
    m_position_.initialize(static_cast<uint32_t>(getLength()));

    m_areChildrenInitialized = true;
}

::nds::lane::reference::types::LaneLength LaneLengthPosition::getLength() const
{
    return m_length_;
}

void LaneLengthPosition::setLength(::nds::lane::reference::types::LaneLength length_)
{
    m_length_ = length_;
}

::nds::core::types::RangePosition& LaneLengthPosition::getPosition()
{
    return m_position_;
}

const ::nds::core::types::RangePosition& LaneLengthPosition::getPosition() const
{
    return m_position_;
}

void LaneLengthPosition::setPosition(const ::nds::core::types::RangePosition& position_)
{
    m_position_ = position_;
}

void LaneLengthPosition::setPosition(::nds::core::types::RangePosition&& position_)
{
    m_position_ = ::std::move(position_);
}

void LaneLengthPosition::initPackingContext(LaneLengthPosition::ZserioPackingContext& context) const
{
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(m_length_);
    m_position_.initPackingContext(context.getPosition());
}

size_t LaneLengthPosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += m_position_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLengthPosition::bitSizeOf(LaneLengthPosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(m_length_);
    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLengthPosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition = m_position_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneLengthPosition::initializeOffsets(LaneLengthPosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(m_length_);
    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);

    return endBitPosition;
}

bool LaneLengthPosition::operator==(const LaneLengthPosition& other) const
{
    if (this != &other)
    {
        return
                (m_length_ == other.m_length_) &&
                (m_position_ == other.m_position_);
    }

    return true;
}

uint32_t LaneLengthPosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_length_);
    result = ::zserio::calcHashCode(result, m_position_);

    return result;
}

void LaneLengthPosition::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_length_);

    // check parameters
    if (m_position_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field LaneLengthPosition.position: ") <<
                m_position_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_position_.write(out);
}

void LaneLengthPosition::write(LaneLengthPosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(out, m_length_);

    // check parameters
    if (m_position_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field LaneLengthPosition.position: ") <<
                m_position_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_position_.write(context.getPosition(), out);
}

::nds::lane::reference::types::LaneLength LaneLengthPosition::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::reference::types::LaneLength>(in.readVarUInt32());
}

::nds::lane::reference::types::LaneLength LaneLengthPosition::readLength(LaneLengthPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(in);
}
::nds::core::types::RangePosition LaneLengthPosition::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::RangePosition(in, static_cast<uint32_t>(getLength()), allocator);
}

::nds::core::types::RangePosition LaneLengthPosition::readPosition(LaneLengthPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::RangePosition(context.getPosition(), in, static_cast<uint32_t>(getLength()), allocator);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneLengthRange.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneLengthRange::LaneLengthRange(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_length_(::nds::lane::reference::types::LaneLength()),
        m_range_(allocator)
{
}

LaneLengthRange::LaneLengthRange(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_length_(readLength(in)),
        m_range_(readRange(in, allocator))
{
}

LaneLengthRange::LaneLengthRange(LaneLengthRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_length_(readLength(context, in)),
        m_range_(readRange(context, in, allocator))
{
}

LaneLengthRange::LaneLengthRange(const LaneLengthRange& other) :
        m_length_(other.m_length_),
        m_range_(other.m_range_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneLengthRange& LaneLengthRange::operator=(const LaneLengthRange& other)
{
    m_length_ = other.m_length_;
    m_range_ = other.m_range_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneLengthRange::LaneLengthRange(LaneLengthRange&& other) :
        m_length_(::std::move(other.m_length_)),
        m_range_(::std::move(other.m_range_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneLengthRange& LaneLengthRange::operator=(LaneLengthRange&& other)
{
    m_length_ = ::std::move(other.m_length_);
    m_range_ = ::std::move(other.m_range_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneLengthRange::LaneLengthRange(::zserio::PropagateAllocatorT,
        const LaneLengthRange& other, const allocator_type& allocator) :
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator)),
        m_range_(::zserio::allocatorPropagatingCopy(other.m_range_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneLengthRange::initializeChildren()
{
    m_range_.initialize(static_cast<uint32_t>(getLength()));

    m_areChildrenInitialized = true;
}

::nds::lane::reference::types::LaneLength LaneLengthRange::getLength() const
{
    return m_length_;
}

void LaneLengthRange::setLength(::nds::lane::reference::types::LaneLength length_)
{
    m_length_ = length_;
}

::nds::core::types::Range& LaneLengthRange::getRange()
{
    return m_range_;
}

const ::nds::core::types::Range& LaneLengthRange::getRange() const
{
    return m_range_;
}

void LaneLengthRange::setRange(const ::nds::core::types::Range& range_)
{
    m_range_ = range_;
}

void LaneLengthRange::setRange(::nds::core::types::Range&& range_)
{
    m_range_ = ::std::move(range_);
}

void LaneLengthRange::initPackingContext(LaneLengthRange::ZserioPackingContext& context) const
{
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(m_length_);
    m_range_.initPackingContext(context.getRange());
}

size_t LaneLengthRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += m_range_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLengthRange::bitSizeOf(LaneLengthRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(m_length_);
    endBitPosition += m_range_.bitSizeOf(context.getRange(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLengthRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition = m_range_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneLengthRange::initializeOffsets(LaneLengthRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(m_length_);
    endBitPosition = m_range_.initializeOffsets(context.getRange(), endBitPosition);

    return endBitPosition;
}

bool LaneLengthRange::operator==(const LaneLengthRange& other) const
{
    if (this != &other)
    {
        return
                (m_length_ == other.m_length_) &&
                (m_range_ == other.m_range_);
    }

    return true;
}

uint32_t LaneLengthRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_length_);
    result = ::zserio::calcHashCode(result, m_range_);

    return result;
}

void LaneLengthRange::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_length_);

    // check parameters
    if (m_range_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field LaneLengthRange.range: ") <<
                m_range_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_range_.write(out);
}

void LaneLengthRange::write(LaneLengthRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(out, m_length_);

    // check parameters
    if (m_range_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field LaneLengthRange.range: ") <<
                m_range_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_range_.write(context.getRange(), out);
}

::nds::lane::reference::types::LaneLength LaneLengthRange::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::lane::reference::types::LaneLength>(in.readVarUInt32());
}

::nds::lane::reference::types::LaneLength LaneLengthRange::readLength(LaneLengthRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::lane::reference::types::LaneLength>>(in);
}
::nds::core::types::Range LaneLengthRange::readRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::Range(in, static_cast<uint32_t>(getLength()), allocator);
}

::nds::core::types::Range LaneLengthRange::readRange(LaneLengthRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::Range(context.getRange(), in, static_cast<uint32_t>(getLength()), allocator);
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LanePositionChoice.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LanePositionChoice::LanePositionChoice(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

LanePositionChoice::LanePositionChoice(::zserio::BitStreamReader& in,
        ::nds::lane::reference::types::LaneValidityType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

LanePositionChoice::LanePositionChoice(LanePositionChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::lane::reference::types::LaneValidityType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

LanePositionChoice::LanePositionChoice(const LanePositionChoice& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

LanePositionChoice& LanePositionChoice::operator=(const LanePositionChoice& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

LanePositionChoice::LanePositionChoice(LanePositionChoice&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

LanePositionChoice& LanePositionChoice::operator=(LanePositionChoice&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

LanePositionChoice::LanePositionChoice(::zserio::PropagateAllocatorT,
        const LanePositionChoice& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void LanePositionChoice::initialize(
        ::nds::lane::reference::types::LaneValidityType type_)
{
    m_type_ = type_;
    m_isInitialized = true;

    initializeChildren();
}

bool LanePositionChoice::isInitialized() const
{
    return m_isInitialized;
}

void LanePositionChoice::initializeChildren()
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>().initializeChildren();
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>().initializeChildren();
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().initialize(static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0));
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }
}

::nds::lane::reference::types::LaneValidityType LanePositionChoice::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'LanePositionChoice' is not initialized!");

    return m_type_;
}

::nds::lane::reference::types::LaneValidityPosition& LanePositionChoice::getValidityPosition()
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>();
}

const ::nds::lane::reference::types::LaneValidityPosition& LanePositionChoice::getValidityPosition() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>();
}

void LanePositionChoice::setValidityPosition(const ::nds::lane::reference::types::LaneValidityPosition& validityPosition_)
{
    m_objectChoice = validityPosition_;
}

void LanePositionChoice::setValidityPosition(::nds::lane::reference::types::LaneValidityPosition&& validityPosition_)
{
    m_objectChoice = ::std::move(validityPosition_);
}

::nds::lane::reference::types::LaneLengthPosition& LanePositionChoice::getLengthPosition()
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>();
}

const ::nds::lane::reference::types::LaneLengthPosition& LanePositionChoice::getLengthPosition() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>();
}

void LanePositionChoice::setLengthPosition(const ::nds::lane::reference::types::LaneLengthPosition& lengthPosition_)
{
    m_objectChoice = lengthPosition_;
}

void LanePositionChoice::setLengthPosition(::nds::lane::reference::types::LaneLengthPosition&& lengthPosition_)
{
    m_objectChoice = ::std::move(lengthPosition_);
}

::nds::lane::reference::types::LaneGeometryPosition LanePositionChoice::getGeometryPosition() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>();
}

void LanePositionChoice::setGeometryPosition(::nds::lane::reference::types::LaneGeometryPosition geometryPosition_)
{
    m_objectChoice = geometryPosition_;
}

::nds::lane::reference::types::LaneGeometryPositionOffset& LanePositionChoice::getGeometryPositionOffset()
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>();
}

const ::nds::lane::reference::types::LaneGeometryPositionOffset& LanePositionChoice::getGeometryPositionOffset() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>();
}

void LanePositionChoice::setGeometryPositionOffset(const ::nds::lane::reference::types::LaneGeometryPositionOffset& geometryPositionOffset_)
{
    m_objectChoice = geometryPositionOffset_;
}

void LanePositionChoice::setGeometryPositionOffset(::nds::lane::reference::types::LaneGeometryPositionOffset&& geometryPositionOffset_)
{
    m_objectChoice = ::std::move(geometryPositionOffset_);
}

::nds::lane::reference::types::LanePercentagePosition& LanePositionChoice::getPercentagePosition()
{
    return m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>();
}

const ::nds::lane::reference::types::LanePercentagePosition& LanePositionChoice::getPercentagePosition() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>();
}

void LanePositionChoice::setPercentagePosition(const ::nds::lane::reference::types::LanePercentagePosition& percentagePosition_)
{
    m_objectChoice = percentagePosition_;
}

void LanePositionChoice::setPercentagePosition(::nds::lane::reference::types::LanePercentagePosition&& percentagePosition_)
{
    m_objectChoice = ::std::move(percentagePosition_);
}

LanePositionChoice::ChoiceTag LanePositionChoice::choiceTag() const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return UNDEFINED_CHOICE;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return UNDEFINED_CHOICE;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return CHOICE_validityPosition;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return CHOICE_lengthPosition;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return CHOICE_geometryPosition;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return CHOICE_geometryPositionOffset;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return CHOICE_percentagePosition;
    default:
        return UNDEFINED_CHOICE;
    }
}

void LanePositionChoice::initPackingContext(LanePositionChoice::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>().initPackingContext(context.getValidityPosition());
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>().initPackingContext(context.getLengthPosition());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        context.getGeometryPosition().init<::zserio::VarSizeArrayTraits>(m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().initPackingContext(context.getGeometryPositionOffset());
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>().initPackingContext(context.getPercentagePosition());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }
}

size_t LanePositionChoice::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        endBitPosition += ::zserio::bitSizeOfVarSize(m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t LanePositionChoice::bitSizeOf(LanePositionChoice::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>().bitSizeOf(context.getValidityPosition(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>().bitSizeOf(context.getLengthPosition(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        endBitPosition += context.getGeometryPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().bitSizeOf(context.getGeometryPositionOffset(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>().bitSizeOf(context.getPercentagePosition(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t LanePositionChoice::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        endBitPosition += ::zserio::bitSizeOfVarSize(m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }

    return endBitPosition;
}

size_t LanePositionChoice::initializeOffsets(LanePositionChoice::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>().initializeOffsets(context.getValidityPosition(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>().initializeOffsets(context.getLengthPosition(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        endBitPosition += context.getGeometryPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().initializeOffsets(context.getGeometryPositionOffset(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>().initializeOffsets(context.getPercentagePosition(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }

    return endBitPosition;
}

bool LanePositionChoice::operator==(const LanePositionChoice& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return true; // empty
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return true; // empty
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>() == other.m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>());
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>() == other.m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>());
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>() == other.m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>());
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>() == other.m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>());
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>() == other.m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }
}

uint32_t LanePositionChoice::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::lane::reference::types::LaneValidityType::NONE:
            // empty
            break;
        case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
            // empty
            break;
        case ::nds::lane::reference::types::LaneValidityType::POSITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>());
            break;
        case ::nds::lane::reference::types::LaneValidityType::LENGTH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>());
            break;
        case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>());
            break;
        case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>());
            break;
        case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>());
            break;
        default:
            break;
        }
    }

    return result;
}

void LanePositionChoice::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>().write(out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>().write(out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        out.writeVarSize(m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LanePositionChoice.geometryPositionOffset: ") <<
                    m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        if (m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LanePositionChoice.geometryPositionOffset: ") <<
                    m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().write(out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }
}

void LanePositionChoice::write(LanePositionChoice::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        m_objectChoice.get<::nds::lane::reference::types::LaneValidityPosition>().write(context.getValidityPosition(), out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        m_objectChoice.get<::nds::lane::reference::types::LaneLengthPosition>().write(context.getLengthPosition(), out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        context.getGeometryPosition().write<::zserio::VarSizeArrayTraits>(out, m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPosition>());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LanePositionChoice.geometryPositionOffset: ") <<
                    m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        if (m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LanePositionChoice.geometryPositionOffset: ") <<
                    m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryPositionOffset>().write(context.getGeometryPositionOffset(), out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::lane::reference::types::LanePercentagePosition>().write(context.getPercentagePosition(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }
}

::zserio::AnyHolder<> LanePositionChoice::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneValidityPosition(in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneLengthPosition(in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(static_cast<::nds::lane::reference::types::LaneGeometryPosition>(in.readVarSize()), allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneGeometryPositionOffset(in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LanePercentagePosition(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }
}

::zserio::AnyHolder<> LanePositionChoice::readObject(LanePositionChoice::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneValidityPosition(context.getValidityPosition(), in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneLengthPosition(context.getLengthPosition(), in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(context.getGeometryPosition().read<::zserio::VarSizeArrayTraits>(in), allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneGeometryPositionOffset(context.getGeometryPositionOffset(), in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LanePercentagePosition(context.getPercentagePosition(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }
}

::zserio::AnyHolder<> LanePositionChoice::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LaneValidityPosition>(m_objectChoice, allocator);
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LaneLengthPosition>(m_objectChoice, allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LaneGeometryPosition>(m_objectChoice, allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LaneGeometryPositionOffset>(m_objectChoice, allocator);
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LanePercentagePosition>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice LanePositionChoice!");
    }
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/lane/reference/types/LaneRangeChoice.h>

namespace nds
{
namespace lane
{
namespace reference
{
namespace types
{

LaneRangeChoice::LaneRangeChoice(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

LaneRangeChoice::LaneRangeChoice(::zserio::BitStreamReader& in,
        ::nds::lane::reference::types::LaneValidityType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

LaneRangeChoice::LaneRangeChoice(LaneRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::lane::reference::types::LaneValidityType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

LaneRangeChoice::LaneRangeChoice(const LaneRangeChoice& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

LaneRangeChoice& LaneRangeChoice::operator=(const LaneRangeChoice& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

LaneRangeChoice::LaneRangeChoice(LaneRangeChoice&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

LaneRangeChoice& LaneRangeChoice::operator=(LaneRangeChoice&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

LaneRangeChoice::LaneRangeChoice(::zserio::PropagateAllocatorT,
        const LaneRangeChoice& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void LaneRangeChoice::initialize(
        ::nds::lane::reference::types::LaneValidityType type_)
{
    m_type_ = type_;
    m_isInitialized = true;

    initializeChildren();
}

bool LaneRangeChoice::isInitialized() const
{
    return m_isInitialized;
}

void LaneRangeChoice::initializeChildren()
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>().initializeChildren();
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>().initializeChildren();
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().initialize(static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0));
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }
}

::nds::lane::reference::types::LaneValidityType LaneRangeChoice::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'LaneRangeChoice' is not initialized!");

    return m_type_;
}

::nds::lane::reference::types::LaneValidityRange& LaneRangeChoice::getValidityRange()
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>();
}

const ::nds::lane::reference::types::LaneValidityRange& LaneRangeChoice::getValidityRange() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>();
}

void LaneRangeChoice::setValidityRange(const ::nds::lane::reference::types::LaneValidityRange& validityRange_)
{
    m_objectChoice = validityRange_;
}

void LaneRangeChoice::setValidityRange(::nds::lane::reference::types::LaneValidityRange&& validityRange_)
{
    m_objectChoice = ::std::move(validityRange_);
}

::nds::lane::reference::types::LaneLengthRange& LaneRangeChoice::getLengthRange()
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>();
}

const ::nds::lane::reference::types::LaneLengthRange& LaneRangeChoice::getLengthRange() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>();
}

void LaneRangeChoice::setLengthRange(const ::nds::lane::reference::types::LaneLengthRange& lengthRange_)
{
    m_objectChoice = lengthRange_;
}

void LaneRangeChoice::setLengthRange(::nds::lane::reference::types::LaneLengthRange&& lengthRange_)
{
    m_objectChoice = ::std::move(lengthRange_);
}

::nds::lane::reference::types::LaneGeometryRange& LaneRangeChoice::getGeometryRange()
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>();
}

const ::nds::lane::reference::types::LaneGeometryRange& LaneRangeChoice::getGeometryRange() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>();
}

void LaneRangeChoice::setGeometryRange(const ::nds::lane::reference::types::LaneGeometryRange& geometryRange_)
{
    m_objectChoice = geometryRange_;
}

void LaneRangeChoice::setGeometryRange(::nds::lane::reference::types::LaneGeometryRange&& geometryRange_)
{
    m_objectChoice = ::std::move(geometryRange_);
}

::nds::lane::reference::types::LaneGeometryRangeOffset& LaneRangeChoice::getGeometryRangeOffset()
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>();
}

const ::nds::lane::reference::types::LaneGeometryRangeOffset& LaneRangeChoice::getGeometryRangeOffset() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>();
}

void LaneRangeChoice::setGeometryRangeOffset(const ::nds::lane::reference::types::LaneGeometryRangeOffset& geometryRangeOffset_)
{
    m_objectChoice = geometryRangeOffset_;
}

void LaneRangeChoice::setGeometryRangeOffset(::nds::lane::reference::types::LaneGeometryRangeOffset&& geometryRangeOffset_)
{
    m_objectChoice = ::std::move(geometryRangeOffset_);
}

::nds::lane::reference::types::LanePercentageRange& LaneRangeChoice::getPercentageRange()
{
    return m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>();
}

const ::nds::lane::reference::types::LanePercentageRange& LaneRangeChoice::getPercentageRange() const
{
    return m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>();
}

void LaneRangeChoice::setPercentageRange(const ::nds::lane::reference::types::LanePercentageRange& percentageRange_)
{
    m_objectChoice = percentageRange_;
}

void LaneRangeChoice::setPercentageRange(::nds::lane::reference::types::LanePercentageRange&& percentageRange_)
{
    m_objectChoice = ::std::move(percentageRange_);
}

LaneRangeChoice::ChoiceTag LaneRangeChoice::choiceTag() const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return UNDEFINED_CHOICE;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return UNDEFINED_CHOICE;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return CHOICE_validityRange;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return CHOICE_lengthRange;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return CHOICE_geometryRange;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return CHOICE_geometryRangeOffset;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return CHOICE_percentageRange;
    default:
        return UNDEFINED_CHOICE;
    }
}

void LaneRangeChoice::initPackingContext(LaneRangeChoice::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>().initPackingContext(context.getValidityRange());
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>().initPackingContext(context.getLengthRange());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>().initPackingContext(context.getGeometryRange());
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().initPackingContext(context.getGeometryRangeOffset());
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>().initPackingContext(context.getPercentageRange());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }
}

size_t LaneRangeChoice::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().bitSizeOf(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t LaneRangeChoice::bitSizeOf(LaneRangeChoice::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>().bitSizeOf(context.getValidityRange(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>().bitSizeOf(context.getLengthRange(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>().bitSizeOf(context.getGeometryRange(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().bitSizeOf(context.getGeometryRangeOffset(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>().bitSizeOf(context.getPercentageRange(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t LaneRangeChoice::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().initializeOffsets(endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }

    return endBitPosition;
}

size_t LaneRangeChoice::initializeOffsets(LaneRangeChoice::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>().initializeOffsets(context.getValidityRange(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>().initializeOffsets(context.getLengthRange(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>().initializeOffsets(context.getGeometryRange(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().initializeOffsets(context.getGeometryRangeOffset(), endBitPosition);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>().initializeOffsets(context.getPercentageRange(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }

    return endBitPosition;
}

bool LaneRangeChoice::operator==(const LaneRangeChoice& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return true; // empty
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return true; // empty
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>() == other.m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>());
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>() == other.m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>());
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>() == other.m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>());
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>() == other.m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>());
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>() == other.m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }
}

uint32_t LaneRangeChoice::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::lane::reference::types::LaneValidityType::NONE:
            // empty
            break;
        case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
            // empty
            break;
        case ::nds::lane::reference::types::LaneValidityType::POSITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>());
            break;
        case ::nds::lane::reference::types::LaneValidityType::LENGTH:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>());
            break;
        case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>());
            break;
        case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>());
            break;
        case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>());
            break;
        default:
            break;
        }
    }

    return result;
}

void LaneRangeChoice::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>().write(out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>().write(out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>().write(out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LaneRangeChoice.geometryRangeOffset: ") <<
                    m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        if (m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LaneRangeChoice.geometryRangeOffset: ") <<
                    m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().write(out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }
}

void LaneRangeChoice::write(LaneRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        // empty
        break;
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        m_objectChoice.get<::nds::lane::reference::types::LaneValidityRange>().write(context.getValidityRange(), out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        m_objectChoice.get<::nds::lane::reference::types::LaneLengthRange>().write(context.getLengthRange(), out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRange>().write(context.getGeometryRange(), out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LaneRangeChoice.geometryRangeOffset: ") <<
                    m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        if (m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LaneRangeChoice.geometryRangeOffset: ") <<
                    m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_objectChoice.get<::nds::lane::reference::types::LaneGeometryRangeOffset>().write(context.getGeometryRangeOffset(), out);
        break;
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::lane::reference::types::LanePercentageRange>().write(context.getPercentageRange(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }
}

::zserio::AnyHolder<> LaneRangeChoice::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneValidityRange(in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneLengthRange(in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneGeometryRange(in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneGeometryRangeOffset(in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LanePercentageRange(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }
}

::zserio::AnyHolder<> LaneRangeChoice::readObject(LaneRangeChoice::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneValidityRange(context.getValidityRange(), in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneLengthRange(context.getLengthRange(), in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneGeometryRange(context.getGeometryRange(), in, allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LaneGeometryRangeOffset(context.getGeometryRangeOffset(), in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator), allocator);
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::lane::reference::types::LanePercentageRange(context.getPercentageRange(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }
}

::zserio::AnyHolder<> LaneRangeChoice::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::lane::reference::types::LaneValidityType::NONE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::lane::reference::types::LaneValidityType::POSITION:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LaneValidityRange>(m_objectChoice, allocator);
    case ::nds::lane::reference::types::LaneValidityType::LENGTH:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LaneLengthRange>(m_objectChoice, allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LaneGeometryRange>(m_objectChoice, allocator);
    case ::nds::lane::reference::types::LaneValidityType::GEOMETRY_OFFSET:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LaneGeometryRangeOffset>(m_objectChoice, allocator);
    case ::nds::lane::reference::types::LaneValidityType::PERCENTAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::lane::reference::types::LanePercentageRange>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice LaneRangeChoice!");
    }
}

} // namespace types
} // namespace reference
} // namespace lane
} // namespace nds
