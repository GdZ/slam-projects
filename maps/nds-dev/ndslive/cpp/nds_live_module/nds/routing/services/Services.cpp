/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/services/RoutingServiceRequest.h>

namespace nds
{
namespace routing
{
namespace services
{

RoutingServiceRequest::RoutingServiceRequest(const allocator_type& allocator) noexcept :
        m_optimizeViaPoints_(bool()),
        m_language_(::nds::core::types::LanguageCode()),
        m_type_(::nds::routing::types::RouteType()),
        m_origin_(allocator),
        m_destination_(allocator),
        m_viaPoints_(::zserio::NullOpt),
        m_routeOptions_(::zserio::NullOpt),
        m_vehicleDetails_(::zserio::NullOpt),
        m_vehiclePose_(::zserio::NullOpt),
        m_driverProfile_(::zserio::NullOpt),
        m_numAlternativeRoutes_(uint8_t()),
        m_departureTime_(::zserio::NullOpt),
        m_arrivalTime_(::zserio::NullOpt),
        m_coveredPath_(::zserio::NullOpt),
        m_customRequestData_(allocator)
{
}

RoutingServiceRequest::RoutingServiceRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_optimizeViaPoints_(readOptimizeViaPoints(in)),
        m_language_(readLanguage(in)),
        m_type_(readType(in)),
        m_origin_(readOrigin(in, allocator)),
        m_destination_(readDestination(in, allocator)),
        m_viaPoints_(readViaPoints(in, allocator)),
        m_routeOptions_(readRouteOptions(in, allocator)),
        m_vehicleDetails_(readVehicleDetails(in, allocator)),
        m_vehiclePose_(readVehiclePose(in, allocator)),
        m_driverProfile_(readDriverProfile(in, allocator)),
        m_numAlternativeRoutes_(readNumAlternativeRoutes(in)),
        m_departureTime_(readDepartureTime(in, allocator)),
        m_arrivalTime_(readArrivalTime(in, allocator)),
        m_coveredPath_(readCoveredPath(in, allocator)),
        m_customRequestData_(readCustomRequestData(in, allocator))
{
}

RoutingServiceRequest::RoutingServiceRequest(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_optimizeViaPoints_(readOptimizeViaPoints(in)),
        m_language_(readLanguage(context, in)),
        m_type_(readType(context, in)),
        m_origin_(readOrigin(context, in, allocator)),
        m_destination_(readDestination(context, in, allocator)),
        m_viaPoints_(readViaPoints(context, in, allocator)),
        m_routeOptions_(readRouteOptions(context, in, allocator)),
        m_vehicleDetails_(readVehicleDetails(context, in, allocator)),
        m_vehiclePose_(readVehiclePose(context, in, allocator)),
        m_driverProfile_(readDriverProfile(context, in, allocator)),
        m_numAlternativeRoutes_(readNumAlternativeRoutes(context, in)),
        m_departureTime_(readDepartureTime(context, in, allocator)),
        m_arrivalTime_(readArrivalTime(context, in, allocator)),
        m_coveredPath_(readCoveredPath(context, in, allocator)),
        m_customRequestData_(readCustomRequestData(in, allocator))
{
}

RoutingServiceRequest::RoutingServiceRequest(::zserio::PropagateAllocatorT,
        const RoutingServiceRequest& other, const allocator_type& allocator) :
        m_optimizeViaPoints_(::zserio::allocatorPropagatingCopy(other.m_optimizeViaPoints_, allocator)),
        m_language_(::zserio::allocatorPropagatingCopy(other.m_language_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_origin_(::zserio::allocatorPropagatingCopy(other.m_origin_, allocator)),
        m_destination_(::zserio::allocatorPropagatingCopy(other.m_destination_, allocator)),
        m_viaPoints_(::zserio::allocatorPropagatingCopy(other.m_viaPoints_, allocator)),
        m_routeOptions_(::zserio::allocatorPropagatingCopy(other.m_routeOptions_, allocator)),
        m_vehicleDetails_(::zserio::allocatorPropagatingCopy(other.m_vehicleDetails_, allocator)),
        m_vehiclePose_(::zserio::allocatorPropagatingCopy(other.m_vehiclePose_, allocator)),
        m_driverProfile_(::zserio::allocatorPropagatingCopy(other.m_driverProfile_, allocator)),
        m_numAlternativeRoutes_(::zserio::allocatorPropagatingCopy(other.m_numAlternativeRoutes_, allocator)),
        m_departureTime_(::zserio::allocatorPropagatingCopy(other.m_departureTime_, allocator)),
        m_arrivalTime_(::zserio::allocatorPropagatingCopy(other.m_arrivalTime_, allocator)),
        m_coveredPath_(::zserio::allocatorPropagatingCopy(other.m_coveredPath_, allocator)),
        m_customRequestData_(::zserio::allocatorPropagatingCopy(other.m_customRequestData_, allocator))
{
}

void RoutingServiceRequest::initializeChildren()
{
    m_origin_.initializeChildren();
    m_destination_.initializeChildren();
    if (isViaPointsSet())
        m_viaPoints_.value().initializeElements(*this);
    if (isVehiclePoseSet())
        m_vehiclePose_.value().initializeChildren();
    if (isDriverProfileSet())
        m_driverProfile_.value().initializeChildren();
    if (isCoveredPathSet())
        m_coveredPath_.value().initializeChildren();
}

bool RoutingServiceRequest::getOptimizeViaPoints() const
{
    return m_optimizeViaPoints_;
}

void RoutingServiceRequest::setOptimizeViaPoints(bool optimizeViaPoints_)
{
    m_optimizeViaPoints_ = optimizeViaPoints_;
}

::nds::core::types::LanguageCode RoutingServiceRequest::getLanguage() const
{
    return m_language_;
}

void RoutingServiceRequest::setLanguage(::nds::core::types::LanguageCode language_)
{
    m_language_ = language_;
}

::nds::routing::types::RouteType RoutingServiceRequest::getType() const
{
    return m_type_;
}

void RoutingServiceRequest::setType(::nds::routing::types::RouteType type_)
{
    m_type_ = type_;
}

::nds::routing::route::Waypoint& RoutingServiceRequest::getOrigin()
{
    return m_origin_;
}

const ::nds::routing::route::Waypoint& RoutingServiceRequest::getOrigin() const
{
    return m_origin_;
}

void RoutingServiceRequest::setOrigin(const ::nds::routing::route::Waypoint& origin_)
{
    m_origin_ = origin_;
}

void RoutingServiceRequest::setOrigin(::nds::routing::route::Waypoint&& origin_)
{
    m_origin_ = ::std::move(origin_);
}

::nds::routing::route::Waypoint& RoutingServiceRequest::getDestination()
{
    return m_destination_;
}

const ::nds::routing::route::Waypoint& RoutingServiceRequest::getDestination() const
{
    return m_destination_;
}

void RoutingServiceRequest::setDestination(const ::nds::routing::route::Waypoint& destination_)
{
    m_destination_ = destination_;
}

void RoutingServiceRequest::setDestination(::nds::routing::route::Waypoint&& destination_)
{
    m_destination_ = ::std::move(destination_);
}

::zserio::vector<::nds::routing::route::Waypoint>& RoutingServiceRequest::getViaPoints()
{
    return m_viaPoints_.value().getRawArray();
}

const ::zserio::vector<::nds::routing::route::Waypoint>& RoutingServiceRequest::getViaPoints() const
{
    return m_viaPoints_.value().getRawArray();
}

void RoutingServiceRequest::setViaPoints(const ::zserio::vector<::nds::routing::route::Waypoint>& viaPoints_)
{
    m_viaPoints_ = ZserioArrayType_viaPoints(viaPoints_);
}

void RoutingServiceRequest::setViaPoints(::zserio::vector<::nds::routing::route::Waypoint>&& viaPoints_)
{
    m_viaPoints_ = ZserioArrayType_viaPoints(std::move(viaPoints_));
}

bool RoutingServiceRequest::isViaPointsUsed() const
{
    return (isViaPointsSet());
}

bool RoutingServiceRequest::isViaPointsSet() const
{
    return m_viaPoints_.hasValue();
}

void RoutingServiceRequest::resetViaPoints()
{
    m_viaPoints_.reset();
}

::zserio::vector<::nds::routing::route::RouteOptions>& RoutingServiceRequest::getRouteOptions()
{
    return m_routeOptions_.value().getRawArray();
}

const ::zserio::vector<::nds::routing::route::RouteOptions>& RoutingServiceRequest::getRouteOptions() const
{
    return m_routeOptions_.value().getRawArray();
}

void RoutingServiceRequest::setRouteOptions(const ::zserio::vector<::nds::routing::route::RouteOptions>& routeOptions_)
{
    m_routeOptions_ = ZserioArrayType_routeOptions(routeOptions_);
}

void RoutingServiceRequest::setRouteOptions(::zserio::vector<::nds::routing::route::RouteOptions>&& routeOptions_)
{
    m_routeOptions_ = ZserioArrayType_routeOptions(std::move(routeOptions_));
}

bool RoutingServiceRequest::isRouteOptionsUsed() const
{
    return (isRouteOptionsSet());
}

bool RoutingServiceRequest::isRouteOptionsSet() const
{
    return m_routeOptions_.hasValue();
}

void RoutingServiceRequest::resetRouteOptions()
{
    m_routeOptions_.reset();
}

::nds::core::vehicle::VehicleDetails& RoutingServiceRequest::getVehicleDetails()
{
    return m_vehicleDetails_.value();
}

const ::nds::core::vehicle::VehicleDetails& RoutingServiceRequest::getVehicleDetails() const
{
    return m_vehicleDetails_.value();
}

void RoutingServiceRequest::setVehicleDetails(const ::nds::core::vehicle::VehicleDetails& vehicleDetails_)
{
    m_vehicleDetails_ = vehicleDetails_;
}

void RoutingServiceRequest::setVehicleDetails(::nds::core::vehicle::VehicleDetails&& vehicleDetails_)
{
    m_vehicleDetails_ = ::std::move(vehicleDetails_);
}

bool RoutingServiceRequest::isVehicleDetailsUsed() const
{
    return (isVehicleDetailsSet());
}

bool RoutingServiceRequest::isVehicleDetailsSet() const
{
    return m_vehicleDetails_.hasValue();
}

void RoutingServiceRequest::resetVehicleDetails()
{
    m_vehicleDetails_.reset();
}

::nds::core::vehicle::VehiclePose& RoutingServiceRequest::getVehiclePose()
{
    return m_vehiclePose_.value();
}

const ::nds::core::vehicle::VehiclePose& RoutingServiceRequest::getVehiclePose() const
{
    return m_vehiclePose_.value();
}

void RoutingServiceRequest::setVehiclePose(const ::nds::core::vehicle::VehiclePose& vehiclePose_)
{
    m_vehiclePose_ = vehiclePose_;
}

void RoutingServiceRequest::setVehiclePose(::nds::core::vehicle::VehiclePose&& vehiclePose_)
{
    m_vehiclePose_ = ::std::move(vehiclePose_);
}

bool RoutingServiceRequest::isVehiclePoseUsed() const
{
    return (isVehiclePoseSet());
}

bool RoutingServiceRequest::isVehiclePoseSet() const
{
    return m_vehiclePose_.hasValue();
}

void RoutingServiceRequest::resetVehiclePose()
{
    m_vehiclePose_.reset();
}

::nds::routing::types::DriverProfile& RoutingServiceRequest::getDriverProfile()
{
    return m_driverProfile_.value();
}

const ::nds::routing::types::DriverProfile& RoutingServiceRequest::getDriverProfile() const
{
    return m_driverProfile_.value();
}

void RoutingServiceRequest::setDriverProfile(const ::nds::routing::types::DriverProfile& driverProfile_)
{
    m_driverProfile_ = driverProfile_;
}

void RoutingServiceRequest::setDriverProfile(::nds::routing::types::DriverProfile&& driverProfile_)
{
    m_driverProfile_ = ::std::move(driverProfile_);
}

bool RoutingServiceRequest::isDriverProfileUsed() const
{
    return (isDriverProfileSet());
}

bool RoutingServiceRequest::isDriverProfileSet() const
{
    return m_driverProfile_.hasValue();
}

void RoutingServiceRequest::resetDriverProfile()
{
    m_driverProfile_.reset();
}

uint8_t RoutingServiceRequest::getNumAlternativeRoutes() const
{
    return m_numAlternativeRoutes_;
}

void RoutingServiceRequest::setNumAlternativeRoutes(uint8_t numAlternativeRoutes_)
{
    m_numAlternativeRoutes_ = numAlternativeRoutes_;
}

::nds::core::types::TimeWithZone& RoutingServiceRequest::getDepartureTime()
{
    return m_departureTime_.value();
}

const ::nds::core::types::TimeWithZone& RoutingServiceRequest::getDepartureTime() const
{
    return m_departureTime_.value();
}

void RoutingServiceRequest::setDepartureTime(const ::nds::core::types::TimeWithZone& departureTime_)
{
    m_departureTime_ = departureTime_;
}

void RoutingServiceRequest::setDepartureTime(::nds::core::types::TimeWithZone&& departureTime_)
{
    m_departureTime_ = ::std::move(departureTime_);
}

bool RoutingServiceRequest::isDepartureTimeUsed() const
{
    return (isDepartureTimeSet());
}

bool RoutingServiceRequest::isDepartureTimeSet() const
{
    return m_departureTime_.hasValue();
}

void RoutingServiceRequest::resetDepartureTime()
{
    m_departureTime_.reset();
}

::nds::core::types::TimeWithZone& RoutingServiceRequest::getArrivalTime()
{
    return m_arrivalTime_.value();
}

const ::nds::core::types::TimeWithZone& RoutingServiceRequest::getArrivalTime() const
{
    return m_arrivalTime_.value();
}

void RoutingServiceRequest::setArrivalTime(const ::nds::core::types::TimeWithZone& arrivalTime_)
{
    m_arrivalTime_ = arrivalTime_;
}

void RoutingServiceRequest::setArrivalTime(::nds::core::types::TimeWithZone&& arrivalTime_)
{
    m_arrivalTime_ = ::std::move(arrivalTime_);
}

bool RoutingServiceRequest::isArrivalTimeUsed() const
{
    return (isArrivalTimeSet());
}

bool RoutingServiceRequest::isArrivalTimeSet() const
{
    return m_arrivalTime_.hasValue();
}

void RoutingServiceRequest::resetArrivalTime()
{
    m_arrivalTime_.reset();
}

::nds::core::location::RoadLocationPath& RoutingServiceRequest::getCoveredPath()
{
    return m_coveredPath_.value();
}

const ::nds::core::location::RoadLocationPath& RoutingServiceRequest::getCoveredPath() const
{
    return m_coveredPath_.value();
}

void RoutingServiceRequest::setCoveredPath(const ::nds::core::location::RoadLocationPath& coveredPath_)
{
    m_coveredPath_ = coveredPath_;
}

void RoutingServiceRequest::setCoveredPath(::nds::core::location::RoadLocationPath&& coveredPath_)
{
    m_coveredPath_ = ::std::move(coveredPath_);
}

bool RoutingServiceRequest::isCoveredPathUsed() const
{
    return (isCoveredPathSet());
}

bool RoutingServiceRequest::isCoveredPathSet() const
{
    return m_coveredPath_.hasValue();
}

void RoutingServiceRequest::resetCoveredPath()
{
    m_coveredPath_.reset();
}

::zserio::BitBuffer& RoutingServiceRequest::getCustomRequestData()
{
    return m_customRequestData_;
}

const ::zserio::BitBuffer& RoutingServiceRequest::getCustomRequestData() const
{
    return m_customRequestData_;
}

void RoutingServiceRequest::setCustomRequestData(const ::zserio::BitBuffer& customRequestData_)
{
    m_customRequestData_ = customRequestData_;
}

void RoutingServiceRequest::setCustomRequestData(::zserio::BitBuffer&& customRequestData_)
{
    m_customRequestData_ = ::std::move(customRequestData_);
}

void RoutingServiceRequest::initPackingContext(RoutingServiceRequest::ZserioPackingContext& context) const
{
    context.getLanguage().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_language_);
    ::zserio::initPackingContext(context.getType(), m_type_);
    m_origin_.initPackingContext(context.getOrigin());
    m_destination_.initPackingContext(context.getDestination());
    if (isVehicleDetailsSet())
    {
        m_vehicleDetails_.value().initPackingContext(context.getVehicleDetails());
    }
    if (isVehiclePoseSet())
    {
        m_vehiclePose_.value().initPackingContext(context.getVehiclePose());
    }
    if (isDriverProfileSet())
    {
        m_driverProfile_.value().initPackingContext(context.getDriverProfile());
    }
    context.getNumAlternativeRoutes().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numAlternativeRoutes_);
    if (isDepartureTimeSet())
    {
        m_departureTime_.value().initPackingContext(context.getDepartureTime());
    }
    if (isArrivalTimeSet())
    {
        m_arrivalTime_.value().initPackingContext(context.getArrivalTime());
    }
    if (isCoveredPathSet())
    {
        m_coveredPath_.value().initPackingContext(context.getCoveredPath());
    }
}

size_t RoutingServiceRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_language_);
    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += m_origin_.bitSizeOf(endBitPosition);
    endBitPosition += m_destination_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isViaPointsSet())
    {
        endBitPosition += m_viaPoints_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isRouteOptionsSet())
    {
        endBitPosition += m_routeOptions_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleDetailsSet())
    {
        endBitPosition += m_vehicleDetails_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isVehiclePoseSet())
    {
        endBitPosition += m_vehiclePose_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isDriverProfileSet())
    {
        endBitPosition += m_driverProfile_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition += m_departureTime_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition += m_arrivalTime_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isCoveredPathSet())
    {
        endBitPosition += m_coveredPath_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customRequestData_);

    return endBitPosition - bitPosition;
}

size_t RoutingServiceRequest::bitSizeOf(RoutingServiceRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += context.getLanguage().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_language_);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += m_origin_.bitSizeOf(context.getOrigin(), endBitPosition);
    endBitPosition += m_destination_.bitSizeOf(context.getDestination(), endBitPosition);
    endBitPosition += 1;
    if (isViaPointsSet())
    {
        endBitPosition += m_viaPoints_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isRouteOptionsSet())
    {
        endBitPosition += m_routeOptions_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleDetailsSet())
    {
        endBitPosition += m_vehicleDetails_.value().bitSizeOf(context.getVehicleDetails(), endBitPosition);
    }
    endBitPosition += 1;
    if (isVehiclePoseSet())
    {
        endBitPosition += m_vehiclePose_.value().bitSizeOf(context.getVehiclePose(), endBitPosition);
    }
    endBitPosition += 1;
    if (isDriverProfileSet())
    {
        endBitPosition += m_driverProfile_.value().bitSizeOf(context.getDriverProfile(), endBitPosition);
    }
    endBitPosition += context.getNumAlternativeRoutes().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numAlternativeRoutes_);
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition += m_departureTime_.value().bitSizeOf(context.getDepartureTime(), endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition += m_arrivalTime_.value().bitSizeOf(context.getArrivalTime(), endBitPosition);
    }
    endBitPosition += 1;
    if (isCoveredPathSet())
    {
        endBitPosition += m_coveredPath_.value().bitSizeOf(context.getCoveredPath(), endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customRequestData_);

    return endBitPosition - bitPosition;
}

size_t RoutingServiceRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_language_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = m_origin_.initializeOffsets(endBitPosition);
    endBitPosition = m_destination_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isViaPointsSet())
    {
        endBitPosition = m_viaPoints_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isRouteOptionsSet())
    {
        endBitPosition = m_routeOptions_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleDetailsSet())
    {
        endBitPosition = m_vehicleDetails_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isVehiclePoseSet())
    {
        endBitPosition = m_vehiclePose_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isDriverProfileSet())
    {
        endBitPosition = m_driverProfile_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition = m_departureTime_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition = m_arrivalTime_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isCoveredPathSet())
    {
        endBitPosition = m_coveredPath_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customRequestData_);

    return endBitPosition;
}

size_t RoutingServiceRequest::initializeOffsets(RoutingServiceRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += context.getLanguage().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_language_);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = m_origin_.initializeOffsets(context.getOrigin(), endBitPosition);
    endBitPosition = m_destination_.initializeOffsets(context.getDestination(), endBitPosition);
    endBitPosition += 1;
    if (isViaPointsSet())
    {
        endBitPosition = m_viaPoints_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isRouteOptionsSet())
    {
        endBitPosition = m_routeOptions_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleDetailsSet())
    {
        endBitPosition = m_vehicleDetails_.value().initializeOffsets(context.getVehicleDetails(), endBitPosition);
    }
    endBitPosition += 1;
    if (isVehiclePoseSet())
    {
        endBitPosition = m_vehiclePose_.value().initializeOffsets(context.getVehiclePose(), endBitPosition);
    }
    endBitPosition += 1;
    if (isDriverProfileSet())
    {
        endBitPosition = m_driverProfile_.value().initializeOffsets(context.getDriverProfile(), endBitPosition);
    }
    endBitPosition += context.getNumAlternativeRoutes().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numAlternativeRoutes_);
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition = m_departureTime_.value().initializeOffsets(context.getDepartureTime(), endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition = m_arrivalTime_.value().initializeOffsets(context.getArrivalTime(), endBitPosition);
    }
    endBitPosition += 1;
    if (isCoveredPathSet())
    {
        endBitPosition = m_coveredPath_.value().initializeOffsets(context.getCoveredPath(), endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customRequestData_);

    return endBitPosition;
}

bool RoutingServiceRequest::operator==(const RoutingServiceRequest& other) const
{
    if (this != &other)
    {
        return
                (m_optimizeViaPoints_ == other.m_optimizeViaPoints_) &&
                (m_language_ == other.m_language_) &&
                (m_type_ == other.m_type_) &&
                (m_origin_ == other.m_origin_) &&
                (m_destination_ == other.m_destination_) &&
                (!isViaPointsUsed() ? !other.isViaPointsUsed() : (m_viaPoints_ == other.m_viaPoints_)) &&
                (!isRouteOptionsUsed() ? !other.isRouteOptionsUsed() : (m_routeOptions_ == other.m_routeOptions_)) &&
                (!isVehicleDetailsUsed() ? !other.isVehicleDetailsUsed() : (m_vehicleDetails_ == other.m_vehicleDetails_)) &&
                (!isVehiclePoseUsed() ? !other.isVehiclePoseUsed() : (m_vehiclePose_ == other.m_vehiclePose_)) &&
                (!isDriverProfileUsed() ? !other.isDriverProfileUsed() : (m_driverProfile_ == other.m_driverProfile_)) &&
                (m_numAlternativeRoutes_ == other.m_numAlternativeRoutes_) &&
                (!isDepartureTimeUsed() ? !other.isDepartureTimeUsed() : (m_departureTime_ == other.m_departureTime_)) &&
                (!isArrivalTimeUsed() ? !other.isArrivalTimeUsed() : (m_arrivalTime_ == other.m_arrivalTime_)) &&
                (!isCoveredPathUsed() ? !other.isCoveredPathUsed() : (m_coveredPath_ == other.m_coveredPath_)) &&
                (m_customRequestData_ == other.m_customRequestData_);
    }

    return true;
}

uint32_t RoutingServiceRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_optimizeViaPoints_);
    result = ::zserio::calcHashCode(result, m_language_);
    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_origin_);
    result = ::zserio::calcHashCode(result, m_destination_);
    if (isViaPointsUsed())
        result = ::zserio::calcHashCode(result, m_viaPoints_);
    if (isRouteOptionsUsed())
        result = ::zserio::calcHashCode(result, m_routeOptions_);
    if (isVehicleDetailsUsed())
        result = ::zserio::calcHashCode(result, m_vehicleDetails_);
    if (isVehiclePoseUsed())
        result = ::zserio::calcHashCode(result, m_vehiclePose_);
    if (isDriverProfileUsed())
        result = ::zserio::calcHashCode(result, m_driverProfile_);
    result = ::zserio::calcHashCode(result, m_numAlternativeRoutes_);
    if (isDepartureTimeUsed())
        result = ::zserio::calcHashCode(result, m_departureTime_);
    if (isArrivalTimeUsed())
        result = ::zserio::calcHashCode(result, m_arrivalTime_);
    if (isCoveredPathUsed())
        result = ::zserio::calcHashCode(result, m_coveredPath_);
    result = ::zserio::calcHashCode(result, m_customRequestData_);

    return result;
}

void RoutingServiceRequest::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_optimizeViaPoints_);
    out.writeVarUInt16(m_language_);
    ::zserio::write(out, m_type_);
    m_origin_.write(out);
    m_destination_.write(out);
    if (isViaPointsSet())
    {
        out.writeBool(true);
        m_viaPoints_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isRouteOptionsSet())
    {
        out.writeBool(true);
        m_routeOptions_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVehicleDetailsSet())
    {
        out.writeBool(true);
        m_vehicleDetails_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVehiclePoseSet())
    {
        out.writeBool(true);
        m_vehiclePose_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDriverProfileSet())
    {
        out.writeBool(true);
        m_driverProfile_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    out.writeBits(m_numAlternativeRoutes_, UINT8_C(8));
    if (isDepartureTimeSet())
    {
        out.writeBool(true);
        m_departureTime_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isArrivalTimeSet())
    {
        out.writeBool(true);
        m_arrivalTime_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isCoveredPathSet())
    {
        out.writeBool(true);
        m_coveredPath_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    out.alignTo(8);
    out.writeBitBuffer(m_customRequestData_);
}

void RoutingServiceRequest::write(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_optimizeViaPoints_);
    context.getLanguage().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(out, m_language_);
    ::zserio::write(context.getType(), out, m_type_);
    m_origin_.write(context.getOrigin(), out);
    m_destination_.write(context.getDestination(), out);
    if (isViaPointsSet())
    {
        out.writeBool(true);
        m_viaPoints_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isRouteOptionsSet())
    {
        out.writeBool(true);
        m_routeOptions_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVehicleDetailsSet())
    {
        out.writeBool(true);
        m_vehicleDetails_.value().write(context.getVehicleDetails(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVehiclePoseSet())
    {
        out.writeBool(true);
        m_vehiclePose_.value().write(context.getVehiclePose(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDriverProfileSet())
    {
        out.writeBool(true);
        m_driverProfile_.value().write(context.getDriverProfile(), out);
    }
    else
    {
        out.writeBool(false);
    }
    context.getNumAlternativeRoutes().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numAlternativeRoutes_);
    if (isDepartureTimeSet())
    {
        out.writeBool(true);
        m_departureTime_.value().write(context.getDepartureTime(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isArrivalTimeSet())
    {
        out.writeBool(true);
        m_arrivalTime_.value().write(context.getArrivalTime(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isCoveredPathSet())
    {
        out.writeBool(true);
        m_coveredPath_.value().write(context.getCoveredPath(), out);
    }
    else
    {
        out.writeBool(false);
    }
    out.alignTo(8);
    out.writeBitBuffer(m_customRequestData_);
}

void RoutingServiceRequest::ZserioArrayExpressions_viaPoints::initializeElement(RoutingServiceRequest&,
        ::nds::routing::route::Waypoint& element, size_t)
{
    element.initializeChildren();
}

void RoutingServiceRequest::ZserioElementFactory_viaPoints::create(RoutingServiceRequest&        ,
        ::zserio::vector<::nds::routing::route::Waypoint>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingServiceRequest::ZserioElementFactory_viaPoints::create(RoutingServiceRequest&        ,
        ::zserio::vector<::nds::routing::route::Waypoint>& array,
        ::nds::routing::route::Waypoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void RoutingServiceRequest::ZserioElementFactory_routeOptions::create(RoutingServiceRequest&        ,
        ::zserio::vector<::nds::routing::route::RouteOptions>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingServiceRequest::ZserioElementFactory_routeOptions::create(RoutingServiceRequest&        ,
        ::zserio::vector<::nds::routing::route::RouteOptions>& array,
        ::nds::routing::route::RouteOptions::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

bool RoutingServiceRequest::readOptimizeViaPoints(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::core::types::LanguageCode RoutingServiceRequest::readLanguage(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LanguageCode>(in.readVarUInt16());
}

::nds::core::types::LanguageCode RoutingServiceRequest::readLanguage(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLanguage().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(in);
}
::nds::routing::types::RouteType RoutingServiceRequest::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::RouteType>(in);
}

::nds::routing::types::RouteType RoutingServiceRequest::readType(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::RouteType>(context.getType(), in);
}
::nds::routing::route::Waypoint RoutingServiceRequest::readOrigin(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routing::route::Waypoint(in, allocator);
}

::nds::routing::route::Waypoint RoutingServiceRequest::readOrigin(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routing::route::Waypoint(context.getOrigin(), in, allocator);
}
::nds::routing::route::Waypoint RoutingServiceRequest::readDestination(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routing::route::Waypoint(in, allocator);
}

::nds::routing::route::Waypoint RoutingServiceRequest::readDestination(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routing::route::Waypoint(context.getDestination(), in, allocator);
}
::zserio::InplaceOptionalHolder<RoutingServiceRequest::ZserioArrayType_viaPoints> RoutingServiceRequest::readViaPoints(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_viaPoints readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_viaPoints>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_viaPoints>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoutingServiceRequest::ZserioArrayType_viaPoints> RoutingServiceRequest::readViaPoints(RoutingServiceRequest::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_viaPoints readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_viaPoints>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_viaPoints>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<RoutingServiceRequest::ZserioArrayType_routeOptions> RoutingServiceRequest::readRouteOptions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_routeOptions readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_routeOptions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_routeOptions>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoutingServiceRequest::ZserioArrayType_routeOptions> RoutingServiceRequest::readRouteOptions(RoutingServiceRequest::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_routeOptions readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_routeOptions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_routeOptions>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleDetails> RoutingServiceRequest::readVehicleDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleDetails>(::nds::core::vehicle::VehicleDetails(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleDetails>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleDetails> RoutingServiceRequest::readVehicleDetails(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleDetails>(::nds::core::vehicle::VehicleDetails(context.getVehicleDetails(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehicleDetails>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose> RoutingServiceRequest::readVehiclePose(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose>(::nds::core::vehicle::VehiclePose(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose> RoutingServiceRequest::readVehiclePose(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose>(::nds::core::vehicle::VehiclePose(context.getVehiclePose(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile> RoutingServiceRequest::readDriverProfile(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile>(::nds::routing::types::DriverProfile(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile> RoutingServiceRequest::readDriverProfile(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile>(::nds::routing::types::DriverProfile(context.getDriverProfile(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile>(::zserio::NullOpt);
}
uint8_t RoutingServiceRequest::readNumAlternativeRoutes(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t RoutingServiceRequest::readNumAlternativeRoutes(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAlternativeRoutes().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> RoutingServiceRequest::readDepartureTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> RoutingServiceRequest::readDepartureTime(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(context.getDepartureTime(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> RoutingServiceRequest::readArrivalTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> RoutingServiceRequest::readArrivalTime(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(context.getArrivalTime(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath> RoutingServiceRequest::readCoveredPath(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath>(::nds::core::location::RoadLocationPath(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath> RoutingServiceRequest::readCoveredPath(RoutingServiceRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath>(::nds::core::location::RoadLocationPath(context.getCoveredPath(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath>(::zserio::NullOpt);
}
::zserio::BitBuffer RoutingServiceRequest::readCustomRequestData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    return static_cast<::zserio::BitBuffer>(in.readBitBuffer(allocator));
}

} // namespace services
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/services/RoutingServiceResponse.h>

namespace nds
{
namespace routing
{
namespace services
{

RoutingServiceResponse::RoutingServiceResponse(const allocator_type& allocator) noexcept :
        m_route_(allocator),
        m_alternativeRoutes_(::zserio::NullOpt),
        m_mapId_(::zserio::NullOpt),
        m_versionId_(::zserio::NullOpt),
        m_customResponseData_(allocator)
{
}

RoutingServiceResponse::RoutingServiceResponse(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_route_(readRoute(in, allocator)),
        m_alternativeRoutes_(readAlternativeRoutes(in, allocator)),
        m_mapId_(readMapId(in, allocator)),
        m_versionId_(readVersionId(in)),
        m_customResponseData_(readCustomResponseData(in, allocator))
{
}

RoutingServiceResponse::RoutingServiceResponse(RoutingServiceResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_route_(readRoute(context, in, allocator)),
        m_alternativeRoutes_(readAlternativeRoutes(context, in, allocator)),
        m_mapId_(readMapId(context, in, allocator)),
        m_versionId_(readVersionId(context, in)),
        m_customResponseData_(readCustomResponseData(in, allocator))
{
}

RoutingServiceResponse::RoutingServiceResponse(::zserio::PropagateAllocatorT,
        const RoutingServiceResponse& other, const allocator_type& allocator) :
        m_route_(::zserio::allocatorPropagatingCopy(other.m_route_, allocator)),
        m_alternativeRoutes_(::zserio::allocatorPropagatingCopy(other.m_alternativeRoutes_, allocator)),
        m_mapId_(::zserio::allocatorPropagatingCopy(other.m_mapId_, allocator)),
        m_versionId_(::zserio::allocatorPropagatingCopy(other.m_versionId_, allocator)),
        m_customResponseData_(::zserio::allocatorPropagatingCopy(other.m_customResponseData_, allocator))
{
}

void RoutingServiceResponse::initializeChildren()
{
    m_route_.initializeChildren();
    if (isAlternativeRoutesSet())
        m_alternativeRoutes_.value().initializeElements(*this);
}

::nds::routing::route::Route& RoutingServiceResponse::getRoute()
{
    return m_route_;
}

const ::nds::routing::route::Route& RoutingServiceResponse::getRoute() const
{
    return m_route_;
}

void RoutingServiceResponse::setRoute(const ::nds::routing::route::Route& route_)
{
    m_route_ = route_;
}

void RoutingServiceResponse::setRoute(::nds::routing::route::Route&& route_)
{
    m_route_ = ::std::move(route_);
}

::zserio::vector<::nds::routing::route::Route>& RoutingServiceResponse::getAlternativeRoutes()
{
    return m_alternativeRoutes_.value().getRawArray();
}

const ::zserio::vector<::nds::routing::route::Route>& RoutingServiceResponse::getAlternativeRoutes() const
{
    return m_alternativeRoutes_.value().getRawArray();
}

void RoutingServiceResponse::setAlternativeRoutes(const ::zserio::vector<::nds::routing::route::Route>& alternativeRoutes_)
{
    m_alternativeRoutes_ = ZserioArrayType_alternativeRoutes(alternativeRoutes_);
}

void RoutingServiceResponse::setAlternativeRoutes(::zserio::vector<::nds::routing::route::Route>&& alternativeRoutes_)
{
    m_alternativeRoutes_ = ZserioArrayType_alternativeRoutes(std::move(alternativeRoutes_));
}

bool RoutingServiceResponse::isAlternativeRoutesUsed() const
{
    return (isAlternativeRoutesSet());
}

bool RoutingServiceResponse::isAlternativeRoutesSet() const
{
    return m_alternativeRoutes_.hasValue();
}

void RoutingServiceResponse::resetAlternativeRoutes()
{
    m_alternativeRoutes_.reset();
}

::nds::system::types::NdsSystemToken& RoutingServiceResponse::getMapId()
{
    return m_mapId_.value();
}

const ::nds::system::types::NdsSystemToken& RoutingServiceResponse::getMapId() const
{
    return m_mapId_.value();
}

void RoutingServiceResponse::setMapId(const ::nds::system::types::NdsSystemToken& mapId_)
{
    m_mapId_ = mapId_;
}

void RoutingServiceResponse::setMapId(::nds::system::types::NdsSystemToken&& mapId_)
{
    m_mapId_ = ::std::move(mapId_);
}

bool RoutingServiceResponse::isMapIdUsed() const
{
    return (isMapIdSet());
}

bool RoutingServiceResponse::isMapIdSet() const
{
    return m_mapId_.hasValue();
}

void RoutingServiceResponse::resetMapId()
{
    m_mapId_.reset();
}

::nds::core::types::VersionId RoutingServiceResponse::getVersionId() const
{
    return m_versionId_.value();
}

void RoutingServiceResponse::setVersionId(::nds::core::types::VersionId versionId_)
{
    m_versionId_ = versionId_;
}

bool RoutingServiceResponse::isVersionIdUsed() const
{
    return (isVersionIdSet());
}

bool RoutingServiceResponse::isVersionIdSet() const
{
    return m_versionId_.hasValue();
}

void RoutingServiceResponse::resetVersionId()
{
    m_versionId_.reset();
}

::zserio::BitBuffer& RoutingServiceResponse::getCustomResponseData()
{
    return m_customResponseData_;
}

const ::zserio::BitBuffer& RoutingServiceResponse::getCustomResponseData() const
{
    return m_customResponseData_;
}

void RoutingServiceResponse::setCustomResponseData(const ::zserio::BitBuffer& customResponseData_)
{
    m_customResponseData_ = customResponseData_;
}

void RoutingServiceResponse::setCustomResponseData(::zserio::BitBuffer&& customResponseData_)
{
    m_customResponseData_ = ::std::move(customResponseData_);
}

void RoutingServiceResponse::initPackingContext(RoutingServiceResponse::ZserioPackingContext& context) const
{
    m_route_.initPackingContext(context.getRoute());
    if (isMapIdSet())
    {
        m_mapId_.value().initPackingContext(context.getMapId());
    }
    if (isVersionIdSet())
    {
        context.getVersionId().init<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(m_versionId_.value());
    }
}

size_t RoutingServiceResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_route_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isAlternativeRoutesSet())
    {
        endBitPosition += m_alternativeRoutes_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isMapIdSet())
    {
        endBitPosition += m_mapId_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isVersionIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_versionId_.value());
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customResponseData_);

    return endBitPosition - bitPosition;
}

size_t RoutingServiceResponse::bitSizeOf(RoutingServiceResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_route_.bitSizeOf(context.getRoute(), endBitPosition);
    endBitPosition += 1;
    if (isAlternativeRoutesSet())
    {
        endBitPosition += m_alternativeRoutes_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isMapIdSet())
    {
        endBitPosition += m_mapId_.value().bitSizeOf(context.getMapId(), endBitPosition);
    }
    endBitPosition += 1;
    if (isVersionIdSet())
    {
        endBitPosition += context.getVersionId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(m_versionId_.value());
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customResponseData_);

    return endBitPosition - bitPosition;
}

size_t RoutingServiceResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_route_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isAlternativeRoutesSet())
    {
        endBitPosition = m_alternativeRoutes_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isMapIdSet())
    {
        endBitPosition = m_mapId_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isVersionIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_versionId_.value());
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customResponseData_);

    return endBitPosition;
}

size_t RoutingServiceResponse::initializeOffsets(RoutingServiceResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_route_.initializeOffsets(context.getRoute(), endBitPosition);
    endBitPosition += 1;
    if (isAlternativeRoutesSet())
    {
        endBitPosition = m_alternativeRoutes_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isMapIdSet())
    {
        endBitPosition = m_mapId_.value().initializeOffsets(context.getMapId(), endBitPosition);
    }
    endBitPosition += 1;
    if (isVersionIdSet())
    {
        endBitPosition += context.getVersionId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(m_versionId_.value());
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customResponseData_);

    return endBitPosition;
}

bool RoutingServiceResponse::operator==(const RoutingServiceResponse& other) const
{
    if (this != &other)
    {
        return
                (m_route_ == other.m_route_) &&
                (!isAlternativeRoutesUsed() ? !other.isAlternativeRoutesUsed() : (m_alternativeRoutes_ == other.m_alternativeRoutes_)) &&
                (!isMapIdUsed() ? !other.isMapIdUsed() : (m_mapId_ == other.m_mapId_)) &&
                (!isVersionIdUsed() ? !other.isVersionIdUsed() : (m_versionId_ == other.m_versionId_)) &&
                (m_customResponseData_ == other.m_customResponseData_);
    }

    return true;
}

uint32_t RoutingServiceResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_route_);
    if (isAlternativeRoutesUsed())
        result = ::zserio::calcHashCode(result, m_alternativeRoutes_);
    if (isMapIdUsed())
        result = ::zserio::calcHashCode(result, m_mapId_);
    if (isVersionIdUsed())
        result = ::zserio::calcHashCode(result, m_versionId_);
    result = ::zserio::calcHashCode(result, m_customResponseData_);

    return result;
}

void RoutingServiceResponse::write(::zserio::BitStreamWriter& out) const
{
    m_route_.write(out);
    if (isAlternativeRoutesSet())
    {
        out.writeBool(true);
        m_alternativeRoutes_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isMapIdSet())
    {
        out.writeBool(true);
        m_mapId_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVersionIdSet())
    {
        out.writeBool(true);
        out.writeVarUInt(m_versionId_.value());
    }
    else
    {
        out.writeBool(false);
    }
    out.alignTo(8);
    out.writeBitBuffer(m_customResponseData_);
}

void RoutingServiceResponse::write(RoutingServiceResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_route_.write(context.getRoute(), out);
    if (isAlternativeRoutesSet())
    {
        out.writeBool(true);
        m_alternativeRoutes_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isMapIdSet())
    {
        out.writeBool(true);
        m_mapId_.value().write(context.getMapId(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVersionIdSet())
    {
        out.writeBool(true);
        context.getVersionId().write<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(out, m_versionId_.value());
    }
    else
    {
        out.writeBool(false);
    }
    out.alignTo(8);
    out.writeBitBuffer(m_customResponseData_);
}

void RoutingServiceResponse::ZserioArrayExpressions_alternativeRoutes::initializeElement(RoutingServiceResponse&,
        ::nds::routing::route::Route& element, size_t)
{
    element.initializeChildren();
}

void RoutingServiceResponse::ZserioElementFactory_alternativeRoutes::create(RoutingServiceResponse&        ,
        ::zserio::vector<::nds::routing::route::Route>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoutingServiceResponse::ZserioElementFactory_alternativeRoutes::create(RoutingServiceResponse&        ,
        ::zserio::vector<::nds::routing::route::Route>& array,
        ::nds::routing::route::Route::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::routing::route::Route RoutingServiceResponse::readRoute(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routing::route::Route(in, allocator);
}

::nds::routing::route::Route RoutingServiceResponse::readRoute(RoutingServiceResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routing::route::Route(context.getRoute(), in, allocator);
}
::zserio::InplaceOptionalHolder<RoutingServiceResponse::ZserioArrayType_alternativeRoutes> RoutingServiceResponse::readAlternativeRoutes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_alternativeRoutes readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_alternativeRoutes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_alternativeRoutes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoutingServiceResponse::ZserioArrayType_alternativeRoutes> RoutingServiceResponse::readAlternativeRoutes(RoutingServiceResponse::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_alternativeRoutes readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_alternativeRoutes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_alternativeRoutes>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::system::types::NdsSystemToken> RoutingServiceResponse::readMapId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::system::types::NdsSystemToken>(::nds::system::types::NdsSystemToken(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::system::types::NdsSystemToken>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::system::types::NdsSystemToken> RoutingServiceResponse::readMapId(RoutingServiceResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::system::types::NdsSystemToken>(::nds::system::types::NdsSystemToken(context.getMapId(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::system::types::NdsSystemToken>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::VersionId> RoutingServiceResponse::readVersionId(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::VersionId>(static_cast<::nds::core::types::VersionId>(in.readVarUInt()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::VersionId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::VersionId> RoutingServiceResponse::readVersionId(RoutingServiceResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::VersionId>(context.getVersionId().read<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::VersionId>(::zserio::NullOpt);
}
::zserio::BitBuffer RoutingServiceResponse::readCustomResponseData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    return static_cast<::zserio::BitBuffer>(in.readBitBuffer(allocator));
}

} // namespace services
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/routing/services/RangeProjectionRequest.h>
#include <nds/routing/types/RangeProjectionType.h>

namespace nds
{
namespace routing
{
namespace services
{

RangeProjectionRequest::RangeProjectionRequest(const allocator_type& allocator) noexcept :
        m_type_(::nds::routing::types::RangeProjectionType()),
        m_origin_(allocator),
        m_timeBudget_(::zserio::NullOpt),
        m_distanceMeters_(::zserio::NullOpt),
        m_vehicleDetails_(allocator),
        m_vehiclePose_(::zserio::NullOpt),
        m_driverProfile_(::zserio::NullOpt),
        m_maxPolyCount_(::zserio::NullOpt)
{
}

RangeProjectionRequest::RangeProjectionRequest(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_origin_(readOrigin(in, allocator)),
        m_timeBudget_(readTimeBudget(in)),
        m_distanceMeters_(readDistanceMeters(in)),
        m_vehicleDetails_(readVehicleDetails(in, allocator)),
        m_vehiclePose_(readVehiclePose(in, allocator)),
        m_driverProfile_(readDriverProfile(in, allocator)),
        m_maxPolyCount_(readMaxPolyCount(in))
{
}

RangeProjectionRequest::RangeProjectionRequest(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_origin_(readOrigin(context, in, allocator)),
        m_timeBudget_(readTimeBudget(context, in)),
        m_distanceMeters_(readDistanceMeters(context, in)),
        m_vehicleDetails_(readVehicleDetails(context, in, allocator)),
        m_vehiclePose_(readVehiclePose(context, in, allocator)),
        m_driverProfile_(readDriverProfile(context, in, allocator)),
        m_maxPolyCount_(readMaxPolyCount(context, in))
{
}

RangeProjectionRequest::RangeProjectionRequest(::zserio::PropagateAllocatorT,
        const RangeProjectionRequest& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_origin_(::zserio::allocatorPropagatingCopy(other.m_origin_, allocator)),
        m_timeBudget_(::zserio::allocatorPropagatingCopy(other.m_timeBudget_, allocator)),
        m_distanceMeters_(::zserio::allocatorPropagatingCopy(other.m_distanceMeters_, allocator)),
        m_vehicleDetails_(::zserio::allocatorPropagatingCopy(other.m_vehicleDetails_, allocator)),
        m_vehiclePose_(::zserio::allocatorPropagatingCopy(other.m_vehiclePose_, allocator)),
        m_driverProfile_(::zserio::allocatorPropagatingCopy(other.m_driverProfile_, allocator)),
        m_maxPolyCount_(::zserio::allocatorPropagatingCopy(other.m_maxPolyCount_, allocator))
{
}

void RangeProjectionRequest::initializeChildren()
{
    m_origin_.initializeChildren();
    if (isVehiclePoseSet())
        m_vehiclePose_.value().initializeChildren();
    if (isDriverProfileSet())
        m_driverProfile_.value().initializeChildren();
}

::nds::routing::types::RangeProjectionType RangeProjectionRequest::getType() const
{
    return m_type_;
}

void RangeProjectionRequest::setType(::nds::routing::types::RangeProjectionType type_)
{
    m_type_ = type_;
}

::nds::routing::route::Waypoint& RangeProjectionRequest::getOrigin()
{
    return m_origin_;
}

const ::nds::routing::route::Waypoint& RangeProjectionRequest::getOrigin() const
{
    return m_origin_;
}

void RangeProjectionRequest::setOrigin(const ::nds::routing::route::Waypoint& origin_)
{
    m_origin_ = origin_;
}

void RangeProjectionRequest::setOrigin(::nds::routing::route::Waypoint&& origin_)
{
    m_origin_ = ::std::move(origin_);
}

::nds::core::types::Seconds RangeProjectionRequest::getTimeBudget() const
{
    return m_timeBudget_.value();
}

void RangeProjectionRequest::setTimeBudget(::nds::core::types::Seconds timeBudget_)
{
    m_timeBudget_ = timeBudget_;
}

bool RangeProjectionRequest::isTimeBudgetUsed() const
{
    return ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME);
}

bool RangeProjectionRequest::isTimeBudgetSet() const
{
    return m_timeBudget_.hasValue();
}

void RangeProjectionRequest::resetTimeBudget()
{
    m_timeBudget_.reset();
}

::nds::core::types::DistanceMeters RangeProjectionRequest::getDistanceMeters() const
{
    return m_distanceMeters_.value();
}

void RangeProjectionRequest::setDistanceMeters(::nds::core::types::DistanceMeters distanceMeters_)
{
    m_distanceMeters_ = distanceMeters_;
}

bool RangeProjectionRequest::isDistanceMetersUsed() const
{
    return ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE);
}

bool RangeProjectionRequest::isDistanceMetersSet() const
{
    return m_distanceMeters_.hasValue();
}

void RangeProjectionRequest::resetDistanceMeters()
{
    m_distanceMeters_.reset();
}

::nds::core::vehicle::VehicleDetails& RangeProjectionRequest::getVehicleDetails()
{
    return m_vehicleDetails_;
}

const ::nds::core::vehicle::VehicleDetails& RangeProjectionRequest::getVehicleDetails() const
{
    return m_vehicleDetails_;
}

void RangeProjectionRequest::setVehicleDetails(const ::nds::core::vehicle::VehicleDetails& vehicleDetails_)
{
    m_vehicleDetails_ = vehicleDetails_;
}

void RangeProjectionRequest::setVehicleDetails(::nds::core::vehicle::VehicleDetails&& vehicleDetails_)
{
    m_vehicleDetails_ = ::std::move(vehicleDetails_);
}

::nds::core::vehicle::VehiclePose& RangeProjectionRequest::getVehiclePose()
{
    return m_vehiclePose_.value();
}

const ::nds::core::vehicle::VehiclePose& RangeProjectionRequest::getVehiclePose() const
{
    return m_vehiclePose_.value();
}

void RangeProjectionRequest::setVehiclePose(const ::nds::core::vehicle::VehiclePose& vehiclePose_)
{
    m_vehiclePose_ = vehiclePose_;
}

void RangeProjectionRequest::setVehiclePose(::nds::core::vehicle::VehiclePose&& vehiclePose_)
{
    m_vehiclePose_ = ::std::move(vehiclePose_);
}

bool RangeProjectionRequest::isVehiclePoseUsed() const
{
    return (isVehiclePoseSet());
}

bool RangeProjectionRequest::isVehiclePoseSet() const
{
    return m_vehiclePose_.hasValue();
}

void RangeProjectionRequest::resetVehiclePose()
{
    m_vehiclePose_.reset();
}

::nds::routing::types::DriverProfile& RangeProjectionRequest::getDriverProfile()
{
    return m_driverProfile_.value();
}

const ::nds::routing::types::DriverProfile& RangeProjectionRequest::getDriverProfile() const
{
    return m_driverProfile_.value();
}

void RangeProjectionRequest::setDriverProfile(const ::nds::routing::types::DriverProfile& driverProfile_)
{
    m_driverProfile_ = driverProfile_;
}

void RangeProjectionRequest::setDriverProfile(::nds::routing::types::DriverProfile&& driverProfile_)
{
    m_driverProfile_ = ::std::move(driverProfile_);
}

bool RangeProjectionRequest::isDriverProfileUsed() const
{
    return (isDriverProfileSet());
}

bool RangeProjectionRequest::isDriverProfileSet() const
{
    return m_driverProfile_.hasValue();
}

void RangeProjectionRequest::resetDriverProfile()
{
    m_driverProfile_.reset();
}

uint32_t RangeProjectionRequest::getMaxPolyCount() const
{
    return m_maxPolyCount_.value();
}

void RangeProjectionRequest::setMaxPolyCount(uint32_t maxPolyCount_)
{
    m_maxPolyCount_ = maxPolyCount_;
}

bool RangeProjectionRequest::isMaxPolyCountUsed() const
{
    return (isMaxPolyCountSet());
}

bool RangeProjectionRequest::isMaxPolyCountSet() const
{
    return m_maxPolyCount_.hasValue();
}

void RangeProjectionRequest::resetMaxPolyCount()
{
    m_maxPolyCount_.reset();
}

void RangeProjectionRequest::initPackingContext(RangeProjectionRequest::ZserioPackingContext& context) const
{
    m_type_.initPackingContext(context.getType());
    m_origin_.initPackingContext(context.getOrigin());
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME)
    {
        context.getTimeBudget().init<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_timeBudget_.value());
    }
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE)
    {
        context.getDistanceMeters().init<::zserio::VarIntNNArrayTraits<::nds::core::types::DistanceMeters>>(m_distanceMeters_.value());
    }
    m_vehicleDetails_.initPackingContext(context.getVehicleDetails());
    if (isVehiclePoseSet())
    {
        m_vehiclePose_.value().initPackingContext(context.getVehiclePose());
    }
    if (isDriverProfileSet())
    {
        m_driverProfile_.value().initPackingContext(context.getDriverProfile());
    }
    if (isMaxPolyCountSet())
    {
        context.getMaxPolyCount().init<::zserio::VarIntNNArrayTraits<uint32_t>>(m_maxPolyCount_.value());
    }
}

size_t RangeProjectionRequest::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_type_.bitSizeOf(endBitPosition);
    endBitPosition += m_origin_.bitSizeOf(endBitPosition);
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_timeBudget_.value());
    }
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_distanceMeters_.value());
    }
    endBitPosition += m_vehicleDetails_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isVehiclePoseSet())
    {
        endBitPosition += m_vehiclePose_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isDriverProfileSet())
    {
        endBitPosition += m_driverProfile_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isMaxPolyCountSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxPolyCount_.value());
    }

    return endBitPosition - bitPosition;
}

size_t RangeProjectionRequest::bitSizeOf(RangeProjectionRequest::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_type_.bitSizeOf(context.getType(), endBitPosition);
    endBitPosition += m_origin_.bitSizeOf(context.getOrigin(), endBitPosition);
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME)
    {
        endBitPosition += context.getTimeBudget().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_timeBudget_.value());
    }
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE)
    {
        endBitPosition += context.getDistanceMeters().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::DistanceMeters>>(m_distanceMeters_.value());
    }
    endBitPosition += m_vehicleDetails_.bitSizeOf(context.getVehicleDetails(), endBitPosition);
    endBitPosition += 1;
    if (isVehiclePoseSet())
    {
        endBitPosition += m_vehiclePose_.value().bitSizeOf(context.getVehiclePose(), endBitPosition);
    }
    endBitPosition += 1;
    if (isDriverProfileSet())
    {
        endBitPosition += m_driverProfile_.value().bitSizeOf(context.getDriverProfile(), endBitPosition);
    }
    endBitPosition += 1;
    if (isMaxPolyCountSet())
    {
        endBitPosition += context.getMaxPolyCount().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_maxPolyCount_.value());
    }

    return endBitPosition - bitPosition;
}

size_t RangeProjectionRequest::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_type_.initializeOffsets(endBitPosition);
    endBitPosition = m_origin_.initializeOffsets(endBitPosition);
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_timeBudget_.value());
    }
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_distanceMeters_.value());
    }
    endBitPosition = m_vehicleDetails_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isVehiclePoseSet())
    {
        endBitPosition = m_vehiclePose_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isDriverProfileSet())
    {
        endBitPosition = m_driverProfile_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isMaxPolyCountSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxPolyCount_.value());
    }

    return endBitPosition;
}

size_t RangeProjectionRequest::initializeOffsets(RangeProjectionRequest::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_type_.initializeOffsets(context.getType(), endBitPosition);
    endBitPosition = m_origin_.initializeOffsets(context.getOrigin(), endBitPosition);
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME)
    {
        endBitPosition += context.getTimeBudget().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_timeBudget_.value());
    }
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE)
    {
        endBitPosition += context.getDistanceMeters().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::DistanceMeters>>(m_distanceMeters_.value());
    }
    endBitPosition = m_vehicleDetails_.initializeOffsets(context.getVehicleDetails(), endBitPosition);
    endBitPosition += 1;
    if (isVehiclePoseSet())
    {
        endBitPosition = m_vehiclePose_.value().initializeOffsets(context.getVehiclePose(), endBitPosition);
    }
    endBitPosition += 1;
    if (isDriverProfileSet())
    {
        endBitPosition = m_driverProfile_.value().initializeOffsets(context.getDriverProfile(), endBitPosition);
    }
    endBitPosition += 1;
    if (isMaxPolyCountSet())
    {
        endBitPosition += context.getMaxPolyCount().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_maxPolyCount_.value());
    }

    return endBitPosition;
}

bool RangeProjectionRequest::operator==(const RangeProjectionRequest& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_origin_ == other.m_origin_) &&
                (!isTimeBudgetUsed() ? !other.isTimeBudgetUsed() : (m_timeBudget_ == other.m_timeBudget_)) &&
                (!isDistanceMetersUsed() ? !other.isDistanceMetersUsed() : (m_distanceMeters_ == other.m_distanceMeters_)) &&
                (m_vehicleDetails_ == other.m_vehicleDetails_) &&
                (!isVehiclePoseUsed() ? !other.isVehiclePoseUsed() : (m_vehiclePose_ == other.m_vehiclePose_)) &&
                (!isDriverProfileUsed() ? !other.isDriverProfileUsed() : (m_driverProfile_ == other.m_driverProfile_)) &&
                (!isMaxPolyCountUsed() ? !other.isMaxPolyCountUsed() : (m_maxPolyCount_ == other.m_maxPolyCount_));
    }

    return true;
}

uint32_t RangeProjectionRequest::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_origin_);
    if (isTimeBudgetUsed())
        result = ::zserio::calcHashCode(result, m_timeBudget_);
    if (isDistanceMetersUsed())
        result = ::zserio::calcHashCode(result, m_distanceMeters_);
    result = ::zserio::calcHashCode(result, m_vehicleDetails_);
    if (isVehiclePoseUsed())
        result = ::zserio::calcHashCode(result, m_vehiclePose_);
    if (isDriverProfileUsed())
        result = ::zserio::calcHashCode(result, m_driverProfile_);
    if (isMaxPolyCountUsed())
        result = ::zserio::calcHashCode(result, m_maxPolyCount_);

    return result;
}

void RangeProjectionRequest::write(::zserio::BitStreamWriter& out) const
{
    m_type_.write(out);
    m_origin_.write(out);
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME)
    {
        out.writeVarUInt(m_timeBudget_.value());
    }
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE)
    {
        out.writeVarUInt32(m_distanceMeters_.value());
    }
    m_vehicleDetails_.write(out);
    if (isVehiclePoseSet())
    {
        out.writeBool(true);
        m_vehiclePose_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDriverProfileSet())
    {
        out.writeBool(true);
        m_driverProfile_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isMaxPolyCountSet())
    {
        out.writeBool(true);
        out.writeVarUInt32(m_maxPolyCount_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void RangeProjectionRequest::write(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_type_.write(context.getType(), out);
    m_origin_.write(context.getOrigin(), out);
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME)
    {
        context.getTimeBudget().write<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(out, m_timeBudget_.value());
    }
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE)
    {
        context.getDistanceMeters().write<::zserio::VarIntNNArrayTraits<::nds::core::types::DistanceMeters>>(out, m_distanceMeters_.value());
    }
    m_vehicleDetails_.write(context.getVehicleDetails(), out);
    if (isVehiclePoseSet())
    {
        out.writeBool(true);
        m_vehiclePose_.value().write(context.getVehiclePose(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDriverProfileSet())
    {
        out.writeBool(true);
        m_driverProfile_.value().write(context.getDriverProfile(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isMaxPolyCountSet())
    {
        out.writeBool(true);
        context.getMaxPolyCount().write<::zserio::VarIntNNArrayTraits<uint32_t>>(out, m_maxPolyCount_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::routing::types::RangeProjectionType RangeProjectionRequest::readType(::zserio::BitStreamReader& in)
{
    return ::nds::routing::types::RangeProjectionType(in);
}

::nds::routing::types::RangeProjectionType RangeProjectionRequest::readType(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::routing::types::RangeProjectionType(context.getType(), in);
}
::nds::routing::route::Waypoint RangeProjectionRequest::readOrigin(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routing::route::Waypoint(in, allocator);
}

::nds::routing::route::Waypoint RangeProjectionRequest::readOrigin(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routing::route::Waypoint(context.getOrigin(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::types::Seconds> RangeProjectionRequest::readTimeBudget(::zserio::BitStreamReader& in)
{
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::Seconds>(static_cast<::nds::core::types::Seconds>(in.readVarUInt()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::Seconds>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::Seconds> RangeProjectionRequest::readTimeBudget(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::TIME) == ::nds::routing::types::RangeProjectionType::Values::TIME)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::Seconds>(context.getTimeBudget().read<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::Seconds>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::DistanceMeters> RangeProjectionRequest::readDistanceMeters(::zserio::BitStreamReader& in)
{
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::DistanceMeters>(static_cast<::nds::core::types::DistanceMeters>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::DistanceMeters>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::DistanceMeters> RangeProjectionRequest::readDistanceMeters(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if ((getType() & ::nds::routing::types::RangeProjectionType::Values::DISTANCE) == ::nds::routing::types::RangeProjectionType::Values::DISTANCE)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::DistanceMeters>(context.getDistanceMeters().read<::zserio::VarIntNNArrayTraits<::nds::core::types::DistanceMeters>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::DistanceMeters>(::zserio::NullOpt);
}
::nds::core::vehicle::VehicleDetails RangeProjectionRequest::readVehicleDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleDetails(in, allocator);
}

::nds::core::vehicle::VehicleDetails RangeProjectionRequest::readVehicleDetails(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleDetails(context.getVehicleDetails(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose> RangeProjectionRequest::readVehiclePose(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose>(::nds::core::vehicle::VehiclePose(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose> RangeProjectionRequest::readVehiclePose(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose>(::nds::core::vehicle::VehiclePose(context.getVehiclePose(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::VehiclePose>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile> RangeProjectionRequest::readDriverProfile(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile>(::nds::routing::types::DriverProfile(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile> RangeProjectionRequest::readDriverProfile(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile>(::nds::routing::types::DriverProfile(context.getDriverProfile(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::types::DriverProfile>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint32_t> RangeProjectionRequest::readMaxPolyCount(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> RangeProjectionRequest::readMaxPolyCount(RangeProjectionRequest::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(context.getMaxPolyCount().read<::zserio::VarIntNNArrayTraits<uint32_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

} // namespace services
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/services/RangeProjectionResponse.h>

namespace nds
{
namespace routing
{
namespace services
{

RangeProjectionResponse::RangeProjectionResponse(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_shift_(::nds::core::geometry::CoordShift()),
        m_geometry_(allocator)
{
}

RangeProjectionResponse::RangeProjectionResponse(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_shift_(readShift(in)),
        m_geometry_(readGeometry(in, allocator))
{
}

RangeProjectionResponse::RangeProjectionResponse(RangeProjectionResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_shift_(readShift(context, in)),
        m_geometry_(readGeometry(context, in, allocator))
{
}

RangeProjectionResponse::RangeProjectionResponse(const RangeProjectionResponse& other) :
        m_shift_(other.m_shift_),
        m_geometry_(other.m_geometry_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RangeProjectionResponse& RangeProjectionResponse::operator=(const RangeProjectionResponse& other)
{
    m_shift_ = other.m_shift_;
    m_geometry_ = other.m_geometry_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RangeProjectionResponse::RangeProjectionResponse(RangeProjectionResponse&& other) :
        m_shift_(::std::move(other.m_shift_)),
        m_geometry_(::std::move(other.m_geometry_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RangeProjectionResponse& RangeProjectionResponse::operator=(RangeProjectionResponse&& other)
{
    m_shift_ = ::std::move(other.m_shift_);
    m_geometry_ = ::std::move(other.m_geometry_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RangeProjectionResponse::RangeProjectionResponse(::zserio::PropagateAllocatorT,
        const RangeProjectionResponse& other, const allocator_type& allocator) :
        m_shift_(::zserio::allocatorPropagatingCopy(other.m_shift_, allocator)),
        m_geometry_(::zserio::allocatorPropagatingCopy(other.m_geometry_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RangeProjectionResponse::initializeChildren()
{
    m_geometry_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));

    m_areChildrenInitialized = true;
}

::nds::core::geometry::CoordShift RangeProjectionResponse::getShift() const
{
    return m_shift_;
}

void RangeProjectionResponse::setShift(::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
}

::nds::core::geometry::Ring2D& RangeProjectionResponse::getGeometry()
{
    return m_geometry_;
}

const ::nds::core::geometry::Ring2D& RangeProjectionResponse::getGeometry() const
{
    return m_geometry_;
}

void RangeProjectionResponse::setGeometry(const ::nds::core::geometry::Ring2D& geometry_)
{
    m_geometry_ = geometry_;
}

void RangeProjectionResponse::setGeometry(::nds::core::geometry::Ring2D&& geometry_)
{
    m_geometry_ = ::std::move(geometry_);
}

void RangeProjectionResponse::initPackingContext(RangeProjectionResponse::ZserioPackingContext& context) const
{
    context.getShift().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    m_geometry_.initPackingContext(context.getGeometry());
}

size_t RangeProjectionResponse::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += m_geometry_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RangeProjectionResponse::bitSizeOf(RangeProjectionResponse::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition += m_geometry_.bitSizeOf(context.getGeometry(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RangeProjectionResponse::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition = m_geometry_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RangeProjectionResponse::initializeOffsets(RangeProjectionResponse::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition = m_geometry_.initializeOffsets(context.getGeometry(), endBitPosition);

    return endBitPosition;
}

bool RangeProjectionResponse::operator==(const RangeProjectionResponse& other) const
{
    if (this != &other)
    {
        return
                (m_shift_ == other.m_shift_) &&
                (m_geometry_ == other.m_geometry_);
    }

    return true;
}

uint32_t RangeProjectionResponse::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_shift_);
    result = ::zserio::calcHashCode(result, m_geometry_);

    return result;
}

void RangeProjectionResponse::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_shift_, UINT8_C(5));

    // check parameters
    if (m_geometry_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RangeProjectionResponse.geometry: ") <<
                m_geometry_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_geometry_.write(out);
}

void RangeProjectionResponse::write(RangeProjectionResponse::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getShift().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_shift_);

    // check parameters
    if (m_geometry_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RangeProjectionResponse.geometry: ") <<
                m_geometry_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_geometry_.write(context.getGeometry(), out);
}

::nds::core::geometry::CoordShift RangeProjectionResponse::readShift(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift RangeProjectionResponse::readShift(RangeProjectionResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getShift().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::core::geometry::Ring2D RangeProjectionResponse::readGeometry(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Ring2D(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::Ring2D RangeProjectionResponse::readGeometry(RangeProjectionResponse::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Ring2D(context.getGeometry(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

} // namespace services
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/routing/services/RoutingService.h>

namespace nds
{
namespace routing
{
namespace services
{

namespace RoutingService
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getServiceModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getServiceNodeSystemReferenceMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getRouteServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[3])
        return getServiceNodeLegalInfoMethod(requestData, context);
    if (methodName == methodNames()[4])
        return getRouteMethod(requestData, context);
    throw ::zserio::ServiceException("nds.routing.services.RoutingService: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.routing.services.RoutingService");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 5>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 5> names =
    {
        ::zserio::makeStringView("getServiceModuleDefinition"),
        ::zserio::makeStringView("getServiceNodeSystemReference"),
        ::zserio::makeStringView("getRouteServiceCapabilities"),
        ::zserio::makeStringView("getServiceNodeLegalInfo"),
        ::zserio::makeStringView("getRoute")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getServiceModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeSystemReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsSystemToken&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeSystemReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getRouteServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::routing::metadata::RouteServiceCapabilities&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getRouteServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeLegalInfoMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsNodeLegalInfo&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeLegalInfoImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getRouteMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::routing::services::RoutingServiceRequest request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::routing::services::RoutingServiceResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getRouteImpl(request, context), get_allocator_ref());
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getServiceModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::system::types::NdsSystemToken Client::getServiceNodeSystemReferenceMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeSystemReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsSystemToken(reader, get_allocator_ref());
}

::nds::routing::metadata::RouteServiceCapabilities Client::getRouteServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getRouteServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::routing::metadata::RouteServiceCapabilities(reader, get_allocator_ref());
}

::nds::system::types::NdsNodeLegalInfo Client::getServiceNodeLegalInfoMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeLegalInfo"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsNodeLegalInfo(reader, get_allocator_ref());
}

::nds::routing::services::RoutingServiceResponse Client::getRouteMethod(const ::nds::routing::services::RoutingServiceRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getRoute"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::routing::services::RoutingServiceResponse(reader, get_allocator_ref());
}

} // namespace RoutingService

} // namespace services
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>

#include <nds/routing/services/RangeProjectionService.h>

namespace nds
{
namespace routing
{
namespace services
{

namespace RangeProjectionService
{

Service::Service(const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator)
{}

::zserio::IServiceDataPtr Service::callMethod(
        ::zserio::StringView methodName, ::zserio::Span<const uint8_t> requestData, void* context)
{
    if (methodName == methodNames()[0])
        return getServiceModuleDefinitionMethod(requestData, context);
    if (methodName == methodNames()[1])
        return getServiceNodeSystemReferenceMethod(requestData, context);
    if (methodName == methodNames()[2])
        return getRangeProjectionServiceCapabilitiesMethod(requestData, context);
    if (methodName == methodNames()[3])
        return calculateRangeMethod(requestData, context);
    throw ::zserio::ServiceException("nds.routing.services.RangeProjectionService: Method '") << methodName << "' does not exist!";
}

::zserio::StringView Service::serviceFullName() noexcept
{
    static const ::zserio::StringView serviceFullName = ::zserio::makeStringView("nds.routing.services.RangeProjectionService");
    return serviceFullName;
}

const ::std::array<::zserio::StringView, 4>& Service::methodNames() noexcept
{
    static constexpr ::std::array<::zserio::StringView, 4> names =
    {
        ::zserio::makeStringView("getServiceModuleDefinition"),
        ::zserio::makeStringView("getServiceNodeSystemReference"),
        ::zserio::makeStringView("getRangeProjectionServiceCapabilities"),
        ::zserio::makeStringView("calculateRange")
    };

    return names;
}

::zserio::IServiceDataPtr Service::getServiceModuleDefinitionMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::ModuleDefinition&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceModuleDefinitionImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getServiceNodeSystemReferenceMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::system::types::NdsSystemToken&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getServiceNodeSystemReferenceImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::getRangeProjectionServiceCapabilitiesMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::core::types::Empty request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::routing::metadata::RangeProjectionServiceCapabilities&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            getRangeProjectionServiceCapabilitiesImpl(request, context), get_allocator_ref());
}

::zserio::IServiceDataPtr Service::calculateRangeMethod(
        ::zserio::Span<const uint8_t> requestData, void* context)
{
    ::zserio::BitStreamReader reader(requestData.data(), requestData.size());
    const ::nds::routing::services::RangeProjectionRequest request(reader, get_allocator_ref());

    class ResponseData : public ::zserio::IServiceDataPtr::element_type
    {
    public:
        ResponseData(::nds::routing::services::RangeProjectionResponse&& response, const allocator_type& allocator) :
                m_serviceData(response, allocator)
        {}

        ::zserio::IReflectableConstPtr getReflectable() const override
        {
            return m_serviceData.getReflectable();
        }

        ::zserio::Span<const uint8_t> getData() const override
        {
            return m_serviceData.getData();
        }

    private:
        ::zserio::ObjectServiceData m_serviceData;
    };

    return ::std::allocate_shared<ResponseData>(get_allocator_ref(),
            calculateRangeImpl(request, context), get_allocator_ref());
}

Client::Client(::zserio::IServiceClient& service, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<::std::allocator<uint8_t>>(allocator),
        m_service(service)
{
}

::nds::system::types::ModuleDefinition Client::getServiceModuleDefinitionMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceModuleDefinition"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::ModuleDefinition(reader, get_allocator_ref());
}

::nds::system::types::NdsSystemToken Client::getServiceNodeSystemReferenceMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getServiceNodeSystemReference"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::system::types::NdsSystemToken(reader, get_allocator_ref());
}

::nds::routing::metadata::RangeProjectionServiceCapabilities Client::getRangeProjectionServiceCapabilitiesMethod(const ::nds::core::types::Empty& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("getRangeProjectionServiceCapabilities"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::routing::metadata::RangeProjectionServiceCapabilities(reader, get_allocator_ref());
}

::nds::routing::services::RangeProjectionResponse Client::calculateRangeMethod(const ::nds::routing::services::RangeProjectionRequest& request, void* context)
{
    const ::zserio::ObjectServiceData requestData(request, get_allocator_ref());

    auto responseData = m_service.callMethod(::zserio::makeStringView("calculateRange"), requestData, context);

    ::zserio::BitStreamReader reader(responseData.data(), responseData.size());
    return ::nds::routing::services::RangeProjectionResponse(reader, get_allocator_ref());
}

} // namespace RangeProjectionService

} // namespace services
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitBuffer.h>
#include <zserio/StringView.h>

#include <nds/routing/services/RoutingTopics.h>

namespace nds
{
namespace routing
{
namespace services
{

namespace
{

template <typename ZSERIO_MESSAGE>
class RoutingTopicsOnRaw : public ::zserio::IPubsub::OnTopicCallback
{
public:
    explicit RoutingTopicsOnRaw(const ::std::shared_ptr<RoutingTopics::RoutingTopicsCallback<ZSERIO_MESSAGE>>& callback,
            const ::std::allocator<uint8_t>& allocator) :
            m_callback(callback), m_allocator(allocator)
    {}

    void operator()(::zserio::StringView topic, ::zserio::Span<const uint8_t> data) override
    {
        ::zserio::BitStreamReader reader(data.data(), data.size());
        const ZSERIO_MESSAGE message(reader, m_allocator);

        m_callback->operator()(topic, message);
    }

private:
    ::std::shared_ptr<RoutingTopics::RoutingTopicsCallback<ZSERIO_MESSAGE>> m_callback;
    ::std::allocator<uint8_t> m_allocator;
};

} // namespace

RoutingTopics::RoutingTopics(::zserio::IPubsub& pubsub, const allocator_type& allocator) :
        ::zserio::AllocatorHolder<allocator_type>(allocator),
        m_pubsub(pubsub)
{
}

void RoutingTopics::publishCurrentRoute(const ::nds::routing::route::Route& message, void* context)
{
    publish(message, ::zserio::makeStringView("nds/routing/current_route"), context);
}

::zserio::IPubsub::SubscriptionId RoutingTopics::subscribeCurrentRoute(
        const ::std::shared_ptr<RoutingTopicsCallback<::nds::routing::route::Route>>& callback,
        void* context)
{
    const auto& onRawCallback = ::std::allocate_shared<RoutingTopicsOnRaw<::nds::routing::route::Route>>(
            get_allocator_ref(), callback, get_allocator_ref());
    return m_pubsub.subscribe(::zserio::makeStringView("nds/routing/current_route"), onRawCallback, context);
}

void RoutingTopics::unsubscribe(::zserio::IPubsub::SubscriptionId id)
{
    m_pubsub.unsubscribe(id);
}

template <typename ZSERIO_MESSAGE>
void RoutingTopics::publish(ZSERIO_MESSAGE& message, ::zserio::StringView topic, void* context)
{
    ::zserio::BitBuffer bitBuffer(message.bitSizeOf(), get_allocator_ref());
    ::zserio::BitStreamWriter writer(bitBuffer);
    message.write(writer);
    m_pubsub.publish(topic, bitBuffer.getBytes(), context);
}

} // namespace services
} // namespace routing
} // namespace nds
