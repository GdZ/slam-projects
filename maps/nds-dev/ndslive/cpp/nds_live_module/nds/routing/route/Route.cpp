/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/route/DelayReasonType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DelayReasonType enumeration.
constexpr ::std::array<const char*, 69> EnumTraits<::nds::routing::route::DelayReasonType>::names;
constexpr ::std::array<::nds::routing::route::DelayReasonType, 69> EnumTraits<::nds::routing::route::DelayReasonType>::values;
constexpr const char* EnumTraits<::nds::routing::route::DelayReasonType>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::route::DelayReasonType value)
{
    switch (value)
    {
    case ::nds::routing::route::DelayReasonType::UNKNOWN:
        return 0;
    case ::nds::routing::route::DelayReasonType::TRAFFIC_CONGESTION:
        return 1;
    case ::nds::routing::route::DelayReasonType::ACCIDENT:
        return 2;
    case ::nds::routing::route::DelayReasonType::ROADWORKS:
        return 3;
    case ::nds::routing::route::DelayReasonType::NARROW_LANES:
        return 4;
    case ::nds::routing::route::DelayReasonType::IMPASSIBILITY:
        return 5;
    case ::nds::routing::route::DelayReasonType::SLIPPERY_ROAD:
        return 6;
    case ::nds::routing::route::DelayReasonType::AQUAPLANING:
        return 7;
    case ::nds::routing::route::DelayReasonType::FIRE:
        return 8;
    case ::nds::routing::route::DelayReasonType::HAZARDOUS_DRIVING_CONDITIONS:
        return 9;
    case ::nds::routing::route::DelayReasonType::OBJECTS_ON_THE_ROAD:
        return 10;
    case ::nds::routing::route::DelayReasonType::ANIMALS_ON_ROADWAY:
        return 11;
    case ::nds::routing::route::DelayReasonType::PEOPLE_ON_ROADWAY:
        return 12;
    case ::nds::routing::route::DelayReasonType::BROKEN_DOWN_VEHICLES:
        return 13;
    case ::nds::routing::route::DelayReasonType::VEHICLE_ON_WRONG_CARRIAGE_WAY_GHOSTDRIVER:
        return 14;
    case ::nds::routing::route::DelayReasonType::RESCUE_RECOVERY_IN_PROGRESS:
        return 15;
    case ::nds::routing::route::DelayReasonType::REGULATORY_MEASURE:
        return 16;
    case ::nds::routing::route::DelayReasonType::EXTREME_WEATHER_CONDITIONS:
        return 17;
    case ::nds::routing::route::DelayReasonType::VISIBILITY_REDUCED:
        return 18;
    case ::nds::routing::route::DelayReasonType::PRECIPITATION:
        return 19;
    case ::nds::routing::route::DelayReasonType::RECKLESS_PERSONS:
        return 20;
    case ::nds::routing::route::DelayReasonType::OVERHEIGHT_WARNING_SYSTEM_TRIGGERED:
        return 21;
    case ::nds::routing::route::DelayReasonType::TRAFFIC_REGULATIONS_CHANGED:
        return 22;
    case ::nds::routing::route::DelayReasonType::MAJOR_EVENT:
        return 23;
    case ::nds::routing::route::DelayReasonType::SERVICE_NOT_OPERATING:
        return 24;
    case ::nds::routing::route::DelayReasonType::SERVICE_NOT_USABLE:
        return 25;
    case ::nds::routing::route::DelayReasonType::SLOW_MOVING_VEHICLES:
        return 26;
    case ::nds::routing::route::DelayReasonType::DANGEROUS_END_OF_QUEUE:
        return 27;
    case ::nds::routing::route::DelayReasonType::RISK_OF_FIRE:
        return 28;
    case ::nds::routing::route::DelayReasonType::TIME_DELAY:
        return 29;
    case ::nds::routing::route::DelayReasonType::POLICE_CHECKPOINT:
        return 30;
    case ::nds::routing::route::DelayReasonType::MALFUNCTIONING_ROADSIDE_EQUIPMENT:
        return 31;
    case ::nds::routing::route::DelayReasonType::SERIOUS_ACCIDENT:
        return 32;
    case ::nds::routing::route::DelayReasonType::EARLIER_ACCIDENT:
        return 33;
    case ::nds::routing::route::DelayReasonType::ACCIDENT_REPORTED:
        return 34;
    case ::nds::routing::route::DelayReasonType::ACCIDENT_INVESTIGATION_WORK:
        return 35;
    case ::nds::routing::route::DelayReasonType::MULTI_VEHICLE_ACCIDENT:
        return 36;
    case ::nds::routing::route::DelayReasonType::ACCIDENT_INVOLVING_LORRY:
        return 37;
    case ::nds::routing::route::DelayReasonType::ACCIDENT_TRAFFIC_BEING_DIRECTED_AROUND:
        return 38;
    case ::nds::routing::route::DelayReasonType::LONG_TERM_ROADWORKS:
        return 39;
    case ::nds::routing::route::DelayReasonType::CONSTRUCTION_WORK:
        return 40;
    case ::nds::routing::route::DelayReasonType::BRIDGE_MAINTENANCE_WORK:
        return 41;
    case ::nds::routing::route::DelayReasonType::RESURFACING_WORK:
        return 42;
    case ::nds::routing::route::DelayReasonType::MAJOR_ROADWORKS:
        return 43;
    case ::nds::routing::route::DelayReasonType::ROAD_MAINTENANCE_WORKS:
        return 44;
    case ::nds::routing::route::DelayReasonType::ROADWORKS_DURING_NIGHT:
        return 45;
    case ::nds::routing::route::DelayReasonType::ROADWORKS_SINGLE_LINE_TRAFFIC_ALTERNATE_DIRECTIONS:
        return 46;
    case ::nds::routing::route::DelayReasonType::FLOODING:
        return 47;
    case ::nds::routing::route::DelayReasonType::SNOW_ON_ROAD:
        return 48;
    case ::nds::routing::route::DelayReasonType::ICE_ON_ROAD:
        return 49;
    case ::nds::routing::route::DelayReasonType::BLACK_ICE_ON_ROAD:
        return 50;
    case ::nds::routing::route::DelayReasonType::GRASS_FIRE:
        return 51;
    case ::nds::routing::route::DelayReasonType::FOREST_FIRE:
        return 52;
    case ::nds::routing::route::DelayReasonType::OVERTURNED_VEHICLE:
        return 53;
    case ::nds::routing::route::DelayReasonType::BROKEN_DOWN_LORRY:
        return 54;
    case ::nds::routing::route::DelayReasonType::VEHICLE_SPUN_AROUND:
        return 55;
    case ::nds::routing::route::DelayReasonType::VEHICLE_ON_FIRE:
        return 56;
    case ::nds::routing::route::DelayReasonType::GUSTY_WINDS:
        return 57;
    case ::nds::routing::route::DelayReasonType::STRONG_WINDS:
        return 58;
    case ::nds::routing::route::DelayReasonType::THUNDERSTORM:
        return 59;
    case ::nds::routing::route::DelayReasonType::VISIBILITY_REDUCED_BY_FOG:
        return 60;
    case ::nds::routing::route::DelayReasonType::VISIBILITY_REDUCED_BY_LOW_SUN_GLARE:
        return 61;
    case ::nds::routing::route::DelayReasonType::SNOW:
        return 62;
    case ::nds::routing::route::DelayReasonType::RAIN:
        return 63;
    case ::nds::routing::route::DelayReasonType::HAIL:
        return 64;
    case ::nds::routing::route::DelayReasonType::SPORTS_EVENT:
        return 65;
    case ::nds::routing::route::DelayReasonType::TRAFFIC_CONTROL_SIGNALS_NOT_WORKING:
        return 66;
    case ::nds::routing::route::DelayReasonType::TRAFFIC_CONTROL_SIGNALS_WORKING_INCORRECTLY:
        return 67;
    case ::nds::routing::route::DelayReasonType::CLOSURE:
        return 68;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DelayReasonType: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::route::DelayReasonType>::type>(value) << "!";
    }
}

template <>
::nds::routing::route::DelayReasonType valueToEnum(
        typename ::std::underlying_type<::nds::routing::route::DelayReasonType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
    case UINT16_C(18):
    case UINT16_C(19):
    case UINT16_C(20):
    case UINT16_C(21):
    case UINT16_C(22):
    case UINT16_C(23):
    case UINT16_C(24):
    case UINT16_C(25):
    case UINT16_C(26):
    case UINT16_C(27):
    case UINT16_C(28):
    case UINT16_C(29):
    case UINT16_C(30):
    case UINT16_C(31):
    case UINT16_C(32):
    case UINT16_C(33):
    case UINT16_C(34):
    case UINT16_C(35):
    case UINT16_C(36):
    case UINT16_C(37):
    case UINT16_C(38):
    case UINT16_C(39):
    case UINT16_C(40):
    case UINT16_C(41):
    case UINT16_C(42):
    case UINT16_C(43):
    case UINT16_C(44):
    case UINT16_C(45):
    case UINT16_C(46):
    case UINT16_C(47):
    case UINT16_C(48):
    case UINT16_C(49):
    case UINT16_C(50):
    case UINT16_C(51):
    case UINT16_C(52):
    case UINT16_C(53):
    case UINT16_C(54):
    case UINT16_C(55):
    case UINT16_C(56):
    case UINT16_C(57):
    case UINT16_C(58):
    case UINT16_C(59):
    case UINT16_C(60):
    case UINT16_C(61):
    case UINT16_C(62):
    case UINT16_C(63):
    case UINT16_C(64):
    case UINT16_C(65):
    case UINT16_C(66):
    case UINT16_C(67):
    case UINT16_C(68):
        return static_cast<::nds::routing::route::DelayReasonType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DelayReasonType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::route::DelayReasonType>(::nds::routing::route::DelayReasonType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::route::DelayReasonType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::routing::route::DelayReasonType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::route::DelayReasonType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::route::DelayReasonType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::routing::route::DelayReasonType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::route::DelayReasonType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::route::DelayReasonType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::route::DelayReasonType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::route::DelayReasonType>(
            static_cast<typename ::std::underlying_type<::nds::routing::route::DelayReasonType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::routing::route::DelayReasonType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::route::DelayReasonType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::routing::route::DelayReasonType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::route::DelayReasonType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::route::DelayReasonType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::routing::route::DelayReasonType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/route/Route.h>

namespace nds
{
namespace routing
{
namespace route
{

Route::Route(const allocator_type& allocator) noexcept :
        m_length_(::nds::core::types::LengthCentimeters()),
        m_travelTime_(::nds::core::types::Seconds()),
        m_routePath_(allocator),
        m_routePointTypes_(allocator),
        m_numRouteSegments_(uint32_t()),
        m_segments_(allocator),
        m_vehicleConsumption_(::zserio::NullOpt),
        m_guidance_(::zserio::NullOpt),
        m_geometries_(::zserio::NullOpt)
{
}

Route::Route(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_length_(readLength(in)),
        m_travelTime_(readTravelTime(in)),
        m_routePath_(readRoutePath(in, allocator)),
        m_routePointTypes_(readRoutePointTypes(in, allocator)),
        m_numRouteSegments_(readNumRouteSegments(in)),
        m_segments_(readSegments(in, allocator)),
        m_vehicleConsumption_(readVehicleConsumption(in, allocator)),
        m_guidance_(readGuidance(in, allocator)),
        m_geometries_(readGeometries(in, allocator))
{
}

Route::Route(Route::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_length_(readLength(context, in)),
        m_travelTime_(readTravelTime(context, in)),
        m_routePath_(readRoutePath(context, in, allocator)),
        m_routePointTypes_(readRoutePointTypes(context, in, allocator)),
        m_numRouteSegments_(readNumRouteSegments(context, in)),
        m_segments_(readSegments(context, in, allocator)),
        m_vehicleConsumption_(readVehicleConsumption(context, in, allocator)),
        m_guidance_(readGuidance(context, in, allocator)),
        m_geometries_(readGeometries(context, in, allocator))
{
}

Route::Route(::zserio::PropagateAllocatorT,
        const Route& other, const allocator_type& allocator) :
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator)),
        m_travelTime_(::zserio::allocatorPropagatingCopy(other.m_travelTime_, allocator)),
        m_routePath_(::zserio::allocatorPropagatingCopy(other.m_routePath_, allocator)),
        m_routePointTypes_(::zserio::allocatorPropagatingCopy(other.m_routePointTypes_, allocator)),
        m_numRouteSegments_(::zserio::allocatorPropagatingCopy(other.m_numRouteSegments_, allocator)),
        m_segments_(::zserio::allocatorPropagatingCopy(other.m_segments_, allocator)),
        m_vehicleConsumption_(::zserio::allocatorPropagatingCopy(other.m_vehicleConsumption_, allocator)),
        m_guidance_(::zserio::allocatorPropagatingCopy(other.m_guidance_, allocator)),
        m_geometries_(::zserio::allocatorPropagatingCopy(other.m_geometries_, allocator))
{
}

void Route::initializeChildren()
{
    m_routePath_.initializeChildren();
    m_segments_.initializeElements(*this);
    if (isGuidanceSet())
        m_guidance_.value().initializeChildren();
    if (isGeometriesSet())
        m_geometries_.value().initializeElements(*this);
}

::nds::core::types::LengthCentimeters Route::getLength() const
{
    return m_length_;
}

void Route::setLength(::nds::core::types::LengthCentimeters length_)
{
    m_length_ = length_;
}

::nds::core::types::Seconds Route::getTravelTime() const
{
    return m_travelTime_;
}

void Route::setTravelTime(::nds::core::types::Seconds travelTime_)
{
    m_travelTime_ = travelTime_;
}

::nds::core::location::RoadLocationPath& Route::getRoutePath()
{
    return m_routePath_;
}

const ::nds::core::location::RoadLocationPath& Route::getRoutePath() const
{
    return m_routePath_;
}

void Route::setRoutePath(const ::nds::core::location::RoadLocationPath& routePath_)
{
    m_routePath_ = routePath_;
}

void Route::setRoutePath(::nds::core::location::RoadLocationPath&& routePath_)
{
    m_routePath_ = ::std::move(routePath_);
}

::zserio::vector<::nds::routing::route::RoutePoint>& Route::getRoutePointTypes()
{
    return m_routePointTypes_.getRawArray();
}

const ::zserio::vector<::nds::routing::route::RoutePoint>& Route::getRoutePointTypes() const
{
    return m_routePointTypes_.getRawArray();
}

void Route::setRoutePointTypes(const ::zserio::vector<::nds::routing::route::RoutePoint>& routePointTypes_)
{
    m_routePointTypes_ = ZserioArrayType_routePointTypes(routePointTypes_);
}

void Route::setRoutePointTypes(::zserio::vector<::nds::routing::route::RoutePoint>&& routePointTypes_)
{
    m_routePointTypes_ = ZserioArrayType_routePointTypes(std::move(routePointTypes_));
}

uint32_t Route::getNumRouteSegments() const
{
    return m_numRouteSegments_;
}

void Route::setNumRouteSegments(uint32_t numRouteSegments_)
{
    m_numRouteSegments_ = numRouteSegments_;
}

::zserio::vector<::nds::routing::route::RouteSegment>& Route::getSegments()
{
    return m_segments_.getRawArray();
}

const ::zserio::vector<::nds::routing::route::RouteSegment>& Route::getSegments() const
{
    return m_segments_.getRawArray();
}

void Route::setSegments(const ::zserio::vector<::nds::routing::route::RouteSegment>& segments_)
{
    m_segments_ = ZserioArrayType_segments(segments_);
}

void Route::setSegments(::zserio::vector<::nds::routing::route::RouteSegment>&& segments_)
{
    m_segments_ = ZserioArrayType_segments(std::move(segments_));
}

::zserio::vector<::nds::routing::types::RouteSegmentConsumption>& Route::getVehicleConsumption()
{
    return m_vehicleConsumption_.value().getRawArray();
}

const ::zserio::vector<::nds::routing::types::RouteSegmentConsumption>& Route::getVehicleConsumption() const
{
    return m_vehicleConsumption_.value().getRawArray();
}

void Route::setVehicleConsumption(const ::zserio::vector<::nds::routing::types::RouteSegmentConsumption>& vehicleConsumption_)
{
    m_vehicleConsumption_ = ZserioArrayType_vehicleConsumption(vehicleConsumption_);
}

void Route::setVehicleConsumption(::zserio::vector<::nds::routing::types::RouteSegmentConsumption>&& vehicleConsumption_)
{
    m_vehicleConsumption_ = ZserioArrayType_vehicleConsumption(std::move(vehicleConsumption_));
}

bool Route::isVehicleConsumptionUsed() const
{
    return (isVehicleConsumptionSet());
}

bool Route::isVehicleConsumptionSet() const
{
    return m_vehicleConsumption_.hasValue();
}

void Route::resetVehicleConsumption()
{
    m_vehicleConsumption_.reset();
}

::nds::routing::guidance::GuidanceInstructions& Route::getGuidance()
{
    return m_guidance_.value();
}

const ::nds::routing::guidance::GuidanceInstructions& Route::getGuidance() const
{
    return m_guidance_.value();
}

void Route::setGuidance(const ::nds::routing::guidance::GuidanceInstructions& guidance_)
{
    m_guidance_ = guidance_;
}

void Route::setGuidance(::nds::routing::guidance::GuidanceInstructions&& guidance_)
{
    m_guidance_ = ::std::move(guidance_);
}

bool Route::isGuidanceUsed() const
{
    return (isGuidanceSet());
}

bool Route::isGuidanceSet() const
{
    return m_guidance_.hasValue();
}

void Route::resetGuidance()
{
    m_guidance_.reset();
}

::zserio::vector<::nds::routing::route::RouteGeometry>& Route::getGeometries()
{
    return m_geometries_.value().getRawArray();
}

const ::zserio::vector<::nds::routing::route::RouteGeometry>& Route::getGeometries() const
{
    return m_geometries_.value().getRawArray();
}

void Route::setGeometries(const ::zserio::vector<::nds::routing::route::RouteGeometry>& geometries_)
{
    m_geometries_ = ZserioArrayType_geometries(geometries_);
}

void Route::setGeometries(::zserio::vector<::nds::routing::route::RouteGeometry>&& geometries_)
{
    m_geometries_ = ZserioArrayType_geometries(std::move(geometries_));
}

bool Route::isGeometriesUsed() const
{
    return (isGeometriesSet());
}

bool Route::isGeometriesSet() const
{
    return m_geometries_.hasValue();
}

void Route::resetGeometries()
{
    m_geometries_.reset();
}

void Route::initPackingContext(Route::ZserioPackingContext& context) const
{
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_length_);
    context.getTravelTime().init<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_travelTime_);
    m_routePath_.initPackingContext(context.getRoutePath());
    context.getNumRouteSegments().init<::zserio::VarIntNNArrayTraits<uint32_t>>(m_numRouteSegments_);
    if (isGuidanceSet())
    {
        m_guidance_.value().initPackingContext(context.getGuidance());
    }
}

size_t Route::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += ::zserio::bitSizeOfVarUInt(m_travelTime_);
    endBitPosition += m_routePath_.bitSizeOf(endBitPosition);
    endBitPosition += m_routePointTypes_.bitSizeOf(*this, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_numRouteSegments_);
    endBitPosition += m_segments_.bitSizeOf(*this, endBitPosition);
    endBitPosition += 1;
    if (isVehicleConsumptionSet())
    {
        endBitPosition += m_vehicleConsumption_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isGuidanceSet())
    {
        endBitPosition += m_guidance_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isGeometriesSet())
    {
        endBitPosition += m_geometries_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Route::bitSizeOf(Route::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_length_);
    endBitPosition += context.getTravelTime().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_travelTime_);
    endBitPosition += m_routePath_.bitSizeOf(context.getRoutePath(), endBitPosition);
    endBitPosition += m_routePointTypes_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += context.getNumRouteSegments().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_numRouteSegments_);
    endBitPosition += m_segments_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isVehicleConsumptionSet())
    {
        endBitPosition += m_vehicleConsumption_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isGuidanceSet())
    {
        endBitPosition += m_guidance_.value().bitSizeOf(context.getGuidance(), endBitPosition);
    }
    endBitPosition += 1;
    if (isGeometriesSet())
    {
        endBitPosition += m_geometries_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Route::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += ::zserio::bitSizeOfVarUInt(m_travelTime_);
    endBitPosition = m_routePath_.initializeOffsets(endBitPosition);
    endBitPosition = m_routePointTypes_.initializeOffsets(*this, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_numRouteSegments_);
    endBitPosition = m_segments_.initializeOffsets(*this, endBitPosition);
    endBitPosition += 1;
    if (isVehicleConsumptionSet())
    {
        endBitPosition = m_vehicleConsumption_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isGuidanceSet())
    {
        endBitPosition = m_guidance_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isGeometriesSet())
    {
        endBitPosition = m_geometries_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t Route::initializeOffsets(Route::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_length_);
    endBitPosition += context.getTravelTime().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_travelTime_);
    endBitPosition = m_routePath_.initializeOffsets(context.getRoutePath(), endBitPosition);
    endBitPosition = m_routePointTypes_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += context.getNumRouteSegments().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_numRouteSegments_);
    endBitPosition = m_segments_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += 1;
    if (isVehicleConsumptionSet())
    {
        endBitPosition = m_vehicleConsumption_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition += 1;
    if (isGuidanceSet())
    {
        endBitPosition = m_guidance_.value().initializeOffsets(context.getGuidance(), endBitPosition);
    }
    endBitPosition += 1;
    if (isGeometriesSet())
    {
        endBitPosition = m_geometries_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool Route::operator==(const Route& other) const
{
    if (this != &other)
    {
        return
                (m_length_ == other.m_length_) &&
                (m_travelTime_ == other.m_travelTime_) &&
                (m_routePath_ == other.m_routePath_) &&
                (m_routePointTypes_ == other.m_routePointTypes_) &&
                (m_numRouteSegments_ == other.m_numRouteSegments_) &&
                (m_segments_ == other.m_segments_) &&
                (!isVehicleConsumptionUsed() ? !other.isVehicleConsumptionUsed() : (m_vehicleConsumption_ == other.m_vehicleConsumption_)) &&
                (!isGuidanceUsed() ? !other.isGuidanceUsed() : (m_guidance_ == other.m_guidance_)) &&
                (!isGeometriesUsed() ? !other.isGeometriesUsed() : (m_geometries_ == other.m_geometries_));
    }

    return true;
}

uint32_t Route::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_length_);
    result = ::zserio::calcHashCode(result, m_travelTime_);
    result = ::zserio::calcHashCode(result, m_routePath_);
    result = ::zserio::calcHashCode(result, m_routePointTypes_);
    result = ::zserio::calcHashCode(result, m_numRouteSegments_);
    result = ::zserio::calcHashCode(result, m_segments_);
    if (isVehicleConsumptionUsed())
        result = ::zserio::calcHashCode(result, m_vehicleConsumption_);
    if (isGuidanceUsed())
        result = ::zserio::calcHashCode(result, m_guidance_);
    if (isGeometriesUsed())
        result = ::zserio::calcHashCode(result, m_geometries_);

    return result;
}

void Route::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_length_);

    out.writeVarUInt(m_travelTime_);

    m_routePath_.write(out);

    // check array length
    if (m_routePointTypes_.getRawArray().size() != static_cast<size_t>(getRoutePath().getPathGeometry().getLine().getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Route.routePointTypes: ") <<
                m_routePointTypes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getRoutePath().getPathGeometry().getLine().getNumPositions()) << "!";
    }
    m_routePointTypes_.write(*this, out);

    out.writeVarUInt32(m_numRouteSegments_);

    // check array length
    if (m_segments_.getRawArray().size() != static_cast<size_t>(getNumRouteSegments()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Route.segments: ") <<
                m_segments_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRouteSegments()) << "!";
    }
    m_segments_.write(*this, out);

    if (isVehicleConsumptionSet())
    {
        out.writeBool(true);
        // check array length
        if (m_vehicleConsumption_.value().getRawArray().size() != static_cast<size_t>(getNumRouteSegments()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Route.vehicleConsumption: ") <<
                    m_vehicleConsumption_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRouteSegments()) << "!";
        }
        m_vehicleConsumption_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isGuidanceSet())
    {
        out.writeBool(true);
        m_guidance_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isGeometriesSet())
    {
        out.writeBool(true);
        m_geometries_.value().write(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void Route::write(Route::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(out, m_length_);

    context.getTravelTime().write<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(out, m_travelTime_);

    m_routePath_.write(context.getRoutePath(), out);

    // check array length
    if (m_routePointTypes_.getRawArray().size() != static_cast<size_t>(getRoutePath().getPathGeometry().getLine().getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Route.routePointTypes: ") <<
                m_routePointTypes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getRoutePath().getPathGeometry().getLine().getNumPositions()) << "!";
    }
    m_routePointTypes_.writePacked(*this, out);

    context.getNumRouteSegments().write<::zserio::VarIntNNArrayTraits<uint32_t>>(out, m_numRouteSegments_);

    // check array length
    if (m_segments_.getRawArray().size() != static_cast<size_t>(getNumRouteSegments()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Route.segments: ") <<
                m_segments_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRouteSegments()) << "!";
    }
    m_segments_.writePacked(*this, out);

    if (isVehicleConsumptionSet())
    {
        out.writeBool(true);
        // check array length
        if (m_vehicleConsumption_.value().getRawArray().size() != static_cast<size_t>(getNumRouteSegments()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Route.vehicleConsumption: ") <<
                    m_vehicleConsumption_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRouteSegments()) << "!";
        }
        m_vehicleConsumption_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isGuidanceSet())
    {
        out.writeBool(true);
        m_guidance_.value().write(context.getGuidance(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isGeometriesSet())
    {
        out.writeBool(true);
        m_geometries_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void Route::ZserioElementFactory_routePointTypes::create(Route&        ,
        ::zserio::vector<::nds::routing::route::RoutePoint>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Route::ZserioElementFactory_routePointTypes::create(Route&        ,
        ::zserio::vector<::nds::routing::route::RoutePoint>& array,
        ::nds::routing::route::RoutePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void Route::ZserioArrayExpressions_segments::initializeElement(Route&,
        ::nds::routing::route::RouteSegment& element, size_t)
{
    element.initializeChildren();
}

void Route::ZserioElementFactory_segments::create(Route&        ,
        ::zserio::vector<::nds::routing::route::RouteSegment>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Route::ZserioElementFactory_segments::create(Route&        ,
        ::zserio::vector<::nds::routing::route::RouteSegment>& array,
        ::nds::routing::route::RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void Route::ZserioElementFactory_vehicleConsumption::create(Route&        ,
        ::zserio::vector<::nds::routing::types::RouteSegmentConsumption>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Route::ZserioElementFactory_vehicleConsumption::create(Route&        ,
        ::zserio::vector<::nds::routing::types::RouteSegmentConsumption>& array,
        ::nds::routing::types::RouteSegmentConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void Route::ZserioArrayExpressions_geometries::initializeElement(Route&,
        ::nds::routing::route::RouteGeometry& element, size_t)
{
    element.initializeChildren();
}

void Route::ZserioElementFactory_geometries::create(Route&        ,
        ::zserio::vector<::nds::routing::route::RouteGeometry>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Route::ZserioElementFactory_geometries::create(Route&        ,
        ::zserio::vector<::nds::routing::route::RouteGeometry>& array,
        ::nds::routing::route::RouteGeometry::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::types::LengthCentimeters Route::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LengthCentimeters>(in.readVarUInt32());
}

::nds::core::types::LengthCentimeters Route::readLength(Route::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(in);
}
::nds::core::types::Seconds Route::readTravelTime(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::Seconds>(in.readVarUInt());
}

::nds::core::types::Seconds Route::readTravelTime(Route::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTravelTime().read<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(in);
}
::nds::core::location::RoadLocationPath Route::readRoutePath(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationPath(in, allocator);
}

::nds::core::location::RoadLocationPath Route::readRoutePath(Route::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::RoadLocationPath(context.getRoutePath(), in, allocator);
}
Route::ZserioArrayType_routePointTypes Route::readRoutePointTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_routePointTypes readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getRoutePath().getPathGeometry().getLine().getNumPositions()));

    return readField;
}

Route::ZserioArrayType_routePointTypes Route::readRoutePointTypes(Route::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_routePointTypes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getRoutePath().getPathGeometry().getLine().getNumPositions()));

    return readField;
}
uint32_t Route::readNumRouteSegments(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarUInt32());
}

uint32_t Route::readNumRouteSegments(Route::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumRouteSegments().read<::zserio::VarIntNNArrayTraits<uint32_t>>(in);
}
Route::ZserioArrayType_segments Route::readSegments(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumRouteSegments()));

    return readField;
}

Route::ZserioArrayType_segments Route::readSegments(Route::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_segments readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumRouteSegments()));

    return readField;
}
::zserio::InplaceOptionalHolder<Route::ZserioArrayType_vehicleConsumption> Route::readVehicleConsumption(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_vehicleConsumption readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumRouteSegments()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_vehicleConsumption>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_vehicleConsumption>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<Route::ZserioArrayType_vehicleConsumption> Route::readVehicleConsumption(Route::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_vehicleConsumption readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumRouteSegments()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_vehicleConsumption>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_vehicleConsumption>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceInstructions> Route::readGuidance(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceInstructions>(::nds::routing::guidance::GuidanceInstructions(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceInstructions>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceInstructions> Route::readGuidance(Route::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceInstructions>(::nds::routing::guidance::GuidanceInstructions(context.getGuidance(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceInstructions>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<Route::ZserioArrayType_geometries> Route::readGeometries(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_geometries readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_geometries>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_geometries>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<Route::ZserioArrayType_geometries> Route::readGeometries(Route::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_geometries readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_geometries>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_geometries>(::zserio::NullOpt);
}

} // namespace route
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/route/RoutePoint.h>

namespace nds
{
namespace routing
{
namespace route
{

RoutePoint::RoutePoint(const allocator_type&) noexcept :
        m_type_(::nds::routing::types::RoutePointType()),
        m_waypointType_(::zserio::NullOpt),
        m_departureTime_(::zserio::NullOpt),
        m_arrivalTime_(::zserio::NullOpt)
{
}

RoutePoint::RoutePoint(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_waypointType_(readWaypointType(in)),
        m_departureTime_(readDepartureTime(in, allocator)),
        m_arrivalTime_(readArrivalTime(in, allocator))
{
}

RoutePoint::RoutePoint(RoutePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_waypointType_(readWaypointType(context, in)),
        m_departureTime_(readDepartureTime(context, in, allocator)),
        m_arrivalTime_(readArrivalTime(context, in, allocator))
{
}

RoutePoint::RoutePoint(::zserio::PropagateAllocatorT,
        const RoutePoint& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_waypointType_(::zserio::allocatorPropagatingCopy(other.m_waypointType_, allocator)),
        m_departureTime_(::zserio::allocatorPropagatingCopy(other.m_departureTime_, allocator)),
        m_arrivalTime_(::zserio::allocatorPropagatingCopy(other.m_arrivalTime_, allocator))
{
}

::nds::routing::types::RoutePointType RoutePoint::getType() const
{
    return m_type_;
}

void RoutePoint::setType(::nds::routing::types::RoutePointType type_)
{
    m_type_ = type_;
}

::nds::routing::types::WaypointType RoutePoint::getWaypointType() const
{
    return m_waypointType_.value();
}

void RoutePoint::setWaypointType(::nds::routing::types::WaypointType waypointType_)
{
    m_waypointType_ = waypointType_;
}

bool RoutePoint::isWaypointTypeUsed() const
{
    return (isWaypointTypeSet());
}

bool RoutePoint::isWaypointTypeSet() const
{
    return m_waypointType_.hasValue();
}

void RoutePoint::resetWaypointType()
{
    m_waypointType_.reset();
}

::nds::core::types::TimeWithZone& RoutePoint::getDepartureTime()
{
    return m_departureTime_.value();
}

const ::nds::core::types::TimeWithZone& RoutePoint::getDepartureTime() const
{
    return m_departureTime_.value();
}

void RoutePoint::setDepartureTime(const ::nds::core::types::TimeWithZone& departureTime_)
{
    m_departureTime_ = departureTime_;
}

void RoutePoint::setDepartureTime(::nds::core::types::TimeWithZone&& departureTime_)
{
    m_departureTime_ = ::std::move(departureTime_);
}

bool RoutePoint::isDepartureTimeUsed() const
{
    return (isDepartureTimeSet());
}

bool RoutePoint::isDepartureTimeSet() const
{
    return m_departureTime_.hasValue();
}

void RoutePoint::resetDepartureTime()
{
    m_departureTime_.reset();
}

::nds::core::types::TimeWithZone& RoutePoint::getArrivalTime()
{
    return m_arrivalTime_.value();
}

const ::nds::core::types::TimeWithZone& RoutePoint::getArrivalTime() const
{
    return m_arrivalTime_.value();
}

void RoutePoint::setArrivalTime(const ::nds::core::types::TimeWithZone& arrivalTime_)
{
    m_arrivalTime_ = arrivalTime_;
}

void RoutePoint::setArrivalTime(::nds::core::types::TimeWithZone&& arrivalTime_)
{
    m_arrivalTime_ = ::std::move(arrivalTime_);
}

bool RoutePoint::isArrivalTimeUsed() const
{
    return (isArrivalTimeSet());
}

bool RoutePoint::isArrivalTimeSet() const
{
    return m_arrivalTime_.hasValue();
}

void RoutePoint::resetArrivalTime()
{
    m_arrivalTime_.reset();
}

void RoutePoint::initPackingContext(RoutePoint::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (isWaypointTypeSet())
    {
        ::zserio::initPackingContext(context.getWaypointType(), m_waypointType_.value());
    }
    if (isDepartureTimeSet())
    {
        m_departureTime_.value().initPackingContext(context.getDepartureTime());
    }
    if (isArrivalTimeSet())
    {
        m_arrivalTime_.value().initPackingContext(context.getArrivalTime());
    }
}

size_t RoutePoint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += 1;
    if (isWaypointTypeSet())
    {
        endBitPosition += ::zserio::bitSizeOf(m_waypointType_.value());
    }
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition += m_departureTime_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition += m_arrivalTime_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutePoint::bitSizeOf(RoutePoint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += 1;
    if (isWaypointTypeSet())
    {
        endBitPosition += ::zserio::bitSizeOf(context.getWaypointType(), m_waypointType_.value());
    }
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition += m_departureTime_.value().bitSizeOf(context.getDepartureTime(), endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition += m_arrivalTime_.value().bitSizeOf(context.getArrivalTime(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoutePoint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += 1;
    if (isWaypointTypeSet())
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_waypointType_.value());
    }
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition = m_departureTime_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition = m_arrivalTime_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RoutePoint::initializeOffsets(RoutePoint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += 1;
    if (isWaypointTypeSet())
    {
        endBitPosition = ::zserio::initializeOffsets(context.getWaypointType(), endBitPosition,
        m_waypointType_.value());
    }
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition = m_departureTime_.value().initializeOffsets(context.getDepartureTime(), endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition = m_arrivalTime_.value().initializeOffsets(context.getArrivalTime(), endBitPosition);
    }

    return endBitPosition;
}

bool RoutePoint::operator==(const RoutePoint& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isWaypointTypeUsed() ? !other.isWaypointTypeUsed() : (m_waypointType_ == other.m_waypointType_)) &&
                (!isDepartureTimeUsed() ? !other.isDepartureTimeUsed() : (m_departureTime_ == other.m_departureTime_)) &&
                (!isArrivalTimeUsed() ? !other.isArrivalTimeUsed() : (m_arrivalTime_ == other.m_arrivalTime_));
    }

    return true;
}

uint32_t RoutePoint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isWaypointTypeUsed())
        result = ::zserio::calcHashCode(result, m_waypointType_);
    if (isDepartureTimeUsed())
        result = ::zserio::calcHashCode(result, m_departureTime_);
    if (isArrivalTimeUsed())
        result = ::zserio::calcHashCode(result, m_arrivalTime_);

    return result;
}

void RoutePoint::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    if (isWaypointTypeSet())
    {
        out.writeBool(true);
        ::zserio::write(out, m_waypointType_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isDepartureTimeSet())
    {
        out.writeBool(true);
        m_departureTime_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isArrivalTimeSet())
    {
        out.writeBool(true);
        m_arrivalTime_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoutePoint::write(RoutePoint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    if (isWaypointTypeSet())
    {
        out.writeBool(true);
        ::zserio::write(context.getWaypointType(), out, m_waypointType_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isDepartureTimeSet())
    {
        out.writeBool(true);
        m_departureTime_.value().write(context.getDepartureTime(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isArrivalTimeSet())
    {
        out.writeBool(true);
        m_arrivalTime_.value().write(context.getArrivalTime(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::routing::types::RoutePointType RoutePoint::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::RoutePointType>(in);
}

::nds::routing::types::RoutePointType RoutePoint::readType(RoutePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::RoutePointType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType> RoutePoint::readWaypointType(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType>(::zserio::read<::nds::routing::types::WaypointType>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType> RoutePoint::readWaypointType(RoutePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType>(::zserio::read<::nds::routing::types::WaypointType>(context.getWaypointType(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> RoutePoint::readDepartureTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> RoutePoint::readDepartureTime(RoutePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(context.getDepartureTime(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> RoutePoint::readArrivalTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> RoutePoint::readArrivalTime(RoutePoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(context.getArrivalTime(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}

} // namespace route
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/route/RouteGeometry.h>

namespace nds
{
namespace routing
{
namespace route
{

RouteGeometry::RouteGeometry(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_scale_(::nds::core::types::ScaleDenominator()),
        m_shift_(::nds::core::geometry::CoordShift()),
        m_geometry_(allocator)
{
}

RouteGeometry::RouteGeometry(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_scale_(readScale(in)),
        m_shift_(readShift(in)),
        m_geometry_(readGeometry(in, allocator))
{
}

RouteGeometry::RouteGeometry(RouteGeometry::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_scale_(readScale(context, in)),
        m_shift_(readShift(context, in)),
        m_geometry_(readGeometry(context, in, allocator))
{
}

RouteGeometry::RouteGeometry(const RouteGeometry& other) :
        m_scale_(other.m_scale_),
        m_shift_(other.m_shift_),
        m_geometry_(other.m_geometry_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RouteGeometry& RouteGeometry::operator=(const RouteGeometry& other)
{
    m_scale_ = other.m_scale_;
    m_shift_ = other.m_shift_;
    m_geometry_ = other.m_geometry_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RouteGeometry::RouteGeometry(RouteGeometry&& other) :
        m_scale_(::std::move(other.m_scale_)),
        m_shift_(::std::move(other.m_shift_)),
        m_geometry_(::std::move(other.m_geometry_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RouteGeometry& RouteGeometry::operator=(RouteGeometry&& other)
{
    m_scale_ = ::std::move(other.m_scale_);
    m_shift_ = ::std::move(other.m_shift_);
    m_geometry_ = ::std::move(other.m_geometry_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RouteGeometry::RouteGeometry(::zserio::PropagateAllocatorT,
        const RouteGeometry& other, const allocator_type& allocator) :
        m_scale_(::zserio::allocatorPropagatingCopy(other.m_scale_, allocator)),
        m_shift_(::zserio::allocatorPropagatingCopy(other.m_shift_, allocator)),
        m_geometry_(::zserio::allocatorPropagatingCopy(other.m_geometry_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RouteGeometry::initializeChildren()
{
    m_geometry_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));

    m_areChildrenInitialized = true;
}

::nds::core::types::ScaleDenominator RouteGeometry::getScale() const
{
    return m_scale_;
}

void RouteGeometry::setScale(::nds::core::types::ScaleDenominator scale_)
{
    m_scale_ = scale_;
}

::nds::core::geometry::CoordShift RouteGeometry::getShift() const
{
    return m_shift_;
}

void RouteGeometry::setShift(::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
}

::nds::core::geometry::Line2D& RouteGeometry::getGeometry()
{
    return m_geometry_;
}

const ::nds::core::geometry::Line2D& RouteGeometry::getGeometry() const
{
    return m_geometry_;
}

void RouteGeometry::setGeometry(const ::nds::core::geometry::Line2D& geometry_)
{
    m_geometry_ = geometry_;
}

void RouteGeometry::setGeometry(::nds::core::geometry::Line2D&& geometry_)
{
    m_geometry_ = ::std::move(geometry_);
}

void RouteGeometry::initPackingContext(RouteGeometry::ZserioPackingContext& context) const
{
    context.getScale().init<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(m_scale_);
    context.getShift().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    m_geometry_.initPackingContext(context.getGeometry());
}

size_t RouteGeometry::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(5);
    endBitPosition += m_geometry_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RouteGeometry::bitSizeOf(RouteGeometry::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getScale().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(m_scale_);
    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition += m_geometry_.bitSizeOf(context.getGeometry(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RouteGeometry::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(5);
    endBitPosition = m_geometry_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RouteGeometry::initializeOffsets(RouteGeometry::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getScale().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(m_scale_);
    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition = m_geometry_.initializeOffsets(context.getGeometry(), endBitPosition);

    return endBitPosition;
}

bool RouteGeometry::operator==(const RouteGeometry& other) const
{
    if (this != &other)
    {
        return
                (m_scale_ == other.m_scale_) &&
                (m_shift_ == other.m_shift_) &&
                (m_geometry_ == other.m_geometry_);
    }

    return true;
}

uint32_t RouteGeometry::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_scale_);
    result = ::zserio::calcHashCode(result, m_shift_);
    result = ::zserio::calcHashCode(result, m_geometry_);

    return result;
}

void RouteGeometry::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_scale_, UINT8_C(32));

    out.writeBits(m_shift_, UINT8_C(5));

    // check parameters
    if (m_geometry_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RouteGeometry.geometry: ") <<
                m_geometry_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_geometry_.write(out);
}

void RouteGeometry::write(RouteGeometry::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getScale().write<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(out, m_scale_);

    context.getShift().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_shift_);

    // check parameters
    if (m_geometry_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RouteGeometry.geometry: ") <<
                m_geometry_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_geometry_.write(context.getGeometry(), out);
}

::nds::core::types::ScaleDenominator RouteGeometry::readScale(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::ScaleDenominator>(in.readBits(UINT8_C(32)));
}

::nds::core::types::ScaleDenominator RouteGeometry::readScale(RouteGeometry::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getScale().read<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(in);
}
::nds::core::geometry::CoordShift RouteGeometry::readShift(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift RouteGeometry::readShift(RouteGeometry::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getShift().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::core::geometry::Line2D RouteGeometry::readGeometry(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Line2D(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::Line2D RouteGeometry::readGeometry(RouteGeometry::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Line2D(context.getGeometry(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

} // namespace route
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/route/RouteSegment.h>

namespace nds
{
namespace routing
{
namespace route
{

RouteSegment::RouteSegment(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_hasStartOffset_(bool()),
        m_hasEndOffset_(bool()),
        m_startPosition_(::zserio::NullOpt),
        m_startPositionWithOffset_(::zserio::NullOpt),
        m_endPosition_(::zserio::NullOpt),
        m_endPositionWithOffset_(::zserio::NullOpt),
        m_length_(::nds::core::types::LengthCentimeters()),
        m_travelTime_(::nds::core::types::Seconds()),
        m_type_(::nds::routing::types::RouteSegmentType()),
        m_segmentDetails_(allocator)
{
}

RouteSegment::RouteSegment(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_hasStartOffset_(readHasStartOffset(in)),
        m_hasEndOffset_(readHasEndOffset(in)),
        m_startPosition_(readStartPosition(in)),
        m_startPositionWithOffset_(readStartPositionWithOffset(in, allocator)),
        m_endPosition_(readEndPosition(in)),
        m_endPositionWithOffset_(readEndPositionWithOffset(in, allocator)),
        m_length_(readLength(in)),
        m_travelTime_(readTravelTime(in)),
        m_type_(readType(in)),
        m_segmentDetails_(readSegmentDetails(in, allocator))
{
}

RouteSegment::RouteSegment(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_hasStartOffset_(readHasStartOffset(in)),
        m_hasEndOffset_(readHasEndOffset(in)),
        m_startPosition_(readStartPosition(context, in)),
        m_startPositionWithOffset_(readStartPositionWithOffset(context, in, allocator)),
        m_endPosition_(readEndPosition(context, in)),
        m_endPositionWithOffset_(readEndPositionWithOffset(context, in, allocator)),
        m_length_(readLength(context, in)),
        m_travelTime_(readTravelTime(context, in)),
        m_type_(readType(context, in)),
        m_segmentDetails_(readSegmentDetails(context, in, allocator))
{
}

RouteSegment::RouteSegment(const RouteSegment& other) :
        m_hasStartOffset_(other.m_hasStartOffset_),
        m_hasEndOffset_(other.m_hasEndOffset_),
        m_startPosition_(other.m_startPosition_),
        m_startPositionWithOffset_(other.m_startPositionWithOffset_),
        m_endPosition_(other.m_endPosition_),
        m_endPositionWithOffset_(other.m_endPositionWithOffset_),
        m_length_(other.m_length_),
        m_travelTime_(other.m_travelTime_),
        m_type_(other.m_type_),
        m_segmentDetails_(other.m_segmentDetails_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RouteSegment& RouteSegment::operator=(const RouteSegment& other)
{
    m_hasStartOffset_ = other.m_hasStartOffset_;
    m_hasEndOffset_ = other.m_hasEndOffset_;
    m_startPosition_ = other.m_startPosition_;
    m_startPositionWithOffset_ = other.m_startPositionWithOffset_;
    m_endPosition_ = other.m_endPosition_;
    m_endPositionWithOffset_ = other.m_endPositionWithOffset_;
    m_length_ = other.m_length_;
    m_travelTime_ = other.m_travelTime_;
    m_type_ = other.m_type_;
    m_segmentDetails_ = other.m_segmentDetails_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RouteSegment::RouteSegment(RouteSegment&& other) :
        m_hasStartOffset_(::std::move(other.m_hasStartOffset_)),
        m_hasEndOffset_(::std::move(other.m_hasEndOffset_)),
        m_startPosition_(::std::move(other.m_startPosition_)),
        m_startPositionWithOffset_(::std::move(other.m_startPositionWithOffset_)),
        m_endPosition_(::std::move(other.m_endPosition_)),
        m_endPositionWithOffset_(::std::move(other.m_endPositionWithOffset_)),
        m_length_(::std::move(other.m_length_)),
        m_travelTime_(::std::move(other.m_travelTime_)),
        m_type_(::std::move(other.m_type_)),
        m_segmentDetails_(::std::move(other.m_segmentDetails_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RouteSegment& RouteSegment::operator=(RouteSegment&& other)
{
    m_hasStartOffset_ = ::std::move(other.m_hasStartOffset_);
    m_hasEndOffset_ = ::std::move(other.m_hasEndOffset_);
    m_startPosition_ = ::std::move(other.m_startPosition_);
    m_startPositionWithOffset_ = ::std::move(other.m_startPositionWithOffset_);
    m_endPosition_ = ::std::move(other.m_endPosition_);
    m_endPositionWithOffset_ = ::std::move(other.m_endPositionWithOffset_);
    m_length_ = ::std::move(other.m_length_);
    m_travelTime_ = ::std::move(other.m_travelTime_);
    m_type_ = ::std::move(other.m_type_);
    m_segmentDetails_ = ::std::move(other.m_segmentDetails_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RouteSegment::RouteSegment(::zserio::PropagateAllocatorT,
        const RouteSegment& other, const allocator_type& allocator) :
        m_hasStartOffset_(::zserio::allocatorPropagatingCopy(other.m_hasStartOffset_, allocator)),
        m_hasEndOffset_(::zserio::allocatorPropagatingCopy(other.m_hasEndOffset_, allocator)),
        m_startPosition_(::zserio::allocatorPropagatingCopy(other.m_startPosition_, allocator)),
        m_startPositionWithOffset_(::zserio::allocatorPropagatingCopy(other.m_startPositionWithOffset_, allocator)),
        m_endPosition_(::zserio::allocatorPropagatingCopy(other.m_endPosition_, allocator)),
        m_endPositionWithOffset_(::zserio::allocatorPropagatingCopy(other.m_endPositionWithOffset_, allocator)),
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator)),
        m_travelTime_(::zserio::allocatorPropagatingCopy(other.m_travelTime_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_segmentDetails_(::zserio::allocatorPropagatingCopy(other.m_segmentDetails_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RouteSegment::initializeChildren()
{
    if (getHasStartOffset())
        m_startPositionWithOffset_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(0));
    if (getHasEndOffset())
        m_endPositionWithOffset_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(0));
    m_segmentDetails_.initialize(static_cast<::nds::routing::types::RouteSegmentType>(getType()));

    m_areChildrenInitialized = true;
}

bool RouteSegment::getHasStartOffset() const
{
    return m_hasStartOffset_;
}

void RouteSegment::setHasStartOffset(bool hasStartOffset_)
{
    m_hasStartOffset_ = hasStartOffset_;
}

bool RouteSegment::getHasEndOffset() const
{
    return m_hasEndOffset_;
}

void RouteSegment::setHasEndOffset(bool hasEndOffset_)
{
    m_hasEndOffset_ = hasEndOffset_;
}

::nds::core::geometry::LinePosition RouteSegment::getStartPosition() const
{
    return m_startPosition_.value();
}

void RouteSegment::setStartPosition(::nds::core::geometry::LinePosition startPosition_)
{
    m_startPosition_ = startPosition_;
}

bool RouteSegment::isStartPositionUsed() const
{
    return (!getHasStartOffset());
}

bool RouteSegment::isStartPositionSet() const
{
    return m_startPosition_.hasValue();
}

void RouteSegment::resetStartPosition()
{
    m_startPosition_.reset();
}

::nds::core::geometry::LinePositionOffset2D& RouteSegment::getStartPositionWithOffset()
{
    return m_startPositionWithOffset_.value();
}

const ::nds::core::geometry::LinePositionOffset2D& RouteSegment::getStartPositionWithOffset() const
{
    return m_startPositionWithOffset_.value();
}

void RouteSegment::setStartPositionWithOffset(const ::nds::core::geometry::LinePositionOffset2D& startPositionWithOffset_)
{
    m_startPositionWithOffset_ = startPositionWithOffset_;
}

void RouteSegment::setStartPositionWithOffset(::nds::core::geometry::LinePositionOffset2D&& startPositionWithOffset_)
{
    m_startPositionWithOffset_ = ::std::move(startPositionWithOffset_);
}

bool RouteSegment::isStartPositionWithOffsetUsed() const
{
    return (getHasStartOffset());
}

bool RouteSegment::isStartPositionWithOffsetSet() const
{
    return m_startPositionWithOffset_.hasValue();
}

void RouteSegment::resetStartPositionWithOffset()
{
    m_startPositionWithOffset_.reset();
}

::nds::core::geometry::LinePosition RouteSegment::getEndPosition() const
{
    return m_endPosition_.value();
}

void RouteSegment::setEndPosition(::nds::core::geometry::LinePosition endPosition_)
{
    m_endPosition_ = endPosition_;
}

bool RouteSegment::isEndPositionUsed() const
{
    return (!getHasEndOffset());
}

bool RouteSegment::isEndPositionSet() const
{
    return m_endPosition_.hasValue();
}

void RouteSegment::resetEndPosition()
{
    m_endPosition_.reset();
}

::nds::core::geometry::LinePositionOffset2D& RouteSegment::getEndPositionWithOffset()
{
    return m_endPositionWithOffset_.value();
}

const ::nds::core::geometry::LinePositionOffset2D& RouteSegment::getEndPositionWithOffset() const
{
    return m_endPositionWithOffset_.value();
}

void RouteSegment::setEndPositionWithOffset(const ::nds::core::geometry::LinePositionOffset2D& endPositionWithOffset_)
{
    m_endPositionWithOffset_ = endPositionWithOffset_;
}

void RouteSegment::setEndPositionWithOffset(::nds::core::geometry::LinePositionOffset2D&& endPositionWithOffset_)
{
    m_endPositionWithOffset_ = ::std::move(endPositionWithOffset_);
}

bool RouteSegment::isEndPositionWithOffsetUsed() const
{
    return (getHasEndOffset());
}

bool RouteSegment::isEndPositionWithOffsetSet() const
{
    return m_endPositionWithOffset_.hasValue();
}

void RouteSegment::resetEndPositionWithOffset()
{
    m_endPositionWithOffset_.reset();
}

::nds::core::types::LengthCentimeters RouteSegment::getLength() const
{
    return m_length_;
}

void RouteSegment::setLength(::nds::core::types::LengthCentimeters length_)
{
    m_length_ = length_;
}

::nds::core::types::Seconds RouteSegment::getTravelTime() const
{
    return m_travelTime_;
}

void RouteSegment::setTravelTime(::nds::core::types::Seconds travelTime_)
{
    m_travelTime_ = travelTime_;
}

::nds::routing::types::RouteSegmentType RouteSegment::getType() const
{
    return m_type_;
}

void RouteSegment::setType(::nds::routing::types::RouteSegmentType type_)
{
    m_type_ = type_;
}

::nds::routing::route::RouteSegmentDetails& RouteSegment::getSegmentDetails()
{
    return m_segmentDetails_;
}

const ::nds::routing::route::RouteSegmentDetails& RouteSegment::getSegmentDetails() const
{
    return m_segmentDetails_;
}

void RouteSegment::setSegmentDetails(const ::nds::routing::route::RouteSegmentDetails& segmentDetails_)
{
    m_segmentDetails_ = segmentDetails_;
}

void RouteSegment::setSegmentDetails(::nds::routing::route::RouteSegmentDetails&& segmentDetails_)
{
    m_segmentDetails_ = ::std::move(segmentDetails_);
}

void RouteSegment::initPackingContext(RouteSegment::ZserioPackingContext& context) const
{
    if (!getHasStartOffset())
    {
        context.getStartPosition().init<::zserio::VarSizeArrayTraits>(m_startPosition_.value());
    }
    if (getHasStartOffset())
    {
        m_startPositionWithOffset_.value().initPackingContext(context.getStartPositionWithOffset());
    }
    if (!getHasEndOffset())
    {
        context.getEndPosition().init<::zserio::VarSizeArrayTraits>(m_endPosition_.value());
    }
    if (getHasEndOffset())
    {
        m_endPositionWithOffset_.value().initPackingContext(context.getEndPositionWithOffset());
    }
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_length_);
    context.getTravelTime().init<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_travelTime_);
    ::zserio::initPackingContext(context.getType(), m_type_);
    m_segmentDetails_.initPackingContext(context.getSegmentDetails());
}

size_t RouteSegment::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (!getHasStartOffset())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startPosition_.value());
    }
    if (getHasStartOffset())
    {
        endBitPosition += m_startPositionWithOffset_.value().bitSizeOf(endBitPosition);
    }
    if (!getHasEndOffset())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_endPosition_.value());
    }
    if (getHasEndOffset())
    {
        endBitPosition += m_endPositionWithOffset_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += ::zserio::bitSizeOfVarUInt(m_travelTime_);
    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += m_segmentDetails_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RouteSegment::bitSizeOf(RouteSegment::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (!getHasStartOffset())
    {
        endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startPosition_.value());
    }
    if (getHasStartOffset())
    {
        endBitPosition += m_startPositionWithOffset_.value().bitSizeOf(context.getStartPositionWithOffset(), endBitPosition);
    }
    if (!getHasEndOffset())
    {
        endBitPosition += context.getEndPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_endPosition_.value());
    }
    if (getHasEndOffset())
    {
        endBitPosition += m_endPositionWithOffset_.value().bitSizeOf(context.getEndPositionWithOffset(), endBitPosition);
    }
    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_length_);
    endBitPosition += context.getTravelTime().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_travelTime_);
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += m_segmentDetails_.bitSizeOf(context.getSegmentDetails(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RouteSegment::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (!getHasStartOffset())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startPosition_.value());
    }
    if (getHasStartOffset())
    {
        endBitPosition = m_startPositionWithOffset_.value().initializeOffsets(endBitPosition);
    }
    if (!getHasEndOffset())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_endPosition_.value());
    }
    if (getHasEndOffset())
    {
        endBitPosition = m_endPositionWithOffset_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += ::zserio::bitSizeOfVarUInt(m_travelTime_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = m_segmentDetails_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RouteSegment::initializeOffsets(RouteSegment::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (!getHasStartOffset())
    {
        endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startPosition_.value());
    }
    if (getHasStartOffset())
    {
        endBitPosition = m_startPositionWithOffset_.value().initializeOffsets(context.getStartPositionWithOffset(), endBitPosition);
    }
    if (!getHasEndOffset())
    {
        endBitPosition += context.getEndPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_endPosition_.value());
    }
    if (getHasEndOffset())
    {
        endBitPosition = m_endPositionWithOffset_.value().initializeOffsets(context.getEndPositionWithOffset(), endBitPosition);
    }
    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_length_);
    endBitPosition += context.getTravelTime().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_travelTime_);
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = m_segmentDetails_.initializeOffsets(context.getSegmentDetails(), endBitPosition);

    return endBitPosition;
}

bool RouteSegment::operator==(const RouteSegment& other) const
{
    if (this != &other)
    {
        return
                (m_hasStartOffset_ == other.m_hasStartOffset_) &&
                (m_hasEndOffset_ == other.m_hasEndOffset_) &&
                (!isStartPositionUsed() ? !other.isStartPositionUsed() : (m_startPosition_ == other.m_startPosition_)) &&
                (!isStartPositionWithOffsetUsed() ? !other.isStartPositionWithOffsetUsed() : (m_startPositionWithOffset_ == other.m_startPositionWithOffset_)) &&
                (!isEndPositionUsed() ? !other.isEndPositionUsed() : (m_endPosition_ == other.m_endPosition_)) &&
                (!isEndPositionWithOffsetUsed() ? !other.isEndPositionWithOffsetUsed() : (m_endPositionWithOffset_ == other.m_endPositionWithOffset_)) &&
                (m_length_ == other.m_length_) &&
                (m_travelTime_ == other.m_travelTime_) &&
                (m_type_ == other.m_type_) &&
                (m_segmentDetails_ == other.m_segmentDetails_);
    }

    return true;
}

uint32_t RouteSegment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_hasStartOffset_);
    result = ::zserio::calcHashCode(result, m_hasEndOffset_);
    if (isStartPositionUsed())
        result = ::zserio::calcHashCode(result, m_startPosition_);
    if (isStartPositionWithOffsetUsed())
        result = ::zserio::calcHashCode(result, m_startPositionWithOffset_);
    if (isEndPositionUsed())
        result = ::zserio::calcHashCode(result, m_endPosition_);
    if (isEndPositionWithOffsetUsed())
        result = ::zserio::calcHashCode(result, m_endPositionWithOffset_);
    result = ::zserio::calcHashCode(result, m_length_);
    result = ::zserio::calcHashCode(result, m_travelTime_);
    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_segmentDetails_);

    return result;
}

void RouteSegment::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasStartOffset_);

    out.writeBool(m_hasEndOffset_);

    if (!getHasStartOffset())
    {
        out.writeVarSize(m_startPosition_.value());
    }

    if (getHasStartOffset())
    {
        // check parameters
        if (m_startPositionWithOffset_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RouteSegment.startPositionWithOffset: ") <<
                    m_startPositionWithOffset_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_startPositionWithOffset_.value().write(out);
    }

    if (!getHasEndOffset())
    {
        out.writeVarSize(m_endPosition_.value());
    }

    if (getHasEndOffset())
    {
        // check parameters
        if (m_endPositionWithOffset_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RouteSegment.endPositionWithOffset: ") <<
                    m_endPositionWithOffset_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_endPositionWithOffset_.value().write(out);
    }

    out.writeVarUInt32(m_length_);

    out.writeVarUInt(m_travelTime_);

    ::zserio::write(out, m_type_);

    // check parameters
    if (m_segmentDetails_.getType() != static_cast<::nds::routing::types::RouteSegmentType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RouteSegment.segmentDetails: ") <<
                m_segmentDetails_.getType() << " != " << static_cast<::nds::routing::types::RouteSegmentType>(getType()) << "!";
    }
    m_segmentDetails_.write(out);
}

void RouteSegment::write(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasStartOffset_);

    out.writeBool(m_hasEndOffset_);

    if (!getHasStartOffset())
    {
        context.getStartPosition().write<::zserio::VarSizeArrayTraits>(out, m_startPosition_.value());
    }

    if (getHasStartOffset())
    {
        // check parameters
        if (m_startPositionWithOffset_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RouteSegment.startPositionWithOffset: ") <<
                    m_startPositionWithOffset_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_startPositionWithOffset_.value().write(context.getStartPositionWithOffset(), out);
    }

    if (!getHasEndOffset())
    {
        context.getEndPosition().write<::zserio::VarSizeArrayTraits>(out, m_endPosition_.value());
    }

    if (getHasEndOffset())
    {
        // check parameters
        if (m_endPositionWithOffset_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field RouteSegment.endPositionWithOffset: ") <<
                    m_endPositionWithOffset_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_endPositionWithOffset_.value().write(context.getEndPositionWithOffset(), out);
    }

    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(out, m_length_);

    context.getTravelTime().write<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(out, m_travelTime_);

    ::zserio::write(context.getType(), out, m_type_);

    // check parameters
    if (m_segmentDetails_.getType() != static_cast<::nds::routing::types::RouteSegmentType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RouteSegment.segmentDetails: ") <<
                m_segmentDetails_.getType() << " != " << static_cast<::nds::routing::types::RouteSegmentType>(getType()) << "!";
    }
    m_segmentDetails_.write(context.getSegmentDetails(), out);
}

bool RouteSegment::readHasStartOffset(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool RouteSegment::readHasEndOffset(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition> RouteSegment::readStartPosition(::zserio::BitStreamReader& in)
{
    if (!getHasStartOffset())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition>(static_cast<::nds::core::geometry::LinePosition>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition> RouteSegment::readStartPosition(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (!getHasStartOffset())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition>(context.getStartPosition().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D> RouteSegment::readStartPositionWithOffset(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasStartOffset())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D>(::nds::core::geometry::LinePositionOffset2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D> RouteSegment::readStartPositionWithOffset(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasStartOffset())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D>(::nds::core::geometry::LinePositionOffset2D(context.getStartPositionWithOffset(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition> RouteSegment::readEndPosition(::zserio::BitStreamReader& in)
{
    if (!getHasEndOffset())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition>(static_cast<::nds::core::geometry::LinePosition>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition> RouteSegment::readEndPosition(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (!getHasEndOffset())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition>(context.getEndPosition().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePosition>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D> RouteSegment::readEndPositionWithOffset(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasEndOffset())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D>(::nds::core::geometry::LinePositionOffset2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D> RouteSegment::readEndPositionWithOffset(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasEndOffset())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D>(::nds::core::geometry::LinePositionOffset2D(context.getEndPositionWithOffset(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::LinePositionOffset2D>(::zserio::NullOpt);
}
::nds::core::types::LengthCentimeters RouteSegment::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LengthCentimeters>(in.readVarUInt32());
}

::nds::core::types::LengthCentimeters RouteSegment::readLength(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(in);
}
::nds::core::types::Seconds RouteSegment::readTravelTime(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::Seconds>(in.readVarUInt());
}

::nds::core::types::Seconds RouteSegment::readTravelTime(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTravelTime().read<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(in);
}
::nds::routing::types::RouteSegmentType RouteSegment::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::RouteSegmentType>(in);
}

::nds::routing::types::RouteSegmentType RouteSegment::readType(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::RouteSegmentType>(context.getType(), in);
}
::nds::routing::route::RouteSegmentDetails RouteSegment::readSegmentDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routing::route::RouteSegmentDetails(in, static_cast<::nds::routing::types::RouteSegmentType>(getType()), allocator);
}

::nds::routing::route::RouteSegmentDetails RouteSegment::readSegmentDetails(RouteSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routing::route::RouteSegmentDetails(context.getSegmentDetails(), in, static_cast<::nds::routing::types::RouteSegmentType>(getType()), allocator);
}

} // namespace route
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/route/DelayInformation.h>

namespace nds
{
namespace routing
{
namespace route
{

DelayInformation::DelayInformation(const allocator_type&) noexcept :
        m_delay_(::nds::core::types::Seconds()),
        m_reasonType_(::nds::routing::route::DelayReasonType()),
        m_reason_(::zserio::NullOpt)
{
}

DelayInformation::DelayInformation(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_delay_(readDelay(in)),
        m_reasonType_(readReasonType(in)),
        m_reason_(readReason(in, allocator))
{
}

DelayInformation::DelayInformation(DelayInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_delay_(readDelay(context, in)),
        m_reasonType_(readReasonType(context, in)),
        m_reason_(readReason(in, allocator))
{
}

DelayInformation::DelayInformation(::zserio::PropagateAllocatorT,
        const DelayInformation& other, const allocator_type& allocator) :
        m_delay_(::zserio::allocatorPropagatingCopy(other.m_delay_, allocator)),
        m_reasonType_(::zserio::allocatorPropagatingCopy(other.m_reasonType_, allocator)),
        m_reason_(::zserio::allocatorPropagatingCopy(other.m_reason_, allocator))
{
}

::nds::core::types::Seconds DelayInformation::getDelay() const
{
    return m_delay_;
}

void DelayInformation::setDelay(::nds::core::types::Seconds delay_)
{
    m_delay_ = delay_;
}

::nds::routing::route::DelayReasonType DelayInformation::getReasonType() const
{
    return m_reasonType_;
}

void DelayInformation::setReasonType(::nds::routing::route::DelayReasonType reasonType_)
{
    m_reasonType_ = reasonType_;
}

::zserio::string<>& DelayInformation::getReason()
{
    return m_reason_.value();
}

const ::zserio::string<>& DelayInformation::getReason() const
{
    return m_reason_.value();
}

void DelayInformation::setReason(const ::zserio::string<>& reason_)
{
    m_reason_ = reason_;
}

void DelayInformation::setReason(::zserio::string<>&& reason_)
{
    m_reason_ = ::std::move(reason_);
}

bool DelayInformation::isReasonUsed() const
{
    return (isReasonSet());
}

bool DelayInformation::isReasonSet() const
{
    return m_reason_.hasValue();
}

void DelayInformation::resetReason()
{
    m_reason_.reset();
}

void DelayInformation::initPackingContext(DelayInformation::ZserioPackingContext& context) const
{
    context.getDelay().init<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_delay_);
    ::zserio::initPackingContext(context.getReasonType(), m_reasonType_);
}

size_t DelayInformation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_delay_);
    endBitPosition += ::zserio::bitSizeOf(m_reasonType_);
    endBitPosition += 1;
    if (isReasonSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_reason_.value());
    }

    return endBitPosition - bitPosition;
}

size_t DelayInformation::bitSizeOf(DelayInformation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDelay().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_delay_);
    endBitPosition += ::zserio::bitSizeOf(context.getReasonType(), m_reasonType_);
    endBitPosition += 1;
    if (isReasonSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_reason_.value());
    }

    return endBitPosition - bitPosition;
}

size_t DelayInformation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_delay_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_reasonType_);
    endBitPosition += 1;
    if (isReasonSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_reason_.value());
    }

    return endBitPosition;
}

size_t DelayInformation::initializeOffsets(DelayInformation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDelay().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(m_delay_);
    endBitPosition = ::zserio::initializeOffsets(context.getReasonType(), endBitPosition,
        m_reasonType_);
    endBitPosition += 1;
    if (isReasonSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_reason_.value());
    }

    return endBitPosition;
}

bool DelayInformation::operator==(const DelayInformation& other) const
{
    if (this != &other)
    {
        return
                (m_delay_ == other.m_delay_) &&
                (m_reasonType_ == other.m_reasonType_) &&
                (!isReasonUsed() ? !other.isReasonUsed() : (m_reason_ == other.m_reason_));
    }

    return true;
}

uint32_t DelayInformation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_delay_);
    result = ::zserio::calcHashCode(result, m_reasonType_);
    if (isReasonUsed())
        result = ::zserio::calcHashCode(result, m_reason_);

    return result;
}

void DelayInformation::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt(m_delay_);
    ::zserio::write(out, m_reasonType_);
    if (isReasonSet())
    {
        out.writeBool(true);
        out.writeString(m_reason_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void DelayInformation::write(DelayInformation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getDelay().write<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(out, m_delay_);
    ::zserio::write(context.getReasonType(), out, m_reasonType_);
    if (isReasonSet())
    {
        out.writeBool(true);
        out.writeString(m_reason_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::types::Seconds DelayInformation::readDelay(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::Seconds>(in.readVarUInt());
}

::nds::core::types::Seconds DelayInformation::readDelay(DelayInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDelay().read<::zserio::VarIntArrayTraits<::nds::core::types::Seconds>>(in);
}
::nds::routing::route::DelayReasonType DelayInformation::readReasonType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::route::DelayReasonType>(in);
}

::nds::routing::route::DelayReasonType DelayInformation::readReasonType(DelayInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::route::DelayReasonType>(context.getReasonType(), in);
}
::zserio::InplaceOptionalHolder<::zserio::string<>> DelayInformation::readReason(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

} // namespace route
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/route/Waypoint.h>

namespace nds
{
namespace routing
{
namespace route
{

Waypoint::Waypoint(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_position_(allocator),
        m_locationPath_(::zserio::NullOpt),
        m_locationId_(::zserio::NullOpt),
        m_rightSide_(::zserio::NullOpt),
        m_type_(::zserio::NullOpt),
        m_departureTime_(::zserio::NullOpt),
        m_arrivalTime_(::zserio::NullOpt)
{
}

Waypoint::Waypoint(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_position_(readPosition(in, allocator)),
        m_locationPath_(readLocationPath(in, allocator)),
        m_locationId_(readLocationId(in, allocator)),
        m_rightSide_(readRightSide(in)),
        m_type_(readType(in)),
        m_departureTime_(readDepartureTime(in, allocator)),
        m_arrivalTime_(readArrivalTime(in, allocator))
{
}

Waypoint::Waypoint(Waypoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_position_(readPosition(context, in, allocator)),
        m_locationPath_(readLocationPath(context, in, allocator)),
        m_locationId_(readLocationId(context, in, allocator)),
        m_rightSide_(readRightSide(in)),
        m_type_(readType(context, in)),
        m_departureTime_(readDepartureTime(context, in, allocator)),
        m_arrivalTime_(readArrivalTime(context, in, allocator))
{
}

Waypoint::Waypoint(const Waypoint& other) :
        m_position_(other.m_position_),
        m_locationPath_(other.m_locationPath_),
        m_locationId_(other.m_locationId_),
        m_rightSide_(other.m_rightSide_),
        m_type_(other.m_type_),
        m_departureTime_(other.m_departureTime_),
        m_arrivalTime_(other.m_arrivalTime_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

Waypoint& Waypoint::operator=(const Waypoint& other)
{
    m_position_ = other.m_position_;
    m_locationPath_ = other.m_locationPath_;
    m_locationId_ = other.m_locationId_;
    m_rightSide_ = other.m_rightSide_;
    m_type_ = other.m_type_;
    m_departureTime_ = other.m_departureTime_;
    m_arrivalTime_ = other.m_arrivalTime_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

Waypoint::Waypoint(Waypoint&& other) :
        m_position_(::std::move(other.m_position_)),
        m_locationPath_(::std::move(other.m_locationPath_)),
        m_locationId_(::std::move(other.m_locationId_)),
        m_rightSide_(::std::move(other.m_rightSide_)),
        m_type_(::std::move(other.m_type_)),
        m_departureTime_(::std::move(other.m_departureTime_)),
        m_arrivalTime_(::std::move(other.m_arrivalTime_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

Waypoint& Waypoint::operator=(Waypoint&& other)
{
    m_position_ = ::std::move(other.m_position_);
    m_locationPath_ = ::std::move(other.m_locationPath_);
    m_locationId_ = ::std::move(other.m_locationId_);
    m_rightSide_ = ::std::move(other.m_rightSide_);
    m_type_ = ::std::move(other.m_type_);
    m_departureTime_ = ::std::move(other.m_departureTime_);
    m_arrivalTime_ = ::std::move(other.m_arrivalTime_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

Waypoint::Waypoint(::zserio::PropagateAllocatorT,
        const Waypoint& other, const allocator_type& allocator) :
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator)),
        m_locationPath_(::zserio::allocatorPropagatingCopy(other.m_locationPath_, allocator)),
        m_locationId_(::zserio::allocatorPropagatingCopy(other.m_locationId_, allocator)),
        m_rightSide_(::zserio::allocatorPropagatingCopy(other.m_rightSide_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_departureTime_(::zserio::allocatorPropagatingCopy(other.m_departureTime_, allocator)),
        m_arrivalTime_(::zserio::allocatorPropagatingCopy(other.m_arrivalTime_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void Waypoint::initializeChildren()
{
    m_position_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));
    if (isLocationPathSet())
        m_locationPath_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::core::geometry::Position2D& Waypoint::getPosition()
{
    return m_position_;
}

const ::nds::core::geometry::Position2D& Waypoint::getPosition() const
{
    return m_position_;
}

void Waypoint::setPosition(const ::nds::core::geometry::Position2D& position_)
{
    m_position_ = position_;
}

void Waypoint::setPosition(::nds::core::geometry::Position2D&& position_)
{
    m_position_ = ::std::move(position_);
}

::nds::core::location::RoadLocationPath& Waypoint::getLocationPath()
{
    return m_locationPath_.value();
}

const ::nds::core::location::RoadLocationPath& Waypoint::getLocationPath() const
{
    return m_locationPath_.value();
}

void Waypoint::setLocationPath(const ::nds::core::location::RoadLocationPath& locationPath_)
{
    m_locationPath_ = locationPath_;
}

void Waypoint::setLocationPath(::nds::core::location::RoadLocationPath&& locationPath_)
{
    m_locationPath_ = ::std::move(locationPath_);
}

bool Waypoint::isLocationPathUsed() const
{
    return (isLocationPathSet());
}

bool Waypoint::isLocationPathSet() const
{
    return m_locationPath_.hasValue();
}

void Waypoint::resetLocationPath()
{
    m_locationPath_.reset();
}

::nds::core::location::RoadLocationId& Waypoint::getLocationId()
{
    return m_locationId_.value();
}

const ::nds::core::location::RoadLocationId& Waypoint::getLocationId() const
{
    return m_locationId_.value();
}

void Waypoint::setLocationId(const ::nds::core::location::RoadLocationId& locationId_)
{
    m_locationId_ = locationId_;
}

void Waypoint::setLocationId(::nds::core::location::RoadLocationId&& locationId_)
{
    m_locationId_ = ::std::move(locationId_);
}

bool Waypoint::isLocationIdUsed() const
{
    return (isLocationIdSet());
}

bool Waypoint::isLocationIdSet() const
{
    return m_locationId_.hasValue();
}

void Waypoint::resetLocationId()
{
    m_locationId_.reset();
}

bool Waypoint::getRightSide() const
{
    return m_rightSide_.value();
}

void Waypoint::setRightSide(bool rightSide_)
{
    m_rightSide_ = rightSide_;
}

bool Waypoint::isRightSideUsed() const
{
    return (isRightSideSet());
}

bool Waypoint::isRightSideSet() const
{
    return m_rightSide_.hasValue();
}

void Waypoint::resetRightSide()
{
    m_rightSide_.reset();
}

::nds::routing::types::WaypointType Waypoint::getType() const
{
    return m_type_.value();
}

void Waypoint::setType(::nds::routing::types::WaypointType type_)
{
    m_type_ = type_;
}

bool Waypoint::isTypeUsed() const
{
    return (isTypeSet());
}

bool Waypoint::isTypeSet() const
{
    return m_type_.hasValue();
}

void Waypoint::resetType()
{
    m_type_.reset();
}

::nds::core::types::TimeWithZone& Waypoint::getDepartureTime()
{
    return m_departureTime_.value();
}

const ::nds::core::types::TimeWithZone& Waypoint::getDepartureTime() const
{
    return m_departureTime_.value();
}

void Waypoint::setDepartureTime(const ::nds::core::types::TimeWithZone& departureTime_)
{
    m_departureTime_ = departureTime_;
}

void Waypoint::setDepartureTime(::nds::core::types::TimeWithZone&& departureTime_)
{
    m_departureTime_ = ::std::move(departureTime_);
}

bool Waypoint::isDepartureTimeUsed() const
{
    return (isDepartureTimeSet());
}

bool Waypoint::isDepartureTimeSet() const
{
    return m_departureTime_.hasValue();
}

void Waypoint::resetDepartureTime()
{
    m_departureTime_.reset();
}

::nds::core::types::TimeWithZone& Waypoint::getArrivalTime()
{
    return m_arrivalTime_.value();
}

const ::nds::core::types::TimeWithZone& Waypoint::getArrivalTime() const
{
    return m_arrivalTime_.value();
}

void Waypoint::setArrivalTime(const ::nds::core::types::TimeWithZone& arrivalTime_)
{
    m_arrivalTime_ = arrivalTime_;
}

void Waypoint::setArrivalTime(::nds::core::types::TimeWithZone&& arrivalTime_)
{
    m_arrivalTime_ = ::std::move(arrivalTime_);
}

bool Waypoint::isArrivalTimeUsed() const
{
    return (isArrivalTimeSet());
}

bool Waypoint::isArrivalTimeSet() const
{
    return m_arrivalTime_.hasValue();
}

void Waypoint::resetArrivalTime()
{
    m_arrivalTime_.reset();
}

void Waypoint::initPackingContext(Waypoint::ZserioPackingContext& context) const
{
    m_position_.initPackingContext(context.getPosition());
    if (isLocationPathSet())
    {
        m_locationPath_.value().initPackingContext(context.getLocationPath());
    }
    if (isLocationIdSet())
    {
        m_locationId_.value().initPackingContext(context.getLocationId());
    }
    if (isTypeSet())
    {
        ::zserio::initPackingContext(context.getType(), m_type_.value());
    }
    if (isDepartureTimeSet())
    {
        m_departureTime_.value().initPackingContext(context.getDepartureTime());
    }
    if (isArrivalTimeSet())
    {
        m_arrivalTime_.value().initPackingContext(context.getArrivalTime());
    }
}

size_t Waypoint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isLocationPathSet())
    {
        endBitPosition += m_locationPath_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isLocationIdSet())
    {
        endBitPosition += m_locationId_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isRightSideSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isTypeSet())
    {
        endBitPosition += ::zserio::bitSizeOf(m_type_.value());
    }
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition += m_departureTime_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition += m_arrivalTime_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Waypoint::bitSizeOf(Waypoint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);
    endBitPosition += 1;
    if (isLocationPathSet())
    {
        endBitPosition += m_locationPath_.value().bitSizeOf(context.getLocationPath(), endBitPosition);
    }
    endBitPosition += 1;
    if (isLocationIdSet())
    {
        endBitPosition += m_locationId_.value().bitSizeOf(context.getLocationId(), endBitPosition);
    }
    endBitPosition += 1;
    if (isRightSideSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isTypeSet())
    {
        endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_.value());
    }
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition += m_departureTime_.value().bitSizeOf(context.getDepartureTime(), endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition += m_arrivalTime_.value().bitSizeOf(context.getArrivalTime(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Waypoint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isLocationPathSet())
    {
        endBitPosition = m_locationPath_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isLocationIdSet())
    {
        endBitPosition = m_locationId_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isRightSideSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isTypeSet())
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_.value());
    }
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition = m_departureTime_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition = m_arrivalTime_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t Waypoint::initializeOffsets(Waypoint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);
    endBitPosition += 1;
    if (isLocationPathSet())
    {
        endBitPosition = m_locationPath_.value().initializeOffsets(context.getLocationPath(), endBitPosition);
    }
    endBitPosition += 1;
    if (isLocationIdSet())
    {
        endBitPosition = m_locationId_.value().initializeOffsets(context.getLocationId(), endBitPosition);
    }
    endBitPosition += 1;
    if (isRightSideSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isTypeSet())
    {
        endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_.value());
    }
    endBitPosition += 1;
    if (isDepartureTimeSet())
    {
        endBitPosition = m_departureTime_.value().initializeOffsets(context.getDepartureTime(), endBitPosition);
    }
    endBitPosition += 1;
    if (isArrivalTimeSet())
    {
        endBitPosition = m_arrivalTime_.value().initializeOffsets(context.getArrivalTime(), endBitPosition);
    }

    return endBitPosition;
}

bool Waypoint::operator==(const Waypoint& other) const
{
    if (this != &other)
    {
        return
                (m_position_ == other.m_position_) &&
                (!isLocationPathUsed() ? !other.isLocationPathUsed() : (m_locationPath_ == other.m_locationPath_)) &&
                (!isLocationIdUsed() ? !other.isLocationIdUsed() : (m_locationId_ == other.m_locationId_)) &&
                (!isRightSideUsed() ? !other.isRightSideUsed() : (m_rightSide_ == other.m_rightSide_)) &&
                (!isTypeUsed() ? !other.isTypeUsed() : (m_type_ == other.m_type_)) &&
                (!isDepartureTimeUsed() ? !other.isDepartureTimeUsed() : (m_departureTime_ == other.m_departureTime_)) &&
                (!isArrivalTimeUsed() ? !other.isArrivalTimeUsed() : (m_arrivalTime_ == other.m_arrivalTime_));
    }

    return true;
}

uint32_t Waypoint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_position_);
    if (isLocationPathUsed())
        result = ::zserio::calcHashCode(result, m_locationPath_);
    if (isLocationIdUsed())
        result = ::zserio::calcHashCode(result, m_locationId_);
    if (isRightSideUsed())
        result = ::zserio::calcHashCode(result, m_rightSide_);
    if (isTypeUsed())
        result = ::zserio::calcHashCode(result, m_type_);
    if (isDepartureTimeUsed())
        result = ::zserio::calcHashCode(result, m_departureTime_);
    if (isArrivalTimeUsed())
        result = ::zserio::calcHashCode(result, m_arrivalTime_);

    return result;
}

void Waypoint::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field Waypoint.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(out);

    if (isLocationPathSet())
    {
        out.writeBool(true);
        m_locationPath_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isLocationIdSet())
    {
        out.writeBool(true);
        m_locationId_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isRightSideSet())
    {
        out.writeBool(true);
        out.writeBool(m_rightSide_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isTypeSet())
    {
        out.writeBool(true);
        ::zserio::write(out, m_type_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isDepartureTimeSet())
    {
        out.writeBool(true);
        m_departureTime_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isArrivalTimeSet())
    {
        out.writeBool(true);
        m_arrivalTime_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void Waypoint::write(Waypoint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field Waypoint.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_position_.write(context.getPosition(), out);

    if (isLocationPathSet())
    {
        out.writeBool(true);
        m_locationPath_.value().write(context.getLocationPath(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isLocationIdSet())
    {
        out.writeBool(true);
        m_locationId_.value().write(context.getLocationId(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isRightSideSet())
    {
        out.writeBool(true);
        out.writeBool(m_rightSide_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isTypeSet())
    {
        out.writeBool(true);
        ::zserio::write(context.getType(), out, m_type_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isDepartureTimeSet())
    {
        out.writeBool(true);
        m_departureTime_.value().write(context.getDepartureTime(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isArrivalTimeSet())
    {
        out.writeBool(true);
        m_arrivalTime_.value().write(context.getArrivalTime(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::geometry::Position2D Waypoint::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::core::geometry::Position2D Waypoint::readPosition(Waypoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getPosition(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath> Waypoint::readLocationPath(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath>(::nds::core::location::RoadLocationPath(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath> Waypoint::readLocationPath(Waypoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath>(::nds::core::location::RoadLocationPath(context.getLocationPath(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationPath>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationId> Waypoint::readLocationId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationId>(::nds::core::location::RoadLocationId(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationId> Waypoint::readLocationId(Waypoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationId>(::nds::core::location::RoadLocationId(context.getLocationId(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::location::RoadLocationId>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> Waypoint::readRightSide(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType> Waypoint::readType(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType>(::zserio::read<::nds::routing::types::WaypointType>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType> Waypoint::readType(Waypoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType>(::zserio::read<::nds::routing::types::WaypointType>(context.getType(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::types::WaypointType>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> Waypoint::readDepartureTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> Waypoint::readDepartureTime(Waypoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(context.getDepartureTime(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> Waypoint::readArrivalTime(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone> Waypoint::readArrivalTime(Waypoint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::nds::core::types::TimeWithZone(context.getArrivalTime(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::TimeWithZone>(::zserio::NullOpt);
}

} // namespace route
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/routing/route/RouteOptions.h>

namespace nds
{
namespace routing
{
namespace route
{

RouteOptions::RouteOptions(const allocator_type&) noexcept :
        m_avoid_(static_cast<bool>(true)),
        m_weight_(::zserio::NullOpt),
        m_type_(::nds::routing::types::RouteOptionType())
{
}

RouteOptions::RouteOptions(::zserio::BitStreamReader& in, const allocator_type&) :
        m_avoid_(readAvoid(in)),
        m_weight_(readWeight(in)),
        m_type_(readType(in))
{
}

RouteOptions::RouteOptions(RouteOptions::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_avoid_(readAvoid(in)),
        m_weight_(readWeight(context, in)),
        m_type_(readType(context, in))
{
}

RouteOptions::RouteOptions(::zserio::PropagateAllocatorT,
        const RouteOptions& other, const allocator_type& allocator) :
        m_avoid_(::zserio::allocatorPropagatingCopy(other.m_avoid_, allocator)),
        m_weight_(::zserio::allocatorPropagatingCopy(other.m_weight_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator))
{
}

bool RouteOptions::getAvoid() const
{
    return m_avoid_;
}

void RouteOptions::setAvoid(bool avoid_)
{
    m_avoid_ = avoid_;
}

uint8_t RouteOptions::getWeight() const
{
    return m_weight_.value();
}

void RouteOptions::setWeight(uint8_t weight_)
{
    m_weight_ = weight_;
}

bool RouteOptions::isWeightUsed() const
{
    return (isWeightSet());
}

bool RouteOptions::isWeightSet() const
{
    return m_weight_.hasValue();
}

void RouteOptions::resetWeight()
{
    m_weight_.reset();
}

::nds::routing::types::RouteOptionType RouteOptions::getType() const
{
    return m_type_;
}

void RouteOptions::setType(::nds::routing::types::RouteOptionType type_)
{
    m_type_ = type_;
}

void RouteOptions::initPackingContext(RouteOptions::ZserioPackingContext& context) const
{
    if (isWeightSet())
    {
        context.getWeight().init<::zserio::StdIntArrayTraits<uint8_t>>(m_weight_.value());
    }
    ::zserio::initPackingContext(context.getType(), m_type_);
}

size_t RouteOptions::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += 1;
    if (isWeightSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += ::zserio::bitSizeOf(m_type_);

    return endBitPosition - bitPosition;
}

size_t RouteOptions::bitSizeOf(RouteOptions::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += 1;
    if (isWeightSet())
    {
        endBitPosition += context.getWeight().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_weight_.value());
    }
    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);

    return endBitPosition - bitPosition;
}

size_t RouteOptions::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += 1;
    if (isWeightSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);

    return endBitPosition;
}

size_t RouteOptions::initializeOffsets(RouteOptions::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += 1;
    if (isWeightSet())
    {
        endBitPosition += context.getWeight().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_weight_.value());
    }
    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);

    return endBitPosition;
}

bool RouteOptions::operator==(const RouteOptions& other) const
{
    if (this != &other)
    {
        return
                (m_avoid_ == other.m_avoid_) &&
                (!isWeightUsed() ? !other.isWeightUsed() : (m_weight_ == other.m_weight_)) &&
                (m_type_ == other.m_type_);
    }

    return true;
}

uint32_t RouteOptions::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_avoid_);
    if (isWeightUsed())
        result = ::zserio::calcHashCode(result, m_weight_);
    result = ::zserio::calcHashCode(result, m_type_);

    return result;
}

void RouteOptions::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_avoid_);

    if (isWeightSet())
    {
        out.writeBool(true);
        // check constraint
        if (!(getWeight() <= 100 && getWeight() != 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at RouteOptions.weight!");
        out.writeBits(m_weight_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }

    ::zserio::write(out, m_type_);
}

void RouteOptions::write(RouteOptions::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_avoid_);

    if (isWeightSet())
    {
        out.writeBool(true);
        // check constraint
        if (!(getWeight() <= 100 && getWeight() != 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at RouteOptions.weight!");
        context.getWeight().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_weight_.value());
    }
    else
    {
        out.writeBool(false);
    }

    ::zserio::write(context.getType(), out, m_type_);
}

bool RouteOptions::readAvoid(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<uint8_t> RouteOptions::readWeight(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        uint8_t readField = static_cast<uint8_t>(in.readBits(UINT8_C(8)));
        // check constraint
        if (!(readField <= 100 && readField != 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at RouteOptions.weight!");

        return ::zserio::InplaceOptionalHolder<uint8_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint8_t> RouteOptions::readWeight(RouteOptions::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        uint8_t readField = context.getWeight().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
        // check constraint
        if (!(readField <= 100 && readField != 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at RouteOptions.weight!");

        return ::zserio::InplaceOptionalHolder<uint8_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}
::nds::routing::types::RouteOptionType RouteOptions::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::RouteOptionType>(in);
}

::nds::routing::types::RouteOptionType RouteOptions::readType(RouteOptions::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::RouteOptionType>(context.getType(), in);
}

} // namespace route
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/route/RouteSegmentDetails.h>

namespace nds
{
namespace routing
{
namespace route
{

RouteSegmentDetails::RouteSegmentDetails(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RouteSegmentDetails::RouteSegmentDetails(::zserio::BitStreamReader& in,
        ::nds::routing::types::RouteSegmentType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RouteSegmentDetails::RouteSegmentDetails(RouteSegmentDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::routing::types::RouteSegmentType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RouteSegmentDetails::RouteSegmentDetails(const RouteSegmentDetails& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RouteSegmentDetails& RouteSegmentDetails::operator=(const RouteSegmentDetails& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RouteSegmentDetails::RouteSegmentDetails(RouteSegmentDetails&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RouteSegmentDetails& RouteSegmentDetails::operator=(RouteSegmentDetails&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RouteSegmentDetails::RouteSegmentDetails(::zserio::PropagateAllocatorT,
        const RouteSegmentDetails& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RouteSegmentDetails::initialize(
        ::nds::routing::types::RouteSegmentType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RouteSegmentDetails::isInitialized() const
{
    return m_isInitialized;
}

::nds::routing::types::RouteSegmentType RouteSegmentDetails::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RouteSegmentDetails' is not initialized!");

    return m_type_;
}

::nds::routing::route::DelayInformation& RouteSegmentDetails::getDelay()
{
    return m_objectChoice.get<::nds::routing::route::DelayInformation>();
}

const ::nds::routing::route::DelayInformation& RouteSegmentDetails::getDelay() const
{
    return m_objectChoice.get<::nds::routing::route::DelayInformation>();
}

void RouteSegmentDetails::setDelay(const ::nds::routing::route::DelayInformation& delay_)
{
    m_objectChoice = delay_;
}

void RouteSegmentDetails::setDelay(::nds::routing::route::DelayInformation&& delay_)
{
    m_objectChoice = ::std::move(delay_);
}

::nds::routing::types::Pollution& RouteSegmentDetails::getPollution()
{
    return m_objectChoice.get<::nds::routing::types::Pollution>();
}

const ::nds::routing::types::Pollution& RouteSegmentDetails::getPollution() const
{
    return m_objectChoice.get<::nds::routing::types::Pollution>();
}

void RouteSegmentDetails::setPollution(const ::nds::routing::types::Pollution& pollution_)
{
    m_objectChoice = pollution_;
}

void RouteSegmentDetails::setPollution(::nds::routing::types::Pollution&& pollution_)
{
    m_objectChoice = ::std::move(pollution_);
}

::nds::core::types::TollCost& RouteSegmentDetails::getTollCost()
{
    return m_objectChoice.get<::nds::core::types::TollCost>();
}

const ::nds::core::types::TollCost& RouteSegmentDetails::getTollCost() const
{
    return m_objectChoice.get<::nds::core::types::TollCost>();
}

void RouteSegmentDetails::setTollCost(const ::nds::core::types::TollCost& tollCost_)
{
    m_objectChoice = tollCost_;
}

void RouteSegmentDetails::setTollCost(::nds::core::types::TollCost&& tollCost_)
{
    m_objectChoice = ::std::move(tollCost_);
}

::nds::core::types::TrafficEnforcementCameraType RouteSegmentDetails::getTrafficEnforcementCameraType() const
{
    return m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>();
}

void RouteSegmentDetails::setTrafficEnforcementCameraType(::nds::core::types::TrafficEnforcementCameraType trafficEnforcementCameraType_)
{
    m_objectChoice = trafficEnforcementCameraType_;
}

::nds::core::types::TrafficEnforcementZoneType RouteSegmentDetails::getTrafficEnforcementZoneType() const
{
    return m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>();
}

void RouteSegmentDetails::setTrafficEnforcementZoneType(::nds::core::types::TrafficEnforcementZoneType trafficEnforcementZoneType_)
{
    m_objectChoice = trafficEnforcementZoneType_;
}

RouteSegmentDetails::ChoiceTag RouteSegmentDetails::choiceTag() const
{
    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        return CHOICE_delay;
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        return CHOICE_pollution;
    case ::nds::routing::types::RouteSegmentType::TOLL:
        return CHOICE_tollCost;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        return CHOICE_trafficEnforcementCameraType;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        return CHOICE_trafficEnforcementZoneType;
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::FERRY:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::BIKE:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        return UNDEFINED_CHOICE;
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        return UNDEFINED_CHOICE;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RouteSegmentDetails::initPackingContext(RouteSegmentDetails::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        m_objectChoice.get<::nds::routing::route::DelayInformation>().initPackingContext(context.getDelay());
        break;
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        m_objectChoice.get<::nds::routing::types::Pollution>().initPackingContext(context.getPollution());
        break;
    case ::nds::routing::types::RouteSegmentType::TOLL:
        m_objectChoice.get<::nds::core::types::TollCost>().initPackingContext(context.getTollCost());
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::initPackingContext(context.getTrafficEnforcementCameraType(), m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        ::zserio::initPackingContext(context.getTrafficEnforcementZoneType(), m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::FERRY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BIKE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        // empty
        break;
    default:
        // empty
        break;
    }
}

size_t RouteSegmentDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        endBitPosition += m_objectChoice.get<::nds::routing::route::DelayInformation>().bitSizeOf(endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        endBitPosition += m_objectChoice.get<::nds::routing::types::Pollution>().bitSizeOf(endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::TOLL:
        endBitPosition += m_objectChoice.get<::nds::core::types::TollCost>().bitSizeOf(endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::FERRY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BIKE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        // empty
        break;
    default:
        // empty
        break;
    }

    return endBitPosition - bitPosition;
}

size_t RouteSegmentDetails::bitSizeOf(RouteSegmentDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        endBitPosition += m_objectChoice.get<::nds::routing::route::DelayInformation>().bitSizeOf(context.getDelay(), endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        endBitPosition += m_objectChoice.get<::nds::routing::types::Pollution>().bitSizeOf(context.getPollution(), endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::TOLL:
        endBitPosition += m_objectChoice.get<::nds::core::types::TollCost>().bitSizeOf(context.getTollCost(), endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficEnforcementCameraType(), m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition += ::zserio::bitSizeOf(context.getTrafficEnforcementZoneType(), m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::FERRY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BIKE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        // empty
        break;
    default:
        // empty
        break;
    }

    return endBitPosition - bitPosition;
}

size_t RouteSegmentDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        endBitPosition = m_objectChoice.get<::nds::routing::route::DelayInformation>().initializeOffsets(endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        endBitPosition = m_objectChoice.get<::nds::routing::types::Pollution>().initializeOffsets(endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::TOLL:
        endBitPosition = m_objectChoice.get<::nds::core::types::TollCost>().initializeOffsets(endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::FERRY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BIKE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        // empty
        break;
    default:
        // empty
        break;
    }

    return endBitPosition;
}

size_t RouteSegmentDetails::initializeOffsets(RouteSegmentDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        endBitPosition = m_objectChoice.get<::nds::routing::route::DelayInformation>().initializeOffsets(context.getDelay(), endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        endBitPosition = m_objectChoice.get<::nds::routing::types::Pollution>().initializeOffsets(context.getPollution(), endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::TOLL:
        endBitPosition = m_objectChoice.get<::nds::core::types::TollCost>().initializeOffsets(context.getTollCost(), endBitPosition);
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficEnforcementCameraType(), endBitPosition,
        m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        endBitPosition = ::zserio::initializeOffsets(context.getTrafficEnforcementZoneType(), endBitPosition,
        m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::FERRY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BIKE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        // empty
        break;
    default:
        // empty
        break;
    }

    return endBitPosition;
}

bool RouteSegmentDetails::operator==(const RouteSegmentDetails& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::routing::route::DelayInformation>() == other.m_objectChoice.get<::nds::routing::route::DelayInformation>());
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::routing::types::Pollution>() == other.m_objectChoice.get<::nds::routing::types::Pollution>());
    case ::nds::routing::types::RouteSegmentType::TOLL:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::types::TollCost>() == other.m_objectChoice.get<::nds::core::types::TollCost>());
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>() == other.m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>());
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>() == other.m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>());
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::FERRY:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::BIKE:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        return true; // empty
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        return true; // empty
    default:
        return true; // empty
    }
}

uint32_t RouteSegmentDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::routing::types::RouteSegmentType::DELAY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::routing::route::DelayInformation>());
            break;
        case ::nds::routing::types::RouteSegmentType::POLLUTION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::routing::types::Pollution>());
            break;
        case ::nds::routing::types::RouteSegmentType::TOLL:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::types::TollCost>());
            break;
        case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>());
            break;
        case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>());
            break;
        case ::nds::routing::types::RouteSegmentType::TUNNEL:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::BRIDGE:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::FERRY:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::MOTORWAY:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::UNPAVED:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::VIGNETTE:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::BIKE:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::SCOOTER:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
            // empty
            break;
        case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
            // empty
            break;
        default:
            // empty
            break;
        }
    }

    return result;
}

void RouteSegmentDetails::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        m_objectChoice.get<::nds::routing::route::DelayInformation>().write(out);
        break;
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        m_objectChoice.get<::nds::routing::types::Pollution>().write(out);
        break;
    case ::nds::routing::types::RouteSegmentType::TOLL:
        m_objectChoice.get<::nds::core::types::TollCost>().write(out);
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::write(out, m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        ::zserio::write(out, m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::FERRY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BIKE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        // empty
        break;
    default:
        // empty
        break;
    }
}

void RouteSegmentDetails::write(RouteSegmentDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        m_objectChoice.get<::nds::routing::route::DelayInformation>().write(context.getDelay(), out);
        break;
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        m_objectChoice.get<::nds::routing::types::Pollution>().write(context.getPollution(), out);
        break;
    case ::nds::routing::types::RouteSegmentType::TOLL:
        m_objectChoice.get<::nds::core::types::TollCost>().write(context.getTollCost(), out);
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        ::zserio::write(context.getTrafficEnforcementCameraType(), out, m_objectChoice.get<::nds::core::types::TrafficEnforcementCameraType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        ::zserio::write(context.getTrafficEnforcementZoneType(), out, m_objectChoice.get<::nds::core::types::TrafficEnforcementZoneType>());
        break;
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::FERRY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::BIKE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        // empty
        break;
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        // empty
        break;
    default:
        // empty
        break;
    }
}

::zserio::AnyHolder<> RouteSegmentDetails::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        return ::zserio::AnyHolder<>(::nds::routing::route::DelayInformation(in, allocator), allocator);
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        return ::zserio::AnyHolder<>(::nds::routing::types::Pollution(in, allocator), allocator);
    case ::nds::routing::types::RouteSegmentType::TOLL:
        return ::zserio::AnyHolder<>(::nds::core::types::TollCost(in, allocator), allocator);
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::core::types::TrafficEnforcementCameraType>(in), allocator);
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::core::types::TrafficEnforcementZoneType>(in), allocator);
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::FERRY:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::BIKE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        return ::zserio::AnyHolder<>(allocator);
    default:
        return ::zserio::AnyHolder<>(allocator);
    }
}

::zserio::AnyHolder<> RouteSegmentDetails::readObject(RouteSegmentDetails::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        return ::zserio::AnyHolder<>(::nds::routing::route::DelayInformation(context.getDelay(), in, allocator), allocator);
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        return ::zserio::AnyHolder<>(::nds::routing::types::Pollution(context.getPollution(), in, allocator), allocator);
    case ::nds::routing::types::RouteSegmentType::TOLL:
        return ::zserio::AnyHolder<>(::nds::core::types::TollCost(context.getTollCost(), in, allocator), allocator);
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::core::types::TrafficEnforcementCameraType>(context.getTrafficEnforcementCameraType(), in), allocator);
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::core::types::TrafficEnforcementZoneType>(context.getTrafficEnforcementZoneType(), in), allocator);
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::FERRY:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::BIKE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        return ::zserio::AnyHolder<>(allocator);
    default:
        return ::zserio::AnyHolder<>(allocator);
    }
}

::zserio::AnyHolder<> RouteSegmentDetails::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        return ::zserio::allocatorPropagatingCopy<::nds::routing::route::DelayInformation>(m_objectChoice, allocator);
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        return ::zserio::allocatorPropagatingCopy<::nds::routing::types::Pollution>(m_objectChoice, allocator);
    case ::nds::routing::types::RouteSegmentType::TOLL:
        return ::zserio::allocatorPropagatingCopy<::nds::core::types::TollCost>(m_objectChoice, allocator);
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        return ::zserio::allocatorPropagatingCopy<::nds::core::types::TrafficEnforcementCameraType>(m_objectChoice, allocator);
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        return ::zserio::allocatorPropagatingCopy<::nds::core::types::TrafficEnforcementZoneType>(m_objectChoice, allocator);
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::FERRY:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::BIKE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        return ::zserio::AnyHolder<>(allocator);
    default:
        return ::zserio::AnyHolder<>(allocator);
    }
}

} // namespace route
} // namespace routing
} // namespace nds
