/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/metadata/RoutingServiceType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoutingServiceType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::routing::metadata::RoutingServiceType>::names;
constexpr ::std::array<::nds::routing::metadata::RoutingServiceType, 2> EnumTraits<::nds::routing::metadata::RoutingServiceType>::values;
constexpr const char* EnumTraits<::nds::routing::metadata::RoutingServiceType>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::metadata::RoutingServiceType value)
{
    switch (value)
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        return 0;
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoutingServiceType: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::metadata::RoutingServiceType>::type>(value) << "!";
    }
}

template <>
::nds::routing::metadata::RoutingServiceType valueToEnum(
        typename ::std::underlying_type<::nds::routing::metadata::RoutingServiceType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::routing::metadata::RoutingServiceType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoutingServiceType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::metadata::RoutingServiceType>(::nds::routing::metadata::RoutingServiceType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::metadata::RoutingServiceType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::metadata::RoutingServiceType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::metadata::RoutingServiceType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::metadata::RoutingServiceType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::metadata::RoutingServiceType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::metadata::RoutingServiceType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::metadata::RoutingServiceType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::metadata::RoutingServiceType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::metadata::RoutingServiceType>(
            static_cast<typename ::std::underlying_type<::nds::routing::metadata::RoutingServiceType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::routing::metadata::RoutingServiceType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::metadata::RoutingServiceType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::metadata::RoutingServiceType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::metadata::RoutingServiceType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::metadata::RoutingServiceType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::metadata::RoutingServiceType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/routing/metadata/SupportedVehicleDetails.h>

namespace nds
{
namespace routing
{
namespace metadata
{

SupportedVehicleDetails::SupportedVehicleDetails(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

SupportedVehicleDetails::SupportedVehicleDetails(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void SupportedVehicleDetails::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::routing::metadata::SupportedVehicleDetails::underlying_type>>(m_value);
}

size_t SupportedVehicleDetails::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t SupportedVehicleDetails::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::routing::metadata::SupportedVehicleDetails::underlying_type>>(m_value);
}

size_t SupportedVehicleDetails::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t SupportedVehicleDetails::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t SupportedVehicleDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void SupportedVehicleDetails::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void SupportedVehicleDetails::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::routing::metadata::SupportedVehicleDetails::underlying_type>>(out, m_value);
}

::zserio::string<> SupportedVehicleDetails::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & SupportedVehicleDetails::Values::ENGINE_TYPE_ELECTRIC) == SupportedVehicleDetails::Values::ENGINE_TYPE_ELECTRIC)
        result += result.empty() ? "ENGINE_TYPE_ELECTRIC" : " | ENGINE_TYPE_ELECTRIC";
    if ((*this & SupportedVehicleDetails::Values::ENGINE_EURO_EMISSION_CLASS) == SupportedVehicleDetails::Values::ENGINE_EURO_EMISSION_CLASS)
        result += result.empty() ? "ENGINE_EURO_EMISSION_CLASS" : " | ENGINE_EURO_EMISSION_CLASS";
    if ((*this & SupportedVehicleDetails::Values::VEHICLE_TYPE_TRUCK) == SupportedVehicleDetails::Values::VEHICLE_TYPE_TRUCK)
        result += result.empty() ? "VEHICLE_TYPE_TRUCK" : " | VEHICLE_TYPE_TRUCK";
    if ((*this & SupportedVehicleDetails::Values::VEHICLE_TYPE_PUBLIC_TRANSPORT) == SupportedVehicleDetails::Values::VEHICLE_TYPE_PUBLIC_TRANSPORT)
        result += result.empty() ? "VEHICLE_TYPE_PUBLIC_TRANSPORT" : " | VEHICLE_TYPE_PUBLIC_TRANSPORT";
    if ((*this & SupportedVehicleDetails::Values::VEHICLE_TYPE_PEDESTRIAN) == SupportedVehicleDetails::Values::VEHICLE_TYPE_PEDESTRIAN)
        result += result.empty() ? "VEHICLE_TYPE_PEDESTRIAN" : " | VEHICLE_TYPE_PEDESTRIAN";
    if ((*this & SupportedVehicleDetails::Values::VEHICLE_TYPE_BICYCLE) == SupportedVehicleDetails::Values::VEHICLE_TYPE_BICYCLE)
        result += result.empty() ? "VEHICLE_TYPE_BICYCLE" : " | VEHICLE_TYPE_BICYCLE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

SupportedVehicleDetails::underlying_type SupportedVehicleDetails::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

SupportedVehicleDetails::underlying_type SupportedVehicleDetails::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::routing::metadata::SupportedVehicleDetails::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/routing/metadata/SupportedDriverProfileDetails.h>

namespace nds
{
namespace routing
{
namespace metadata
{

SupportedDriverProfileDetails::SupportedDriverProfileDetails(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

SupportedDriverProfileDetails::SupportedDriverProfileDetails(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void SupportedDriverProfileDetails::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::routing::metadata::SupportedDriverProfileDetails::underlying_type>>(m_value);
}

size_t SupportedDriverProfileDetails::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t SupportedDriverProfileDetails::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::routing::metadata::SupportedDriverProfileDetails::underlying_type>>(m_value);
}

size_t SupportedDriverProfileDetails::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t SupportedDriverProfileDetails::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t SupportedDriverProfileDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void SupportedDriverProfileDetails::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void SupportedDriverProfileDetails::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::routing::metadata::SupportedDriverProfileDetails::underlying_type>>(out, m_value);
}

::zserio::string<> SupportedDriverProfileDetails::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & SupportedDriverProfileDetails::Values::DRIVER_AGGRESSIVENESS) == SupportedDriverProfileDetails::Values::DRIVER_AGGRESSIVENESS)
        result += result.empty() ? "DRIVER_AGGRESSIVENESS" : " | DRIVER_AGGRESSIVENESS";
    if ((*this & SupportedDriverProfileDetails::Values::DISABLED_DRIVERS) == SupportedDriverProfileDetails::Values::DISABLED_DRIVERS)
        result += result.empty() ? "DISABLED_DRIVERS" : " | DISABLED_DRIVERS";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

SupportedDriverProfileDetails::underlying_type SupportedDriverProfileDetails::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

SupportedDriverProfileDetails::underlying_type SupportedDriverProfileDetails::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::routing::metadata::SupportedDriverProfileDetails::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/routing/metadata/RouteServiceMethods.h>

namespace nds
{
namespace routing
{
namespace metadata
{

RouteServiceMethods::RouteServiceMethods(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

RouteServiceMethods::RouteServiceMethods(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void RouteServiceMethods::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::routing::metadata::RouteServiceMethods::underlying_type>>(m_value);
}

size_t RouteServiceMethods::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t RouteServiceMethods::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::routing::metadata::RouteServiceMethods::underlying_type>>(m_value);
}

size_t RouteServiceMethods::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t RouteServiceMethods::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t RouteServiceMethods::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void RouteServiceMethods::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void RouteServiceMethods::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::routing::metadata::RouteServiceMethods::underlying_type>>(out, m_value);
}

::zserio::string<> RouteServiceMethods::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & RouteServiceMethods::Values::GET_ROUTE) == RouteServiceMethods::Values::GET_ROUTE)
        result += result.empty() ? "GET_ROUTE" : " | GET_ROUTE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

RouteServiceMethods::underlying_type RouteServiceMethods::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

RouteServiceMethods::underlying_type RouteServiceMethods::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::routing::metadata::RouteServiceMethods::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/routing/metadata/RangeProjectionServiceMethods.h>

namespace nds
{
namespace routing
{
namespace metadata
{

RangeProjectionServiceMethods::RangeProjectionServiceMethods(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

RangeProjectionServiceMethods::RangeProjectionServiceMethods(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void RangeProjectionServiceMethods::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::routing::metadata::RangeProjectionServiceMethods::underlying_type>>(m_value);
}

size_t RangeProjectionServiceMethods::bitSizeOf(size_t) const
{
    return UINT8_C(16);
}

size_t RangeProjectionServiceMethods::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::routing::metadata::RangeProjectionServiceMethods::underlying_type>>(m_value);
}

size_t RangeProjectionServiceMethods::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t RangeProjectionServiceMethods::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t RangeProjectionServiceMethods::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void RangeProjectionServiceMethods::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(16));
}

void RangeProjectionServiceMethods::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::routing::metadata::RangeProjectionServiceMethods::underlying_type>>(out, m_value);
}

::zserio::string<> RangeProjectionServiceMethods::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & RangeProjectionServiceMethods::Values::CALCULATE_RANGE) == RangeProjectionServiceMethods::Values::CALCULATE_RANGE)
        result += result.empty() ? "CALCULATE_RANGE" : " | CALCULATE_RANGE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

RangeProjectionServiceMethods::underlying_type RangeProjectionServiceMethods::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(16)));
}

RangeProjectionServiceMethods::underlying_type RangeProjectionServiceMethods::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::routing::metadata::RangeProjectionServiceMethods::underlying_type>>(
            in);
}

} // namespace metadata
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/metadata/RoutingRegistryMetadata.h>

namespace nds
{
namespace routing
{
namespace metadata
{

RoutingRegistryMetadata::RoutingRegistryMetadata(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_routingServiceType_(::nds::routing::metadata::RoutingServiceType()),
        m_capabilities_(allocator),
        m_availableLanguages_(allocator)
{
}

RoutingRegistryMetadata::RoutingRegistryMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_routingServiceType_(readRoutingServiceType(in)),
        m_capabilities_(readCapabilities(in, allocator)),
        m_availableLanguages_(readAvailableLanguages(in, allocator))
{
}

RoutingRegistryMetadata::RoutingRegistryMetadata(RoutingRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_routingServiceType_(readRoutingServiceType(context, in)),
        m_capabilities_(readCapabilities(context, in, allocator)),
        m_availableLanguages_(readAvailableLanguages(context, in, allocator))
{
}

RoutingRegistryMetadata::RoutingRegistryMetadata(const RoutingRegistryMetadata& other) :
        m_routingServiceType_(other.m_routingServiceType_),
        m_capabilities_(other.m_capabilities_),
        m_availableLanguages_(other.m_availableLanguages_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingRegistryMetadata& RoutingRegistryMetadata::operator=(const RoutingRegistryMetadata& other)
{
    m_routingServiceType_ = other.m_routingServiceType_;
    m_capabilities_ = other.m_capabilities_;
    m_availableLanguages_ = other.m_availableLanguages_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingRegistryMetadata::RoutingRegistryMetadata(RoutingRegistryMetadata&& other) :
        m_routingServiceType_(::std::move(other.m_routingServiceType_)),
        m_capabilities_(::std::move(other.m_capabilities_)),
        m_availableLanguages_(::std::move(other.m_availableLanguages_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoutingRegistryMetadata& RoutingRegistryMetadata::operator=(RoutingRegistryMetadata&& other)
{
    m_routingServiceType_ = ::std::move(other.m_routingServiceType_);
    m_capabilities_ = ::std::move(other.m_capabilities_);
    m_availableLanguages_ = ::std::move(other.m_availableLanguages_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoutingRegistryMetadata::RoutingRegistryMetadata(::zserio::PropagateAllocatorT,
        const RoutingRegistryMetadata& other, const allocator_type& allocator) :
        m_routingServiceType_(::zserio::allocatorPropagatingCopy(other.m_routingServiceType_, allocator)),
        m_capabilities_(::zserio::allocatorPropagatingCopy(other.m_capabilities_, allocator)),
        m_availableLanguages_(::zserio::allocatorPropagatingCopy(other.m_availableLanguages_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoutingRegistryMetadata::initializeChildren()
{
    m_capabilities_.initialize(static_cast<::nds::routing::metadata::RoutingServiceType>(getRoutingServiceType()));

    m_areChildrenInitialized = true;
}

::nds::routing::metadata::RoutingServiceType RoutingRegistryMetadata::getRoutingServiceType() const
{
    return m_routingServiceType_;
}

void RoutingRegistryMetadata::setRoutingServiceType(::nds::routing::metadata::RoutingServiceType routingServiceType_)
{
    m_routingServiceType_ = routingServiceType_;
}

::nds::routing::metadata::RoutingServiceCapabilities& RoutingRegistryMetadata::getCapabilities()
{
    return m_capabilities_;
}

const ::nds::routing::metadata::RoutingServiceCapabilities& RoutingRegistryMetadata::getCapabilities() const
{
    return m_capabilities_;
}

void RoutingRegistryMetadata::setCapabilities(const ::nds::routing::metadata::RoutingServiceCapabilities& capabilities_)
{
    m_capabilities_ = capabilities_;
}

void RoutingRegistryMetadata::setCapabilities(::nds::routing::metadata::RoutingServiceCapabilities&& capabilities_)
{
    m_capabilities_ = ::std::move(capabilities_);
}

::nds::core::language::AvailableLanguages& RoutingRegistryMetadata::getAvailableLanguages()
{
    return m_availableLanguages_;
}

const ::nds::core::language::AvailableLanguages& RoutingRegistryMetadata::getAvailableLanguages() const
{
    return m_availableLanguages_;
}

void RoutingRegistryMetadata::setAvailableLanguages(const ::nds::core::language::AvailableLanguages& availableLanguages_)
{
    m_availableLanguages_ = availableLanguages_;
}

void RoutingRegistryMetadata::setAvailableLanguages(::nds::core::language::AvailableLanguages&& availableLanguages_)
{
    m_availableLanguages_ = ::std::move(availableLanguages_);
}

void RoutingRegistryMetadata::initPackingContext(RoutingRegistryMetadata::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getRoutingServiceType(), m_routingServiceType_);
    m_capabilities_.initPackingContext(context.getCapabilities());
    m_availableLanguages_.initPackingContext(context.getAvailableLanguages());
}

size_t RoutingRegistryMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_routingServiceType_);
    endBitPosition += m_capabilities_.bitSizeOf(endBitPosition);
    endBitPosition += m_availableLanguages_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRegistryMetadata::bitSizeOf(RoutingRegistryMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getRoutingServiceType(), m_routingServiceType_);
    endBitPosition += m_capabilities_.bitSizeOf(context.getCapabilities(), endBitPosition);
    endBitPosition += m_availableLanguages_.bitSizeOf(context.getAvailableLanguages(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoutingRegistryMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_routingServiceType_);
    endBitPosition = m_capabilities_.initializeOffsets(endBitPosition);
    endBitPosition = m_availableLanguages_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoutingRegistryMetadata::initializeOffsets(RoutingRegistryMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getRoutingServiceType(), endBitPosition,
        m_routingServiceType_);
    endBitPosition = m_capabilities_.initializeOffsets(context.getCapabilities(), endBitPosition);
    endBitPosition = m_availableLanguages_.initializeOffsets(context.getAvailableLanguages(), endBitPosition);

    return endBitPosition;
}

bool RoutingRegistryMetadata::operator==(const RoutingRegistryMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_routingServiceType_ == other.m_routingServiceType_) &&
                (m_capabilities_ == other.m_capabilities_) &&
                (m_availableLanguages_ == other.m_availableLanguages_);
    }

    return true;
}

uint32_t RoutingRegistryMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_routingServiceType_);
    result = ::zserio::calcHashCode(result, m_capabilities_);
    result = ::zserio::calcHashCode(result, m_availableLanguages_);

    return result;
}

void RoutingRegistryMetadata::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_routingServiceType_);

    // check parameters
    if (m_capabilities_.getType() != static_cast<::nds::routing::metadata::RoutingServiceType>(getRoutingServiceType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRegistryMetadata.capabilities: ") <<
                m_capabilities_.getType() << " != " << static_cast<::nds::routing::metadata::RoutingServiceType>(getRoutingServiceType()) << "!";
    }
    m_capabilities_.write(out);

    m_availableLanguages_.write(out);
}

void RoutingRegistryMetadata::write(RoutingRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getRoutingServiceType(), out, m_routingServiceType_);

    // check parameters
    if (m_capabilities_.getType() != static_cast<::nds::routing::metadata::RoutingServiceType>(getRoutingServiceType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field RoutingRegistryMetadata.capabilities: ") <<
                m_capabilities_.getType() << " != " << static_cast<::nds::routing::metadata::RoutingServiceType>(getRoutingServiceType()) << "!";
    }
    m_capabilities_.write(context.getCapabilities(), out);

    m_availableLanguages_.write(context.getAvailableLanguages(), out);
}

::nds::routing::metadata::RoutingServiceType RoutingRegistryMetadata::readRoutingServiceType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::metadata::RoutingServiceType>(in);
}

::nds::routing::metadata::RoutingServiceType RoutingRegistryMetadata::readRoutingServiceType(RoutingRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::metadata::RoutingServiceType>(context.getRoutingServiceType(), in);
}
::nds::routing::metadata::RoutingServiceCapabilities RoutingRegistryMetadata::readCapabilities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::routing::metadata::RoutingServiceCapabilities(in, static_cast<::nds::routing::metadata::RoutingServiceType>(getRoutingServiceType()), allocator);
}

::nds::routing::metadata::RoutingServiceCapabilities RoutingRegistryMetadata::readCapabilities(RoutingRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::routing::metadata::RoutingServiceCapabilities(context.getCapabilities(), in, static_cast<::nds::routing::metadata::RoutingServiceType>(getRoutingServiceType()), allocator);
}
::nds::core::language::AvailableLanguages RoutingRegistryMetadata::readAvailableLanguages(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::language::AvailableLanguages(in, allocator);
}

::nds::core::language::AvailableLanguages RoutingRegistryMetadata::readAvailableLanguages(RoutingRegistryMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::language::AvailableLanguages(context.getAvailableLanguages(), in, allocator);
}

} // namespace metadata
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/metadata/RouteServiceCapabilities.h>

namespace nds
{
namespace routing
{
namespace metadata
{

RouteServiceCapabilities::RouteServiceCapabilities(const allocator_type& allocator) noexcept :
        m_implementedMethods_(::nds::routing::metadata::RouteServiceMethods()),
        m_supportedRouteTypes_(allocator),
        m_supportedRouteOptions_(allocator),
        m_supportedLanguages_(allocator),
        m_supportedVehicleDetails_(::nds::routing::metadata::SupportedVehicleDetails()),
        m_supportedDriverProfileDetails_(::nds::routing::metadata::SupportedDriverProfileDetails()),
        m_providesAlternativeRoutes_(bool()),
        m_considersTimes_(bool()),
        m_usesCustomData_(bool()),
        m_customDataMetadata_(::zserio::NullOpt)
{
}

RouteServiceCapabilities::RouteServiceCapabilities(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_implementedMethods_(readImplementedMethods(in)),
        m_supportedRouteTypes_(readSupportedRouteTypes(in, allocator)),
        m_supportedRouteOptions_(readSupportedRouteOptions(in, allocator)),
        m_supportedLanguages_(readSupportedLanguages(in, allocator)),
        m_supportedVehicleDetails_(readSupportedVehicleDetails(in)),
        m_supportedDriverProfileDetails_(readSupportedDriverProfileDetails(in)),
        m_providesAlternativeRoutes_(readProvidesAlternativeRoutes(in)),
        m_considersTimes_(readConsidersTimes(in)),
        m_usesCustomData_(readUsesCustomData(in)),
        m_customDataMetadata_(readCustomDataMetadata(in, allocator))
{
}

RouteServiceCapabilities::RouteServiceCapabilities(RouteServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_implementedMethods_(readImplementedMethods(context, in)),
        m_supportedRouteTypes_(readSupportedRouteTypes(context, in, allocator)),
        m_supportedRouteOptions_(readSupportedRouteOptions(context, in, allocator)),
        m_supportedLanguages_(readSupportedLanguages(context, in, allocator)),
        m_supportedVehicleDetails_(readSupportedVehicleDetails(context, in)),
        m_supportedDriverProfileDetails_(readSupportedDriverProfileDetails(context, in)),
        m_providesAlternativeRoutes_(readProvidesAlternativeRoutes(in)),
        m_considersTimes_(readConsidersTimes(in)),
        m_usesCustomData_(readUsesCustomData(in)),
        m_customDataMetadata_(readCustomDataMetadata(in, allocator))
{
}

RouteServiceCapabilities::RouteServiceCapabilities(::zserio::PropagateAllocatorT,
        const RouteServiceCapabilities& other, const allocator_type& allocator) :
        m_implementedMethods_(::zserio::allocatorPropagatingCopy(other.m_implementedMethods_, allocator)),
        m_supportedRouteTypes_(::zserio::allocatorPropagatingCopy(other.m_supportedRouteTypes_, allocator)),
        m_supportedRouteOptions_(::zserio::allocatorPropagatingCopy(other.m_supportedRouteOptions_, allocator)),
        m_supportedLanguages_(::zserio::allocatorPropagatingCopy(other.m_supportedLanguages_, allocator)),
        m_supportedVehicleDetails_(::zserio::allocatorPropagatingCopy(other.m_supportedVehicleDetails_, allocator)),
        m_supportedDriverProfileDetails_(::zserio::allocatorPropagatingCopy(other.m_supportedDriverProfileDetails_, allocator)),
        m_providesAlternativeRoutes_(::zserio::allocatorPropagatingCopy(other.m_providesAlternativeRoutes_, allocator)),
        m_considersTimes_(::zserio::allocatorPropagatingCopy(other.m_considersTimes_, allocator)),
        m_usesCustomData_(::zserio::allocatorPropagatingCopy(other.m_usesCustomData_, allocator)),
        m_customDataMetadata_(::zserio::allocatorPropagatingCopy(other.m_customDataMetadata_, allocator))
{
}

::nds::routing::metadata::RouteServiceMethods RouteServiceCapabilities::getImplementedMethods() const
{
    return m_implementedMethods_;
}

void RouteServiceCapabilities::setImplementedMethods(::nds::routing::metadata::RouteServiceMethods implementedMethods_)
{
    m_implementedMethods_ = implementedMethods_;
}

::zserio::vector<::nds::routing::types::RouteType>& RouteServiceCapabilities::getSupportedRouteTypes()
{
    return m_supportedRouteTypes_.getRawArray();
}

const ::zserio::vector<::nds::routing::types::RouteType>& RouteServiceCapabilities::getSupportedRouteTypes() const
{
    return m_supportedRouteTypes_.getRawArray();
}

void RouteServiceCapabilities::setSupportedRouteTypes(const ::zserio::vector<::nds::routing::types::RouteType>& supportedRouteTypes_)
{
    m_supportedRouteTypes_ = ZserioArrayType_supportedRouteTypes(supportedRouteTypes_);
}

void RouteServiceCapabilities::setSupportedRouteTypes(::zserio::vector<::nds::routing::types::RouteType>&& supportedRouteTypes_)
{
    m_supportedRouteTypes_ = ZserioArrayType_supportedRouteTypes(std::move(supportedRouteTypes_));
}

::zserio::vector<::nds::routing::route::RouteOptions>& RouteServiceCapabilities::getSupportedRouteOptions()
{
    return m_supportedRouteOptions_.getRawArray();
}

const ::zserio::vector<::nds::routing::route::RouteOptions>& RouteServiceCapabilities::getSupportedRouteOptions() const
{
    return m_supportedRouteOptions_.getRawArray();
}

void RouteServiceCapabilities::setSupportedRouteOptions(const ::zserio::vector<::nds::routing::route::RouteOptions>& supportedRouteOptions_)
{
    m_supportedRouteOptions_ = ZserioArrayType_supportedRouteOptions(supportedRouteOptions_);
}

void RouteServiceCapabilities::setSupportedRouteOptions(::zserio::vector<::nds::routing::route::RouteOptions>&& supportedRouteOptions_)
{
    m_supportedRouteOptions_ = ZserioArrayType_supportedRouteOptions(std::move(supportedRouteOptions_));
}

::zserio::vector<::nds::core::types::LanguageCode>& RouteServiceCapabilities::getSupportedLanguages()
{
    return m_supportedLanguages_.getRawArray();
}

const ::zserio::vector<::nds::core::types::LanguageCode>& RouteServiceCapabilities::getSupportedLanguages() const
{
    return m_supportedLanguages_.getRawArray();
}

void RouteServiceCapabilities::setSupportedLanguages(const ::zserio::vector<::nds::core::types::LanguageCode>& supportedLanguages_)
{
    m_supportedLanguages_ = ZserioArrayType_supportedLanguages(supportedLanguages_);
}

void RouteServiceCapabilities::setSupportedLanguages(::zserio::vector<::nds::core::types::LanguageCode>&& supportedLanguages_)
{
    m_supportedLanguages_ = ZserioArrayType_supportedLanguages(std::move(supportedLanguages_));
}

::nds::routing::metadata::SupportedVehicleDetails RouteServiceCapabilities::getSupportedVehicleDetails() const
{
    return m_supportedVehicleDetails_;
}

void RouteServiceCapabilities::setSupportedVehicleDetails(::nds::routing::metadata::SupportedVehicleDetails supportedVehicleDetails_)
{
    m_supportedVehicleDetails_ = supportedVehicleDetails_;
}

::nds::routing::metadata::SupportedDriverProfileDetails RouteServiceCapabilities::getSupportedDriverProfileDetails() const
{
    return m_supportedDriverProfileDetails_;
}

void RouteServiceCapabilities::setSupportedDriverProfileDetails(::nds::routing::metadata::SupportedDriverProfileDetails supportedDriverProfileDetails_)
{
    m_supportedDriverProfileDetails_ = supportedDriverProfileDetails_;
}

bool RouteServiceCapabilities::getProvidesAlternativeRoutes() const
{
    return m_providesAlternativeRoutes_;
}

void RouteServiceCapabilities::setProvidesAlternativeRoutes(bool providesAlternativeRoutes_)
{
    m_providesAlternativeRoutes_ = providesAlternativeRoutes_;
}

bool RouteServiceCapabilities::getConsidersTimes() const
{
    return m_considersTimes_;
}

void RouteServiceCapabilities::setConsidersTimes(bool considersTimes_)
{
    m_considersTimes_ = considersTimes_;
}

bool RouteServiceCapabilities::getUsesCustomData() const
{
    return m_usesCustomData_;
}

void RouteServiceCapabilities::setUsesCustomData(bool usesCustomData_)
{
    m_usesCustomData_ = usesCustomData_;
}

::zserio::BitBuffer& RouteServiceCapabilities::getCustomDataMetadata()
{
    return m_customDataMetadata_.value();
}

const ::zserio::BitBuffer& RouteServiceCapabilities::getCustomDataMetadata() const
{
    return m_customDataMetadata_.value();
}

void RouteServiceCapabilities::setCustomDataMetadata(const ::zserio::BitBuffer& customDataMetadata_)
{
    m_customDataMetadata_ = customDataMetadata_;
}

void RouteServiceCapabilities::setCustomDataMetadata(::zserio::BitBuffer&& customDataMetadata_)
{
    m_customDataMetadata_ = ::std::move(customDataMetadata_);
}

bool RouteServiceCapabilities::isCustomDataMetadataUsed() const
{
    return (getUsesCustomData());
}

bool RouteServiceCapabilities::isCustomDataMetadataSet() const
{
    return m_customDataMetadata_.hasValue();
}

void RouteServiceCapabilities::resetCustomDataMetadata()
{
    m_customDataMetadata_.reset();
}

void RouteServiceCapabilities::initPackingContext(RouteServiceCapabilities::ZserioPackingContext& context) const
{
    m_implementedMethods_.initPackingContext(context.getImplementedMethods());
    m_supportedVehicleDetails_.initPackingContext(context.getSupportedVehicleDetails());
    m_supportedDriverProfileDetails_.initPackingContext(context.getSupportedDriverProfileDetails());
}

size_t RouteServiceCapabilities::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_implementedMethods_.bitSizeOf(endBitPosition);
    endBitPosition += m_supportedRouteTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_supportedRouteOptions_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_supportedLanguages_.bitSizeOf(endBitPosition);
    endBitPosition += m_supportedVehicleDetails_.bitSizeOf(endBitPosition);
    endBitPosition += m_supportedDriverProfileDetails_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getUsesCustomData())
    {
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customDataMetadata_.value());
    }

    return endBitPosition - bitPosition;
}

size_t RouteServiceCapabilities::bitSizeOf(RouteServiceCapabilities::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_implementedMethods_.bitSizeOf(context.getImplementedMethods(), endBitPosition);
    endBitPosition += m_supportedRouteTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_supportedRouteOptions_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_supportedLanguages_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_supportedVehicleDetails_.bitSizeOf(context.getSupportedVehicleDetails(), endBitPosition);
    endBitPosition += m_supportedDriverProfileDetails_.bitSizeOf(context.getSupportedDriverProfileDetails(), endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getUsesCustomData())
    {
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customDataMetadata_.value());
    }

    return endBitPosition - bitPosition;
}

size_t RouteServiceCapabilities::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_implementedMethods_.initializeOffsets(endBitPosition);
    endBitPosition = m_supportedRouteTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_supportedRouteOptions_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_supportedLanguages_.initializeOffsets(endBitPosition);
    endBitPosition = m_supportedVehicleDetails_.initializeOffsets(endBitPosition);
    endBitPosition = m_supportedDriverProfileDetails_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getUsesCustomData())
    {
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customDataMetadata_.value());
    }

    return endBitPosition;
}

size_t RouteServiceCapabilities::initializeOffsets(RouteServiceCapabilities::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_implementedMethods_.initializeOffsets(context.getImplementedMethods(), endBitPosition);
    endBitPosition = m_supportedRouteTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_supportedRouteOptions_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_supportedLanguages_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_supportedVehicleDetails_.initializeOffsets(context.getSupportedVehicleDetails(), endBitPosition);
    endBitPosition = m_supportedDriverProfileDetails_.initializeOffsets(context.getSupportedDriverProfileDetails(), endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getUsesCustomData())
    {
        endBitPosition += ::zserio::bitSizeOfBitBuffer(m_customDataMetadata_.value());
    }

    return endBitPosition;
}

bool RouteServiceCapabilities::operator==(const RouteServiceCapabilities& other) const
{
    if (this != &other)
    {
        return
                (m_implementedMethods_ == other.m_implementedMethods_) &&
                (m_supportedRouteTypes_ == other.m_supportedRouteTypes_) &&
                (m_supportedRouteOptions_ == other.m_supportedRouteOptions_) &&
                (m_supportedLanguages_ == other.m_supportedLanguages_) &&
                (m_supportedVehicleDetails_ == other.m_supportedVehicleDetails_) &&
                (m_supportedDriverProfileDetails_ == other.m_supportedDriverProfileDetails_) &&
                (m_providesAlternativeRoutes_ == other.m_providesAlternativeRoutes_) &&
                (m_considersTimes_ == other.m_considersTimes_) &&
                (m_usesCustomData_ == other.m_usesCustomData_) &&
                (!isCustomDataMetadataUsed() ? !other.isCustomDataMetadataUsed() : (m_customDataMetadata_ == other.m_customDataMetadata_));
    }

    return true;
}

uint32_t RouteServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_implementedMethods_);
    result = ::zserio::calcHashCode(result, m_supportedRouteTypes_);
    result = ::zserio::calcHashCode(result, m_supportedRouteOptions_);
    result = ::zserio::calcHashCode(result, m_supportedLanguages_);
    result = ::zserio::calcHashCode(result, m_supportedVehicleDetails_);
    result = ::zserio::calcHashCode(result, m_supportedDriverProfileDetails_);
    result = ::zserio::calcHashCode(result, m_providesAlternativeRoutes_);
    result = ::zserio::calcHashCode(result, m_considersTimes_);
    result = ::zserio::calcHashCode(result, m_usesCustomData_);
    if (isCustomDataMetadataUsed())
        result = ::zserio::calcHashCode(result, m_customDataMetadata_);

    return result;
}

void RouteServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    m_implementedMethods_.write(out);
    m_supportedRouteTypes_.write(out);
    m_supportedRouteOptions_.write(*this, out);
    m_supportedLanguages_.write(out);
    m_supportedVehicleDetails_.write(out);
    m_supportedDriverProfileDetails_.write(out);
    out.writeBool(m_providesAlternativeRoutes_);
    out.writeBool(m_considersTimes_);
    out.writeBool(m_usesCustomData_);
    if (getUsesCustomData())
    {
        out.writeBitBuffer(m_customDataMetadata_.value());
    }
}

void RouteServiceCapabilities::write(RouteServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_implementedMethods_.write(context.getImplementedMethods(), out);
    m_supportedRouteTypes_.writePacked(out);
    m_supportedRouteOptions_.writePacked(*this, out);
    m_supportedLanguages_.writePacked(out);
    m_supportedVehicleDetails_.write(context.getSupportedVehicleDetails(), out);
    m_supportedDriverProfileDetails_.write(context.getSupportedDriverProfileDetails(), out);
    out.writeBool(m_providesAlternativeRoutes_);
    out.writeBool(m_considersTimes_);
    out.writeBool(m_usesCustomData_);
    if (getUsesCustomData())
    {
        out.writeBitBuffer(m_customDataMetadata_.value());
    }
}

void RouteServiceCapabilities::ZserioElementFactory_supportedRouteOptions::create(RouteServiceCapabilities&        ,
        ::zserio::vector<::nds::routing::route::RouteOptions>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RouteServiceCapabilities::ZserioElementFactory_supportedRouteOptions::create(RouteServiceCapabilities&        ,
        ::zserio::vector<::nds::routing::route::RouteOptions>& array,
        ::nds::routing::route::RouteOptions::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::routing::metadata::RouteServiceMethods RouteServiceCapabilities::readImplementedMethods(::zserio::BitStreamReader& in)
{
    return ::nds::routing::metadata::RouteServiceMethods(in);
}

::nds::routing::metadata::RouteServiceMethods RouteServiceCapabilities::readImplementedMethods(RouteServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::routing::metadata::RouteServiceMethods(context.getImplementedMethods(), in);
}
RouteServiceCapabilities::ZserioArrayType_supportedRouteTypes RouteServiceCapabilities::readSupportedRouteTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_supportedRouteTypes readField(allocator);
    readField.read(in);

    return readField;
}

RouteServiceCapabilities::ZserioArrayType_supportedRouteTypes RouteServiceCapabilities::readSupportedRouteTypes(RouteServiceCapabilities::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_supportedRouteTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
RouteServiceCapabilities::ZserioArrayType_supportedRouteOptions RouteServiceCapabilities::readSupportedRouteOptions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_supportedRouteOptions readField(allocator);
    readField.read(*this, in);

    return readField;
}

RouteServiceCapabilities::ZserioArrayType_supportedRouteOptions RouteServiceCapabilities::readSupportedRouteOptions(RouteServiceCapabilities::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_supportedRouteOptions readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
RouteServiceCapabilities::ZserioArrayType_supportedLanguages RouteServiceCapabilities::readSupportedLanguages(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_supportedLanguages readField(allocator);
    readField.read(in);

    return readField;
}

RouteServiceCapabilities::ZserioArrayType_supportedLanguages RouteServiceCapabilities::readSupportedLanguages(RouteServiceCapabilities::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_supportedLanguages readField(allocator);
    readField.readPacked(in);

    return readField;
}
::nds::routing::metadata::SupportedVehicleDetails RouteServiceCapabilities::readSupportedVehicleDetails(::zserio::BitStreamReader& in)
{
    return ::nds::routing::metadata::SupportedVehicleDetails(in);
}

::nds::routing::metadata::SupportedVehicleDetails RouteServiceCapabilities::readSupportedVehicleDetails(RouteServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::routing::metadata::SupportedVehicleDetails(context.getSupportedVehicleDetails(), in);
}
::nds::routing::metadata::SupportedDriverProfileDetails RouteServiceCapabilities::readSupportedDriverProfileDetails(::zserio::BitStreamReader& in)
{
    return ::nds::routing::metadata::SupportedDriverProfileDetails(in);
}

::nds::routing::metadata::SupportedDriverProfileDetails RouteServiceCapabilities::readSupportedDriverProfileDetails(RouteServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::routing::metadata::SupportedDriverProfileDetails(context.getSupportedDriverProfileDetails(), in);
}
bool RouteServiceCapabilities::readProvidesAlternativeRoutes(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool RouteServiceCapabilities::readConsidersTimes(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool RouteServiceCapabilities::readUsesCustomData(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::zserio::BitBuffer> RouteServiceCapabilities::readCustomDataMetadata(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getUsesCustomData())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::BitBuffer>(static_cast<::zserio::BitBuffer>(in.readBitBuffer(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::BitBuffer>(::zserio::NullOpt);
}

} // namespace metadata
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/metadata/RangeProjectionServiceCapabilities.h>

namespace nds
{
namespace routing
{
namespace metadata
{

RangeProjectionServiceCapabilities::RangeProjectionServiceCapabilities(const allocator_type& allocator) noexcept :
        m_implementedMethods_(::nds::routing::metadata::RangeProjectionServiceMethods()),
        m_supportedRangeProjectionTypes_(allocator)
{
}

RangeProjectionServiceCapabilities::RangeProjectionServiceCapabilities(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_implementedMethods_(readImplementedMethods(in)),
        m_supportedRangeProjectionTypes_(readSupportedRangeProjectionTypes(in, allocator))
{
}

RangeProjectionServiceCapabilities::RangeProjectionServiceCapabilities(RangeProjectionServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_implementedMethods_(readImplementedMethods(context, in)),
        m_supportedRangeProjectionTypes_(readSupportedRangeProjectionTypes(context, in, allocator))
{
}

RangeProjectionServiceCapabilities::RangeProjectionServiceCapabilities(::zserio::PropagateAllocatorT,
        const RangeProjectionServiceCapabilities& other, const allocator_type& allocator) :
        m_implementedMethods_(::zserio::allocatorPropagatingCopy(other.m_implementedMethods_, allocator)),
        m_supportedRangeProjectionTypes_(::zserio::allocatorPropagatingCopy(other.m_supportedRangeProjectionTypes_, allocator))
{
}

::nds::routing::metadata::RangeProjectionServiceMethods RangeProjectionServiceCapabilities::getImplementedMethods() const
{
    return m_implementedMethods_;
}

void RangeProjectionServiceCapabilities::setImplementedMethods(::nds::routing::metadata::RangeProjectionServiceMethods implementedMethods_)
{
    m_implementedMethods_ = implementedMethods_;
}

::zserio::vector<::nds::routing::types::RangeProjectionType>& RangeProjectionServiceCapabilities::getSupportedRangeProjectionTypes()
{
    return m_supportedRangeProjectionTypes_.getRawArray();
}

const ::zserio::vector<::nds::routing::types::RangeProjectionType>& RangeProjectionServiceCapabilities::getSupportedRangeProjectionTypes() const
{
    return m_supportedRangeProjectionTypes_.getRawArray();
}

void RangeProjectionServiceCapabilities::setSupportedRangeProjectionTypes(const ::zserio::vector<::nds::routing::types::RangeProjectionType>& supportedRangeProjectionTypes_)
{
    m_supportedRangeProjectionTypes_ = ZserioArrayType_supportedRangeProjectionTypes(supportedRangeProjectionTypes_);
}

void RangeProjectionServiceCapabilities::setSupportedRangeProjectionTypes(::zserio::vector<::nds::routing::types::RangeProjectionType>&& supportedRangeProjectionTypes_)
{
    m_supportedRangeProjectionTypes_ = ZserioArrayType_supportedRangeProjectionTypes(std::move(supportedRangeProjectionTypes_));
}

void RangeProjectionServiceCapabilities::initPackingContext(RangeProjectionServiceCapabilities::ZserioPackingContext& context) const
{
    m_implementedMethods_.initPackingContext(context.getImplementedMethods());
}

size_t RangeProjectionServiceCapabilities::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_implementedMethods_.bitSizeOf(endBitPosition);
    endBitPosition += m_supportedRangeProjectionTypes_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RangeProjectionServiceCapabilities::bitSizeOf(RangeProjectionServiceCapabilities::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_implementedMethods_.bitSizeOf(context.getImplementedMethods(), endBitPosition);
    endBitPosition += m_supportedRangeProjectionTypes_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RangeProjectionServiceCapabilities::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_implementedMethods_.initializeOffsets(endBitPosition);
    endBitPosition = m_supportedRangeProjectionTypes_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RangeProjectionServiceCapabilities::initializeOffsets(RangeProjectionServiceCapabilities::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_implementedMethods_.initializeOffsets(context.getImplementedMethods(), endBitPosition);
    endBitPosition = m_supportedRangeProjectionTypes_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool RangeProjectionServiceCapabilities::operator==(const RangeProjectionServiceCapabilities& other) const
{
    if (this != &other)
    {
        return
                (m_implementedMethods_ == other.m_implementedMethods_) &&
                (m_supportedRangeProjectionTypes_ == other.m_supportedRangeProjectionTypes_);
    }

    return true;
}

uint32_t RangeProjectionServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_implementedMethods_);
    result = ::zserio::calcHashCode(result, m_supportedRangeProjectionTypes_);

    return result;
}

void RangeProjectionServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    m_implementedMethods_.write(out);
    m_supportedRangeProjectionTypes_.write(out);
}

void RangeProjectionServiceCapabilities::write(RangeProjectionServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_implementedMethods_.write(context.getImplementedMethods(), out);
    m_supportedRangeProjectionTypes_.writePacked(out);
}

::nds::routing::metadata::RangeProjectionServiceMethods RangeProjectionServiceCapabilities::readImplementedMethods(::zserio::BitStreamReader& in)
{
    return ::nds::routing::metadata::RangeProjectionServiceMethods(in);
}

::nds::routing::metadata::RangeProjectionServiceMethods RangeProjectionServiceCapabilities::readImplementedMethods(RangeProjectionServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::routing::metadata::RangeProjectionServiceMethods(context.getImplementedMethods(), in);
}
RangeProjectionServiceCapabilities::ZserioArrayType_supportedRangeProjectionTypes RangeProjectionServiceCapabilities::readSupportedRangeProjectionTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_supportedRangeProjectionTypes readField(allocator);
    readField.read(in);

    return readField;
}

RangeProjectionServiceCapabilities::ZserioArrayType_supportedRangeProjectionTypes RangeProjectionServiceCapabilities::readSupportedRangeProjectionTypes(RangeProjectionServiceCapabilities::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_supportedRangeProjectionTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}

} // namespace metadata
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/metadata/RoutingServiceCapabilities.h>

namespace nds
{
namespace routing
{
namespace metadata
{

RoutingServiceCapabilities::RoutingServiceCapabilities(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

RoutingServiceCapabilities::RoutingServiceCapabilities(::zserio::BitStreamReader& in,
        ::nds::routing::metadata::RoutingServiceType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

RoutingServiceCapabilities::RoutingServiceCapabilities(RoutingServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::routing::metadata::RoutingServiceType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

RoutingServiceCapabilities::RoutingServiceCapabilities(const RoutingServiceCapabilities& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RoutingServiceCapabilities& RoutingServiceCapabilities::operator=(const RoutingServiceCapabilities& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingServiceCapabilities::RoutingServiceCapabilities(RoutingServiceCapabilities&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

RoutingServiceCapabilities& RoutingServiceCapabilities::operator=(RoutingServiceCapabilities&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

RoutingServiceCapabilities::RoutingServiceCapabilities(::zserio::PropagateAllocatorT,
        const RoutingServiceCapabilities& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void RoutingServiceCapabilities::initialize(
        ::nds::routing::metadata::RoutingServiceType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool RoutingServiceCapabilities::isInitialized() const
{
    return m_isInitialized;
}

::nds::routing::metadata::RoutingServiceType RoutingServiceCapabilities::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'RoutingServiceCapabilities' is not initialized!");

    return m_type_;
}

::nds::routing::metadata::RouteServiceCapabilities& RoutingServiceCapabilities::getRouteServiceCapabilities()
{
    return m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>();
}

const ::nds::routing::metadata::RouteServiceCapabilities& RoutingServiceCapabilities::getRouteServiceCapabilities() const
{
    return m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>();
}

void RoutingServiceCapabilities::setRouteServiceCapabilities(const ::nds::routing::metadata::RouteServiceCapabilities& routeServiceCapabilities_)
{
    m_objectChoice = routeServiceCapabilities_;
}

void RoutingServiceCapabilities::setRouteServiceCapabilities(::nds::routing::metadata::RouteServiceCapabilities&& routeServiceCapabilities_)
{
    m_objectChoice = ::std::move(routeServiceCapabilities_);
}

::nds::routing::metadata::RangeProjectionServiceCapabilities& RoutingServiceCapabilities::getRangeProjectionServiceCapabilities()
{
    return m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>();
}

const ::nds::routing::metadata::RangeProjectionServiceCapabilities& RoutingServiceCapabilities::getRangeProjectionServiceCapabilities() const
{
    return m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>();
}

void RoutingServiceCapabilities::setRangeProjectionServiceCapabilities(const ::nds::routing::metadata::RangeProjectionServiceCapabilities& rangeProjectionServiceCapabilities_)
{
    m_objectChoice = rangeProjectionServiceCapabilities_;
}

void RoutingServiceCapabilities::setRangeProjectionServiceCapabilities(::nds::routing::metadata::RangeProjectionServiceCapabilities&& rangeProjectionServiceCapabilities_)
{
    m_objectChoice = ::std::move(rangeProjectionServiceCapabilities_);
}

RoutingServiceCapabilities::ChoiceTag RoutingServiceCapabilities::choiceTag() const
{
    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        return CHOICE_routeServiceCapabilities;
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        return CHOICE_rangeProjectionServiceCapabilities;
    default:
        return UNDEFINED_CHOICE;
    }
}

void RoutingServiceCapabilities::initPackingContext(RoutingServiceCapabilities::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>().initPackingContext(context.getRouteServiceCapabilities());
        break;
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>().initPackingContext(context.getRangeProjectionServiceCapabilities());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }
}

size_t RoutingServiceCapabilities::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        endBitPosition += m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>().bitSizeOf(endBitPosition);
        break;
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        endBitPosition += m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }

    return endBitPosition - bitPosition;
}

size_t RoutingServiceCapabilities::bitSizeOf(RoutingServiceCapabilities::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        endBitPosition += m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>().bitSizeOf(context.getRouteServiceCapabilities(), endBitPosition);
        break;
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        endBitPosition += m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>().bitSizeOf(context.getRangeProjectionServiceCapabilities(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }

    return endBitPosition - bitPosition;
}

size_t RoutingServiceCapabilities::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        endBitPosition = m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>().initializeOffsets(endBitPosition);
        break;
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        endBitPosition = m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }

    return endBitPosition;
}

size_t RoutingServiceCapabilities::initializeOffsets(RoutingServiceCapabilities::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        endBitPosition = m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>().initializeOffsets(context.getRouteServiceCapabilities(), endBitPosition);
        break;
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        endBitPosition = m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>().initializeOffsets(context.getRangeProjectionServiceCapabilities(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }

    return endBitPosition;
}

bool RoutingServiceCapabilities::operator==(const RoutingServiceCapabilities& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>() == other.m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>());
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>() == other.m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }
}

uint32_t RoutingServiceCapabilities::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>());
            break;
        case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>());
            break;
        default:
            break;
        }
    }

    return result;
}

void RoutingServiceCapabilities::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>().write(out);
        break;
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }
}

void RoutingServiceCapabilities::write(RoutingServiceCapabilities::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        m_objectChoice.get<::nds::routing::metadata::RouteServiceCapabilities>().write(context.getRouteServiceCapabilities(), out);
        break;
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        m_objectChoice.get<::nds::routing::metadata::RangeProjectionServiceCapabilities>().write(context.getRangeProjectionServiceCapabilities(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }
}

::zserio::AnyHolder<> RoutingServiceCapabilities::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        return ::zserio::AnyHolder<>(::nds::routing::metadata::RouteServiceCapabilities(in, allocator), allocator);
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        return ::zserio::AnyHolder<>(::nds::routing::metadata::RangeProjectionServiceCapabilities(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }
}

::zserio::AnyHolder<> RoutingServiceCapabilities::readObject(RoutingServiceCapabilities::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        return ::zserio::AnyHolder<>(::nds::routing::metadata::RouteServiceCapabilities(context.getRouteServiceCapabilities(), in, allocator), allocator);
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        return ::zserio::AnyHolder<>(::nds::routing::metadata::RangeProjectionServiceCapabilities(context.getRangeProjectionServiceCapabilities(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }
}

::zserio::AnyHolder<> RoutingServiceCapabilities::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::routing::metadata::RoutingServiceType::ROUTE_SERVICE:
        return ::zserio::allocatorPropagatingCopy<::nds::routing::metadata::RouteServiceCapabilities>(m_objectChoice, allocator);
    case ::nds::routing::metadata::RoutingServiceType::RANGE_PROJECTION_SERVICE:
        return ::zserio::allocatorPropagatingCopy<::nds::routing::metadata::RangeProjectionServiceCapabilities>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice RoutingServiceCapabilities!");
    }
}

} // namespace metadata
} // namespace routing
} // namespace nds
