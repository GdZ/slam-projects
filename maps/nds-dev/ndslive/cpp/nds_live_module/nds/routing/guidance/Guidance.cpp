/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/guidance/GuidanceNameStringRelationType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for GuidanceNameStringRelationType enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::routing::guidance::GuidanceNameStringRelationType>::names;
constexpr ::std::array<::nds::routing::guidance::GuidanceNameStringRelationType, 5> EnumTraits<::nds::routing::guidance::GuidanceNameStringRelationType>::values;
constexpr const char* EnumTraits<::nds::routing::guidance::GuidanceNameStringRelationType>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::guidance::GuidanceNameStringRelationType value)
{
    switch (value)
    {
    case ::nds::routing::guidance::GuidanceNameStringRelationType::SYNONYM:
        return 0;
    case ::nds::routing::guidance::GuidanceNameStringRelationType::TRANSLITERATION:
        return 1;
    case ::nds::routing::guidance::GuidanceNameStringRelationType::EXONYM:
        return 2;
    case ::nds::routing::guidance::GuidanceNameStringRelationType::ALTERNATE_SPELLING:
        return 3;
    case ::nds::routing::guidance::GuidanceNameStringRelationType::ABBREVIATION:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GuidanceNameStringRelationType: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameStringRelationType>::type>(value) << "!";
    }
}

template <>
::nds::routing::guidance::GuidanceNameStringRelationType valueToEnum(
        typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameStringRelationType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::routing::guidance::GuidanceNameStringRelationType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GuidanceNameStringRelationType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::guidance::GuidanceNameStringRelationType>(::nds::routing::guidance::GuidanceNameStringRelationType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::guidance::GuidanceNameStringRelationType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameStringRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::guidance::GuidanceNameStringRelationType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::guidance::GuidanceNameStringRelationType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameStringRelationType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::guidance::GuidanceNameStringRelationType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::guidance::GuidanceNameStringRelationType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::guidance::GuidanceNameStringRelationType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::guidance::GuidanceNameStringRelationType>(
            static_cast<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameStringRelationType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::routing::guidance::GuidanceNameStringRelationType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::guidance::GuidanceNameStringRelationType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameStringRelationType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::guidance::GuidanceNameStringRelationType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::guidance::GuidanceNameStringRelationType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameStringRelationType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/guidance/GuidanceNameClass.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for GuidanceNameClass enumeration.
constexpr ::std::array<const char*, 27> EnumTraits<::nds::routing::guidance::GuidanceNameClass>::names;
constexpr ::std::array<::nds::routing::guidance::GuidanceNameClass, 27> EnumTraits<::nds::routing::guidance::GuidanceNameClass>::values;
constexpr const char* EnumTraits<::nds::routing::guidance::GuidanceNameClass>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::guidance::GuidanceNameClass value)
{
    switch (value)
    {
    case ::nds::routing::guidance::GuidanceNameClass::CITY_BLOCK:
        return 0;
    case ::nds::routing::guidance::GuidanceNameClass::COUNTY:
        return 1;
    case ::nds::routing::guidance::GuidanceNameClass::COUNTRY:
        return 2;
    case ::nds::routing::guidance::GuidanceNameClass::COUNTRY_SET:
        return 3;
    case ::nds::routing::guidance::GuidanceNameClass::HAMLET:
        return 4;
    case ::nds::routing::guidance::GuidanceNameClass::HOUSE:
        return 5;
    case ::nds::routing::guidance::GuidanceNameClass::INTERSECTION:
        return 6;
    case ::nds::routing::guidance::GuidanceNameClass::LICENSE_PLATE_ZONE:
        return 7;
    case ::nds::routing::guidance::GuidanceNameClass::MUNICIPALITY:
        return 8;
    case ::nds::routing::guidance::GuidanceNameClass::MUNICIPALITY_SUBDIVISION:
        return 9;
    case ::nds::routing::guidance::GuidanceNameClass::NAMED_AREA:
        return 10;
    case ::nds::routing::guidance::GuidanceNameClass::NAMED_BRIDGE:
        return 11;
    case ::nds::routing::guidance::GuidanceNameClass::NAMED_TUNNEL:
        return 12;
    case ::nds::routing::guidance::GuidanceNameClass::NEIGHBORHOOD:
        return 13;
    case ::nds::routing::guidance::GuidanceNameClass::POSTAL_CODE_DISTRICT:
        return 14;
    case ::nds::routing::guidance::GuidanceNameClass::PREFERRED_POSTAL_PLACE:
        return 15;
    case ::nds::routing::guidance::GuidanceNameClass::POI:
        return 16;
    case ::nds::routing::guidance::GuidanceNameClass::ROAD:
        return 17;
    case ::nds::routing::guidance::GuidanceNameClass::ROAD_NUMBER:
        return 18;
    case ::nds::routing::guidance::GuidanceNameClass::ROUTE:
        return 19;
    case ::nds::routing::guidance::GuidanceNameClass::SIGNPOST:
        return 20;
    case ::nds::routing::guidance::GuidanceNameClass::SUB_COUNTRY:
        return 21;
    case ::nds::routing::guidance::GuidanceNameClass::SUB_COUNTRY_SET:
        return 22;
    case ::nds::routing::guidance::GuidanceNameClass::TOLL_GATE:
        return 23;
    case ::nds::routing::guidance::GuidanceNameClass::TOURIST_ROUTE:
        return 24;
    case ::nds::routing::guidance::GuidanceNameClass::TRAFFIC_ZONE:
        return 25;
    case ::nds::routing::guidance::GuidanceNameClass::ZONE:
        return 26;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GuidanceNameClass: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameClass>::type>(value) << "!";
    }
}

template <>
::nds::routing::guidance::GuidanceNameClass valueToEnum(
        typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameClass>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
    case UINT8_C(17):
    case UINT8_C(18):
    case UINT8_C(19):
    case UINT8_C(20):
    case UINT8_C(21):
    case UINT8_C(22):
    case UINT8_C(23):
    case UINT8_C(24):
    case UINT8_C(25):
    case UINT8_C(26):
        return static_cast<::nds::routing::guidance::GuidanceNameClass>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GuidanceNameClass: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::guidance::GuidanceNameClass>(::nds::routing::guidance::GuidanceNameClass value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::guidance::GuidanceNameClass value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameClass>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::guidance::GuidanceNameClass)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::guidance::GuidanceNameClass value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameClass>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::guidance::GuidanceNameClass value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::guidance::GuidanceNameClass value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::guidance::GuidanceNameClass read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::guidance::GuidanceNameClass>(
            static_cast<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameClass>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::routing::guidance::GuidanceNameClass read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::guidance::GuidanceNameClass>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameClass>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::guidance::GuidanceNameClass value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::guidance::GuidanceNameClass value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::guidance::GuidanceNameClass>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/guidance/GuidanceLaneMarking.h>

namespace nds
{
namespace routing
{
namespace guidance
{

GuidanceLaneMarking::GuidanceLaneMarking(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

GuidanceLaneMarking::GuidanceLaneMarking(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

GuidanceLaneMarking::GuidanceLaneMarking(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT64_C(144115188075855871))
        throw ::zserio::CppRuntimeException("Value for bitmask 'GuidanceLaneMarking' out of bounds: ") << value << "!";
}

void GuidanceLaneMarking::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::routing::guidance::GuidanceLaneMarking::underlying_type>>(m_value);
}

size_t GuidanceLaneMarking::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt64(m_value);
}

size_t GuidanceLaneMarking::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::routing::guidance::GuidanceLaneMarking::underlying_type>>(m_value);
}

size_t GuidanceLaneMarking::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t GuidanceLaneMarking::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t GuidanceLaneMarking::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void GuidanceLaneMarking::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt64(m_value);
}

void GuidanceLaneMarking::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::routing::guidance::GuidanceLaneMarking::underlying_type>>(out, m_value);
}

::zserio::string<> GuidanceLaneMarking::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & GuidanceLaneMarking::Values::ARROW_STRAIGHT) == GuidanceLaneMarking::Values::ARROW_STRAIGHT)
        result += result.empty() ? "ARROW_STRAIGHT" : " | ARROW_STRAIGHT";
    if ((*this & GuidanceLaneMarking::Values::ARROW_LEFT) == GuidanceLaneMarking::Values::ARROW_LEFT)
        result += result.empty() ? "ARROW_LEFT" : " | ARROW_LEFT";
    if ((*this & GuidanceLaneMarking::Values::ARROW_RIGHT) == GuidanceLaneMarking::Values::ARROW_RIGHT)
        result += result.empty() ? "ARROW_RIGHT" : " | ARROW_RIGHT";
    if ((*this & GuidanceLaneMarking::Values::ARROW_SLIGHT_LEFT) == GuidanceLaneMarking::Values::ARROW_SLIGHT_LEFT)
        result += result.empty() ? "ARROW_SLIGHT_LEFT" : " | ARROW_SLIGHT_LEFT";
    if ((*this & GuidanceLaneMarking::Values::ARROW_SLIGHT_RIGHT) == GuidanceLaneMarking::Values::ARROW_SLIGHT_RIGHT)
        result += result.empty() ? "ARROW_SLIGHT_RIGHT" : " | ARROW_SLIGHT_RIGHT";
    if ((*this & GuidanceLaneMarking::Values::ARROW_SHARP_RIGHT) == GuidanceLaneMarking::Values::ARROW_SHARP_RIGHT)
        result += result.empty() ? "ARROW_SHARP_RIGHT" : " | ARROW_SHARP_RIGHT";
    if ((*this & GuidanceLaneMarking::Values::ARROW_SHARP_LEFT) == GuidanceLaneMarking::Values::ARROW_SHARP_LEFT)
        result += result.empty() ? "ARROW_SHARP_LEFT" : " | ARROW_SHARP_LEFT";
    if ((*this & GuidanceLaneMarking::Values::ARROW_U_TURN_LEFT) == GuidanceLaneMarking::Values::ARROW_U_TURN_LEFT)
        result += result.empty() ? "ARROW_U_TURN_LEFT" : " | ARROW_U_TURN_LEFT";
    if ((*this & GuidanceLaneMarking::Values::ARROW_U_TURN_RIGHT) == GuidanceLaneMarking::Values::ARROW_U_TURN_RIGHT)
        result += result.empty() ? "ARROW_U_TURN_RIGHT" : " | ARROW_U_TURN_RIGHT";
    if (result.empty() && m_value == 0)
        result += "NONE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

GuidanceLaneMarking::underlying_type GuidanceLaneMarking::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt64());
}

GuidanceLaneMarking::underlying_type GuidanceLaneMarking::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::routing::guidance::GuidanceLaneMarking::underlying_type>>(
            in);
}

} // namespace guidance
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/guidance/GuidanceInstructions.h>

namespace nds
{
namespace routing
{
namespace guidance
{

GuidanceInstructions::GuidanceInstructions(const allocator_type& allocator) noexcept :
        m_instructions_(allocator)
{
}

GuidanceInstructions::GuidanceInstructions(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_instructions_(readInstructions(in, allocator))
{
}

GuidanceInstructions::GuidanceInstructions(GuidanceInstructions::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_instructions_(readInstructions(context, in, allocator))
{
}

GuidanceInstructions::GuidanceInstructions(::zserio::PropagateAllocatorT,
        const GuidanceInstructions& other, const allocator_type& allocator) :
        m_instructions_(::zserio::allocatorPropagatingCopy(other.m_instructions_, allocator))
{
}

void GuidanceInstructions::initializeChildren()
{
    m_instructions_.initializeElements(*this);
}

::zserio::vector<::nds::routing::guidance::Instruction>& GuidanceInstructions::getInstructions()
{
    return m_instructions_.getRawArray();
}

const ::zserio::vector<::nds::routing::guidance::Instruction>& GuidanceInstructions::getInstructions() const
{
    return m_instructions_.getRawArray();
}

void GuidanceInstructions::setInstructions(const ::zserio::vector<::nds::routing::guidance::Instruction>& instructions_)
{
    m_instructions_ = ZserioArrayType_instructions(instructions_);
}

void GuidanceInstructions::setInstructions(::zserio::vector<::nds::routing::guidance::Instruction>&& instructions_)
{
    m_instructions_ = ZserioArrayType_instructions(std::move(instructions_));
}

void GuidanceInstructions::initPackingContext(GuidanceInstructions::ZserioPackingContext&) const
{
}

size_t GuidanceInstructions::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_instructions_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GuidanceInstructions::bitSizeOf(GuidanceInstructions::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_instructions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GuidanceInstructions::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_instructions_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t GuidanceInstructions::initializeOffsets(GuidanceInstructions::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_instructions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool GuidanceInstructions::operator==(const GuidanceInstructions& other) const
{
    if (this != &other)
    {
        return
                (m_instructions_ == other.m_instructions_);
    }

    return true;
}

uint32_t GuidanceInstructions::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_instructions_);

    return result;
}

void GuidanceInstructions::write(::zserio::BitStreamWriter& out) const
{
    m_instructions_.write(*this, out);
}

void GuidanceInstructions::write(GuidanceInstructions::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_instructions_.writePacked(*this, out);
}

void GuidanceInstructions::ZserioArrayExpressions_instructions::initializeElement(GuidanceInstructions&,
        ::nds::routing::guidance::Instruction& element, size_t)
{
    element.initializeChildren();
}

void GuidanceInstructions::ZserioElementFactory_instructions::create(GuidanceInstructions&        ,
        ::zserio::vector<::nds::routing::guidance::Instruction>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void GuidanceInstructions::ZserioElementFactory_instructions::create(GuidanceInstructions&        ,
        ::zserio::vector<::nds::routing::guidance::Instruction>& array,
        ::nds::routing::guidance::Instruction::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

GuidanceInstructions::ZserioArrayType_instructions GuidanceInstructions::readInstructions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_instructions readField(allocator);
    readField.read(*this, in);

    return readField;
}

GuidanceInstructions::ZserioArrayType_instructions GuidanceInstructions::readInstructions(GuidanceInstructions::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_instructions readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace guidance
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/routing/guidance/Instruction.h>
#include <nds/routing/types/GuidanceCode.h>

namespace nds
{
namespace routing
{
namespace guidance
{

Instruction::Instruction(const allocator_type&) noexcept :
        m_targetIndex_(uint64_t()),
        m_activationDistance_(uint64_t()),
        m_guidanceCode_(::nds::routing::types::GuidanceCode()),
        m_extGuidanceCode_(::zserio::NullOpt),
        m_roundaboutExitNumber_(::zserio::NullOpt),
        m_targetName_(::zserio::NullOpt),
        m_towardsName_(::zserio::NullOpt),
        m_lanes_(::zserio::NullOpt)
{
}

Instruction::Instruction(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_targetIndex_(readTargetIndex(in)),
        m_activationDistance_(readActivationDistance(in)),
        m_guidanceCode_(readGuidanceCode(in)),
        m_extGuidanceCode_(readExtGuidanceCode(in, allocator)),
        m_roundaboutExitNumber_(readRoundaboutExitNumber(in)),
        m_targetName_(readTargetName(in, allocator)),
        m_towardsName_(readTowardsName(in, allocator)),
        m_lanes_(readLanes(in, allocator))
{
}

Instruction::Instruction(Instruction::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_targetIndex_(readTargetIndex(context, in)),
        m_activationDistance_(readActivationDistance(context, in)),
        m_guidanceCode_(readGuidanceCode(context, in)),
        m_extGuidanceCode_(readExtGuidanceCode(in, allocator)),
        m_roundaboutExitNumber_(readRoundaboutExitNumber(context, in)),
        m_targetName_(readTargetName(context, in, allocator)),
        m_towardsName_(readTowardsName(context, in, allocator)),
        m_lanes_(readLanes(context, in, allocator))
{
}

Instruction::Instruction(::zserio::PropagateAllocatorT,
        const Instruction& other, const allocator_type& allocator) :
        m_targetIndex_(::zserio::allocatorPropagatingCopy(other.m_targetIndex_, allocator)),
        m_activationDistance_(::zserio::allocatorPropagatingCopy(other.m_activationDistance_, allocator)),
        m_guidanceCode_(::zserio::allocatorPropagatingCopy(other.m_guidanceCode_, allocator)),
        m_extGuidanceCode_(::zserio::allocatorPropagatingCopy(other.m_extGuidanceCode_, allocator)),
        m_roundaboutExitNumber_(::zserio::allocatorPropagatingCopy(other.m_roundaboutExitNumber_, allocator)),
        m_targetName_(::zserio::allocatorPropagatingCopy(other.m_targetName_, allocator)),
        m_towardsName_(::zserio::allocatorPropagatingCopy(other.m_towardsName_, allocator)),
        m_lanes_(::zserio::allocatorPropagatingCopy(other.m_lanes_, allocator))
{
}

void Instruction::initializeChildren()
{
    if (isTargetNameSet())
        m_targetName_.value().initializeChildren();
    if (isTowardsNameSet())
        m_towardsName_.value().initializeChildren();
}

uint64_t Instruction::getTargetIndex() const
{
    return m_targetIndex_;
}

void Instruction::setTargetIndex(uint64_t targetIndex_)
{
    m_targetIndex_ = targetIndex_;
}

uint64_t Instruction::getActivationDistance() const
{
    return m_activationDistance_;
}

void Instruction::setActivationDistance(uint64_t activationDistance_)
{
    m_activationDistance_ = activationDistance_;
}

::nds::routing::types::GuidanceCode Instruction::getGuidanceCode() const
{
    return m_guidanceCode_;
}

void Instruction::setGuidanceCode(::nds::routing::types::GuidanceCode guidanceCode_)
{
    m_guidanceCode_ = guidanceCode_;
}

::nds::routing::types::ExtGuidanceCode& Instruction::getExtGuidanceCode()
{
    return m_extGuidanceCode_.value();
}

const ::nds::routing::types::ExtGuidanceCode& Instruction::getExtGuidanceCode() const
{
    return m_extGuidanceCode_.value();
}

void Instruction::setExtGuidanceCode(const ::nds::routing::types::ExtGuidanceCode& extGuidanceCode_)
{
    m_extGuidanceCode_ = extGuidanceCode_;
}

void Instruction::setExtGuidanceCode(::nds::routing::types::ExtGuidanceCode&& extGuidanceCode_)
{
    m_extGuidanceCode_ = ::std::move(extGuidanceCode_);
}

bool Instruction::isExtGuidanceCodeUsed() const
{
    return (isExtGuidanceCodeSet());
}

bool Instruction::isExtGuidanceCodeSet() const
{
    return m_extGuidanceCode_.hasValue();
}

void Instruction::resetExtGuidanceCode()
{
    m_extGuidanceCode_.reset();
}

uint8_t Instruction::getRoundaboutExitNumber() const
{
    return m_roundaboutExitNumber_.value();
}

void Instruction::setRoundaboutExitNumber(uint8_t roundaboutExitNumber_)
{
    m_roundaboutExitNumber_ = roundaboutExitNumber_;
}

bool Instruction::isRoundaboutExitNumberUsed() const
{
    return (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED);
}

bool Instruction::isRoundaboutExitNumberSet() const
{
    return m_roundaboutExitNumber_.hasValue();
}

void Instruction::resetRoundaboutExitNumber()
{
    m_roundaboutExitNumber_.reset();
}

::nds::routing::guidance::GuidanceName& Instruction::getTargetName()
{
    return m_targetName_.value();
}

const ::nds::routing::guidance::GuidanceName& Instruction::getTargetName() const
{
    return m_targetName_.value();
}

void Instruction::setTargetName(const ::nds::routing::guidance::GuidanceName& targetName_)
{
    m_targetName_ = targetName_;
}

void Instruction::setTargetName(::nds::routing::guidance::GuidanceName&& targetName_)
{
    m_targetName_ = ::std::move(targetName_);
}

bool Instruction::isTargetNameUsed() const
{
    return (isTargetNameSet());
}

bool Instruction::isTargetNameSet() const
{
    return m_targetName_.hasValue();
}

void Instruction::resetTargetName()
{
    m_targetName_.reset();
}

::nds::routing::guidance::GuidanceName& Instruction::getTowardsName()
{
    return m_towardsName_.value();
}

const ::nds::routing::guidance::GuidanceName& Instruction::getTowardsName() const
{
    return m_towardsName_.value();
}

void Instruction::setTowardsName(const ::nds::routing::guidance::GuidanceName& towardsName_)
{
    m_towardsName_ = towardsName_;
}

void Instruction::setTowardsName(::nds::routing::guidance::GuidanceName&& towardsName_)
{
    m_towardsName_ = ::std::move(towardsName_);
}

bool Instruction::isTowardsNameUsed() const
{
    return (isTowardsNameSet());
}

bool Instruction::isTowardsNameSet() const
{
    return m_towardsName_.hasValue();
}

void Instruction::resetTowardsName()
{
    m_towardsName_.reset();
}

::nds::routing::guidance::GuidanceLanes& Instruction::getLanes()
{
    return m_lanes_.value();
}

const ::nds::routing::guidance::GuidanceLanes& Instruction::getLanes() const
{
    return m_lanes_.value();
}

void Instruction::setLanes(const ::nds::routing::guidance::GuidanceLanes& lanes_)
{
    m_lanes_ = lanes_;
}

void Instruction::setLanes(::nds::routing::guidance::GuidanceLanes&& lanes_)
{
    m_lanes_ = ::std::move(lanes_);
}

bool Instruction::isLanesUsed() const
{
    return (isLanesSet());
}

bool Instruction::isLanesSet() const
{
    return m_lanes_.hasValue();
}

void Instruction::resetLanes()
{
    m_lanes_.reset();
}

void Instruction::initPackingContext(Instruction::ZserioPackingContext& context) const
{
    context.getTargetIndex().init<::zserio::VarIntArrayTraits<uint64_t>>(m_targetIndex_);
    context.getActivationDistance().init<::zserio::VarIntArrayTraits<uint64_t>>(m_activationDistance_);
    ::zserio::initPackingContext(context.getGuidanceCode(), m_guidanceCode_);
    if (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED)
    {
        context.getRoundaboutExitNumber().init<::zserio::StdIntArrayTraits<uint8_t>>(m_roundaboutExitNumber_.value());
    }
    if (isTargetNameSet())
    {
        m_targetName_.value().initPackingContext(context.getTargetName());
    }
    if (isTowardsNameSet())
    {
        m_towardsName_.value().initPackingContext(context.getTowardsName());
    }
    if (isLanesSet())
    {
        m_lanes_.value().initPackingContext(context.getLanes());
    }
}

size_t Instruction::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_targetIndex_);
    endBitPosition += ::zserio::bitSizeOfVarUInt(m_activationDistance_);
    endBitPosition += ::zserio::bitSizeOf(m_guidanceCode_);
    endBitPosition += 1;
    if (isExtGuidanceCodeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_extGuidanceCode_.value());
    }
    if (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED)
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isTargetNameSet())
    {
        endBitPosition += m_targetName_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isTowardsNameSet())
    {
        endBitPosition += m_towardsName_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isLanesSet())
    {
        endBitPosition += m_lanes_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Instruction::bitSizeOf(Instruction::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTargetIndex().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_targetIndex_);
    endBitPosition += context.getActivationDistance().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_activationDistance_);
    endBitPosition += ::zserio::bitSizeOf(context.getGuidanceCode(), m_guidanceCode_);
    endBitPosition += 1;
    if (isExtGuidanceCodeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_extGuidanceCode_.value());
    }
    if (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED)
    {
        endBitPosition += context.getRoundaboutExitNumber().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_roundaboutExitNumber_.value());
    }
    endBitPosition += 1;
    if (isTargetNameSet())
    {
        endBitPosition += m_targetName_.value().bitSizeOf(context.getTargetName(), endBitPosition);
    }
    endBitPosition += 1;
    if (isTowardsNameSet())
    {
        endBitPosition += m_towardsName_.value().bitSizeOf(context.getTowardsName(), endBitPosition);
    }
    endBitPosition += 1;
    if (isLanesSet())
    {
        endBitPosition += m_lanes_.value().bitSizeOf(context.getLanes(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Instruction::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_targetIndex_);
    endBitPosition += ::zserio::bitSizeOfVarUInt(m_activationDistance_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_guidanceCode_);
    endBitPosition += 1;
    if (isExtGuidanceCodeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_extGuidanceCode_.value());
    }
    if (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED)
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isTargetNameSet())
    {
        endBitPosition = m_targetName_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isTowardsNameSet())
    {
        endBitPosition = m_towardsName_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isLanesSet())
    {
        endBitPosition = m_lanes_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t Instruction::initializeOffsets(Instruction::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTargetIndex().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_targetIndex_);
    endBitPosition += context.getActivationDistance().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_activationDistance_);
    endBitPosition = ::zserio::initializeOffsets(context.getGuidanceCode(), endBitPosition,
        m_guidanceCode_);
    endBitPosition += 1;
    if (isExtGuidanceCodeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_extGuidanceCode_.value());
    }
    if (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED)
    {
        endBitPosition += context.getRoundaboutExitNumber().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_roundaboutExitNumber_.value());
    }
    endBitPosition += 1;
    if (isTargetNameSet())
    {
        endBitPosition = m_targetName_.value().initializeOffsets(context.getTargetName(), endBitPosition);
    }
    endBitPosition += 1;
    if (isTowardsNameSet())
    {
        endBitPosition = m_towardsName_.value().initializeOffsets(context.getTowardsName(), endBitPosition);
    }
    endBitPosition += 1;
    if (isLanesSet())
    {
        endBitPosition = m_lanes_.value().initializeOffsets(context.getLanes(), endBitPosition);
    }

    return endBitPosition;
}

bool Instruction::operator==(const Instruction& other) const
{
    if (this != &other)
    {
        return
                (m_targetIndex_ == other.m_targetIndex_) &&
                (m_activationDistance_ == other.m_activationDistance_) &&
                (m_guidanceCode_ == other.m_guidanceCode_) &&
                (!isExtGuidanceCodeUsed() ? !other.isExtGuidanceCodeUsed() : (m_extGuidanceCode_ == other.m_extGuidanceCode_)) &&
                (!isRoundaboutExitNumberUsed() ? !other.isRoundaboutExitNumberUsed() : (m_roundaboutExitNumber_ == other.m_roundaboutExitNumber_)) &&
                (!isTargetNameUsed() ? !other.isTargetNameUsed() : (m_targetName_ == other.m_targetName_)) &&
                (!isTowardsNameUsed() ? !other.isTowardsNameUsed() : (m_towardsName_ == other.m_towardsName_)) &&
                (!isLanesUsed() ? !other.isLanesUsed() : (m_lanes_ == other.m_lanes_));
    }

    return true;
}

uint32_t Instruction::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_targetIndex_);
    result = ::zserio::calcHashCode(result, m_activationDistance_);
    result = ::zserio::calcHashCode(result, m_guidanceCode_);
    if (isExtGuidanceCodeUsed())
        result = ::zserio::calcHashCode(result, m_extGuidanceCode_);
    if (isRoundaboutExitNumberUsed())
        result = ::zserio::calcHashCode(result, m_roundaboutExitNumber_);
    if (isTargetNameUsed())
        result = ::zserio::calcHashCode(result, m_targetName_);
    if (isTowardsNameUsed())
        result = ::zserio::calcHashCode(result, m_towardsName_);
    if (isLanesUsed())
        result = ::zserio::calcHashCode(result, m_lanes_);

    return result;
}

void Instruction::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt(m_targetIndex_);
    out.writeVarUInt(m_activationDistance_);
    ::zserio::write(out, m_guidanceCode_);
    if (isExtGuidanceCodeSet())
    {
        out.writeBool(true);
        out.writeString(m_extGuidanceCode_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED)
    {
        out.writeBits(m_roundaboutExitNumber_.value(), UINT8_C(8));
    }
    if (isTargetNameSet())
    {
        out.writeBool(true);
        m_targetName_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isTowardsNameSet())
    {
        out.writeBool(true);
        m_towardsName_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isLanesSet())
    {
        out.writeBool(true);
        m_lanes_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void Instruction::write(Instruction::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getTargetIndex().write<::zserio::VarIntArrayTraits<uint64_t>>(out, m_targetIndex_);
    context.getActivationDistance().write<::zserio::VarIntArrayTraits<uint64_t>>(out, m_activationDistance_);
    ::zserio::write(context.getGuidanceCode(), out, m_guidanceCode_);
    if (isExtGuidanceCodeSet())
    {
        out.writeBool(true);
        out.writeString(m_extGuidanceCode_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED)
    {
        context.getRoundaboutExitNumber().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_roundaboutExitNumber_.value());
    }
    if (isTargetNameSet())
    {
        out.writeBool(true);
        m_targetName_.value().write(context.getTargetName(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isTowardsNameSet())
    {
        out.writeBool(true);
        m_towardsName_.value().write(context.getTowardsName(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isLanesSet())
    {
        out.writeBool(true);
        m_lanes_.value().write(context.getLanes(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

uint64_t Instruction::readTargetIndex(::zserio::BitStreamReader& in)
{
    return static_cast<uint64_t>(in.readVarUInt());
}

uint64_t Instruction::readTargetIndex(Instruction::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTargetIndex().read<::zserio::VarIntArrayTraits<uint64_t>>(in);
}
uint64_t Instruction::readActivationDistance(::zserio::BitStreamReader& in)
{
    return static_cast<uint64_t>(in.readVarUInt());
}

uint64_t Instruction::readActivationDistance(Instruction::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getActivationDistance().read<::zserio::VarIntArrayTraits<uint64_t>>(in);
}
::nds::routing::types::GuidanceCode Instruction::readGuidanceCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::GuidanceCode>(in);
}

::nds::routing::types::GuidanceCode Instruction::readGuidanceCode(Instruction::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::types::GuidanceCode>(context.getGuidanceCode(), in);
}
::zserio::InplaceOptionalHolder<::nds::routing::types::ExtGuidanceCode> Instruction::readExtGuidanceCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::types::ExtGuidanceCode>(static_cast<::nds::routing::types::ExtGuidanceCode>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::types::ExtGuidanceCode>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint8_t> Instruction::readRoundaboutExitNumber(::zserio::BitStreamReader& in)
{
    if (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(static_cast<uint8_t>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint8_t> Instruction::readRoundaboutExitNumber(Instruction::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT || getGuidanceCode() == ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(context.getRoundaboutExitNumber().read<::zserio::StdIntArrayTraits<uint8_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName> Instruction::readTargetName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName>(::nds::routing::guidance::GuidanceName(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName> Instruction::readTargetName(Instruction::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName>(::nds::routing::guidance::GuidanceName(context.getTargetName(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName> Instruction::readTowardsName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName>(::nds::routing::guidance::GuidanceName(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName> Instruction::readTowardsName(Instruction::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName>(::nds::routing::guidance::GuidanceName(context.getTowardsName(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceName>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceLanes> Instruction::readLanes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceLanes>(::nds::routing::guidance::GuidanceLanes(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceLanes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceLanes> Instruction::readLanes(Instruction::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceLanes>(::nds::routing::guidance::GuidanceLanes(context.getLanes(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceLanes>(::zserio::NullOpt);
}

} // namespace guidance
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/guidance/GuidanceLanes.h>

namespace nds
{
namespace routing
{
namespace guidance
{

GuidanceLanes::GuidanceLanes(const allocator_type& allocator) noexcept :
        m_numLanes_(uint8_t()),
        m_active_(allocator),
        m_markings_(::zserio::NullOpt)
{
}

GuidanceLanes::GuidanceLanes(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numLanes_(readNumLanes(in)),
        m_active_(readActive(in, allocator)),
        m_markings_(readMarkings(in, allocator))
{
}

GuidanceLanes::GuidanceLanes(GuidanceLanes::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numLanes_(readNumLanes(context, in)),
        m_active_(readActive(in, allocator)),
        m_markings_(readMarkings(context, in, allocator))
{
}

GuidanceLanes::GuidanceLanes(::zserio::PropagateAllocatorT,
        const GuidanceLanes& other, const allocator_type& allocator) :
        m_numLanes_(::zserio::allocatorPropagatingCopy(other.m_numLanes_, allocator)),
        m_active_(::zserio::allocatorPropagatingCopy(other.m_active_, allocator)),
        m_markings_(::zserio::allocatorPropagatingCopy(other.m_markings_, allocator))
{
}

uint8_t GuidanceLanes::getNumLanes() const
{
    return m_numLanes_;
}

void GuidanceLanes::setNumLanes(uint8_t numLanes_)
{
    m_numLanes_ = numLanes_;
}

::zserio::vector<bool>& GuidanceLanes::getActive()
{
    return m_active_.getRawArray();
}

const ::zserio::vector<bool>& GuidanceLanes::getActive() const
{
    return m_active_.getRawArray();
}

void GuidanceLanes::setActive(const ::zserio::vector<bool>& active_)
{
    m_active_ = ZserioArrayType_active(active_);
}

void GuidanceLanes::setActive(::zserio::vector<bool>&& active_)
{
    m_active_ = ZserioArrayType_active(std::move(active_));
}

::zserio::vector<::nds::routing::guidance::GuidanceLaneMarking>& GuidanceLanes::getMarkings()
{
    return m_markings_.value().getRawArray();
}

const ::zserio::vector<::nds::routing::guidance::GuidanceLaneMarking>& GuidanceLanes::getMarkings() const
{
    return m_markings_.value().getRawArray();
}

void GuidanceLanes::setMarkings(const ::zserio::vector<::nds::routing::guidance::GuidanceLaneMarking>& markings_)
{
    m_markings_ = ZserioArrayType_markings(markings_);
}

void GuidanceLanes::setMarkings(::zserio::vector<::nds::routing::guidance::GuidanceLaneMarking>&& markings_)
{
    m_markings_ = ZserioArrayType_markings(std::move(markings_));
}

bool GuidanceLanes::isMarkingsUsed() const
{
    return (isMarkingsSet());
}

bool GuidanceLanes::isMarkingsSet() const
{
    return m_markings_.hasValue();
}

void GuidanceLanes::resetMarkings()
{
    m_markings_.reset();
}

void GuidanceLanes::initPackingContext(GuidanceLanes::ZserioPackingContext& context) const
{
    context.getNumLanes().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numLanes_);
}

size_t GuidanceLanes::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_active_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isMarkingsSet())
    {
        endBitPosition += m_markings_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t GuidanceLanes::bitSizeOf(GuidanceLanes::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numLanes_);
    endBitPosition += m_active_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isMarkingsSet())
    {
        endBitPosition += m_markings_.value().bitSizeOfPacked(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t GuidanceLanes::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_active_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isMarkingsSet())
    {
        endBitPosition = m_markings_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t GuidanceLanes::initializeOffsets(GuidanceLanes::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLanes().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numLanes_);
    endBitPosition = m_active_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isMarkingsSet())
    {
        endBitPosition = m_markings_.value().initializeOffsetsPacked(endBitPosition);
    }

    return endBitPosition;
}

bool GuidanceLanes::operator==(const GuidanceLanes& other) const
{
    if (this != &other)
    {
        return
                (m_numLanes_ == other.m_numLanes_) &&
                (m_active_ == other.m_active_) &&
                (!isMarkingsUsed() ? !other.isMarkingsUsed() : (m_markings_ == other.m_markings_));
    }

    return true;
}

uint32_t GuidanceLanes::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numLanes_);
    result = ::zserio::calcHashCode(result, m_active_);
    if (isMarkingsUsed())
        result = ::zserio::calcHashCode(result, m_markings_);

    return result;
}

void GuidanceLanes::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numLanes_, UINT8_C(8));

    // check array length
    if (m_active_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field GuidanceLanes.active: ") <<
                m_active_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_active_.write(out);

    if (isMarkingsSet())
    {
        out.writeBool(true);
        // check array length
        if (m_markings_.value().getRawArray().size() != static_cast<size_t>(getNumLanes()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field GuidanceLanes.markings: ") <<
                    m_markings_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLanes()) << "!";
        }
        m_markings_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void GuidanceLanes::write(GuidanceLanes::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumLanes().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numLanes_);

    // check array length
    if (m_active_.getRawArray().size() != static_cast<size_t>(getNumLanes()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field GuidanceLanes.active: ") <<
                m_active_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLanes()) << "!";
    }
    m_active_.write(out);

    if (isMarkingsSet())
    {
        out.writeBool(true);
        // check array length
        if (m_markings_.value().getRawArray().size() != static_cast<size_t>(getNumLanes()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field GuidanceLanes.markings: ") <<
                    m_markings_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLanes()) << "!";
        }
        m_markings_.value().writePacked(out);
    }
    else
    {
        out.writeBool(false);
    }
}

uint8_t GuidanceLanes::readNumLanes(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t GuidanceLanes::readNumLanes(GuidanceLanes::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumLanes().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
GuidanceLanes::ZserioArrayType_active GuidanceLanes::readActive(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_active readField(allocator);
    readField.read(in, static_cast<size_t>(getNumLanes()));

    return readField;
}
::zserio::InplaceOptionalHolder<GuidanceLanes::ZserioArrayType_markings> GuidanceLanes::readMarkings(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_markings readField(allocator);
        readField.read(in, static_cast<size_t>(getNumLanes()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_markings>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_markings>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<GuidanceLanes::ZserioArrayType_markings> GuidanceLanes::readMarkings(GuidanceLanes::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_markings readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumLanes()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_markings>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_markings>(::zserio::NullOpt);
}

} // namespace guidance
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/guidance/GuidanceName.h>

namespace nds
{
namespace routing
{
namespace guidance
{

GuidanceName::GuidanceName(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_guidanceNameClass_(::nds::routing::guidance::GuidanceNameClass()),
        m_numNames_(uint8_t()),
        m_nameStrings_(allocator)
{
}

GuidanceName::GuidanceName(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_guidanceNameClass_(readGuidanceNameClass(in)),
        m_numNames_(readNumNames(in)),
        m_nameStrings_(readNameStrings(in, allocator))
{
}

GuidanceName::GuidanceName(GuidanceName::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_guidanceNameClass_(readGuidanceNameClass(context, in)),
        m_numNames_(readNumNames(context, in)),
        m_nameStrings_(readNameStrings(context, in, allocator))
{
}

GuidanceName::GuidanceName(const GuidanceName& other) :
        m_guidanceNameClass_(other.m_guidanceNameClass_),
        m_numNames_(other.m_numNames_),
        m_nameStrings_(other.m_nameStrings_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

GuidanceName& GuidanceName::operator=(const GuidanceName& other)
{
    m_guidanceNameClass_ = other.m_guidanceNameClass_;
    m_numNames_ = other.m_numNames_;
    m_nameStrings_ = other.m_nameStrings_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

GuidanceName::GuidanceName(GuidanceName&& other) :
        m_guidanceNameClass_(::std::move(other.m_guidanceNameClass_)),
        m_numNames_(::std::move(other.m_numNames_)),
        m_nameStrings_(::std::move(other.m_nameStrings_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

GuidanceName& GuidanceName::operator=(GuidanceName&& other)
{
    m_guidanceNameClass_ = ::std::move(other.m_guidanceNameClass_);
    m_numNames_ = ::std::move(other.m_numNames_);
    m_nameStrings_ = ::std::move(other.m_nameStrings_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

GuidanceName::GuidanceName(::zserio::PropagateAllocatorT,
        const GuidanceName& other, const allocator_type& allocator) :
        m_guidanceNameClass_(::zserio::allocatorPropagatingCopy(other.m_guidanceNameClass_, allocator)),
        m_numNames_(::zserio::allocatorPropagatingCopy(other.m_numNames_, allocator)),
        m_nameStrings_(::zserio::allocatorPropagatingCopy(other.m_nameStrings_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void GuidanceName::initializeChildren()
{
    m_nameStrings_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::nds::routing::guidance::GuidanceNameClass GuidanceName::getGuidanceNameClass() const
{
    return m_guidanceNameClass_;
}

void GuidanceName::setGuidanceNameClass(::nds::routing::guidance::GuidanceNameClass guidanceNameClass_)
{
    m_guidanceNameClass_ = guidanceNameClass_;
}

uint8_t GuidanceName::getNumNames() const
{
    return m_numNames_;
}

void GuidanceName::setNumNames(uint8_t numNames_)
{
    m_numNames_ = numNames_;
}

::zserio::vector<::nds::routing::guidance::GuidanceNameString>& GuidanceName::getNameStrings()
{
    return m_nameStrings_.getRawArray();
}

const ::zserio::vector<::nds::routing::guidance::GuidanceNameString>& GuidanceName::getNameStrings() const
{
    return m_nameStrings_.getRawArray();
}

void GuidanceName::setNameStrings(const ::zserio::vector<::nds::routing::guidance::GuidanceNameString>& nameStrings_)
{
    m_nameStrings_ = ZserioArrayType_nameStrings(nameStrings_);
}

void GuidanceName::setNameStrings(::zserio::vector<::nds::routing::guidance::GuidanceNameString>&& nameStrings_)
{
    m_nameStrings_ = ZserioArrayType_nameStrings(std::move(nameStrings_));
}

void GuidanceName::initPackingContext(GuidanceName::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getGuidanceNameClass(), m_guidanceNameClass_);
    context.getNumNames().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numNames_);
}

size_t GuidanceName::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_guidanceNameClass_);
    endBitPosition += UINT8_C(8);
    endBitPosition += m_nameStrings_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GuidanceName::bitSizeOf(GuidanceName::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getGuidanceNameClass(), m_guidanceNameClass_);
    endBitPosition += context.getNumNames().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numNames_);
    endBitPosition += m_nameStrings_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GuidanceName::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_guidanceNameClass_);
    endBitPosition += UINT8_C(8);
    endBitPosition = m_nameStrings_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t GuidanceName::initializeOffsets(GuidanceName::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getGuidanceNameClass(), endBitPosition,
        m_guidanceNameClass_);
    endBitPosition += context.getNumNames().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numNames_);
    endBitPosition = m_nameStrings_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool GuidanceName::operator==(const GuidanceName& other) const
{
    if (this != &other)
    {
        return
                (m_guidanceNameClass_ == other.m_guidanceNameClass_) &&
                (m_numNames_ == other.m_numNames_) &&
                (m_nameStrings_ == other.m_nameStrings_);
    }

    return true;
}

uint32_t GuidanceName::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_guidanceNameClass_);
    result = ::zserio::calcHashCode(result, m_numNames_);
    result = ::zserio::calcHashCode(result, m_nameStrings_);

    return result;
}

void GuidanceName::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_guidanceNameClass_);

    out.writeBits(m_numNames_, UINT8_C(8));

    // check array length
    if (m_nameStrings_.getRawArray().size() != static_cast<size_t>(getNumNames()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field GuidanceName.nameStrings: ") <<
                m_nameStrings_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumNames()) << "!";
    }
    m_nameStrings_.write(*this, out);
}

void GuidanceName::write(GuidanceName::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getGuidanceNameClass(), out, m_guidanceNameClass_);

    context.getNumNames().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numNames_);

    // check array length
    if (m_nameStrings_.getRawArray().size() != static_cast<size_t>(getNumNames()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field GuidanceName.nameStrings: ") <<
                m_nameStrings_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumNames()) << "!";
    }
    m_nameStrings_.writePacked(*this, out);
}

void GuidanceName::ZserioArrayExpressions_nameStrings::initializeElement(GuidanceName& owner,
        ::nds::routing::guidance::GuidanceNameString& element, size_t)
{
    element.initialize(static_cast<uint8_t>(owner.getNumNames()));
}

void GuidanceName::ZserioElementFactory_nameStrings::create(GuidanceName&         owner,
        ::zserio::vector<::nds::routing::guidance::GuidanceNameString>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint8_t>(owner.getNumNames()), array.get_allocator());
}

void GuidanceName::ZserioElementFactory_nameStrings::create(GuidanceName&         owner,
        ::zserio::vector<::nds::routing::guidance::GuidanceNameString>& array,
        ::nds::routing::guidance::GuidanceNameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint8_t>(owner.getNumNames()), array.get_allocator());
}

::nds::routing::guidance::GuidanceNameClass GuidanceName::readGuidanceNameClass(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::guidance::GuidanceNameClass>(in);
}

::nds::routing::guidance::GuidanceNameClass GuidanceName::readGuidanceNameClass(GuidanceName::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::guidance::GuidanceNameClass>(context.getGuidanceNameClass(), in);
}
uint8_t GuidanceName::readNumNames(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t GuidanceName::readNumNames(GuidanceName::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumNames().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
GuidanceName::ZserioArrayType_nameStrings GuidanceName::readNameStrings(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_nameStrings readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumNames()));

    return readField;
}

GuidanceName::ZserioArrayType_nameStrings GuidanceName::readNameStrings(GuidanceName::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_nameStrings readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumNames()));

    return readField;
}

} // namespace guidance
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/guidance/GuidanceNameString.h>

namespace nds
{
namespace routing
{
namespace guidance
{

GuidanceNameString::GuidanceNameString(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_language_(::nds::core::types::LanguageCode()),
        m_name_(allocator),
        m_relations_(::zserio::NullOpt),
        m_phoneticTranscriptions_(::zserio::NullOpt)
{
}

GuidanceNameString::GuidanceNameString(::zserio::BitStreamReader& in,
        uint8_t numNames_, const allocator_type& allocator) :
        m_numNames_(numNames_),
        m_isInitialized(true),
        m_language_(readLanguage(in)),
        m_name_(readName(in, allocator)),
        m_relations_(readRelations(in, allocator)),
        m_phoneticTranscriptions_(readPhoneticTranscriptions(in, allocator))
{
}

GuidanceNameString::GuidanceNameString(GuidanceNameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint8_t numNames_, const allocator_type& allocator) :
        m_numNames_(numNames_),
        m_isInitialized(true),
        m_language_(readLanguage(context, in)),
        m_name_(readName(in, allocator)),
        m_relations_(readRelations(context, in, allocator)),
        m_phoneticTranscriptions_(readPhoneticTranscriptions(context, in, allocator))
{
}

GuidanceNameString::GuidanceNameString(const GuidanceNameString& other) :
        m_language_(other.m_language_),
        m_name_(other.m_name_),
        m_relations_(other.m_relations_),
        m_phoneticTranscriptions_(other.m_phoneticTranscriptions_)
{
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;
}

GuidanceNameString& GuidanceNameString::operator=(const GuidanceNameString& other)
{
    m_language_ = other.m_language_;
    m_name_ = other.m_name_;
    m_relations_ = other.m_relations_;
    m_phoneticTranscriptions_ = other.m_phoneticTranscriptions_;
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;

    return *this;
}

GuidanceNameString::GuidanceNameString(GuidanceNameString&& other) :
        m_language_(::std::move(other.m_language_)),
        m_name_(::std::move(other.m_name_)),
        m_relations_(::std::move(other.m_relations_)),
        m_phoneticTranscriptions_(::std::move(other.m_phoneticTranscriptions_))
{
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;
}

GuidanceNameString& GuidanceNameString::operator=(GuidanceNameString&& other)
{
    m_language_ = ::std::move(other.m_language_);
    m_name_ = ::std::move(other.m_name_);
    m_relations_ = ::std::move(other.m_relations_);
    m_phoneticTranscriptions_ = ::std::move(other.m_phoneticTranscriptions_);
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;

    return *this;
}

GuidanceNameString::GuidanceNameString(::zserio::PropagateAllocatorT,
        const GuidanceNameString& other, const allocator_type& allocator) :
        m_language_(::zserio::allocatorPropagatingCopy(other.m_language_, allocator)),
        m_name_(::zserio::allocatorPropagatingCopy(other.m_name_, allocator)),
        m_relations_(::zserio::allocatorPropagatingCopy(other.m_relations_, allocator)),
        m_phoneticTranscriptions_(::zserio::allocatorPropagatingCopy(other.m_phoneticTranscriptions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;
}

void GuidanceNameString::initialize(
        uint8_t numNames_)
{
    m_numNames_ = numNames_;
    m_isInitialized = true;

    initializeChildren();
}

bool GuidanceNameString::isInitialized() const
{
    return m_isInitialized;
}

void GuidanceNameString::initializeChildren()
{
    if (isRelationsSet())
        m_relations_.value().initialize(static_cast<uint8_t>(getNumNames()));
}

uint8_t GuidanceNameString::getNumNames() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numNames' of compound 'GuidanceNameString' is not initialized!");

    return m_numNames_;
}

::nds::core::types::LanguageCode GuidanceNameString::getLanguage() const
{
    return m_language_;
}

void GuidanceNameString::setLanguage(::nds::core::types::LanguageCode language_)
{
    m_language_ = language_;
}

::zserio::string<>& GuidanceNameString::getName()
{
    return m_name_;
}

const ::zserio::string<>& GuidanceNameString::getName() const
{
    return m_name_;
}

void GuidanceNameString::setName(const ::zserio::string<>& name_)
{
    m_name_ = name_;
}

void GuidanceNameString::setName(::zserio::string<>&& name_)
{
    m_name_ = ::std::move(name_);
}

::nds::routing::guidance::GuidanceNameStringRelationList& GuidanceNameString::getRelations()
{
    return m_relations_.value();
}

const ::nds::routing::guidance::GuidanceNameStringRelationList& GuidanceNameString::getRelations() const
{
    return m_relations_.value();
}

void GuidanceNameString::setRelations(const ::nds::routing::guidance::GuidanceNameStringRelationList& relations_)
{
    m_relations_ = relations_;
}

void GuidanceNameString::setRelations(::nds::routing::guidance::GuidanceNameStringRelationList&& relations_)
{
    m_relations_ = ::std::move(relations_);
}

bool GuidanceNameString::isRelationsUsed() const
{
    return (isRelationsSet());
}

bool GuidanceNameString::isRelationsSet() const
{
    return m_relations_.hasValue();
}

void GuidanceNameString::resetRelations()
{
    m_relations_.reset();
}

::nds::core::speech::PhoneticTranscriptionList& GuidanceNameString::getPhoneticTranscriptions()
{
    return m_phoneticTranscriptions_.value();
}

const ::nds::core::speech::PhoneticTranscriptionList& GuidanceNameString::getPhoneticTranscriptions() const
{
    return m_phoneticTranscriptions_.value();
}

void GuidanceNameString::setPhoneticTranscriptions(const ::nds::core::speech::PhoneticTranscriptionList& phoneticTranscriptions_)
{
    m_phoneticTranscriptions_ = phoneticTranscriptions_;
}

void GuidanceNameString::setPhoneticTranscriptions(::nds::core::speech::PhoneticTranscriptionList&& phoneticTranscriptions_)
{
    m_phoneticTranscriptions_ = ::std::move(phoneticTranscriptions_);
}

bool GuidanceNameString::isPhoneticTranscriptionsUsed() const
{
    return (isPhoneticTranscriptionsSet());
}

bool GuidanceNameString::isPhoneticTranscriptionsSet() const
{
    return m_phoneticTranscriptions_.hasValue();
}

void GuidanceNameString::resetPhoneticTranscriptions()
{
    m_phoneticTranscriptions_.reset();
}

void GuidanceNameString::initPackingContext(GuidanceNameString::ZserioPackingContext& context) const
{
    context.getLanguage().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_language_);
    if (isRelationsSet())
    {
        m_relations_.value().initPackingContext(context.getRelations());
    }
    if (isPhoneticTranscriptionsSet())
    {
        m_phoneticTranscriptions_.value().initPackingContext(context.getPhoneticTranscriptions());
    }
}

size_t GuidanceNameString::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_language_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += 1;
    if (isRelationsSet())
    {
        endBitPosition += m_relations_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isPhoneticTranscriptionsSet())
    {
        endBitPosition += m_phoneticTranscriptions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t GuidanceNameString::bitSizeOf(GuidanceNameString::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLanguage().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_language_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += 1;
    if (isRelationsSet())
    {
        endBitPosition += m_relations_.value().bitSizeOf(context.getRelations(), endBitPosition);
    }
    endBitPosition += 1;
    if (isPhoneticTranscriptionsSet())
    {
        endBitPosition += m_phoneticTranscriptions_.value().bitSizeOf(context.getPhoneticTranscriptions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t GuidanceNameString::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_language_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += 1;
    if (isRelationsSet())
    {
        endBitPosition = m_relations_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isPhoneticTranscriptionsSet())
    {
        endBitPosition = m_phoneticTranscriptions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t GuidanceNameString::initializeOffsets(GuidanceNameString::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLanguage().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_language_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += 1;
    if (isRelationsSet())
    {
        endBitPosition = m_relations_.value().initializeOffsets(context.getRelations(), endBitPosition);
    }
    endBitPosition += 1;
    if (isPhoneticTranscriptionsSet())
    {
        endBitPosition = m_phoneticTranscriptions_.value().initializeOffsets(context.getPhoneticTranscriptions(), endBitPosition);
    }

    return endBitPosition;
}

bool GuidanceNameString::operator==(const GuidanceNameString& other) const
{
    if (this != &other)
    {
        return
                (getNumNames() == other.getNumNames()) &&
                (m_language_ == other.m_language_) &&
                (m_name_ == other.m_name_) &&
                (!isRelationsUsed() ? !other.isRelationsUsed() : (m_relations_ == other.m_relations_)) &&
                (!isPhoneticTranscriptionsUsed() ? !other.isPhoneticTranscriptionsUsed() : (m_phoneticTranscriptions_ == other.m_phoneticTranscriptions_));
    }

    return true;
}

uint32_t GuidanceNameString::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumNames());
    result = ::zserio::calcHashCode(result, m_language_);
    result = ::zserio::calcHashCode(result, m_name_);
    if (isRelationsUsed())
        result = ::zserio::calcHashCode(result, m_relations_);
    if (isPhoneticTranscriptionsUsed())
        result = ::zserio::calcHashCode(result, m_phoneticTranscriptions_);

    return result;
}

void GuidanceNameString::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_language_);

    out.writeString(m_name_);

    if (isRelationsSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_relations_.value().getNumNames() != static_cast<uint8_t>(getNumNames()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numNames for field GuidanceNameString.relations: ") <<
                    m_relations_.value().getNumNames() << " != " << static_cast<uint8_t>(getNumNames()) << "!";
        }
        m_relations_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isPhoneticTranscriptionsSet())
    {
        out.writeBool(true);
        m_phoneticTranscriptions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void GuidanceNameString::write(GuidanceNameString::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLanguage().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(out, m_language_);

    out.writeString(m_name_);

    if (isRelationsSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_relations_.value().getNumNames() != static_cast<uint8_t>(getNumNames()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numNames for field GuidanceNameString.relations: ") <<
                    m_relations_.value().getNumNames() << " != " << static_cast<uint8_t>(getNumNames()) << "!";
        }
        m_relations_.value().write(context.getRelations(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isPhoneticTranscriptionsSet())
    {
        out.writeBool(true);
        m_phoneticTranscriptions_.value().write(context.getPhoneticTranscriptions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::types::LanguageCode GuidanceNameString::readLanguage(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LanguageCode>(in.readVarUInt16());
}

::nds::core::types::LanguageCode GuidanceNameString::readLanguage(GuidanceNameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLanguage().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(in);
}
::zserio::string<> GuidanceNameString::readName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceNameStringRelationList> GuidanceNameString::readRelations(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceNameStringRelationList>(::nds::routing::guidance::GuidanceNameStringRelationList(in, static_cast<uint8_t>(getNumNames()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceNameStringRelationList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceNameStringRelationList> GuidanceNameString::readRelations(GuidanceNameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceNameStringRelationList>(::nds::routing::guidance::GuidanceNameStringRelationList(context.getRelations(), in, static_cast<uint8_t>(getNumNames()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::routing::guidance::GuidanceNameStringRelationList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticTranscriptionList> GuidanceNameString::readPhoneticTranscriptions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticTranscriptionList>(::nds::core::speech::PhoneticTranscriptionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticTranscriptionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticTranscriptionList> GuidanceNameString::readPhoneticTranscriptions(GuidanceNameString::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticTranscriptionList>(::nds::core::speech::PhoneticTranscriptionList(context.getPhoneticTranscriptions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticTranscriptionList>(::zserio::NullOpt);
}

} // namespace guidance
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/guidance/GuidanceNameStringRelationList.h>

namespace nds
{
namespace routing
{
namespace guidance
{

GuidanceNameStringRelationList::GuidanceNameStringRelationList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numRelations_(uint8_t()),
        m_relations_(allocator)
{
}

GuidanceNameStringRelationList::GuidanceNameStringRelationList(::zserio::BitStreamReader& in,
        uint8_t numNames_, const allocator_type& allocator) :
        m_numNames_(numNames_),
        m_isInitialized(true),
        m_numRelations_(readNumRelations(in)),
        m_relations_(readRelations(in, allocator))
{
}

GuidanceNameStringRelationList::GuidanceNameStringRelationList(GuidanceNameStringRelationList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint8_t numNames_, const allocator_type& allocator) :
        m_numNames_(numNames_),
        m_isInitialized(true),
        m_numRelations_(readNumRelations(context, in)),
        m_relations_(readRelations(context, in, allocator))
{
}

GuidanceNameStringRelationList::GuidanceNameStringRelationList(const GuidanceNameStringRelationList& other) :
        m_numRelations_(other.m_numRelations_),
        m_relations_(other.m_relations_)
{
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;
}

GuidanceNameStringRelationList& GuidanceNameStringRelationList::operator=(const GuidanceNameStringRelationList& other)
{
    m_numRelations_ = other.m_numRelations_;
    m_relations_ = other.m_relations_;
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;

    return *this;
}

GuidanceNameStringRelationList::GuidanceNameStringRelationList(GuidanceNameStringRelationList&& other) :
        m_numRelations_(::std::move(other.m_numRelations_)),
        m_relations_(::std::move(other.m_relations_))
{
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;
}

GuidanceNameStringRelationList& GuidanceNameStringRelationList::operator=(GuidanceNameStringRelationList&& other)
{
    m_numRelations_ = ::std::move(other.m_numRelations_);
    m_relations_ = ::std::move(other.m_relations_);
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;

    return *this;
}

GuidanceNameStringRelationList::GuidanceNameStringRelationList(::zserio::PropagateAllocatorT,
        const GuidanceNameStringRelationList& other, const allocator_type& allocator) :
        m_numRelations_(::zserio::allocatorPropagatingCopy(other.m_numRelations_, allocator)),
        m_relations_(::zserio::allocatorPropagatingCopy(other.m_relations_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;
}

void GuidanceNameStringRelationList::initialize(
        uint8_t numNames_)
{
    m_numNames_ = numNames_;
    m_isInitialized = true;

    initializeChildren();
}

bool GuidanceNameStringRelationList::isInitialized() const
{
    return m_isInitialized;
}

void GuidanceNameStringRelationList::initializeChildren()
{
    m_relations_.initializeElements(*this);
}

uint8_t GuidanceNameStringRelationList::getNumNames() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numNames' of compound 'GuidanceNameStringRelationList' is not initialized!");

    return m_numNames_;
}

uint8_t GuidanceNameStringRelationList::getNumRelations() const
{
    return m_numRelations_;
}

void GuidanceNameStringRelationList::setNumRelations(uint8_t numRelations_)
{
    m_numRelations_ = numRelations_;
}

::zserio::vector<::nds::routing::guidance::GuidanceNameStringRelation>& GuidanceNameStringRelationList::getRelations()
{
    return m_relations_.getRawArray();
}

const ::zserio::vector<::nds::routing::guidance::GuidanceNameStringRelation>& GuidanceNameStringRelationList::getRelations() const
{
    return m_relations_.getRawArray();
}

void GuidanceNameStringRelationList::setRelations(const ::zserio::vector<::nds::routing::guidance::GuidanceNameStringRelation>& relations_)
{
    m_relations_ = ZserioArrayType_relations(relations_);
}

void GuidanceNameStringRelationList::setRelations(::zserio::vector<::nds::routing::guidance::GuidanceNameStringRelation>&& relations_)
{
    m_relations_ = ZserioArrayType_relations(std::move(relations_));
}

void GuidanceNameStringRelationList::initPackingContext(GuidanceNameStringRelationList::ZserioPackingContext& context) const
{
    context.getNumRelations().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numRelations_);
}

size_t GuidanceNameStringRelationList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_relations_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GuidanceNameStringRelationList::bitSizeOf(GuidanceNameStringRelationList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumRelations().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numRelations_);
    endBitPosition += m_relations_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GuidanceNameStringRelationList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_relations_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t GuidanceNameStringRelationList::initializeOffsets(GuidanceNameStringRelationList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumRelations().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numRelations_);
    endBitPosition = m_relations_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool GuidanceNameStringRelationList::operator==(const GuidanceNameStringRelationList& other) const
{
    if (this != &other)
    {
        return
                (getNumNames() == other.getNumNames()) &&
                (m_numRelations_ == other.m_numRelations_) &&
                (m_relations_ == other.m_relations_);
    }

    return true;
}

uint32_t GuidanceNameStringRelationList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumNames());
    result = ::zserio::calcHashCode(result, m_numRelations_);
    result = ::zserio::calcHashCode(result, m_relations_);

    return result;
}

void GuidanceNameStringRelationList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numRelations_, UINT8_C(8));

    // check array length
    if (m_relations_.getRawArray().size() != static_cast<size_t>(getNumRelations()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field GuidanceNameStringRelationList.relations: ") <<
                m_relations_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRelations()) << "!";
    }
    m_relations_.write(*this, out);
}

void GuidanceNameStringRelationList::write(GuidanceNameStringRelationList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumRelations().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numRelations_);

    // check array length
    if (m_relations_.getRawArray().size() != static_cast<size_t>(getNumRelations()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field GuidanceNameStringRelationList.relations: ") <<
                m_relations_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRelations()) << "!";
    }
    m_relations_.writePacked(*this, out);
}

void GuidanceNameStringRelationList::ZserioArrayExpressions_relations::initializeElement(GuidanceNameStringRelationList& owner,
        ::nds::routing::guidance::GuidanceNameStringRelation& element, size_t)
{
    element.initialize(static_cast<uint8_t>(owner.getNumNames()));
}

void GuidanceNameStringRelationList::ZserioElementFactory_relations::create(GuidanceNameStringRelationList&         owner,
        ::zserio::vector<::nds::routing::guidance::GuidanceNameStringRelation>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint8_t>(owner.getNumNames()), array.get_allocator());
}

void GuidanceNameStringRelationList::ZserioElementFactory_relations::create(GuidanceNameStringRelationList&         owner,
        ::zserio::vector<::nds::routing::guidance::GuidanceNameStringRelation>& array,
        ::nds::routing::guidance::GuidanceNameStringRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint8_t>(owner.getNumNames()), array.get_allocator());
}

uint8_t GuidanceNameStringRelationList::readNumRelations(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t GuidanceNameStringRelationList::readNumRelations(GuidanceNameStringRelationList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumRelations().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
GuidanceNameStringRelationList::ZserioArrayType_relations GuidanceNameStringRelationList::readRelations(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_relations readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumRelations()));

    return readField;
}

GuidanceNameStringRelationList::ZserioArrayType_relations GuidanceNameStringRelationList::readRelations(GuidanceNameStringRelationList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_relations readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumRelations()));

    return readField;
}

} // namespace guidance
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/routing/guidance/GuidanceNameStringRelation.h>

namespace nds
{
namespace routing
{
namespace guidance
{

GuidanceNameStringRelation::GuidanceNameStringRelation(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_relationType_(::nds::routing::guidance::GuidanceNameStringRelationType()),
        m_relatedGuidanceNameStringIndex_(uint8_t())
{
}

GuidanceNameStringRelation::GuidanceNameStringRelation(::zserio::BitStreamReader& in,
        uint8_t numNames_, const allocator_type&) :
        m_numNames_(numNames_),
        m_isInitialized(true),
        m_relationType_(readRelationType(in)),
        m_relatedGuidanceNameStringIndex_(readRelatedGuidanceNameStringIndex(in))
{
}

GuidanceNameStringRelation::GuidanceNameStringRelation(GuidanceNameStringRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint8_t numNames_, const allocator_type&) :
        m_numNames_(numNames_),
        m_isInitialized(true),
        m_relationType_(readRelationType(context, in)),
        m_relatedGuidanceNameStringIndex_(readRelatedGuidanceNameStringIndex(context, in))
{
}

GuidanceNameStringRelation::GuidanceNameStringRelation(const GuidanceNameStringRelation& other) :
        m_relationType_(other.m_relationType_),
        m_relatedGuidanceNameStringIndex_(other.m_relatedGuidanceNameStringIndex_)
{
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;
}

GuidanceNameStringRelation& GuidanceNameStringRelation::operator=(const GuidanceNameStringRelation& other)
{
    m_relationType_ = other.m_relationType_;
    m_relatedGuidanceNameStringIndex_ = other.m_relatedGuidanceNameStringIndex_;
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;

    return *this;
}

GuidanceNameStringRelation::GuidanceNameStringRelation(GuidanceNameStringRelation&& other) :
        m_relationType_(::std::move(other.m_relationType_)),
        m_relatedGuidanceNameStringIndex_(::std::move(other.m_relatedGuidanceNameStringIndex_))
{
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;
}

GuidanceNameStringRelation& GuidanceNameStringRelation::operator=(GuidanceNameStringRelation&& other)
{
    m_relationType_ = ::std::move(other.m_relationType_);
    m_relatedGuidanceNameStringIndex_ = ::std::move(other.m_relatedGuidanceNameStringIndex_);
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;

    return *this;
}

GuidanceNameStringRelation::GuidanceNameStringRelation(::zserio::PropagateAllocatorT,
        const GuidanceNameStringRelation& other, const allocator_type& allocator) :
        m_relationType_(::zserio::allocatorPropagatingCopy(other.m_relationType_, allocator)),
        m_relatedGuidanceNameStringIndex_(::zserio::allocatorPropagatingCopy(other.m_relatedGuidanceNameStringIndex_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numNames_);
    else
        m_isInitialized = false;
}

void GuidanceNameStringRelation::initialize(
        uint8_t numNames_)
{
    m_numNames_ = numNames_;
    m_isInitialized = true;
}

bool GuidanceNameStringRelation::isInitialized() const
{
    return m_isInitialized;
}

uint8_t GuidanceNameStringRelation::getNumNames() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numNames' of compound 'GuidanceNameStringRelation' is not initialized!");

    return m_numNames_;
}

::nds::routing::guidance::GuidanceNameStringRelationType GuidanceNameStringRelation::getRelationType() const
{
    return m_relationType_;
}

void GuidanceNameStringRelation::setRelationType(::nds::routing::guidance::GuidanceNameStringRelationType relationType_)
{
    m_relationType_ = relationType_;
}

uint8_t GuidanceNameStringRelation::getRelatedGuidanceNameStringIndex() const
{
    return m_relatedGuidanceNameStringIndex_;
}

void GuidanceNameStringRelation::setRelatedGuidanceNameStringIndex(uint8_t relatedGuidanceNameStringIndex_)
{
    m_relatedGuidanceNameStringIndex_ = relatedGuidanceNameStringIndex_;
}

void GuidanceNameStringRelation::initPackingContext(GuidanceNameStringRelation::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getRelationType(), m_relationType_);
    context.getRelatedGuidanceNameStringIndex().init<::zserio::StdIntArrayTraits<uint8_t>>(m_relatedGuidanceNameStringIndex_);
}

size_t GuidanceNameStringRelation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_relationType_);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t GuidanceNameStringRelation::bitSizeOf(GuidanceNameStringRelation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getRelationType(), m_relationType_);
    endBitPosition += context.getRelatedGuidanceNameStringIndex().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_relatedGuidanceNameStringIndex_);

    return endBitPosition - bitPosition;
}

size_t GuidanceNameStringRelation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_relationType_);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t GuidanceNameStringRelation::initializeOffsets(GuidanceNameStringRelation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getRelationType(), endBitPosition,
        m_relationType_);
    endBitPosition += context.getRelatedGuidanceNameStringIndex().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_relatedGuidanceNameStringIndex_);

    return endBitPosition;
}

bool GuidanceNameStringRelation::operator==(const GuidanceNameStringRelation& other) const
{
    if (this != &other)
    {
        return
                (getNumNames() == other.getNumNames()) &&
                (m_relationType_ == other.m_relationType_) &&
                (m_relatedGuidanceNameStringIndex_ == other.m_relatedGuidanceNameStringIndex_);
    }

    return true;
}

uint32_t GuidanceNameStringRelation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumNames());
    result = ::zserio::calcHashCode(result, m_relationType_);
    result = ::zserio::calcHashCode(result, m_relatedGuidanceNameStringIndex_);

    return result;
}

void GuidanceNameStringRelation::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_relationType_);

    // check constraint
    if (!(getRelatedGuidanceNameStringIndex() < getNumNames()))
        throw ::zserio::ConstraintException("Write: Constraint violated at GuidanceNameStringRelation.relatedGuidanceNameStringIndex!");
    out.writeBits(m_relatedGuidanceNameStringIndex_, UINT8_C(8));
}

void GuidanceNameStringRelation::write(GuidanceNameStringRelation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getRelationType(), out, m_relationType_);

    // check constraint
    if (!(getRelatedGuidanceNameStringIndex() < getNumNames()))
        throw ::zserio::ConstraintException("Write: Constraint violated at GuidanceNameStringRelation.relatedGuidanceNameStringIndex!");
    context.getRelatedGuidanceNameStringIndex().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_relatedGuidanceNameStringIndex_);
}

::nds::routing::guidance::GuidanceNameStringRelationType GuidanceNameStringRelation::readRelationType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::guidance::GuidanceNameStringRelationType>(in);
}

::nds::routing::guidance::GuidanceNameStringRelationType GuidanceNameStringRelation::readRelationType(GuidanceNameStringRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::routing::guidance::GuidanceNameStringRelationType>(context.getRelationType(), in);
}
uint8_t GuidanceNameStringRelation::readRelatedGuidanceNameStringIndex(::zserio::BitStreamReader& in)
{
    uint8_t readField = static_cast<uint8_t>(in.readBits(UINT8_C(8)));
    // check constraint
    if (!(readField < getNumNames()))
        throw ::zserio::ConstraintException("Read: Constraint violated at GuidanceNameStringRelation.relatedGuidanceNameStringIndex!");

    return readField;
}

uint8_t GuidanceNameStringRelation::readRelatedGuidanceNameStringIndex(GuidanceNameStringRelation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint8_t readField = context.getRelatedGuidanceNameStringIndex().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
    // check constraint
    if (!(readField < getNumNames()))
        throw ::zserio::ConstraintException("Read: Constraint violated at GuidanceNameStringRelation.relatedGuidanceNameStringIndex!");

    return readField;
}

} // namespace guidance
} // namespace routing
} // namespace nds
