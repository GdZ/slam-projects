/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/types/RoutePointType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoutePointType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::routing::types::RoutePointType>::names;
constexpr ::std::array<::nds::routing::types::RoutePointType, 3> EnumTraits<::nds::routing::types::RoutePointType>::values;
constexpr const char* EnumTraits<::nds::routing::types::RoutePointType>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::types::RoutePointType value)
{
    switch (value)
    {
    case ::nds::routing::types::RoutePointType::DECISION:
        return 0;
    case ::nds::routing::types::RoutePointType::MANEUVER:
        return 1;
    case ::nds::routing::types::RoutePointType::RECONSTRUCTION:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoutePointType: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::types::RoutePointType>::type>(value) << "!";
    }
}

template <>
::nds::routing::types::RoutePointType valueToEnum(
        typename ::std::underlying_type<::nds::routing::types::RoutePointType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::routing::types::RoutePointType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoutePointType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::types::RoutePointType>(::nds::routing::types::RoutePointType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::types::RoutePointType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RoutePointType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::types::RoutePointType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::types::RoutePointType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RoutePointType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::types::RoutePointType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::types::RoutePointType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::types::RoutePointType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::RoutePointType>(
            static_cast<typename ::std::underlying_type<::nds::routing::types::RoutePointType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::routing::types::RoutePointType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::RoutePointType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RoutePointType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::types::RoutePointType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::types::RoutePointType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RoutePointType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/types/WaypointType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for WaypointType enumeration.
constexpr ::std::array<const char*, 11> EnumTraits<::nds::routing::types::WaypointType>::names;
constexpr ::std::array<::nds::routing::types::WaypointType, 11> EnumTraits<::nds::routing::types::WaypointType>::values;
constexpr const char* EnumTraits<::nds::routing::types::WaypointType>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::types::WaypointType value)
{
    switch (value)
    {
    case ::nds::routing::types::WaypointType::DESTINATION:
        return 0;
    case ::nds::routing::types::WaypointType::ORIGIN:
        return 1;
    case ::nds::routing::types::WaypointType::STOPOVER:
        return 2;
    case ::nds::routing::types::WaypointType::VIA_POINT:
        return 3;
    case ::nds::routing::types::WaypointType::EV_RECHARGE:
        return 4;
    case ::nds::routing::types::WaypointType::REFUEL:
        return 5;
    case ::nds::routing::types::WaypointType::REST_STOP:
        return 6;
    case ::nds::routing::types::WaypointType::HOME:
        return 7;
    case ::nds::routing::types::WaypointType::WORK:
        return 8;
    case ::nds::routing::types::WaypointType::USER:
        return 9;
    case ::nds::routing::types::WaypointType::DESTINATION_FINAL:
        return 10;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration WaypointType: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::types::WaypointType>::type>(value) << "!";
    }
}

template <>
::nds::routing::types::WaypointType valueToEnum(
        typename ::std::underlying_type<::nds::routing::types::WaypointType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
        return static_cast<::nds::routing::types::WaypointType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration WaypointType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::types::WaypointType>(::nds::routing::types::WaypointType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::types::WaypointType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::WaypointType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::types::WaypointType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::types::WaypointType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::WaypointType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::types::WaypointType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::types::WaypointType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::types::WaypointType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::WaypointType>(
            static_cast<typename ::std::underlying_type<::nds::routing::types::WaypointType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::routing::types::WaypointType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::WaypointType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::WaypointType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::types::WaypointType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::types::WaypointType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::WaypointType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/types/RouteOptionType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RouteOptionType enumeration.
constexpr ::std::array<const char*, 12> EnumTraits<::nds::routing::types::RouteOptionType>::names;
constexpr ::std::array<::nds::routing::types::RouteOptionType, 12> EnumTraits<::nds::routing::types::RouteOptionType>::values;
constexpr const char* EnumTraits<::nds::routing::types::RouteOptionType>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::types::RouteOptionType value)
{
    switch (value)
    {
    case ::nds::routing::types::RouteOptionType::SCENIC:
        return 0;
    case ::nds::routing::types::RouteOptionType::MOTORWAY:
        return 1;
    case ::nds::routing::types::RouteOptionType::AUTONOMOUS_DRIVING:
        return 2;
    case ::nds::routing::types::RouteOptionType::DIFFICULT_TURNS:
        return 3;
    case ::nds::routing::types::RouteOptionType::TUNNEL:
        return 4;
    case ::nds::routing::types::RouteOptionType::FERRY:
        return 5;
    case ::nds::routing::types::RouteOptionType::VIGNETTE:
        return 6;
    case ::nds::routing::types::RouteOptionType::TOLL:
        return 7;
    case ::nds::routing::types::RouteOptionType::HOV:
        return 8;
    case ::nds::routing::types::RouteOptionType::UNPAVED:
        return 9;
    case ::nds::routing::types::RouteOptionType::LOCAL_ROADS:
        return 10;
    case ::nds::routing::types::RouteOptionType::CHALLENGING:
        return 11;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RouteOptionType: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::types::RouteOptionType>::type>(value) << "!";
    }
}

template <>
::nds::routing::types::RouteOptionType valueToEnum(
        typename ::std::underlying_type<::nds::routing::types::RouteOptionType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
        return static_cast<::nds::routing::types::RouteOptionType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RouteOptionType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::types::RouteOptionType>(::nds::routing::types::RouteOptionType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::types::RouteOptionType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteOptionType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::types::RouteOptionType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::types::RouteOptionType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteOptionType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::types::RouteOptionType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::types::RouteOptionType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::types::RouteOptionType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::RouteOptionType>(
            static_cast<typename ::std::underlying_type<::nds::routing::types::RouteOptionType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::routing::types::RouteOptionType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::RouteOptionType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteOptionType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::types::RouteOptionType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::types::RouteOptionType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteOptionType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/types/RouteType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RouteType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::routing::types::RouteType>::names;
constexpr ::std::array<::nds::routing::types::RouteType, 4> EnumTraits<::nds::routing::types::RouteType>::values;
constexpr const char* EnumTraits<::nds::routing::types::RouteType>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::types::RouteType value)
{
    switch (value)
    {
    case ::nds::routing::types::RouteType::FASTEST:
        return 0;
    case ::nds::routing::types::RouteType::SHORTEST:
        return 1;
    case ::nds::routing::types::RouteType::ECO:
        return 2;
    case ::nds::routing::types::RouteType::GREEN:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RouteType: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::types::RouteType>::type>(value) << "!";
    }
}

template <>
::nds::routing::types::RouteType valueToEnum(
        typename ::std::underlying_type<::nds::routing::types::RouteType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::routing::types::RouteType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RouteType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::types::RouteType>(::nds::routing::types::RouteType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::types::RouteType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::types::RouteType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::types::RouteType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::types::RouteType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::types::RouteType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::types::RouteType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::RouteType>(
            static_cast<typename ::std::underlying_type<::nds::routing::types::RouteType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::routing::types::RouteType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::RouteType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::types::RouteType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::types::RouteType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/types/RouteSegmentType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RouteSegmentType enumeration.
constexpr ::std::array<const char*, 24> EnumTraits<::nds::routing::types::RouteSegmentType>::names;
constexpr ::std::array<::nds::routing::types::RouteSegmentType, 24> EnumTraits<::nds::routing::types::RouteSegmentType>::values;
constexpr const char* EnumTraits<::nds::routing::types::RouteSegmentType>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::types::RouteSegmentType value)
{
    switch (value)
    {
    case ::nds::routing::types::RouteSegmentType::DELAY:
        return 0;
    case ::nds::routing::types::RouteSegmentType::POLLUTION:
        return 1;
    case ::nds::routing::types::RouteSegmentType::TUNNEL:
        return 2;
    case ::nds::routing::types::RouteSegmentType::BRIDGE:
        return 3;
    case ::nds::routing::types::RouteSegmentType::FERRY:
        return 4;
    case ::nds::routing::types::RouteSegmentType::CAR_TRAIN:
        return 5;
    case ::nds::routing::types::RouteSegmentType::PUBLIC_TRANSPORT:
        return 6;
    case ::nds::routing::types::RouteSegmentType::MOTORWAY:
        return 7;
    case ::nds::routing::types::RouteSegmentType::UNPAVED:
        return 8;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L3:
        return 9;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L4:
        return 10;
    case ::nds::routing::types::RouteSegmentType::AUTOMATED_DRIVING_L5:
        return 11;
    case ::nds::routing::types::RouteSegmentType::LIMITED_MOBILE_DATA_COVERAGE:
        return 12;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_CAMERA:
        return 13;
    case ::nds::routing::types::RouteSegmentType::TRAFFIC_ENFORCEMENT_ZONE:
        return 14;
    case ::nds::routing::types::RouteSegmentType::TOLL:
        return 15;
    case ::nds::routing::types::RouteSegmentType::VIGNETTE:
        return 16;
    case ::nds::routing::types::RouteSegmentType::PEDESTRIAN:
        return 17;
    case ::nds::routing::types::RouteSegmentType::BIKE:
        return 18;
    case ::nds::routing::types::RouteSegmentType::SCOOTER:
        return 19;
    case ::nds::routing::types::RouteSegmentType::ENVIRONMENT_ZONE:
        return 20;
    case ::nds::routing::types::RouteSegmentType::USER_RESTRICTED_ACCESS:
        return 21;
    case ::nds::routing::types::RouteSegmentType::PHYSICAL_RESTRICTED_ACCESS:
        return 22;
    case ::nds::routing::types::RouteSegmentType::LEGAL_RESTRICTED_ACCESS:
        return 23;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RouteSegmentType: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::types::RouteSegmentType>::type>(value) << "!";
    }
}

template <>
::nds::routing::types::RouteSegmentType valueToEnum(
        typename ::std::underlying_type<::nds::routing::types::RouteSegmentType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
    case UINT8_C(17):
    case UINT8_C(18):
    case UINT8_C(19):
    case UINT8_C(20):
    case UINT8_C(21):
    case UINT8_C(22):
    case UINT8_C(23):
        return static_cast<::nds::routing::types::RouteSegmentType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RouteSegmentType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::types::RouteSegmentType>(::nds::routing::types::RouteSegmentType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::types::RouteSegmentType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteSegmentType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::types::RouteSegmentType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::types::RouteSegmentType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteSegmentType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::types::RouteSegmentType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::types::RouteSegmentType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::types::RouteSegmentType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::RouteSegmentType>(
            static_cast<typename ::std::underlying_type<::nds::routing::types::RouteSegmentType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::routing::types::RouteSegmentType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::RouteSegmentType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteSegmentType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::types::RouteSegmentType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::types::RouteSegmentType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::RouteSegmentType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/routing/types/GuidanceCode.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for GuidanceCode enumeration.
constexpr ::std::array<const char*, 35> EnumTraits<::nds::routing::types::GuidanceCode>::names;
constexpr ::std::array<::nds::routing::types::GuidanceCode, 35> EnumTraits<::nds::routing::types::GuidanceCode>::values;
constexpr const char* EnumTraits<::nds::routing::types::GuidanceCode>::enumName;

template <>
size_t enumToOrdinal(::nds::routing::types::GuidanceCode value)
{
    switch (value)
    {
    case ::nds::routing::types::GuidanceCode::STRAIGHT:
        return 0;
    case ::nds::routing::types::GuidanceCode::BEAR_LEFT:
        return 1;
    case ::nds::routing::types::GuidanceCode::BEAR_RIGHT:
        return 2;
    case ::nds::routing::types::GuidanceCode::LEFT:
        return 3;
    case ::nds::routing::types::GuidanceCode::RIGHT:
        return 4;
    case ::nds::routing::types::GuidanceCode::SLIGHT_LEFT:
        return 5;
    case ::nds::routing::types::GuidanceCode::SLIGHT_RIGHT:
        return 6;
    case ::nds::routing::types::GuidanceCode::SHARP_LEFT:
        return 7;
    case ::nds::routing::types::GuidanceCode::SHARP_RIGHT:
        return 8;
    case ::nds::routing::types::GuidanceCode::UTURN_LEFT:
        return 9;
    case ::nds::routing::types::GuidanceCode::UTURN_RIGHT:
        return 10;
    case ::nds::routing::types::GuidanceCode::UTURN_LEFT_DUAL:
        return 11;
    case ::nds::routing::types::GuidanceCode::UTURN_RIGHT_DUAL:
        return 12;
    case ::nds::routing::types::GuidanceCode::KEEP_LEFT:
        return 13;
    case ::nds::routing::types::GuidanceCode::KEEP_RIGHT:
        return 14;
    case ::nds::routing::types::GuidanceCode::KEEP_LEFT_SINGLE:
        return 15;
    case ::nds::routing::types::GuidanceCode::KEEP_RIGHT_SINGLE:
        return 16;
    case ::nds::routing::types::GuidanceCode::ROUNDABOUT:
        return 17;
    case ::nds::routing::types::GuidanceCode::ROUNDABOUT_REVERSED:
        return 18;
    case ::nds::routing::types::GuidanceCode::MOTORWAY_EXIT_LEFT:
        return 19;
    case ::nds::routing::types::GuidanceCode::MOTORWAY_EXIT_RIGHT:
        return 20;
    case ::nds::routing::types::GuidanceCode::BOARD_FERRY:
        return 21;
    case ::nds::routing::types::GuidanceCode::LEAVE_FERRY:
        return 22;
    case ::nds::routing::types::GuidanceCode::BOARD_CAR_SHUTTLE_TRAIN:
        return 23;
    case ::nds::routing::types::GuidanceCode::LEAVE_CAR_SHUTTLE_TRAIN:
        return 24;
    case ::nds::routing::types::GuidanceCode::ARRIVE:
        return 25;
    case ::nds::routing::types::GuidanceCode::DEPART:
        return 26;
    case ::nds::routing::types::GuidanceCode::HEAD_NORTH:
        return 27;
    case ::nds::routing::types::GuidanceCode::HEAD_NORTH_EAST:
        return 28;
    case ::nds::routing::types::GuidanceCode::HEAD_EAST:
        return 29;
    case ::nds::routing::types::GuidanceCode::HEAD_SOUTH_EAST:
        return 30;
    case ::nds::routing::types::GuidanceCode::HEAD_SOUTH:
        return 31;
    case ::nds::routing::types::GuidanceCode::HEAD_SOUTH_WEST:
        return 32;
    case ::nds::routing::types::GuidanceCode::HEAD_WEST:
        return 33;
    case ::nds::routing::types::GuidanceCode::HEAD_NORTH_WEST:
        return 34;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GuidanceCode: ") <<
                static_cast<typename ::std::underlying_type<::nds::routing::types::GuidanceCode>::type>(value) << "!";
    }
}

template <>
::nds::routing::types::GuidanceCode valueToEnum(
        typename ::std::underlying_type<::nds::routing::types::GuidanceCode>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
    case UINT8_C(17):
    case UINT8_C(18):
    case UINT8_C(19):
    case UINT8_C(20):
    case UINT8_C(21):
    case UINT8_C(22):
    case UINT8_C(23):
    case UINT8_C(24):
    case UINT8_C(25):
    case UINT8_C(26):
    case UINT8_C(27):
    case UINT8_C(28):
    case UINT8_C(29):
    case UINT8_C(30):
    case UINT8_C(31):
    case UINT8_C(32):
    case UINT8_C(33):
    case UINT8_C(34):
        return static_cast<::nds::routing::types::GuidanceCode>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GuidanceCode: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::routing::types::GuidanceCode>(::nds::routing::types::GuidanceCode value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::routing::types::GuidanceCode value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::GuidanceCode>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::routing::types::GuidanceCode)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::routing::types::GuidanceCode value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::GuidanceCode>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::routing::types::GuidanceCode value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::routing::types::GuidanceCode value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::routing::types::GuidanceCode read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::GuidanceCode>(
            static_cast<typename ::std::underlying_type<::nds::routing::types::GuidanceCode>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::routing::types::GuidanceCode read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::routing::types::GuidanceCode>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::GuidanceCode>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::routing::types::GuidanceCode value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::routing::types::GuidanceCode value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::routing::types::GuidanceCode>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>

#include <nds/routing/types/RangeProjectionType.h>

namespace nds
{
namespace routing
{
namespace types
{

RangeProjectionType::RangeProjectionType(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

RangeProjectionType::RangeProjectionType(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

void RangeProjectionType::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::nds::routing::types::RangeProjectionType::underlying_type>>(m_value);
}

size_t RangeProjectionType::bitSizeOf(size_t) const
{
    return UINT8_C(8);
}

size_t RangeProjectionType::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::nds::routing::types::RangeProjectionType::underlying_type>>(m_value);
}

size_t RangeProjectionType::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t RangeProjectionType::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t RangeProjectionType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void RangeProjectionType::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(8));
}

void RangeProjectionType::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::nds::routing::types::RangeProjectionType::underlying_type>>(out, m_value);
}

::zserio::string<> RangeProjectionType::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & RangeProjectionType::Values::DISTANCE) == RangeProjectionType::Values::DISTANCE)
        result += result.empty() ? "DISTANCE" : " | DISTANCE";
    if ((*this & RangeProjectionType::Values::TIME) == RangeProjectionType::Values::TIME)
        result += result.empty() ? "TIME" : " | TIME";
    if ((*this & RangeProjectionType::Values::FUEL) == RangeProjectionType::Values::FUEL)
        result += result.empty() ? "FUEL" : " | FUEL";
    if ((*this & RangeProjectionType::Values::BATTERY) == RangeProjectionType::Values::BATTERY)
        result += result.empty() ? "BATTERY" : " | BATTERY";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

RangeProjectionType::underlying_type RangeProjectionType::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(8)));
}

RangeProjectionType::underlying_type RangeProjectionType::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::nds::routing::types::RangeProjectionType::underlying_type>>(
            in);
}

} // namespace types
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/types/RouteSegmentConsumption.h>

namespace nds
{
namespace routing
{
namespace types
{

RouteSegmentConsumption::RouteSegmentConsumption(const allocator_type&) noexcept :
        m_fuelConsumption_(::nds::core::vehicle::FuelLiters()),
        m_batteryConsumption_(::nds::core::vehicle::WattHrs())
{
}

RouteSegmentConsumption::RouteSegmentConsumption(::zserio::BitStreamReader& in, const allocator_type&) :
        m_fuelConsumption_(readFuelConsumption(in)),
        m_batteryConsumption_(readBatteryConsumption(in))
{
}

RouteSegmentConsumption::RouteSegmentConsumption(RouteSegmentConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_fuelConsumption_(readFuelConsumption(in)),
        m_batteryConsumption_(readBatteryConsumption(context, in))
{
}

RouteSegmentConsumption::RouteSegmentConsumption(::zserio::PropagateAllocatorT,
        const RouteSegmentConsumption& other, const allocator_type& allocator) :
        m_fuelConsumption_(::zserio::allocatorPropagatingCopy(other.m_fuelConsumption_, allocator)),
        m_batteryConsumption_(::zserio::allocatorPropagatingCopy(other.m_batteryConsumption_, allocator))
{
}

::nds::core::vehicle::FuelLiters RouteSegmentConsumption::getFuelConsumption() const
{
    return m_fuelConsumption_;
}

void RouteSegmentConsumption::setFuelConsumption(::nds::core::vehicle::FuelLiters fuelConsumption_)
{
    m_fuelConsumption_ = fuelConsumption_;
}

::nds::core::vehicle::WattHrs RouteSegmentConsumption::getBatteryConsumption() const
{
    return m_batteryConsumption_;
}

void RouteSegmentConsumption::setBatteryConsumption(::nds::core::vehicle::WattHrs batteryConsumption_)
{
    m_batteryConsumption_ = batteryConsumption_;
}

void RouteSegmentConsumption::initPackingContext(RouteSegmentConsumption::ZserioPackingContext& context) const
{
    context.getBatteryConsumption().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(m_batteryConsumption_);
}

size_t RouteSegmentConsumption::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_batteryConsumption_);

    return endBitPosition - bitPosition;
}

size_t RouteSegmentConsumption::bitSizeOf(RouteSegmentConsumption::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += context.getBatteryConsumption().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(m_batteryConsumption_);

    return endBitPosition - bitPosition;
}

size_t RouteSegmentConsumption::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_batteryConsumption_);

    return endBitPosition;
}

size_t RouteSegmentConsumption::initializeOffsets(RouteSegmentConsumption::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += context.getBatteryConsumption().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(m_batteryConsumption_);

    return endBitPosition;
}

bool RouteSegmentConsumption::operator==(const RouteSegmentConsumption& other) const
{
    if (this != &other)
    {
        return
                (m_fuelConsumption_ == other.m_fuelConsumption_) &&
                (m_batteryConsumption_ == other.m_batteryConsumption_);
    }

    return true;
}

uint32_t RouteSegmentConsumption::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_fuelConsumption_);
    result = ::zserio::calcHashCode(result, m_batteryConsumption_);

    return result;
}

void RouteSegmentConsumption::write(::zserio::BitStreamWriter& out) const
{
    out.writeFloat16(m_fuelConsumption_);
    out.writeVarUInt32(m_batteryConsumption_);
}

void RouteSegmentConsumption::write(RouteSegmentConsumption::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeFloat16(m_fuelConsumption_);
    context.getBatteryConsumption().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(out, m_batteryConsumption_);
}

::nds::core::vehicle::FuelLiters RouteSegmentConsumption::readFuelConsumption(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::FuelLiters>(in.readFloat16());
}
::nds::core::vehicle::WattHrs RouteSegmentConsumption::readBatteryConsumption(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::WattHrs>(in.readVarUInt32());
}

::nds::core::vehicle::WattHrs RouteSegmentConsumption::readBatteryConsumption(RouteSegmentConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getBatteryConsumption().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(in);
}

} // namespace types
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/types/Pollution.h>

namespace nds
{
namespace routing
{
namespace types
{

Pollution::Pollution(const allocator_type&) noexcept :
        m_carbonDioxide_(uint64_t())
{
}

Pollution::Pollution(::zserio::BitStreamReader& in, const allocator_type&) :
        m_carbonDioxide_(readCarbonDioxide(in))
{
}

Pollution::Pollution(Pollution::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_carbonDioxide_(readCarbonDioxide(context, in))
{
}

Pollution::Pollution(::zserio::PropagateAllocatorT,
        const Pollution& other, const allocator_type& allocator) :
        m_carbonDioxide_(::zserio::allocatorPropagatingCopy(other.m_carbonDioxide_, allocator))
{
}

uint64_t Pollution::getCarbonDioxide() const
{
    return m_carbonDioxide_;
}

void Pollution::setCarbonDioxide(uint64_t carbonDioxide_)
{
    m_carbonDioxide_ = carbonDioxide_;
}

void Pollution::initPackingContext(Pollution::ZserioPackingContext& context) const
{
    context.getCarbonDioxide().init<::zserio::VarIntArrayTraits<uint64_t>>(m_carbonDioxide_);
}

size_t Pollution::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_carbonDioxide_);

    return endBitPosition - bitPosition;
}

size_t Pollution::bitSizeOf(Pollution::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCarbonDioxide().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_carbonDioxide_);

    return endBitPosition - bitPosition;
}

size_t Pollution::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_carbonDioxide_);

    return endBitPosition;
}

size_t Pollution::initializeOffsets(Pollution::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCarbonDioxide().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_carbonDioxide_);

    return endBitPosition;
}

bool Pollution::operator==(const Pollution& other) const
{
    if (this != &other)
    {
        return
                (m_carbonDioxide_ == other.m_carbonDioxide_);
    }

    return true;
}

uint32_t Pollution::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_carbonDioxide_);

    return result;
}

void Pollution::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt(m_carbonDioxide_);
}

void Pollution::write(Pollution::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getCarbonDioxide().write<::zserio::VarIntArrayTraits<uint64_t>>(out, m_carbonDioxide_);
}

uint64_t Pollution::readCarbonDioxide(::zserio::BitStreamReader& in)
{
    return static_cast<uint64_t>(in.readVarUInt());
}

uint64_t Pollution::readCarbonDioxide(Pollution::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCarbonDioxide().read<::zserio::VarIntArrayTraits<uint64_t>>(in);
}

} // namespace types
} // namespace routing
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/routing/types/DriverProfile.h>

namespace nds
{
namespace routing
{
namespace types
{

DriverProfile::DriverProfile(const allocator_type&) noexcept :
        m_areChildrenInitialized(false),
        m_aggressiveness_(::zserio::NullOpt),
        m_isDisabledPerson_(::zserio::NullOpt),
        m_homeAddress_(::zserio::NullOpt),
        m_workAddress_(::zserio::NullOpt)
{
}

DriverProfile::DriverProfile(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_aggressiveness_(readAggressiveness(in)),
        m_isDisabledPerson_(readIsDisabledPerson(in)),
        m_homeAddress_(readHomeAddress(in, allocator)),
        m_workAddress_(readWorkAddress(in, allocator))
{
}

DriverProfile::DriverProfile(DriverProfile::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_aggressiveness_(readAggressiveness(context, in)),
        m_isDisabledPerson_(readIsDisabledPerson(in)),
        m_homeAddress_(readHomeAddress(context, in, allocator)),
        m_workAddress_(readWorkAddress(context, in, allocator))
{
}

DriverProfile::DriverProfile(const DriverProfile& other) :
        m_aggressiveness_(other.m_aggressiveness_),
        m_isDisabledPerson_(other.m_isDisabledPerson_),
        m_homeAddress_(other.m_homeAddress_),
        m_workAddress_(other.m_workAddress_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

DriverProfile& DriverProfile::operator=(const DriverProfile& other)
{
    m_aggressiveness_ = other.m_aggressiveness_;
    m_isDisabledPerson_ = other.m_isDisabledPerson_;
    m_homeAddress_ = other.m_homeAddress_;
    m_workAddress_ = other.m_workAddress_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

DriverProfile::DriverProfile(DriverProfile&& other) :
        m_aggressiveness_(::std::move(other.m_aggressiveness_)),
        m_isDisabledPerson_(::std::move(other.m_isDisabledPerson_)),
        m_homeAddress_(::std::move(other.m_homeAddress_)),
        m_workAddress_(::std::move(other.m_workAddress_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

DriverProfile& DriverProfile::operator=(DriverProfile&& other)
{
    m_aggressiveness_ = ::std::move(other.m_aggressiveness_);
    m_isDisabledPerson_ = ::std::move(other.m_isDisabledPerson_);
    m_homeAddress_ = ::std::move(other.m_homeAddress_);
    m_workAddress_ = ::std::move(other.m_workAddress_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

DriverProfile::DriverProfile(::zserio::PropagateAllocatorT,
        const DriverProfile& other, const allocator_type& allocator) :
        m_aggressiveness_(::zserio::allocatorPropagatingCopy(other.m_aggressiveness_, allocator)),
        m_isDisabledPerson_(::zserio::allocatorPropagatingCopy(other.m_isDisabledPerson_, allocator)),
        m_homeAddress_(::zserio::allocatorPropagatingCopy(other.m_homeAddress_, allocator)),
        m_workAddress_(::zserio::allocatorPropagatingCopy(other.m_workAddress_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void DriverProfile::initializeChildren()
{
    if (isHomeAddressSet())
        m_homeAddress_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(0));
    if (isWorkAddressSet())
        m_workAddress_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

uint8_t DriverProfile::getAggressiveness() const
{
    return m_aggressiveness_.value();
}

void DriverProfile::setAggressiveness(uint8_t aggressiveness_)
{
    m_aggressiveness_ = aggressiveness_;
}

bool DriverProfile::isAggressivenessUsed() const
{
    return (isAggressivenessSet());
}

bool DriverProfile::isAggressivenessSet() const
{
    return m_aggressiveness_.hasValue();
}

void DriverProfile::resetAggressiveness()
{
    m_aggressiveness_.reset();
}

bool DriverProfile::getIsDisabledPerson() const
{
    return m_isDisabledPerson_.value();
}

void DriverProfile::setIsDisabledPerson(bool isDisabledPerson_)
{
    m_isDisabledPerson_ = isDisabledPerson_;
}

bool DriverProfile::isIsDisabledPersonUsed() const
{
    return (isIsDisabledPersonSet());
}

bool DriverProfile::isIsDisabledPersonSet() const
{
    return m_isDisabledPerson_.hasValue();
}

void DriverProfile::resetIsDisabledPerson()
{
    m_isDisabledPerson_.reset();
}

::nds::core::geometry::Position2D& DriverProfile::getHomeAddress()
{
    return m_homeAddress_.value();
}

const ::nds::core::geometry::Position2D& DriverProfile::getHomeAddress() const
{
    return m_homeAddress_.value();
}

void DriverProfile::setHomeAddress(const ::nds::core::geometry::Position2D& homeAddress_)
{
    m_homeAddress_ = homeAddress_;
}

void DriverProfile::setHomeAddress(::nds::core::geometry::Position2D&& homeAddress_)
{
    m_homeAddress_ = ::std::move(homeAddress_);
}

bool DriverProfile::isHomeAddressUsed() const
{
    return (isHomeAddressSet());
}

bool DriverProfile::isHomeAddressSet() const
{
    return m_homeAddress_.hasValue();
}

void DriverProfile::resetHomeAddress()
{
    m_homeAddress_.reset();
}

::nds::core::geometry::Position2D& DriverProfile::getWorkAddress()
{
    return m_workAddress_.value();
}

const ::nds::core::geometry::Position2D& DriverProfile::getWorkAddress() const
{
    return m_workAddress_.value();
}

void DriverProfile::setWorkAddress(const ::nds::core::geometry::Position2D& workAddress_)
{
    m_workAddress_ = workAddress_;
}

void DriverProfile::setWorkAddress(::nds::core::geometry::Position2D&& workAddress_)
{
    m_workAddress_ = ::std::move(workAddress_);
}

bool DriverProfile::isWorkAddressUsed() const
{
    return (isWorkAddressSet());
}

bool DriverProfile::isWorkAddressSet() const
{
    return m_workAddress_.hasValue();
}

void DriverProfile::resetWorkAddress()
{
    m_workAddress_.reset();
}

void DriverProfile::initPackingContext(DriverProfile::ZserioPackingContext& context) const
{
    if (isAggressivenessSet())
    {
        context.getAggressiveness().init<::zserio::StdIntArrayTraits<uint8_t>>(m_aggressiveness_.value());
    }
    if (isHomeAddressSet())
    {
        m_homeAddress_.value().initPackingContext(context.getHomeAddress());
    }
    if (isWorkAddressSet())
    {
        m_workAddress_.value().initPackingContext(context.getWorkAddress());
    }
}

size_t DriverProfile::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isAggressivenessSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isIsDisabledPersonSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isHomeAddressSet())
    {
        endBitPosition += m_homeAddress_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isWorkAddressSet())
    {
        endBitPosition += m_workAddress_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DriverProfile::bitSizeOf(DriverProfile::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isAggressivenessSet())
    {
        endBitPosition += context.getAggressiveness().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_aggressiveness_.value());
    }
    endBitPosition += 1;
    if (isIsDisabledPersonSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isHomeAddressSet())
    {
        endBitPosition += m_homeAddress_.value().bitSizeOf(context.getHomeAddress(), endBitPosition);
    }
    endBitPosition += 1;
    if (isWorkAddressSet())
    {
        endBitPosition += m_workAddress_.value().bitSizeOf(context.getWorkAddress(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DriverProfile::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isAggressivenessSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isIsDisabledPersonSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isHomeAddressSet())
    {
        endBitPosition = m_homeAddress_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isWorkAddressSet())
    {
        endBitPosition = m_workAddress_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t DriverProfile::initializeOffsets(DriverProfile::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isAggressivenessSet())
    {
        endBitPosition += context.getAggressiveness().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_aggressiveness_.value());
    }
    endBitPosition += 1;
    if (isIsDisabledPersonSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isHomeAddressSet())
    {
        endBitPosition = m_homeAddress_.value().initializeOffsets(context.getHomeAddress(), endBitPosition);
    }
    endBitPosition += 1;
    if (isWorkAddressSet())
    {
        endBitPosition = m_workAddress_.value().initializeOffsets(context.getWorkAddress(), endBitPosition);
    }

    return endBitPosition;
}

bool DriverProfile::operator==(const DriverProfile& other) const
{
    if (this != &other)
    {
        return
                (!isAggressivenessUsed() ? !other.isAggressivenessUsed() : (m_aggressiveness_ == other.m_aggressiveness_)) &&
                (!isIsDisabledPersonUsed() ? !other.isIsDisabledPersonUsed() : (m_isDisabledPerson_ == other.m_isDisabledPerson_)) &&
                (!isHomeAddressUsed() ? !other.isHomeAddressUsed() : (m_homeAddress_ == other.m_homeAddress_)) &&
                (!isWorkAddressUsed() ? !other.isWorkAddressUsed() : (m_workAddress_ == other.m_workAddress_));
    }

    return true;
}

uint32_t DriverProfile::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isAggressivenessUsed())
        result = ::zserio::calcHashCode(result, m_aggressiveness_);
    if (isIsDisabledPersonUsed())
        result = ::zserio::calcHashCode(result, m_isDisabledPerson_);
    if (isHomeAddressUsed())
        result = ::zserio::calcHashCode(result, m_homeAddress_);
    if (isWorkAddressUsed())
        result = ::zserio::calcHashCode(result, m_workAddress_);

    return result;
}

void DriverProfile::write(::zserio::BitStreamWriter& out) const
{
    if (isAggressivenessSet())
    {
        out.writeBool(true);
        out.writeBits(m_aggressiveness_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }

    if (isIsDisabledPersonSet())
    {
        out.writeBool(true);
        out.writeBool(m_isDisabledPerson_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isHomeAddressSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_homeAddress_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DriverProfile.homeAddress: ") <<
                    m_homeAddress_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_homeAddress_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isWorkAddressSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_workAddress_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DriverProfile.workAddress: ") <<
                    m_workAddress_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_workAddress_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void DriverProfile::write(DriverProfile::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    if (isAggressivenessSet())
    {
        out.writeBool(true);
        context.getAggressiveness().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_aggressiveness_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isIsDisabledPersonSet())
    {
        out.writeBool(true);
        out.writeBool(m_isDisabledPerson_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isHomeAddressSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_homeAddress_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DriverProfile.homeAddress: ") <<
                    m_homeAddress_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_homeAddress_.value().write(context.getHomeAddress(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isWorkAddressSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_workAddress_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DriverProfile.workAddress: ") <<
                    m_workAddress_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_workAddress_.value().write(context.getWorkAddress(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::InplaceOptionalHolder<uint8_t> DriverProfile::readAggressiveness(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(static_cast<uint8_t>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint8_t> DriverProfile::readAggressiveness(DriverProfile::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(context.getAggressiveness().read<::zserio::StdIntArrayTraits<uint8_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> DriverProfile::readIsDisabledPerson(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D> DriverProfile::readHomeAddress(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D> DriverProfile::readHomeAddress(DriverProfile::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::nds::core::geometry::Position2D(context.getHomeAddress(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D> DriverProfile::readWorkAddress(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D> DriverProfile::readWorkAddress(DriverProfile::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::nds::core::geometry::Position2D(context.getWorkAddress(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::zserio::NullOpt);
}

} // namespace types
} // namespace routing
} // namespace nds
