/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/reference/types/DisplayLineValidityType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DisplayLineValidityType enumeration.
constexpr ::std::array<const char*, 6> EnumTraits<::nds::display::reference::types::DisplayLineValidityType>::names;
constexpr ::std::array<::nds::display::reference::types::DisplayLineValidityType, 6> EnumTraits<::nds::display::reference::types::DisplayLineValidityType>::values;
constexpr const char* EnumTraits<::nds::display::reference::types::DisplayLineValidityType>::enumName;

template <>
size_t enumToOrdinal(::nds::display::reference::types::DisplayLineValidityType value)
{
    switch (value)
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return 0;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return 1;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return 2;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return 3;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return 4;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return 5;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayLineValidityType: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::reference::types::DisplayLineValidityType>::type>(value) << "!";
    }
}

template <>
::nds::display::reference::types::DisplayLineValidityType valueToEnum(
        typename ::std::underlying_type<::nds::display::reference::types::DisplayLineValidityType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
        return static_cast<::nds::display::reference::types::DisplayLineValidityType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayLineValidityType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::reference::types::DisplayLineValidityType>(::nds::display::reference::types::DisplayLineValidityType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::reference::types::DisplayLineValidityType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::reference::types::DisplayLineValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::reference::types::DisplayLineValidityType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::reference::types::DisplayLineValidityType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::reference::types::DisplayLineValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::reference::types::DisplayLineValidityType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::reference::types::DisplayLineValidityType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::reference::types::DisplayLineValidityType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::reference::types::DisplayLineValidityType>(
            static_cast<typename ::std::underlying_type<::nds::display::reference::types::DisplayLineValidityType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::display::reference::types::DisplayLineValidityType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::reference::types::DisplayLineValidityType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::reference::types::DisplayLineValidityType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::reference::types::DisplayLineValidityType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::reference::types::DisplayLineValidityType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::reference::types::DisplayLineValidityType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/reference/types/DisplayAreaValidityType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DisplayAreaValidityType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::display::reference::types::DisplayAreaValidityType>::names;
constexpr ::std::array<::nds::display::reference::types::DisplayAreaValidityType, 2> EnumTraits<::nds::display::reference::types::DisplayAreaValidityType>::values;
constexpr const char* EnumTraits<::nds::display::reference::types::DisplayAreaValidityType>::enumName;

template <>
size_t enumToOrdinal(::nds::display::reference::types::DisplayAreaValidityType value)
{
    switch (value)
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        return 0;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayAreaValidityType: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::reference::types::DisplayAreaValidityType>::type>(value) << "!";
    }
}

template <>
::nds::display::reference::types::DisplayAreaValidityType valueToEnum(
        typename ::std::underlying_type<::nds::display::reference::types::DisplayAreaValidityType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::display::reference::types::DisplayAreaValidityType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayAreaValidityType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::reference::types::DisplayAreaValidityType>(::nds::display::reference::types::DisplayAreaValidityType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::reference::types::DisplayAreaValidityType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::reference::types::DisplayAreaValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::reference::types::DisplayAreaValidityType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::reference::types::DisplayAreaValidityType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::reference::types::DisplayAreaValidityType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::reference::types::DisplayAreaValidityType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::reference::types::DisplayAreaValidityType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::reference::types::DisplayAreaValidityType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::reference::types::DisplayAreaValidityType>(
            static_cast<typename ::std::underlying_type<::nds::display::reference::types::DisplayAreaValidityType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::display::reference::types::DisplayAreaValidityType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::reference::types::DisplayAreaValidityType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::reference::types::DisplayAreaValidityType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::reference::types::DisplayAreaValidityType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::reference::types::DisplayAreaValidityType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::reference::types::DisplayAreaValidityType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/DisplayLineReference.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

DisplayLineReference::DisplayLineReference(const allocator_type&) noexcept :
        m_isDirected_(bool()),
        m_directedLineReference_(::zserio::NullOpt),
        m_lineReference_(::zserio::NullOpt)
{
}

DisplayLineReference::DisplayLineReference(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_isDirected_(readIsDirected(in)),
        m_directedLineReference_(readDirectedLineReference(in, allocator)),
        m_lineReference_(readLineReference(in, allocator))
{
}

DisplayLineReference::DisplayLineReference(DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_isDirected_(readIsDirected(in)),
        m_directedLineReference_(readDirectedLineReference(context, in, allocator)),
        m_lineReference_(readLineReference(context, in, allocator))
{
}

DisplayLineReference::DisplayLineReference(::zserio::PropagateAllocatorT,
        const DisplayLineReference& other, const allocator_type& allocator) :
        m_isDirected_(::zserio::allocatorPropagatingCopy(other.m_isDirected_, allocator)),
        m_directedLineReference_(::zserio::allocatorPropagatingCopy(other.m_directedLineReference_, allocator)),
        m_lineReference_(::zserio::allocatorPropagatingCopy(other.m_lineReference_, allocator))
{
}

bool DisplayLineReference::getIsDirected() const
{
    return m_isDirected_;
}

void DisplayLineReference::setIsDirected(bool isDirected_)
{
    m_isDirected_ = isDirected_;
}

::nds::display::reference::types::DirectedDisplayLineReference& DisplayLineReference::getDirectedLineReference()
{
    return m_directedLineReference_.value();
}

const ::nds::display::reference::types::DirectedDisplayLineReference& DisplayLineReference::getDirectedLineReference() const
{
    return m_directedLineReference_.value();
}

void DisplayLineReference::setDirectedLineReference(const ::nds::display::reference::types::DirectedDisplayLineReference& directedLineReference_)
{
    m_directedLineReference_ = directedLineReference_;
}

void DisplayLineReference::setDirectedLineReference(::nds::display::reference::types::DirectedDisplayLineReference&& directedLineReference_)
{
    m_directedLineReference_ = ::std::move(directedLineReference_);
}

bool DisplayLineReference::isDirectedLineReferenceUsed() const
{
    return (getIsDirected());
}

bool DisplayLineReference::isDirectedLineReferenceSet() const
{
    return m_directedLineReference_.hasValue();
}

void DisplayLineReference::resetDirectedLineReference()
{
    m_directedLineReference_.reset();
}

::nds::display::reference::types::DisplayLineId& DisplayLineReference::getLineReference()
{
    return m_lineReference_.value();
}

const ::nds::display::reference::types::DisplayLineId& DisplayLineReference::getLineReference() const
{
    return m_lineReference_.value();
}

void DisplayLineReference::setLineReference(const ::nds::display::reference::types::DisplayLineId& lineReference_)
{
    m_lineReference_ = lineReference_;
}

void DisplayLineReference::setLineReference(::nds::display::reference::types::DisplayLineId&& lineReference_)
{
    m_lineReference_ = ::std::move(lineReference_);
}

bool DisplayLineReference::isLineReferenceUsed() const
{
    return (!getIsDirected());
}

bool DisplayLineReference::isLineReferenceSet() const
{
    return m_lineReference_.hasValue();
}

void DisplayLineReference::resetLineReference()
{
    m_lineReference_.reset();
}

void DisplayLineReference::initPackingContext(DisplayLineReference::ZserioPackingContext& context) const
{
    if (getIsDirected())
    {
        m_directedLineReference_.value().initPackingContext(context.getDirectedLineReference());
    }
    if (!getIsDirected())
    {
        m_lineReference_.value().initPackingContext(context.getLineReference());
    }
}

size_t DisplayLineReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirected())
    {
        endBitPosition += m_directedLineReference_.value().bitSizeOf(endBitPosition);
    }
    if (!getIsDirected())
    {
        endBitPosition += m_lineReference_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLineReference::bitSizeOf(DisplayLineReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirected())
    {
        endBitPosition += m_directedLineReference_.value().bitSizeOf(context.getDirectedLineReference(), endBitPosition);
    }
    if (!getIsDirected())
    {
        endBitPosition += m_lineReference_.value().bitSizeOf(context.getLineReference(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLineReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirected())
    {
        endBitPosition = m_directedLineReference_.value().initializeOffsets(endBitPosition);
    }
    if (!getIsDirected())
    {
        endBitPosition = m_lineReference_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t DisplayLineReference::initializeOffsets(DisplayLineReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getIsDirected())
    {
        endBitPosition = m_directedLineReference_.value().initializeOffsets(context.getDirectedLineReference(), endBitPosition);
    }
    if (!getIsDirected())
    {
        endBitPosition = m_lineReference_.value().initializeOffsets(context.getLineReference(), endBitPosition);
    }

    return endBitPosition;
}

bool DisplayLineReference::operator==(const DisplayLineReference& other) const
{
    if (this != &other)
    {
        return
                (m_isDirected_ == other.m_isDirected_) &&
                (!isDirectedLineReferenceUsed() ? !other.isDirectedLineReferenceUsed() : (m_directedLineReference_ == other.m_directedLineReference_)) &&
                (!isLineReferenceUsed() ? !other.isLineReferenceUsed() : (m_lineReference_ == other.m_lineReference_));
    }

    return true;
}

uint32_t DisplayLineReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_isDirected_);
    if (isDirectedLineReferenceUsed())
        result = ::zserio::calcHashCode(result, m_directedLineReference_);
    if (isLineReferenceUsed())
        result = ::zserio::calcHashCode(result, m_lineReference_);

    return result;
}

void DisplayLineReference::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirected_);
    if (getIsDirected())
    {
        m_directedLineReference_.value().write(out);
    }
    if (!getIsDirected())
    {
        m_lineReference_.value().write(out);
    }
}

void DisplayLineReference::write(DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_isDirected_);
    if (getIsDirected())
    {
        m_directedLineReference_.value().write(context.getDirectedLineReference(), out);
    }
    if (!getIsDirected())
    {
        m_lineReference_.value().write(context.getLineReference(), out);
    }
}

bool DisplayLineReference::readIsDirected(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::display::reference::types::DirectedDisplayLineReference> DisplayLineReference::readDirectedLineReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getIsDirected())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::DirectedDisplayLineReference>(::nds::display::reference::types::DirectedDisplayLineReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::DirectedDisplayLineReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::reference::types::DirectedDisplayLineReference> DisplayLineReference::readDirectedLineReference(DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getIsDirected())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::DirectedDisplayLineReference>(::nds::display::reference::types::DirectedDisplayLineReference(context.getDirectedLineReference(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::DirectedDisplayLineReference>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::display::reference::types::DisplayLineId> DisplayLineReference::readLineReference(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (!getIsDirected())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::DisplayLineId>(::nds::display::reference::types::DisplayLineId(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::DisplayLineId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::reference::types::DisplayLineId> DisplayLineReference::readLineReference(DisplayLineReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (!getIsDirected())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::DisplayLineId>(::nds::display::reference::types::DisplayLineId(context.getLineReference(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::DisplayLineId>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/TextureReference.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

TextureReference::TextureReference(const allocator_type&) noexcept :
        m_textureId_(::nds::display::reference::types::TextureId()),
        m_isSection_(bool()),
        m_textureSectionIndex_(::zserio::NullOpt)
{
}

TextureReference::TextureReference(::zserio::BitStreamReader& in, const allocator_type&) :
        m_textureId_(readTextureId(in)),
        m_isSection_(readIsSection(in)),
        m_textureSectionIndex_(readTextureSectionIndex(in))
{
}

TextureReference::TextureReference(TextureReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_textureId_(readTextureId(context, in)),
        m_isSection_(readIsSection(in)),
        m_textureSectionIndex_(readTextureSectionIndex(context, in))
{
}

TextureReference::TextureReference(::zserio::PropagateAllocatorT,
        const TextureReference& other, const allocator_type& allocator) :
        m_textureId_(::zserio::allocatorPropagatingCopy(other.m_textureId_, allocator)),
        m_isSection_(::zserio::allocatorPropagatingCopy(other.m_isSection_, allocator)),
        m_textureSectionIndex_(::zserio::allocatorPropagatingCopy(other.m_textureSectionIndex_, allocator))
{
}

::nds::display::reference::types::TextureId TextureReference::getTextureId() const
{
    return m_textureId_;
}

void TextureReference::setTextureId(::nds::display::reference::types::TextureId textureId_)
{
    m_textureId_ = textureId_;
}

bool TextureReference::getIsSection() const
{
    return m_isSection_;
}

void TextureReference::setIsSection(bool isSection_)
{
    m_isSection_ = isSection_;
}

::nds::display::reference::types::TextureSectionIndex TextureReference::getTextureSectionIndex() const
{
    return m_textureSectionIndex_.value();
}

void TextureReference::setTextureSectionIndex(::nds::display::reference::types::TextureSectionIndex textureSectionIndex_)
{
    m_textureSectionIndex_ = textureSectionIndex_;
}

bool TextureReference::isTextureSectionIndexUsed() const
{
    return (getIsSection() == true);
}

bool TextureReference::isTextureSectionIndexSet() const
{
    return m_textureSectionIndex_.hasValue();
}

void TextureReference::resetTextureSectionIndex()
{
    m_textureSectionIndex_.reset();
}

void TextureReference::initPackingContext(TextureReference::ZserioPackingContext& context) const
{
    context.getTextureId().init<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(m_textureId_);
    if (getIsSection() == true)
    {
        context.getTextureSectionIndex().init<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionIndex>>(m_textureSectionIndex_.value());
    }
}

size_t TextureReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_textureId_);
    endBitPosition += UINT8_C(1);
    if (getIsSection() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_textureSectionIndex_.value());
    }

    return endBitPosition - bitPosition;
}

size_t TextureReference::bitSizeOf(TextureReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTextureId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(m_textureId_);
    endBitPosition += UINT8_C(1);
    if (getIsSection() == true)
    {
        endBitPosition += context.getTextureSectionIndex().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionIndex>>(m_textureSectionIndex_.value());
    }

    return endBitPosition - bitPosition;
}

size_t TextureReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_textureId_);
    endBitPosition += UINT8_C(1);
    if (getIsSection() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_textureSectionIndex_.value());
    }

    return endBitPosition;
}

size_t TextureReference::initializeOffsets(TextureReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTextureId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(m_textureId_);
    endBitPosition += UINT8_C(1);
    if (getIsSection() == true)
    {
        endBitPosition += context.getTextureSectionIndex().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionIndex>>(m_textureSectionIndex_.value());
    }

    return endBitPosition;
}

bool TextureReference::operator==(const TextureReference& other) const
{
    if (this != &other)
    {
        return
                (m_textureId_ == other.m_textureId_) &&
                (m_isSection_ == other.m_isSection_) &&
                (!isTextureSectionIndexUsed() ? !other.isTextureSectionIndexUsed() : (m_textureSectionIndex_ == other.m_textureSectionIndex_));
    }

    return true;
}

uint32_t TextureReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_textureId_);
    result = ::zserio::calcHashCode(result, m_isSection_);
    if (isTextureSectionIndexUsed())
        result = ::zserio::calcHashCode(result, m_textureSectionIndex_);

    return result;
}

void TextureReference::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_textureId_);
    out.writeBool(m_isSection_);
    if (getIsSection() == true)
    {
        out.writeVarUInt16(m_textureSectionIndex_.value());
    }
}

void TextureReference::write(TextureReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getTextureId().write<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(out, m_textureId_);
    out.writeBool(m_isSection_);
    if (getIsSection() == true)
    {
        context.getTextureSectionIndex().write<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionIndex>>(out, m_textureSectionIndex_.value());
    }
}

::nds::display::reference::types::TextureId TextureReference::readTextureId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::display::reference::types::TextureId>(in.readVarUInt32());
}

::nds::display::reference::types::TextureId TextureReference::readTextureId(TextureReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTextureId().read<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(in);
}
bool TextureReference::readIsSection(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureSectionIndex> TextureReference::readTextureSectionIndex(::zserio::BitStreamReader& in)
{
    if (getIsSection() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureSectionIndex>(static_cast<::nds::display::reference::types::TextureSectionIndex>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureSectionIndex>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureSectionIndex> TextureReference::readTextureSectionIndex(TextureReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getIsSection() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureSectionIndex>(context.getTextureSectionIndex().read<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionIndex>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureSectionIndex>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/display/reference/types/DisplayLineRangeValidity.h>
#include <nds/display/reference/types/DisplayLineValidityType.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

DisplayLineRangeValidity::DisplayLineRangeValidity(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_type_(::nds::display::reference::types::DisplayLineValidityType()),
        m_numRanges_(::zserio::NullOpt),
        m_ranges_(::zserio::NullOpt)
{
}

DisplayLineRangeValidity::DisplayLineRangeValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(in)),
        m_numRanges_(readNumRanges(in)),
        m_ranges_(readRanges(in, allocator))
{
}

DisplayLineRangeValidity::DisplayLineRangeValidity(DisplayLineRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(context, in)),
        m_numRanges_(readNumRanges(context, in)),
        m_ranges_(readRanges(context, in, allocator))
{
}

DisplayLineRangeValidity::DisplayLineRangeValidity(const DisplayLineRangeValidity& other) :
        m_type_(other.m_type_),
        m_numRanges_(other.m_numRanges_),
        m_ranges_(other.m_ranges_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLineRangeValidity& DisplayLineRangeValidity::operator=(const DisplayLineRangeValidity& other)
{
    m_type_ = other.m_type_;
    m_numRanges_ = other.m_numRanges_;
    m_ranges_ = other.m_ranges_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLineRangeValidity::DisplayLineRangeValidity(DisplayLineRangeValidity&& other) :
        m_type_(::std::move(other.m_type_)),
        m_numRanges_(::std::move(other.m_numRanges_)),
        m_ranges_(::std::move(other.m_ranges_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLineRangeValidity& DisplayLineRangeValidity::operator=(DisplayLineRangeValidity&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_numRanges_ = ::std::move(other.m_numRanges_);
    m_ranges_ = ::std::move(other.m_ranges_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLineRangeValidity::DisplayLineRangeValidity(::zserio::PropagateAllocatorT,
        const DisplayLineRangeValidity& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_numRanges_(::zserio::allocatorPropagatingCopy(other.m_numRanges_, allocator)),
        m_ranges_(::zserio::allocatorPropagatingCopy(other.m_ranges_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void DisplayLineRangeValidity::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool DisplayLineRangeValidity::isInitialized() const
{
    return m_isInitialized;
}

void DisplayLineRangeValidity::initializeChildren()
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
        m_ranges_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift DisplayLineRangeValidity::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'DisplayLineRangeValidity' is not initialized!");

    return m_shift_;
}

::nds::display::reference::types::DisplayLineValidityType DisplayLineRangeValidity::getType() const
{
    return m_type_;
}

void DisplayLineRangeValidity::setType(::nds::display::reference::types::DisplayLineValidityType type_)
{
    m_type_ = type_;
}

uint32_t DisplayLineRangeValidity::getNumRanges() const
{
    return m_numRanges_.value();
}

void DisplayLineRangeValidity::setNumRanges(uint32_t numRanges_)
{
    m_numRanges_ = numRanges_;
}

bool DisplayLineRangeValidity::isNumRangesUsed() const
{
    return (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE);
}

bool DisplayLineRangeValidity::isNumRangesSet() const
{
    return m_numRanges_.hasValue();
}

void DisplayLineRangeValidity::resetNumRanges()
{
    m_numRanges_.reset();
}

::zserio::vector<::nds::display::reference::types::DisplayLineRangeChoice>& DisplayLineRangeValidity::getRanges()
{
    return m_ranges_.value().getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeChoice>& DisplayLineRangeValidity::getRanges() const
{
    return m_ranges_.value().getRawArray();
}

void DisplayLineRangeValidity::setRanges(const ::zserio::vector<::nds::display::reference::types::DisplayLineRangeChoice>& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(ranges_);
}

void DisplayLineRangeValidity::setRanges(::zserio::vector<::nds::display::reference::types::DisplayLineRangeChoice>&& ranges_)
{
    m_ranges_ = ZserioArrayType_ranges(std::move(ranges_));
}

bool DisplayLineRangeValidity::isRangesUsed() const
{
    return (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE);
}

bool DisplayLineRangeValidity::isRangesSet() const
{
    return m_ranges_.hasValue();
}

void DisplayLineRangeValidity::resetRanges()
{
    m_ranges_.reset();
}

void DisplayLineRangeValidity::initPackingContext(DisplayLineRangeValidity::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        context.getNumRanges().init<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
}

size_t DisplayLineRangeValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numRanges_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += m_ranges_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLineRangeValidity::bitSizeOf(DisplayLineRangeValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += context.getNumRanges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += m_ranges_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLineRangeValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numRanges_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition = m_ranges_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t DisplayLineRangeValidity::initializeOffsets(DisplayLineRangeValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += context.getNumRanges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRanges_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition = m_ranges_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool DisplayLineRangeValidity::operator==(const DisplayLineRangeValidity& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_type_ == other.m_type_) &&
                (!isNumRangesUsed() ? !other.isNumRangesUsed() : (m_numRanges_ == other.m_numRanges_)) &&
                (!isRangesUsed() ? !other.isRangesUsed() : (m_ranges_ == other.m_ranges_));
    }

    return true;
}

uint32_t DisplayLineRangeValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_type_);
    if (isNumRangesUsed())
        result = ::zserio::calcHashCode(result, m_numRanges_);
    if (isRangesUsed())
        result = ::zserio::calcHashCode(result, m_ranges_);

    return result;
}

void DisplayLineRangeValidity::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumRanges() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at DisplayLineRangeValidity.numRanges!");
        out.writeVarSize(m_numRanges_.value());
    }

    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        // check array length
        if (m_ranges_.value().getRawArray().size() != static_cast<size_t>(getNumRanges()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field DisplayLineRangeValidity.ranges: ") <<
                    m_ranges_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRanges()) << "!";
        }
        m_ranges_.value().write(*this, out);
    }
}

void DisplayLineRangeValidity::write(DisplayLineRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumRanges() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at DisplayLineRangeValidity.numRanges!");
        context.getNumRanges().write<::zserio::VarSizeArrayTraits>(out, m_numRanges_.value());
    }

    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        // check array length
        if (m_ranges_.value().getRawArray().size() != static_cast<size_t>(getNumRanges()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field DisplayLineRangeValidity.ranges: ") <<
                    m_ranges_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumRanges()) << "!";
        }
        m_ranges_.value().writePacked(*this, out);
    }
}

void DisplayLineRangeValidity::ZserioArrayExpressions_ranges::initializeElement(DisplayLineRangeValidity& owner,
        ::nds::display::reference::types::DisplayLineRangeChoice& element, size_t)
{
    element.initialize(static_cast<::nds::display::reference::types::DisplayLineValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void DisplayLineRangeValidity::ZserioElementFactory_ranges::create(DisplayLineRangeValidity&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeChoice>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::display::reference::types::DisplayLineValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void DisplayLineRangeValidity::ZserioElementFactory_ranges::create(DisplayLineRangeValidity&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLineRangeChoice>& array,
        ::nds::display::reference::types::DisplayLineRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::display::reference::types::DisplayLineValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

::nds::display::reference::types::DisplayLineValidityType DisplayLineRangeValidity::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::reference::types::DisplayLineValidityType>(in);
}

::nds::display::reference::types::DisplayLineValidityType DisplayLineRangeValidity::readType(DisplayLineRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::reference::types::DisplayLineValidityType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<uint32_t> DisplayLineRangeValidity::readNumRanges(::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at DisplayLineRangeValidity.numRanges!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> DisplayLineRangeValidity::readNumRanges(DisplayLineRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        uint32_t readField = context.getNumRanges().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at DisplayLineRangeValidity.numRanges!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<DisplayLineRangeValidity::ZserioArrayType_ranges> DisplayLineRangeValidity::readRanges(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        ZserioArrayType_ranges readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumRanges()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<DisplayLineRangeValidity::ZserioArrayType_ranges> DisplayLineRangeValidity::readRanges(DisplayLineRangeValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        ZserioArrayType_ranges readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumRanges()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_ranges>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/DisplayLineValidityRange.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

DisplayLineValidityRange::DisplayLineValidityRange(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_start_(allocator),
        m_end_(allocator)
{
}

DisplayLineValidityRange::DisplayLineValidityRange(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_start_(readStart(in, allocator)),
        m_end_(readEnd(in, allocator))
{
}

DisplayLineValidityRange::DisplayLineValidityRange(DisplayLineValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_start_(readStart(context, in, allocator)),
        m_end_(readEnd(context, in, allocator))
{
}

DisplayLineValidityRange::DisplayLineValidityRange(const DisplayLineValidityRange& other) :
        m_start_(other.m_start_),
        m_end_(other.m_end_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLineValidityRange& DisplayLineValidityRange::operator=(const DisplayLineValidityRange& other)
{
    m_start_ = other.m_start_;
    m_end_ = other.m_end_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLineValidityRange::DisplayLineValidityRange(DisplayLineValidityRange&& other) :
        m_start_(::std::move(other.m_start_)),
        m_end_(::std::move(other.m_end_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLineValidityRange& DisplayLineValidityRange::operator=(DisplayLineValidityRange&& other)
{
    m_start_ = ::std::move(other.m_start_);
    m_end_ = ::std::move(other.m_end_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLineValidityRange::DisplayLineValidityRange(::zserio::PropagateAllocatorT,
        const DisplayLineValidityRange& other, const allocator_type& allocator) :
        m_start_(::zserio::allocatorPropagatingCopy(other.m_start_, allocator)),
        m_end_(::zserio::allocatorPropagatingCopy(other.m_end_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void DisplayLineValidityRange::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool DisplayLineValidityRange::isInitialized() const
{
    return m_isInitialized;
}

void DisplayLineValidityRange::initializeChildren()
{
    m_start_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
    m_end_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
}

::nds::core::geometry::CoordShift DisplayLineValidityRange::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'DisplayLineValidityRange' is not initialized!");

    return m_shift_;
}

::nds::display::reference::types::DisplayLineValidityPosition& DisplayLineValidityRange::getStart()
{
    return m_start_;
}

const ::nds::display::reference::types::DisplayLineValidityPosition& DisplayLineValidityRange::getStart() const
{
    return m_start_;
}

void DisplayLineValidityRange::setStart(const ::nds::display::reference::types::DisplayLineValidityPosition& start_)
{
    m_start_ = start_;
}

void DisplayLineValidityRange::setStart(::nds::display::reference::types::DisplayLineValidityPosition&& start_)
{
    m_start_ = ::std::move(start_);
}

::nds::display::reference::types::DisplayLineValidityPosition& DisplayLineValidityRange::getEnd()
{
    return m_end_;
}

const ::nds::display::reference::types::DisplayLineValidityPosition& DisplayLineValidityRange::getEnd() const
{
    return m_end_;
}

void DisplayLineValidityRange::setEnd(const ::nds::display::reference::types::DisplayLineValidityPosition& end_)
{
    m_end_ = end_;
}

void DisplayLineValidityRange::setEnd(::nds::display::reference::types::DisplayLineValidityPosition&& end_)
{
    m_end_ = ::std::move(end_);
}

void DisplayLineValidityRange::initPackingContext(DisplayLineValidityRange::ZserioPackingContext& context) const
{
    m_start_.initPackingContext(context.getStart());
    m_end_.initPackingContext(context.getEnd());
}

size_t DisplayLineValidityRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_start_.bitSizeOf(endBitPosition);
    endBitPosition += m_end_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DisplayLineValidityRange::bitSizeOf(DisplayLineValidityRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_start_.bitSizeOf(context.getStart(), endBitPosition);
    endBitPosition += m_end_.bitSizeOf(context.getEnd(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DisplayLineValidityRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_start_.initializeOffsets(endBitPosition);
    endBitPosition = m_end_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t DisplayLineValidityRange::initializeOffsets(DisplayLineValidityRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_start_.initializeOffsets(context.getStart(), endBitPosition);
    endBitPosition = m_end_.initializeOffsets(context.getEnd(), endBitPosition);

    return endBitPosition;
}

bool DisplayLineValidityRange::operator==(const DisplayLineValidityRange& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_start_ == other.m_start_) &&
                (m_end_ == other.m_end_);
    }

    return true;
}

uint32_t DisplayLineValidityRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_start_);
    result = ::zserio::calcHashCode(result, m_end_);

    return result;
}

void DisplayLineValidityRange::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_start_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineValidityRange.start: ") <<
                m_start_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_start_.write(out);

    // check parameters
    if (m_end_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineValidityRange.end: ") <<
                m_end_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_end_.write(out);
}

void DisplayLineValidityRange::write(DisplayLineValidityRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_start_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineValidityRange.start: ") <<
                m_start_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_start_.write(context.getStart(), out);

    // check parameters
    if (m_end_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineValidityRange.end: ") <<
                m_end_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_end_.write(context.getEnd(), out);
}

::nds::display::reference::types::DisplayLineValidityPosition DisplayLineValidityRange::readStart(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::display::reference::types::DisplayLineValidityPosition(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::display::reference::types::DisplayLineValidityPosition DisplayLineValidityRange::readStart(DisplayLineValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::display::reference::types::DisplayLineValidityPosition(context.getStart(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}
::nds::display::reference::types::DisplayLineValidityPosition DisplayLineValidityRange::readEnd(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::display::reference::types::DisplayLineValidityPosition(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::display::reference::types::DisplayLineValidityPosition DisplayLineValidityRange::readEnd(DisplayLineValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::display::reference::types::DisplayLineValidityPosition(context.getEnd(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/display/reference/types/DisplayLinePositionValidity.h>
#include <nds/display/reference/types/DisplayLineValidityType.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

DisplayLinePositionValidity::DisplayLinePositionValidity(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_type_(::nds::display::reference::types::DisplayLineValidityType()),
        m_numPositions_(::zserio::NullOpt),
        m_positions_(::zserio::NullOpt)
{
}

DisplayLinePositionValidity::DisplayLinePositionValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(in)),
        m_numPositions_(readNumPositions(in)),
        m_positions_(readPositions(in, allocator))
{
}

DisplayLinePositionValidity::DisplayLinePositionValidity(DisplayLinePositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(context, in)),
        m_numPositions_(readNumPositions(context, in)),
        m_positions_(readPositions(context, in, allocator))
{
}

DisplayLinePositionValidity::DisplayLinePositionValidity(const DisplayLinePositionValidity& other) :
        m_type_(other.m_type_),
        m_numPositions_(other.m_numPositions_),
        m_positions_(other.m_positions_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLinePositionValidity& DisplayLinePositionValidity::operator=(const DisplayLinePositionValidity& other)
{
    m_type_ = other.m_type_;
    m_numPositions_ = other.m_numPositions_;
    m_positions_ = other.m_positions_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLinePositionValidity::DisplayLinePositionValidity(DisplayLinePositionValidity&& other) :
        m_type_(::std::move(other.m_type_)),
        m_numPositions_(::std::move(other.m_numPositions_)),
        m_positions_(::std::move(other.m_positions_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLinePositionValidity& DisplayLinePositionValidity::operator=(DisplayLinePositionValidity&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_numPositions_ = ::std::move(other.m_numPositions_);
    m_positions_ = ::std::move(other.m_positions_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLinePositionValidity::DisplayLinePositionValidity(::zserio::PropagateAllocatorT,
        const DisplayLinePositionValidity& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator)),
        m_positions_(::zserio::allocatorPropagatingCopy(other.m_positions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void DisplayLinePositionValidity::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool DisplayLinePositionValidity::isInitialized() const
{
    return m_isInitialized;
}

void DisplayLinePositionValidity::initializeChildren()
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
        m_positions_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift DisplayLinePositionValidity::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'DisplayLinePositionValidity' is not initialized!");

    return m_shift_;
}

::nds::display::reference::types::DisplayLineValidityType DisplayLinePositionValidity::getType() const
{
    return m_type_;
}

void DisplayLinePositionValidity::setType(::nds::display::reference::types::DisplayLineValidityType type_)
{
    m_type_ = type_;
}

uint32_t DisplayLinePositionValidity::getNumPositions() const
{
    return m_numPositions_.value();
}

void DisplayLinePositionValidity::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

bool DisplayLinePositionValidity::isNumPositionsUsed() const
{
    return (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE);
}

bool DisplayLinePositionValidity::isNumPositionsSet() const
{
    return m_numPositions_.hasValue();
}

void DisplayLinePositionValidity::resetNumPositions()
{
    m_numPositions_.reset();
}

::zserio::vector<::nds::display::reference::types::DisplayLinePositionChoice>& DisplayLinePositionValidity::getPositions()
{
    return m_positions_.value().getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayLinePositionChoice>& DisplayLinePositionValidity::getPositions() const
{
    return m_positions_.value().getRawArray();
}

void DisplayLinePositionValidity::setPositions(const ::zserio::vector<::nds::display::reference::types::DisplayLinePositionChoice>& positions_)
{
    m_positions_ = ZserioArrayType_positions(positions_);
}

void DisplayLinePositionValidity::setPositions(::zserio::vector<::nds::display::reference::types::DisplayLinePositionChoice>&& positions_)
{
    m_positions_ = ZserioArrayType_positions(std::move(positions_));
}

bool DisplayLinePositionValidity::isPositionsUsed() const
{
    return (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE);
}

bool DisplayLinePositionValidity::isPositionsSet() const
{
    return m_positions_.hasValue();
}

void DisplayLinePositionValidity::resetPositions()
{
    m_positions_.reset();
}

void DisplayLinePositionValidity::initPackingContext(DisplayLinePositionValidity::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_.value());
    }
}

size_t DisplayLinePositionValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += m_positions_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLinePositionValidity::bitSizeOf(DisplayLinePositionValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += m_positions_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLinePositionValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition = m_positions_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t DisplayLinePositionValidity::initializeOffsets(DisplayLinePositionValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        endBitPosition = m_positions_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool DisplayLinePositionValidity::operator==(const DisplayLinePositionValidity& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_type_ == other.m_type_) &&
                (!isNumPositionsUsed() ? !other.isNumPositionsUsed() : (m_numPositions_ == other.m_numPositions_)) &&
                (!isPositionsUsed() ? !other.isPositionsUsed() : (m_positions_ == other.m_positions_));
    }

    return true;
}

uint32_t DisplayLinePositionValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_type_);
    if (isNumPositionsUsed())
        result = ::zserio::calcHashCode(result, m_numPositions_);
    if (isPositionsUsed())
        result = ::zserio::calcHashCode(result, m_positions_);

    return result;
}

void DisplayLinePositionValidity::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Write: Constraint violated at DisplayLinePositionValidity.type!");
    ::zserio::write(out, m_type_);

    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumPositions() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at DisplayLinePositionValidity.numPositions!");
        out.writeVarSize(m_numPositions_.value());
    }

    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        // check array length
        if (m_positions_.value().getRawArray().size() != static_cast<size_t>(getNumPositions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field DisplayLinePositionValidity.positions: ") <<
                    m_positions_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumPositions()) << "!";
        }
        m_positions_.value().write(*this, out);
    }
}

void DisplayLinePositionValidity::write(DisplayLinePositionValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Write: Constraint violated at DisplayLinePositionValidity.type!");
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumPositions() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at DisplayLinePositionValidity.numPositions!");
        context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_.value());
    }

    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        // check array length
        if (m_positions_.value().getRawArray().size() != static_cast<size_t>(getNumPositions()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field DisplayLinePositionValidity.positions: ") <<
                    m_positions_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumPositions()) << "!";
        }
        m_positions_.value().writePacked(*this, out);
    }
}

void DisplayLinePositionValidity::ZserioArrayExpressions_positions::initializeElement(DisplayLinePositionValidity& owner,
        ::nds::display::reference::types::DisplayLinePositionChoice& element, size_t)
{
    element.initialize(static_cast<::nds::display::reference::types::DisplayLineValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void DisplayLinePositionValidity::ZserioElementFactory_positions::create(DisplayLinePositionValidity&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLinePositionChoice>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::display::reference::types::DisplayLineValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void DisplayLinePositionValidity::ZserioElementFactory_positions::create(DisplayLinePositionValidity&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayLinePositionChoice>& array,
        ::nds::display::reference::types::DisplayLinePositionChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::display::reference::types::DisplayLineValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

::nds::display::reference::types::DisplayLineValidityType DisplayLinePositionValidity::readType(::zserio::BitStreamReader& in)
{
    ::nds::display::reference::types::DisplayLineValidityType readField = ::zserio::read<::nds::display::reference::types::DisplayLineValidityType>(in);
    // check constraint
    if (!(readField != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Read: Constraint violated at DisplayLinePositionValidity.type!");

    return readField;
}

::nds::display::reference::types::DisplayLineValidityType DisplayLinePositionValidity::readType(DisplayLinePositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::display::reference::types::DisplayLineValidityType readField = ::zserio::read<::nds::display::reference::types::DisplayLineValidityType>(context.getType(), in);
    // check constraint
    if (!(readField != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE))
        throw ::zserio::ConstraintException("Read: Constraint violated at DisplayLinePositionValidity.type!");

    return readField;
}
::zserio::InplaceOptionalHolder<uint32_t> DisplayLinePositionValidity::readNumPositions(::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at DisplayLinePositionValidity.numPositions!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> DisplayLinePositionValidity::readNumPositions(DisplayLinePositionValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        uint32_t readField = context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at DisplayLinePositionValidity.numPositions!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<DisplayLinePositionValidity::ZserioArrayType_positions> DisplayLinePositionValidity::readPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        ZserioArrayType_positions readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumPositions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<DisplayLinePositionValidity::ZserioArrayType_positions> DisplayLinePositionValidity::readPositions(DisplayLinePositionValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() != ::nds::display::reference::types::DisplayLineValidityType::COMPLETE)
    {
        ZserioArrayType_positions readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_positions>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/DisplayLineValidityPosition.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

DisplayLineValidityPosition::DisplayLineValidityPosition(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_position_(allocator),
        m_positionIndication_(::zserio::NullOpt)
{
}

DisplayLineValidityPosition::DisplayLineValidityPosition(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_position_(readPosition(in, allocator)),
        m_positionIndication_(readPositionIndication(in))
{
}

DisplayLineValidityPosition::DisplayLineValidityPosition(DisplayLineValidityPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_position_(readPosition(context, in, allocator)),
        m_positionIndication_(readPositionIndication(in))
{
}

DisplayLineValidityPosition::DisplayLineValidityPosition(const DisplayLineValidityPosition& other) :
        m_position_(other.m_position_),
        m_positionIndication_(other.m_positionIndication_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLineValidityPosition& DisplayLineValidityPosition::operator=(const DisplayLineValidityPosition& other)
{
    m_position_ = other.m_position_;
    m_positionIndication_ = other.m_positionIndication_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLineValidityPosition::DisplayLineValidityPosition(DisplayLineValidityPosition&& other) :
        m_position_(::std::move(other.m_position_)),
        m_positionIndication_(::std::move(other.m_positionIndication_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLineValidityPosition& DisplayLineValidityPosition::operator=(DisplayLineValidityPosition&& other)
{
    m_position_ = ::std::move(other.m_position_);
    m_positionIndication_ = ::std::move(other.m_positionIndication_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLineValidityPosition::DisplayLineValidityPosition(::zserio::PropagateAllocatorT,
        const DisplayLineValidityPosition& other, const allocator_type& allocator) :
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator)),
        m_positionIndication_(::zserio::allocatorPropagatingCopy(other.m_positionIndication_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void DisplayLineValidityPosition::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool DisplayLineValidityPosition::isInitialized() const
{
    return m_isInitialized;
}

void DisplayLineValidityPosition::initializeChildren()
{
    m_position_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
}

::nds::core::geometry::CoordShift DisplayLineValidityPosition::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'DisplayLineValidityPosition' is not initialized!");

    return m_shift_;
}

::nds::core::geometry::Position2D& DisplayLineValidityPosition::getPosition()
{
    return m_position_;
}

const ::nds::core::geometry::Position2D& DisplayLineValidityPosition::getPosition() const
{
    return m_position_;
}

void DisplayLineValidityPosition::setPosition(const ::nds::core::geometry::Position2D& position_)
{
    m_position_ = position_;
}

void DisplayLineValidityPosition::setPosition(::nds::core::geometry::Position2D&& position_)
{
    m_position_ = ::std::move(position_);
}

::nds::display::reference::types::PercentageIndication DisplayLineValidityPosition::getPositionIndication() const
{
    return m_positionIndication_.value();
}

void DisplayLineValidityPosition::setPositionIndication(::nds::display::reference::types::PercentageIndication positionIndication_)
{
    m_positionIndication_ = positionIndication_;
}

bool DisplayLineValidityPosition::isPositionIndicationUsed() const
{
    return (isPositionIndicationSet());
}

bool DisplayLineValidityPosition::isPositionIndicationSet() const
{
    return m_positionIndication_.hasValue();
}

void DisplayLineValidityPosition::resetPositionIndication()
{
    m_positionIndication_.reset();
}

void DisplayLineValidityPosition::initPackingContext(DisplayLineValidityPosition::ZserioPackingContext& context) const
{
    m_position_.initPackingContext(context.getPosition());
}

size_t DisplayLineValidityPosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLineValidityPosition::bitSizeOf(DisplayLineValidityPosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_position_.bitSizeOf(context.getPosition(), endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLineValidityPosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition;
}

size_t DisplayLineValidityPosition::initializeOffsets(DisplayLineValidityPosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_position_.initializeOffsets(context.getPosition(), endBitPosition);
    endBitPosition += 1;
    if (isPositionIndicationSet())
    {
        endBitPosition += UINT8_C(16);
    }

    return endBitPosition;
}

bool DisplayLineValidityPosition::operator==(const DisplayLineValidityPosition& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_position_ == other.m_position_) &&
                (!isPositionIndicationUsed() ? !other.isPositionIndicationUsed() : (m_positionIndication_ == other.m_positionIndication_));
    }

    return true;
}

uint32_t DisplayLineValidityPosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_position_);
    if (isPositionIndicationUsed())
        result = ::zserio::calcHashCode(result, m_positionIndication_);

    return result;
}

void DisplayLineValidityPosition::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineValidityPosition.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_position_.write(out);

    if (isPositionIndicationSet())
    {
        out.writeBool(true);
        out.writeFloat16(m_positionIndication_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void DisplayLineValidityPosition::write(DisplayLineValidityPosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_position_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineValidityPosition.position: ") <<
                m_position_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_position_.write(context.getPosition(), out);

    if (isPositionIndicationSet())
    {
        out.writeBool(true);
        out.writeFloat16(m_positionIndication_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::geometry::Position2D DisplayLineValidityPosition::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::Position2D DisplayLineValidityPosition::readPosition(DisplayLineValidityPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::display::reference::types::PercentageIndication> DisplayLineValidityPosition::readPositionIndication(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::PercentageIndication>(static_cast<::nds::display::reference::types::PercentageIndication>(in.readFloat16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::PercentageIndication>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/display/reference/types/DisplayAreaValidity.h>
#include <nds/display/reference/types/DisplayAreaValidityType.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

DisplayAreaValidity::DisplayAreaValidity(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_type_(::nds::display::reference::types::DisplayAreaValidityType()),
        m_numLabelAreas_(::zserio::NullOpt),
        m_labelAreas_(::zserio::NullOpt)
{
}

DisplayAreaValidity::DisplayAreaValidity(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(in)),
        m_numLabelAreas_(readNumLabelAreas(in)),
        m_labelAreas_(readLabelAreas(in, allocator))
{
}

DisplayAreaValidity::DisplayAreaValidity(DisplayAreaValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_type_(readType(context, in)),
        m_numLabelAreas_(readNumLabelAreas(context, in)),
        m_labelAreas_(readLabelAreas(context, in, allocator))
{
}

DisplayAreaValidity::DisplayAreaValidity(const DisplayAreaValidity& other) :
        m_type_(other.m_type_),
        m_numLabelAreas_(other.m_numLabelAreas_),
        m_labelAreas_(other.m_labelAreas_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayAreaValidity& DisplayAreaValidity::operator=(const DisplayAreaValidity& other)
{
    m_type_ = other.m_type_;
    m_numLabelAreas_ = other.m_numLabelAreas_;
    m_labelAreas_ = other.m_labelAreas_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayAreaValidity::DisplayAreaValidity(DisplayAreaValidity&& other) :
        m_type_(::std::move(other.m_type_)),
        m_numLabelAreas_(::std::move(other.m_numLabelAreas_)),
        m_labelAreas_(::std::move(other.m_labelAreas_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayAreaValidity& DisplayAreaValidity::operator=(DisplayAreaValidity&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_numLabelAreas_ = ::std::move(other.m_numLabelAreas_);
    m_labelAreas_ = ::std::move(other.m_labelAreas_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayAreaValidity::DisplayAreaValidity(::zserio::PropagateAllocatorT,
        const DisplayAreaValidity& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_numLabelAreas_(::zserio::allocatorPropagatingCopy(other.m_numLabelAreas_, allocator)),
        m_labelAreas_(::zserio::allocatorPropagatingCopy(other.m_labelAreas_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void DisplayAreaValidity::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool DisplayAreaValidity::isInitialized() const
{
    return m_isInitialized;
}

void DisplayAreaValidity::initializeChildren()
{
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
        m_labelAreas_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift DisplayAreaValidity::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'DisplayAreaValidity' is not initialized!");

    return m_shift_;
}

::nds::display::reference::types::DisplayAreaValidityType DisplayAreaValidity::getType() const
{
    return m_type_;
}

void DisplayAreaValidity::setType(::nds::display::reference::types::DisplayAreaValidityType type_)
{
    m_type_ = type_;
}

uint32_t DisplayAreaValidity::getNumLabelAreas() const
{
    return m_numLabelAreas_.value();
}

void DisplayAreaValidity::setNumLabelAreas(uint32_t numLabelAreas_)
{
    m_numLabelAreas_ = numLabelAreas_;
}

bool DisplayAreaValidity::isNumLabelAreasUsed() const
{
    return (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE);
}

bool DisplayAreaValidity::isNumLabelAreasSet() const
{
    return m_numLabelAreas_.hasValue();
}

void DisplayAreaValidity::resetNumLabelAreas()
{
    m_numLabelAreas_.reset();
}

::zserio::vector<::nds::display::reference::types::DisplayAreaChoice>& DisplayAreaValidity::getLabelAreas()
{
    return m_labelAreas_.value().getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::DisplayAreaChoice>& DisplayAreaValidity::getLabelAreas() const
{
    return m_labelAreas_.value().getRawArray();
}

void DisplayAreaValidity::setLabelAreas(const ::zserio::vector<::nds::display::reference::types::DisplayAreaChoice>& labelAreas_)
{
    m_labelAreas_ = ZserioArrayType_labelAreas(labelAreas_);
}

void DisplayAreaValidity::setLabelAreas(::zserio::vector<::nds::display::reference::types::DisplayAreaChoice>&& labelAreas_)
{
    m_labelAreas_ = ZserioArrayType_labelAreas(std::move(labelAreas_));
}

bool DisplayAreaValidity::isLabelAreasUsed() const
{
    return (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE);
}

bool DisplayAreaValidity::isLabelAreasSet() const
{
    return m_labelAreas_.hasValue();
}

void DisplayAreaValidity::resetLabelAreas()
{
    m_labelAreas_.reset();
}

void DisplayAreaValidity::initPackingContext(DisplayAreaValidity::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        context.getNumLabelAreas().init<::zserio::VarSizeArrayTraits>(m_numLabelAreas_.value());
    }
}

size_t DisplayAreaValidity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numLabelAreas_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        endBitPosition += m_labelAreas_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayAreaValidity::bitSizeOf(DisplayAreaValidity::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        endBitPosition += context.getNumLabelAreas().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numLabelAreas_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        endBitPosition += m_labelAreas_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DisplayAreaValidity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numLabelAreas_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        endBitPosition = m_labelAreas_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t DisplayAreaValidity::initializeOffsets(DisplayAreaValidity::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        endBitPosition += context.getNumLabelAreas().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numLabelAreas_.value());
    }
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        endBitPosition = m_labelAreas_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool DisplayAreaValidity::operator==(const DisplayAreaValidity& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_type_ == other.m_type_) &&
                (!isNumLabelAreasUsed() ? !other.isNumLabelAreasUsed() : (m_numLabelAreas_ == other.m_numLabelAreas_)) &&
                (!isLabelAreasUsed() ? !other.isLabelAreasUsed() : (m_labelAreas_ == other.m_labelAreas_));
    }

    return true;
}

uint32_t DisplayAreaValidity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_type_);
    if (isNumLabelAreasUsed())
        result = ::zserio::calcHashCode(result, m_numLabelAreas_);
    if (isLabelAreasUsed())
        result = ::zserio::calcHashCode(result, m_labelAreas_);

    return result;
}

void DisplayAreaValidity::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumLabelAreas() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at DisplayAreaValidity.numLabelAreas!");
        out.writeVarSize(m_numLabelAreas_.value());
    }

    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        // check array length
        if (m_labelAreas_.value().getRawArray().size() != static_cast<size_t>(getNumLabelAreas()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field DisplayAreaValidity.labelAreas: ") <<
                    m_labelAreas_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLabelAreas()) << "!";
        }
        m_labelAreas_.value().write(*this, out);
    }
}

void DisplayAreaValidity::write(DisplayAreaValidity::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        // check constraint
        if (!(getNumLabelAreas() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at DisplayAreaValidity.numLabelAreas!");
        context.getNumLabelAreas().write<::zserio::VarSizeArrayTraits>(out, m_numLabelAreas_.value());
    }

    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        // check array length
        if (m_labelAreas_.value().getRawArray().size() != static_cast<size_t>(getNumLabelAreas()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field DisplayAreaValidity.labelAreas: ") <<
                    m_labelAreas_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumLabelAreas()) << "!";
        }
        m_labelAreas_.value().writePacked(*this, out);
    }
}

void DisplayAreaValidity::ZserioArrayExpressions_labelAreas::initializeElement(DisplayAreaValidity& owner,
        ::nds::display::reference::types::DisplayAreaChoice& element, size_t)
{
    element.initialize(static_cast<::nds::display::reference::types::DisplayAreaValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void DisplayAreaValidity::ZserioElementFactory_labelAreas::create(DisplayAreaValidity&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayAreaChoice>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::display::reference::types::DisplayAreaValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void DisplayAreaValidity::ZserioElementFactory_labelAreas::create(DisplayAreaValidity&         owner,
        ::zserio::vector<::nds::display::reference::types::DisplayAreaChoice>& array,
        ::nds::display::reference::types::DisplayAreaChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::display::reference::types::DisplayAreaValidityType>(owner.getType()), static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

::nds::display::reference::types::DisplayAreaValidityType DisplayAreaValidity::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::reference::types::DisplayAreaValidityType>(in);
}

::nds::display::reference::types::DisplayAreaValidityType DisplayAreaValidity::readType(DisplayAreaValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::reference::types::DisplayAreaValidityType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<uint32_t> DisplayAreaValidity::readNumLabelAreas(::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at DisplayAreaValidity.numLabelAreas!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> DisplayAreaValidity::readNumLabelAreas(DisplayAreaValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        uint32_t readField = context.getNumLabelAreas().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at DisplayAreaValidity.numLabelAreas!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<DisplayAreaValidity::ZserioArrayType_labelAreas> DisplayAreaValidity::readLabelAreas(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        ZserioArrayType_labelAreas readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumLabelAreas()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_labelAreas>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_labelAreas>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<DisplayAreaValidity::ZserioArrayType_labelAreas> DisplayAreaValidity::readLabelAreas(DisplayAreaValidity::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() != ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE)
    {
        ZserioArrayType_labelAreas readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumLabelAreas()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_labelAreas>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_labelAreas>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/LabelPositioningHint.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

LabelPositioningHint::LabelPositioningHint(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_importance_(uint8_t()),
        m_hasCurvedLabel_(bool()),
        m_hasStraightLabel_(bool()),
        m_curvedLabelHint_(::zserio::NullOpt),
        m_straightLabelHint_(::zserio::NullOpt)
{
}

LabelPositioningHint::LabelPositioningHint(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_importance_(readImportance(in)),
        m_hasCurvedLabel_(readHasCurvedLabel(in)),
        m_hasStraightLabel_(readHasStraightLabel(in)),
        m_curvedLabelHint_(readCurvedLabelHint(in, allocator)),
        m_straightLabelHint_(readStraightLabelHint(in, allocator))
{
}

LabelPositioningHint::LabelPositioningHint(LabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_importance_(readImportance(context, in)),
        m_hasCurvedLabel_(readHasCurvedLabel(in)),
        m_hasStraightLabel_(readHasStraightLabel(in)),
        m_curvedLabelHint_(readCurvedLabelHint(context, in, allocator)),
        m_straightLabelHint_(readStraightLabelHint(context, in, allocator))
{
}

LabelPositioningHint::LabelPositioningHint(const LabelPositioningHint& other) :
        m_importance_(other.m_importance_),
        m_hasCurvedLabel_(other.m_hasCurvedLabel_),
        m_hasStraightLabel_(other.m_hasStraightLabel_),
        m_curvedLabelHint_(other.m_curvedLabelHint_),
        m_straightLabelHint_(other.m_straightLabelHint_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

LabelPositioningHint& LabelPositioningHint::operator=(const LabelPositioningHint& other)
{
    m_importance_ = other.m_importance_;
    m_hasCurvedLabel_ = other.m_hasCurvedLabel_;
    m_hasStraightLabel_ = other.m_hasStraightLabel_;
    m_curvedLabelHint_ = other.m_curvedLabelHint_;
    m_straightLabelHint_ = other.m_straightLabelHint_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

LabelPositioningHint::LabelPositioningHint(LabelPositioningHint&& other) :
        m_importance_(::std::move(other.m_importance_)),
        m_hasCurvedLabel_(::std::move(other.m_hasCurvedLabel_)),
        m_hasStraightLabel_(::std::move(other.m_hasStraightLabel_)),
        m_curvedLabelHint_(::std::move(other.m_curvedLabelHint_)),
        m_straightLabelHint_(::std::move(other.m_straightLabelHint_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

LabelPositioningHint& LabelPositioningHint::operator=(LabelPositioningHint&& other)
{
    m_importance_ = ::std::move(other.m_importance_);
    m_hasCurvedLabel_ = ::std::move(other.m_hasCurvedLabel_);
    m_hasStraightLabel_ = ::std::move(other.m_hasStraightLabel_);
    m_curvedLabelHint_ = ::std::move(other.m_curvedLabelHint_);
    m_straightLabelHint_ = ::std::move(other.m_straightLabelHint_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

LabelPositioningHint::LabelPositioningHint(::zserio::PropagateAllocatorT,
        const LabelPositioningHint& other, const allocator_type& allocator) :
        m_importance_(::zserio::allocatorPropagatingCopy(other.m_importance_, allocator)),
        m_hasCurvedLabel_(::zserio::allocatorPropagatingCopy(other.m_hasCurvedLabel_, allocator)),
        m_hasStraightLabel_(::zserio::allocatorPropagatingCopy(other.m_hasStraightLabel_, allocator)),
        m_curvedLabelHint_(::zserio::allocatorPropagatingCopy(other.m_curvedLabelHint_, allocator)),
        m_straightLabelHint_(::zserio::allocatorPropagatingCopy(other.m_straightLabelHint_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void LabelPositioningHint::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LabelPositioningHint::isInitialized() const
{
    return m_isInitialized;
}

void LabelPositioningHint::initializeChildren()
{
    if (getHasCurvedLabel())
        m_curvedLabelHint_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
    if (getHasStraightLabel())
        m_straightLabelHint_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
}

::nds::core::geometry::CoordShift LabelPositioningHint::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'LabelPositioningHint' is not initialized!");

    return m_shift_;
}

uint8_t LabelPositioningHint::getImportance() const
{
    return m_importance_;
}

void LabelPositioningHint::setImportance(uint8_t importance_)
{
    m_importance_ = importance_;
}

bool LabelPositioningHint::getHasCurvedLabel() const
{
    return m_hasCurvedLabel_;
}

void LabelPositioningHint::setHasCurvedLabel(bool hasCurvedLabel_)
{
    m_hasCurvedLabel_ = hasCurvedLabel_;
}

bool LabelPositioningHint::getHasStraightLabel() const
{
    return m_hasStraightLabel_;
}

void LabelPositioningHint::setHasStraightLabel(bool hasStraightLabel_)
{
    m_hasStraightLabel_ = hasStraightLabel_;
}

::nds::display::reference::types::CurvedLabelPositioningHint& LabelPositioningHint::getCurvedLabelHint()
{
    return m_curvedLabelHint_.value();
}

const ::nds::display::reference::types::CurvedLabelPositioningHint& LabelPositioningHint::getCurvedLabelHint() const
{
    return m_curvedLabelHint_.value();
}

void LabelPositioningHint::setCurvedLabelHint(const ::nds::display::reference::types::CurvedLabelPositioningHint& curvedLabelHint_)
{
    m_curvedLabelHint_ = curvedLabelHint_;
}

void LabelPositioningHint::setCurvedLabelHint(::nds::display::reference::types::CurvedLabelPositioningHint&& curvedLabelHint_)
{
    m_curvedLabelHint_ = ::std::move(curvedLabelHint_);
}

bool LabelPositioningHint::isCurvedLabelHintUsed() const
{
    return (getHasCurvedLabel());
}

bool LabelPositioningHint::isCurvedLabelHintSet() const
{
    return m_curvedLabelHint_.hasValue();
}

void LabelPositioningHint::resetCurvedLabelHint()
{
    m_curvedLabelHint_.reset();
}

::nds::display::reference::types::StraightLabelPositioningHint& LabelPositioningHint::getStraightLabelHint()
{
    return m_straightLabelHint_.value();
}

const ::nds::display::reference::types::StraightLabelPositioningHint& LabelPositioningHint::getStraightLabelHint() const
{
    return m_straightLabelHint_.value();
}

void LabelPositioningHint::setStraightLabelHint(const ::nds::display::reference::types::StraightLabelPositioningHint& straightLabelHint_)
{
    m_straightLabelHint_ = straightLabelHint_;
}

void LabelPositioningHint::setStraightLabelHint(::nds::display::reference::types::StraightLabelPositioningHint&& straightLabelHint_)
{
    m_straightLabelHint_ = ::std::move(straightLabelHint_);
}

bool LabelPositioningHint::isStraightLabelHintUsed() const
{
    return (getHasStraightLabel());
}

bool LabelPositioningHint::isStraightLabelHintSet() const
{
    return m_straightLabelHint_.hasValue();
}

void LabelPositioningHint::resetStraightLabelHint()
{
    m_straightLabelHint_.reset();
}

void LabelPositioningHint::initPackingContext(LabelPositioningHint::ZserioPackingContext& context) const
{
    context.getImportance().init<::zserio::StdIntArrayTraits<uint8_t>>(m_importance_);
    if (getHasCurvedLabel())
    {
        m_curvedLabelHint_.value().initPackingContext(context.getCurvedLabelHint());
    }
    if (getHasStraightLabel())
    {
        m_straightLabelHint_.value().initPackingContext(context.getStraightLabelHint());
    }
}

size_t LabelPositioningHint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getHasCurvedLabel())
    {
        endBitPosition += m_curvedLabelHint_.value().bitSizeOf(endBitPosition);
    }
    if (getHasStraightLabel())
    {
        endBitPosition += m_straightLabelHint_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LabelPositioningHint::bitSizeOf(LabelPositioningHint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getImportance().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_importance_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getHasCurvedLabel())
    {
        endBitPosition += m_curvedLabelHint_.value().bitSizeOf(context.getCurvedLabelHint(), endBitPosition);
    }
    if (getHasStraightLabel())
    {
        endBitPosition += m_straightLabelHint_.value().bitSizeOf(context.getStraightLabelHint(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LabelPositioningHint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getHasCurvedLabel())
    {
        endBitPosition = m_curvedLabelHint_.value().initializeOffsets(endBitPosition);
    }
    if (getHasStraightLabel())
    {
        endBitPosition = m_straightLabelHint_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LabelPositioningHint::initializeOffsets(LabelPositioningHint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getImportance().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_importance_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getHasCurvedLabel())
    {
        endBitPosition = m_curvedLabelHint_.value().initializeOffsets(context.getCurvedLabelHint(), endBitPosition);
    }
    if (getHasStraightLabel())
    {
        endBitPosition = m_straightLabelHint_.value().initializeOffsets(context.getStraightLabelHint(), endBitPosition);
    }

    return endBitPosition;
}

bool LabelPositioningHint::operator==(const LabelPositioningHint& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_importance_ == other.m_importance_) &&
                (m_hasCurvedLabel_ == other.m_hasCurvedLabel_) &&
                (m_hasStraightLabel_ == other.m_hasStraightLabel_) &&
                (!isCurvedLabelHintUsed() ? !other.isCurvedLabelHintUsed() : (m_curvedLabelHint_ == other.m_curvedLabelHint_)) &&
                (!isStraightLabelHintUsed() ? !other.isStraightLabelHintUsed() : (m_straightLabelHint_ == other.m_straightLabelHint_));
    }

    return true;
}

uint32_t LabelPositioningHint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_importance_);
    result = ::zserio::calcHashCode(result, m_hasCurvedLabel_);
    result = ::zserio::calcHashCode(result, m_hasStraightLabel_);
    if (isCurvedLabelHintUsed())
        result = ::zserio::calcHashCode(result, m_curvedLabelHint_);
    if (isStraightLabelHintUsed())
        result = ::zserio::calcHashCode(result, m_straightLabelHint_);

    return result;
}

void LabelPositioningHint::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_importance_, UINT8_C(8));

    out.writeBool(m_hasCurvedLabel_);

    out.writeBool(m_hasStraightLabel_);

    if (getHasCurvedLabel())
    {
        // check parameters
        if (m_curvedLabelHint_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LabelPositioningHint.curvedLabelHint: ") <<
                    m_curvedLabelHint_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_curvedLabelHint_.value().write(out);
    }

    if (getHasStraightLabel())
    {
        // check parameters
        if (m_straightLabelHint_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LabelPositioningHint.straightLabelHint: ") <<
                    m_straightLabelHint_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_straightLabelHint_.value().write(out);
    }
}

void LabelPositioningHint::write(LabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getImportance().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_importance_);

    out.writeBool(m_hasCurvedLabel_);

    out.writeBool(m_hasStraightLabel_);

    if (getHasCurvedLabel())
    {
        // check parameters
        if (m_curvedLabelHint_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LabelPositioningHint.curvedLabelHint: ") <<
                    m_curvedLabelHint_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_curvedLabelHint_.value().write(context.getCurvedLabelHint(), out);
    }

    if (getHasStraightLabel())
    {
        // check parameters
        if (m_straightLabelHint_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LabelPositioningHint.straightLabelHint: ") <<
                    m_straightLabelHint_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_straightLabelHint_.value().write(context.getStraightLabelHint(), out);
    }
}

uint8_t LabelPositioningHint::readImportance(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t LabelPositioningHint::readImportance(LabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getImportance().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
bool LabelPositioningHint::readHasCurvedLabel(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool LabelPositioningHint::readHasStraightLabel(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::display::reference::types::CurvedLabelPositioningHint> LabelPositioningHint::readCurvedLabelHint(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasCurvedLabel())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::CurvedLabelPositioningHint>(::nds::display::reference::types::CurvedLabelPositioningHint(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::CurvedLabelPositioningHint>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::reference::types::CurvedLabelPositioningHint> LabelPositioningHint::readCurvedLabelHint(LabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasCurvedLabel())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::CurvedLabelPositioningHint>(::nds::display::reference::types::CurvedLabelPositioningHint(context.getCurvedLabelHint(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::CurvedLabelPositioningHint>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::display::reference::types::StraightLabelPositioningHint> LabelPositioningHint::readStraightLabelHint(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasStraightLabel())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::StraightLabelPositioningHint>(::nds::display::reference::types::StraightLabelPositioningHint(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::StraightLabelPositioningHint>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::reference::types::StraightLabelPositioningHint> LabelPositioningHint::readStraightLabelHint(LabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasStraightLabel())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::StraightLabelPositioningHint>(::nds::display::reference::types::StraightLabelPositioningHint(context.getStraightLabelHint(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::StraightLabelPositioningHint>(::zserio::NullOpt);
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/StraightLabelPositioningHint.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

StraightLabelPositioningHint::StraightLabelPositioningHint(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numPositions_(uint32_t()),
        m_coordWidth_(::nds::core::geometry::CoordWidth()),
        m_positions_(allocator)
{
}

StraightLabelPositioningHint::StraightLabelPositioningHint(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(in)),
        m_coordWidth_(readCoordWidth(in)),
        m_positions_(readPositions(in, allocator))
{
}

StraightLabelPositioningHint::StraightLabelPositioningHint(StraightLabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(context, in)),
        m_coordWidth_(readCoordWidth(context, in)),
        m_positions_(readPositions(context, in, allocator))
{
}

StraightLabelPositioningHint::StraightLabelPositioningHint(const StraightLabelPositioningHint& other) :
        m_numPositions_(other.m_numPositions_),
        m_coordWidth_(other.m_coordWidth_),
        m_positions_(other.m_positions_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

StraightLabelPositioningHint& StraightLabelPositioningHint::operator=(const StraightLabelPositioningHint& other)
{
    m_numPositions_ = other.m_numPositions_;
    m_coordWidth_ = other.m_coordWidth_;
    m_positions_ = other.m_positions_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

StraightLabelPositioningHint::StraightLabelPositioningHint(StraightLabelPositioningHint&& other) :
        m_numPositions_(::std::move(other.m_numPositions_)),
        m_coordWidth_(::std::move(other.m_coordWidth_)),
        m_positions_(::std::move(other.m_positions_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

StraightLabelPositioningHint& StraightLabelPositioningHint::operator=(StraightLabelPositioningHint&& other)
{
    m_numPositions_ = ::std::move(other.m_numPositions_);
    m_coordWidth_ = ::std::move(other.m_coordWidth_);
    m_positions_ = ::std::move(other.m_positions_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

StraightLabelPositioningHint::StraightLabelPositioningHint(::zserio::PropagateAllocatorT,
        const StraightLabelPositioningHint& other, const allocator_type& allocator) :
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator)),
        m_coordWidth_(::zserio::allocatorPropagatingCopy(other.m_coordWidth_, allocator)),
        m_positions_(::zserio::allocatorPropagatingCopy(other.m_positions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void StraightLabelPositioningHint::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool StraightLabelPositioningHint::isInitialized() const
{
    return m_isInitialized;
}

void StraightLabelPositioningHint::initializeChildren()
{
    m_positions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift StraightLabelPositioningHint::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'StraightLabelPositioningHint' is not initialized!");

    return m_shift_;
}

uint32_t StraightLabelPositioningHint::getNumPositions() const
{
    return m_numPositions_;
}

void StraightLabelPositioningHint::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

::nds::core::geometry::CoordWidth StraightLabelPositioningHint::getCoordWidth() const
{
    return m_coordWidth_;
}

void StraightLabelPositioningHint::setCoordWidth(::nds::core::geometry::CoordWidth coordWidth_)
{
    m_coordWidth_ = coordWidth_;
}

::zserio::vector<::nds::display::reference::types::StraightLabelingPosition>& StraightLabelPositioningHint::getPositions()
{
    return m_positions_.getRawArray();
}

const ::zserio::vector<::nds::display::reference::types::StraightLabelingPosition>& StraightLabelPositioningHint::getPositions() const
{
    return m_positions_.getRawArray();
}

void StraightLabelPositioningHint::setPositions(const ::zserio::vector<::nds::display::reference::types::StraightLabelingPosition>& positions_)
{
    m_positions_ = ZserioArrayType_positions(positions_);
}

void StraightLabelPositioningHint::setPositions(::zserio::vector<::nds::display::reference::types::StraightLabelingPosition>&& positions_)
{
    m_positions_ = ZserioArrayType_positions(std::move(positions_));
}

void StraightLabelPositioningHint::initPackingContext(StraightLabelPositioningHint::ZserioPackingContext& context) const
{
    context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_);
    context.getCoordWidth().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_coordWidth_);
}

size_t StraightLabelPositioningHint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition += UINT8_C(5);
    endBitPosition += m_positions_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t StraightLabelPositioningHint::bitSizeOf(StraightLabelPositioningHint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition += context.getCoordWidth().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_coordWidth_);
    endBitPosition += m_positions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t StraightLabelPositioningHint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition += UINT8_C(5);
    endBitPosition = m_positions_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t StraightLabelPositioningHint::initializeOffsets(StraightLabelPositioningHint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition += context.getCoordWidth().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_coordWidth_);
    endBitPosition = m_positions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool StraightLabelPositioningHint::operator==(const StraightLabelPositioningHint& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_numPositions_ == other.m_numPositions_) &&
                (m_coordWidth_ == other.m_coordWidth_) &&
                (m_positions_ == other.m_positions_);
    }

    return true;
}

uint32_t StraightLabelPositioningHint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_numPositions_);
    result = ::zserio::calcHashCode(result, m_coordWidth_);
    result = ::zserio::calcHashCode(result, m_positions_);

    return result;
}

void StraightLabelPositioningHint::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numPositions_);

    out.writeBits(m_coordWidth_, UINT8_C(5));

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field StraightLabelPositioningHint.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.write(*this, out);
}

void StraightLabelPositioningHint::write(StraightLabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_);

    context.getCoordWidth().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(out, m_coordWidth_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field StraightLabelPositioningHint.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(*this, out);
}

void StraightLabelPositioningHint::ZserioArrayExpressions_positions::initializeElement(StraightLabelPositioningHint& owner,
        ::nds::display::reference::types::StraightLabelingPosition& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), static_cast<::nds::core::geometry::CoordWidth>(owner.getCoordWidth()));
}

void StraightLabelPositioningHint::ZserioElementFactory_positions::create(StraightLabelPositioningHint&         owner,
        ::zserio::vector<::nds::display::reference::types::StraightLabelingPosition>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), static_cast<::nds::core::geometry::CoordWidth>(owner.getCoordWidth()), array.get_allocator());
}

void StraightLabelPositioningHint::ZserioElementFactory_positions::create(StraightLabelPositioningHint&         owner,
        ::zserio::vector<::nds::display::reference::types::StraightLabelingPosition>& array,
        ::nds::display::reference::types::StraightLabelingPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), static_cast<::nds::core::geometry::CoordWidth>(owner.getCoordWidth()), array.get_allocator());
}

uint32_t StraightLabelPositioningHint::readNumPositions(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t StraightLabelPositioningHint::readNumPositions(StraightLabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::geometry::CoordWidth StraightLabelPositioningHint::readCoordWidth(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordWidth>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordWidth StraightLabelPositioningHint::readCoordWidth(StraightLabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordWidth().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(in);
}
StraightLabelPositioningHint::ZserioArrayType_positions StraightLabelPositioningHint::readPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}

StraightLabelPositioningHint::ZserioArrayType_positions StraightLabelPositioningHint::readPositions(StraightLabelPositioningHint::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/StraightLabelingPosition.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

StraightLabelingPosition::StraightLabelingPosition(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_centerPosition_(allocator),
        m_radiusPosition_(allocator)
{
}

StraightLabelingPosition::StraightLabelingPosition(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_,
        ::nds::core::geometry::CoordWidth width_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_width_(width_),
        m_isInitialized(true),
        m_centerPosition_(readCenterPosition(in, allocator)),
        m_radiusPosition_(readRadiusPosition(in, allocator))
{
}

StraightLabelingPosition::StraightLabelingPosition(StraightLabelingPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_,
        ::nds::core::geometry::CoordWidth width_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_width_(width_),
        m_isInitialized(true),
        m_centerPosition_(readCenterPosition(context, in, allocator)),
        m_radiusPosition_(readRadiusPosition(context, in, allocator))
{
}

StraightLabelingPosition::StraightLabelingPosition(const StraightLabelingPosition& other) :
        m_centerPosition_(other.m_centerPosition_),
        m_radiusPosition_(other.m_radiusPosition_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_width_);
    else
        m_isInitialized = false;
}

StraightLabelingPosition& StraightLabelingPosition::operator=(const StraightLabelingPosition& other)
{
    m_centerPosition_ = other.m_centerPosition_;
    m_radiusPosition_ = other.m_radiusPosition_;
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_width_);
    else
        m_isInitialized = false;

    return *this;
}

StraightLabelingPosition::StraightLabelingPosition(StraightLabelingPosition&& other) :
        m_centerPosition_(::std::move(other.m_centerPosition_)),
        m_radiusPosition_(::std::move(other.m_radiusPosition_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_width_);
    else
        m_isInitialized = false;
}

StraightLabelingPosition& StraightLabelingPosition::operator=(StraightLabelingPosition&& other)
{
    m_centerPosition_ = ::std::move(other.m_centerPosition_);
    m_radiusPosition_ = ::std::move(other.m_radiusPosition_);
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_width_);
    else
        m_isInitialized = false;

    return *this;
}

StraightLabelingPosition::StraightLabelingPosition(::zserio::PropagateAllocatorT,
        const StraightLabelingPosition& other, const allocator_type& allocator) :
        m_centerPosition_(::zserio::allocatorPropagatingCopy(other.m_centerPosition_, allocator)),
        m_radiusPosition_(::zserio::allocatorPropagatingCopy(other.m_radiusPosition_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_width_);
    else
        m_isInitialized = false;
}

void StraightLabelingPosition::initialize(
        ::nds::core::geometry::CoordShift shift_,
        ::nds::core::geometry::CoordWidth width_)
{
    m_shift_ = shift_;
    m_width_ = width_;
    m_isInitialized = true;

    initializeChildren();
}

bool StraightLabelingPosition::isInitialized() const
{
    return m_isInitialized;
}

void StraightLabelingPosition::initializeChildren()
{
    m_centerPosition_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
    m_radiusPosition_.initialize(static_cast<::nds::core::geometry::CoordWidth>(getWidth()), static_cast<::nds::core::geometry::CoordShift>(getShift()));
}

::nds::core::geometry::CoordShift StraightLabelingPosition::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'StraightLabelingPosition' is not initialized!");

    return m_shift_;
}

::nds::core::geometry::CoordWidth StraightLabelingPosition::getWidth() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'width' of compound 'StraightLabelingPosition' is not initialized!");

    return m_width_;
}

::nds::core::geometry::Position2D& StraightLabelingPosition::getCenterPosition()
{
    return m_centerPosition_;
}

const ::nds::core::geometry::Position2D& StraightLabelingPosition::getCenterPosition() const
{
    return m_centerPosition_;
}

void StraightLabelingPosition::setCenterPosition(const ::nds::core::geometry::Position2D& centerPosition_)
{
    m_centerPosition_ = centerPosition_;
}

void StraightLabelingPosition::setCenterPosition(::nds::core::geometry::Position2D&& centerPosition_)
{
    m_centerPosition_ = ::std::move(centerPosition_);
}

::nds::core::geometry::PositionOffset2D& StraightLabelingPosition::getRadiusPosition()
{
    return m_radiusPosition_;
}

const ::nds::core::geometry::PositionOffset2D& StraightLabelingPosition::getRadiusPosition() const
{
    return m_radiusPosition_;
}

void StraightLabelingPosition::setRadiusPosition(const ::nds::core::geometry::PositionOffset2D& radiusPosition_)
{
    m_radiusPosition_ = radiusPosition_;
}

void StraightLabelingPosition::setRadiusPosition(::nds::core::geometry::PositionOffset2D&& radiusPosition_)
{
    m_radiusPosition_ = ::std::move(radiusPosition_);
}

void StraightLabelingPosition::initPackingContext(StraightLabelingPosition::ZserioPackingContext& context) const
{
    m_centerPosition_.initPackingContext(context.getCenterPosition());
    m_radiusPosition_.initPackingContext(context.getRadiusPosition());
}

size_t StraightLabelingPosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_centerPosition_.bitSizeOf(endBitPosition);
    endBitPosition += m_radiusPosition_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t StraightLabelingPosition::bitSizeOf(StraightLabelingPosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_centerPosition_.bitSizeOf(context.getCenterPosition(), endBitPosition);
    endBitPosition += m_radiusPosition_.bitSizeOf(context.getRadiusPosition(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t StraightLabelingPosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_centerPosition_.initializeOffsets(endBitPosition);
    endBitPosition = m_radiusPosition_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t StraightLabelingPosition::initializeOffsets(StraightLabelingPosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_centerPosition_.initializeOffsets(context.getCenterPosition(), endBitPosition);
    endBitPosition = m_radiusPosition_.initializeOffsets(context.getRadiusPosition(), endBitPosition);

    return endBitPosition;
}

bool StraightLabelingPosition::operator==(const StraightLabelingPosition& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (getWidth() == other.getWidth()) &&
                (m_centerPosition_ == other.m_centerPosition_) &&
                (m_radiusPosition_ == other.m_radiusPosition_);
    }

    return true;
}

uint32_t StraightLabelingPosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, getWidth());
    result = ::zserio::calcHashCode(result, m_centerPosition_);
    result = ::zserio::calcHashCode(result, m_radiusPosition_);

    return result;
}

void StraightLabelingPosition::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_centerPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field StraightLabelingPosition.centerPosition: ") <<
                m_centerPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_centerPosition_.write(out);

    // check parameters
    if (m_radiusPosition_.getNumBits() != static_cast<::nds::core::geometry::CoordWidth>(getWidth()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numBits for field StraightLabelingPosition.radiusPosition: ") <<
                m_radiusPosition_.getNumBits() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getWidth()) << "!";
    }
    if (m_radiusPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field StraightLabelingPosition.radiusPosition: ") <<
                m_radiusPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_radiusPosition_.write(out);
}

void StraightLabelingPosition::write(StraightLabelingPosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_centerPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field StraightLabelingPosition.centerPosition: ") <<
                m_centerPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_centerPosition_.write(context.getCenterPosition(), out);

    // check parameters
    if (m_radiusPosition_.getNumBits() != static_cast<::nds::core::geometry::CoordWidth>(getWidth()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numBits for field StraightLabelingPosition.radiusPosition: ") <<
                m_radiusPosition_.getNumBits() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getWidth()) << "!";
    }
    if (m_radiusPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field StraightLabelingPosition.radiusPosition: ") <<
                m_radiusPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_radiusPosition_.write(context.getRadiusPosition(), out);
}

::nds::core::geometry::Position2D StraightLabelingPosition::readCenterPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::Position2D StraightLabelingPosition::readCenterPosition(StraightLabelingPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getCenterPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}
::nds::core::geometry::PositionOffset2D StraightLabelingPosition::readRadiusPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::PositionOffset2D(in, static_cast<::nds::core::geometry::CoordWidth>(getWidth()), static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::PositionOffset2D StraightLabelingPosition::readRadiusPosition(StraightLabelingPosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::PositionOffset2D(context.getRadiusPosition(), in, static_cast<::nds::core::geometry::CoordWidth>(getWidth()), static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/CurvedLabelPositioningHint.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

CurvedLabelPositioningHint::CurvedLabelPositioningHint(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numLines_(uint32_t()),
        m_hintLines_(allocator)
{
}

CurvedLabelPositioningHint::CurvedLabelPositioningHint(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numLines_(readNumLines(in)),
        m_hintLines_(readHintLines(in, allocator))
{
}

CurvedLabelPositioningHint::CurvedLabelPositioningHint(CurvedLabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numLines_(readNumLines(context, in)),
        m_hintLines_(readHintLines(context, in, allocator))
{
}

CurvedLabelPositioningHint::CurvedLabelPositioningHint(const CurvedLabelPositioningHint& other) :
        m_numLines_(other.m_numLines_),
        m_hintLines_(other.m_hintLines_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

CurvedLabelPositioningHint& CurvedLabelPositioningHint::operator=(const CurvedLabelPositioningHint& other)
{
    m_numLines_ = other.m_numLines_;
    m_hintLines_ = other.m_hintLines_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

CurvedLabelPositioningHint::CurvedLabelPositioningHint(CurvedLabelPositioningHint&& other) :
        m_numLines_(::std::move(other.m_numLines_)),
        m_hintLines_(::std::move(other.m_hintLines_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

CurvedLabelPositioningHint& CurvedLabelPositioningHint::operator=(CurvedLabelPositioningHint&& other)
{
    m_numLines_ = ::std::move(other.m_numLines_);
    m_hintLines_ = ::std::move(other.m_hintLines_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

CurvedLabelPositioningHint::CurvedLabelPositioningHint(::zserio::PropagateAllocatorT,
        const CurvedLabelPositioningHint& other, const allocator_type& allocator) :
        m_numLines_(::zserio::allocatorPropagatingCopy(other.m_numLines_, allocator)),
        m_hintLines_(::zserio::allocatorPropagatingCopy(other.m_hintLines_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void CurvedLabelPositioningHint::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool CurvedLabelPositioningHint::isInitialized() const
{
    return m_isInitialized;
}

void CurvedLabelPositioningHint::initializeChildren()
{
    m_hintLines_.initializeElements(*this);
}

::nds::core::geometry::CoordShift CurvedLabelPositioningHint::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'CurvedLabelPositioningHint' is not initialized!");

    return m_shift_;
}

uint32_t CurvedLabelPositioningHint::getNumLines() const
{
    return m_numLines_;
}

void CurvedLabelPositioningHint::setNumLines(uint32_t numLines_)
{
    m_numLines_ = numLines_;
}

::zserio::vector<::nds::core::geometry::Line2D>& CurvedLabelPositioningHint::getHintLines()
{
    return m_hintLines_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Line2D>& CurvedLabelPositioningHint::getHintLines() const
{
    return m_hintLines_.getRawArray();
}

void CurvedLabelPositioningHint::setHintLines(const ::zserio::vector<::nds::core::geometry::Line2D>& hintLines_)
{
    m_hintLines_ = ZserioArrayType_hintLines(hintLines_);
}

void CurvedLabelPositioningHint::setHintLines(::zserio::vector<::nds::core::geometry::Line2D>&& hintLines_)
{
    m_hintLines_ = ZserioArrayType_hintLines(std::move(hintLines_));
}

void CurvedLabelPositioningHint::initPackingContext(CurvedLabelPositioningHint::ZserioPackingContext& context) const
{
    context.getNumLines().init<::zserio::VarSizeArrayTraits>(m_numLines_);
}

size_t CurvedLabelPositioningHint::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numLines_);
    endBitPosition += m_hintLines_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CurvedLabelPositioningHint::bitSizeOf(CurvedLabelPositioningHint::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLines().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numLines_);
    endBitPosition += m_hintLines_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CurvedLabelPositioningHint::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numLines_);
    endBitPosition = m_hintLines_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t CurvedLabelPositioningHint::initializeOffsets(CurvedLabelPositioningHint::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumLines().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numLines_);
    endBitPosition = m_hintLines_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool CurvedLabelPositioningHint::operator==(const CurvedLabelPositioningHint& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_numLines_ == other.m_numLines_) &&
                (m_hintLines_ == other.m_hintLines_);
    }

    return true;
}

uint32_t CurvedLabelPositioningHint::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_numLines_);
    result = ::zserio::calcHashCode(result, m_hintLines_);

    return result;
}

void CurvedLabelPositioningHint::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numLines_);

    // check array length
    if (m_hintLines_.getRawArray().size() != static_cast<size_t>(getNumLines()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CurvedLabelPositioningHint.hintLines: ") <<
                m_hintLines_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLines()) << "!";
    }
    m_hintLines_.write(*this, out);
}

void CurvedLabelPositioningHint::write(CurvedLabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumLines().write<::zserio::VarSizeArrayTraits>(out, m_numLines_);

    // check array length
    if (m_hintLines_.getRawArray().size() != static_cast<size_t>(getNumLines()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CurvedLabelPositioningHint.hintLines: ") <<
                m_hintLines_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumLines()) << "!";
    }
    m_hintLines_.writePacked(*this, out);
}

void CurvedLabelPositioningHint::ZserioArrayExpressions_hintLines::initializeElement(CurvedLabelPositioningHint& owner,
        ::nds::core::geometry::Line2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void CurvedLabelPositioningHint::ZserioElementFactory_hintLines::create(CurvedLabelPositioningHint&         owner,
        ::zserio::vector<::nds::core::geometry::Line2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void CurvedLabelPositioningHint::ZserioElementFactory_hintLines::create(CurvedLabelPositioningHint&         owner,
        ::zserio::vector<::nds::core::geometry::Line2D>& array,
        ::nds::core::geometry::Line2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

uint32_t CurvedLabelPositioningHint::readNumLines(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t CurvedLabelPositioningHint::readNumLines(CurvedLabelPositioningHint::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumLines().read<::zserio::VarSizeArrayTraits>(in);
}
CurvedLabelPositioningHint::ZserioArrayType_hintLines CurvedLabelPositioningHint::readHintLines(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_hintLines readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumLines()));

    return readField;
}

CurvedLabelPositioningHint::ZserioArrayType_hintLines CurvedLabelPositioningHint::readHintLines(CurvedLabelPositioningHint::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_hintLines readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumLines()));

    return readField;
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/DisplayLineRangeChoice.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

DisplayLineRangeChoice::DisplayLineRangeChoice(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

DisplayLineRangeChoice::DisplayLineRangeChoice(::zserio::BitStreamReader& in,
        ::nds::display::reference::types::DisplayLineValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

DisplayLineRangeChoice::DisplayLineRangeChoice(DisplayLineRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::display::reference::types::DisplayLineValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

DisplayLineRangeChoice::DisplayLineRangeChoice(const DisplayLineRangeChoice& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLineRangeChoice& DisplayLineRangeChoice::operator=(const DisplayLineRangeChoice& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLineRangeChoice::DisplayLineRangeChoice(DisplayLineRangeChoice&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLineRangeChoice& DisplayLineRangeChoice::operator=(DisplayLineRangeChoice&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLineRangeChoice::DisplayLineRangeChoice(::zserio::PropagateAllocatorT,
        const DisplayLineRangeChoice& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

void DisplayLineRangeChoice::initialize(
        ::nds::display::reference::types::DisplayLineValidityType type_,
        ::nds::core::geometry::CoordShift shift_)
{
    m_type_ = type_;
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool DisplayLineRangeChoice::isInitialized() const
{
    return m_isInitialized;
}

void DisplayLineRangeChoice::initializeChildren()
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }
}

::nds::display::reference::types::DisplayLineValidityType DisplayLineRangeChoice::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'DisplayLineRangeChoice' is not initialized!");

    return m_type_;
}

::nds::core::geometry::CoordShift DisplayLineRangeChoice::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'DisplayLineRangeChoice' is not initialized!");

    return m_shift_;
}

::nds::display::reference::types::DisplayLineValidityRange& DisplayLineRangeChoice::getValidityRange()
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>();
}

const ::nds::display::reference::types::DisplayLineValidityRange& DisplayLineRangeChoice::getValidityRange() const
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>();
}

void DisplayLineRangeChoice::setValidityRange(const ::nds::display::reference::types::DisplayLineValidityRange& validityRange_)
{
    m_objectChoice = validityRange_;
}

void DisplayLineRangeChoice::setValidityRange(::nds::display::reference::types::DisplayLineValidityRange&& validityRange_)
{
    m_objectChoice = ::std::move(validityRange_);
}

::nds::display::reference::types::DisplayLineGeometryRange& DisplayLineRangeChoice::getGeometryRange()
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>();
}

const ::nds::display::reference::types::DisplayLineGeometryRange& DisplayLineRangeChoice::getGeometryRange() const
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>();
}

void DisplayLineRangeChoice::setGeometryRange(const ::nds::display::reference::types::DisplayLineGeometryRange& geometryRange_)
{
    m_objectChoice = geometryRange_;
}

void DisplayLineRangeChoice::setGeometryRange(::nds::display::reference::types::DisplayLineGeometryRange&& geometryRange_)
{
    m_objectChoice = ::std::move(geometryRange_);
}

::nds::display::reference::types::DisplayLineGeometryOffsetRange& DisplayLineRangeChoice::getGeometryOffsetRange()
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>();
}

const ::nds::display::reference::types::DisplayLineGeometryOffsetRange& DisplayLineRangeChoice::getGeometryOffsetRange() const
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>();
}

void DisplayLineRangeChoice::setGeometryOffsetRange(const ::nds::display::reference::types::DisplayLineGeometryOffsetRange& geometryOffsetRange_)
{
    m_objectChoice = geometryOffsetRange_;
}

void DisplayLineRangeChoice::setGeometryOffsetRange(::nds::display::reference::types::DisplayLineGeometryOffsetRange&& geometryOffsetRange_)
{
    m_objectChoice = ::std::move(geometryOffsetRange_);
}

::nds::display::reference::types::DisplayLinePercentageRange& DisplayLineRangeChoice::getPercentageRange()
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>();
}

const ::nds::display::reference::types::DisplayLinePercentageRange& DisplayLineRangeChoice::getPercentageRange() const
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>();
}

void DisplayLineRangeChoice::setPercentageRange(const ::nds::display::reference::types::DisplayLinePercentageRange& percentageRange_)
{
    m_objectChoice = percentageRange_;
}

void DisplayLineRangeChoice::setPercentageRange(::nds::display::reference::types::DisplayLinePercentageRange&& percentageRange_)
{
    m_objectChoice = ::std::move(percentageRange_);
}

::nds::display::reference::types::CurvedLabelPositioningHint& DisplayLineRangeChoice::getCurvedLabelPositioningHint()
{
    return m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>();
}

const ::nds::display::reference::types::CurvedLabelPositioningHint& DisplayLineRangeChoice::getCurvedLabelPositioningHint() const
{
    return m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>();
}

void DisplayLineRangeChoice::setCurvedLabelPositioningHint(const ::nds::display::reference::types::CurvedLabelPositioningHint& curvedLabelPositioningHint_)
{
    m_objectChoice = curvedLabelPositioningHint_;
}

void DisplayLineRangeChoice::setCurvedLabelPositioningHint(::nds::display::reference::types::CurvedLabelPositioningHint&& curvedLabelPositioningHint_)
{
    m_objectChoice = ::std::move(curvedLabelPositioningHint_);
}

DisplayLineRangeChoice::ChoiceTag DisplayLineRangeChoice::choiceTag() const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return UNDEFINED_CHOICE;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return CHOICE_validityRange;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return CHOICE_geometryRange;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return CHOICE_geometryOffsetRange;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return CHOICE_percentageRange;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return CHOICE_curvedLabelPositioningHint;
    default:
        return UNDEFINED_CHOICE;
    }
}

void DisplayLineRangeChoice::initPackingContext(DisplayLineRangeChoice::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().initPackingContext(context.getValidityRange());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>().initPackingContext(context.getGeometryRange());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().initPackingContext(context.getGeometryOffsetRange());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>().initPackingContext(context.getPercentageRange());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().initPackingContext(context.getCurvedLabelPositioningHint());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }
}

size_t DisplayLineRangeChoice::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>().bitSizeOf(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLineRangeChoice::bitSizeOf(DisplayLineRangeChoice::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().bitSizeOf(context.getValidityRange(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>().bitSizeOf(context.getGeometryRange(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().bitSizeOf(context.getGeometryOffsetRange(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>().bitSizeOf(context.getPercentageRange(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().bitSizeOf(context.getCurvedLabelPositioningHint(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLineRangeChoice::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>().initializeOffsets(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }

    return endBitPosition;
}

size_t DisplayLineRangeChoice::initializeOffsets(DisplayLineRangeChoice::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().initializeOffsets(context.getValidityRange(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>().initializeOffsets(context.getGeometryRange(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().initializeOffsets(context.getGeometryOffsetRange(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>().initializeOffsets(context.getPercentageRange(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().initializeOffsets(context.getCurvedLabelPositioningHint(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }

    return endBitPosition;
}

bool DisplayLineRangeChoice::operator==(const DisplayLineRangeChoice& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType())||
            !(getShift() == other.getShift()))
        return false;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return true; // empty
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>() == other.m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>());
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>() == other.m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>());
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>() == other.m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>());
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>() == other.m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>());
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>() == other.m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }
}

uint32_t DisplayLineRangeChoice::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getShift());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
            // empty
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>());
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>());
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>());
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>());
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>());
            break;
        default:
            break;
        }
    }

    return result;
}

void DisplayLineRangeChoice::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineRangeChoice.validityRange: ") <<
                    m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().write(out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>().write(out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineRangeChoice.geometryOffsetRange: ") <<
                    m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().write(out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>().write(out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineRangeChoice.curvedLabelPositioningHint: ") <<
                    m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }
}

void DisplayLineRangeChoice::write(DisplayLineRangeChoice::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineRangeChoice.validityRange: ") <<
                    m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityRange>().write(context.getValidityRange(), out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryRange>().write(context.getGeometryRange(), out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineRangeChoice.geometryOffsetRange: ") <<
                    m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetRange>().write(context.getGeometryOffsetRange(), out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentageRange>().write(context.getPercentageRange(), out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLineRangeChoice.curvedLabelPositioningHint: ") <<
                    m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().write(context.getCurvedLabelPositioningHint(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }
}

::zserio::AnyHolder<> DisplayLineRangeChoice::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineValidityRange(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineGeometryRange(in, allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineGeometryOffsetRange(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLinePercentageRange(in, allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::CurvedLabelPositioningHint(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }
}

::zserio::AnyHolder<> DisplayLineRangeChoice::readObject(DisplayLineRangeChoice::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineValidityRange(context.getValidityRange(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineGeometryRange(context.getGeometryRange(), in, allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineGeometryOffsetRange(context.getGeometryOffsetRange(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLinePercentageRange(context.getPercentageRange(), in, allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::CurvedLabelPositioningHint(context.getCurvedLabelPositioningHint(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }
}

::zserio::AnyHolder<> DisplayLineRangeChoice::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::DisplayLineValidityRange>(m_objectChoice, allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::DisplayLineGeometryRange>(m_objectChoice, allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::DisplayLineGeometryOffsetRange>(m_objectChoice, allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::DisplayLinePercentageRange>(m_objectChoice, allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::CurvedLabelPositioningHint>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLineRangeChoice!");
    }
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/DisplayLinePositionChoice.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

DisplayLinePositionChoice::DisplayLinePositionChoice(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

DisplayLinePositionChoice::DisplayLinePositionChoice(::zserio::BitStreamReader& in,
        ::nds::display::reference::types::DisplayLineValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

DisplayLinePositionChoice::DisplayLinePositionChoice(DisplayLinePositionChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::display::reference::types::DisplayLineValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

DisplayLinePositionChoice::DisplayLinePositionChoice(const DisplayLinePositionChoice& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLinePositionChoice& DisplayLinePositionChoice::operator=(const DisplayLinePositionChoice& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLinePositionChoice::DisplayLinePositionChoice(DisplayLinePositionChoice&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayLinePositionChoice& DisplayLinePositionChoice::operator=(DisplayLinePositionChoice&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayLinePositionChoice::DisplayLinePositionChoice(::zserio::PropagateAllocatorT,
        const DisplayLinePositionChoice& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

void DisplayLinePositionChoice::initialize(
        ::nds::display::reference::types::DisplayLineValidityType type_,
        ::nds::core::geometry::CoordShift shift_)
{
    m_type_ = type_;
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool DisplayLinePositionChoice::isInitialized() const
{
    return m_isInitialized;
}

void DisplayLinePositionChoice::initializeChildren()
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }
}

::nds::display::reference::types::DisplayLineValidityType DisplayLinePositionChoice::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'DisplayLinePositionChoice' is not initialized!");

    return m_type_;
}

::nds::core::geometry::CoordShift DisplayLinePositionChoice::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'DisplayLinePositionChoice' is not initialized!");

    return m_shift_;
}

::nds::display::reference::types::DisplayLineValidityPosition& DisplayLinePositionChoice::getValidityPosition()
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>();
}

const ::nds::display::reference::types::DisplayLineValidityPosition& DisplayLinePositionChoice::getValidityPosition() const
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>();
}

void DisplayLinePositionChoice::setValidityPosition(const ::nds::display::reference::types::DisplayLineValidityPosition& validityPosition_)
{
    m_objectChoice = validityPosition_;
}

void DisplayLinePositionChoice::setValidityPosition(::nds::display::reference::types::DisplayLineValidityPosition&& validityPosition_)
{
    m_objectChoice = ::std::move(validityPosition_);
}

::nds::display::reference::types::DisplayLineGeometryPosition DisplayLinePositionChoice::getGeometryPosition() const
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>();
}

void DisplayLinePositionChoice::setGeometryPosition(::nds::display::reference::types::DisplayLineGeometryPosition geometryPosition_)
{
    m_objectChoice = geometryPosition_;
}

::nds::display::reference::types::DisplayLineGeometryOffsetPosition& DisplayLinePositionChoice::getGeometryOffsetPosition()
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>();
}

const ::nds::display::reference::types::DisplayLineGeometryOffsetPosition& DisplayLinePositionChoice::getGeometryOffsetPosition() const
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>();
}

void DisplayLinePositionChoice::setGeometryOffsetPosition(const ::nds::display::reference::types::DisplayLineGeometryOffsetPosition& geometryOffsetPosition_)
{
    m_objectChoice = geometryOffsetPosition_;
}

void DisplayLinePositionChoice::setGeometryOffsetPosition(::nds::display::reference::types::DisplayLineGeometryOffsetPosition&& geometryOffsetPosition_)
{
    m_objectChoice = ::std::move(geometryOffsetPosition_);
}

::nds::display::reference::types::DisplayLinePercentagePosition& DisplayLinePositionChoice::getPercentagePosition()
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>();
}

const ::nds::display::reference::types::DisplayLinePercentagePosition& DisplayLinePositionChoice::getPercentagePosition() const
{
    return m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>();
}

void DisplayLinePositionChoice::setPercentagePosition(const ::nds::display::reference::types::DisplayLinePercentagePosition& percentagePosition_)
{
    m_objectChoice = percentagePosition_;
}

void DisplayLinePositionChoice::setPercentagePosition(::nds::display::reference::types::DisplayLinePercentagePosition&& percentagePosition_)
{
    m_objectChoice = ::std::move(percentagePosition_);
}

::nds::display::reference::types::CurvedLabelPositioningHint& DisplayLinePositionChoice::getCurvedLabelPositioningHint()
{
    return m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>();
}

const ::nds::display::reference::types::CurvedLabelPositioningHint& DisplayLinePositionChoice::getCurvedLabelPositioningHint() const
{
    return m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>();
}

void DisplayLinePositionChoice::setCurvedLabelPositioningHint(const ::nds::display::reference::types::CurvedLabelPositioningHint& curvedLabelPositioningHint_)
{
    m_objectChoice = curvedLabelPositioningHint_;
}

void DisplayLinePositionChoice::setCurvedLabelPositioningHint(::nds::display::reference::types::CurvedLabelPositioningHint&& curvedLabelPositioningHint_)
{
    m_objectChoice = ::std::move(curvedLabelPositioningHint_);
}

DisplayLinePositionChoice::ChoiceTag DisplayLinePositionChoice::choiceTag() const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return UNDEFINED_CHOICE;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return CHOICE_validityPosition;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return CHOICE_geometryPosition;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return CHOICE_geometryOffsetPosition;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return CHOICE_percentagePosition;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return CHOICE_curvedLabelPositioningHint;
    default:
        return UNDEFINED_CHOICE;
    }
}

void DisplayLinePositionChoice::initPackingContext(DisplayLinePositionChoice::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().initPackingContext(context.getValidityPosition());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        context.getGeometryPosition().init<::zserio::VarSizeArrayTraits>(m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().initPackingContext(context.getGeometryOffsetPosition());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>().initPackingContext(context.getPercentagePosition());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().initPackingContext(context.getCurvedLabelPositioningHint());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }
}

size_t DisplayLinePositionChoice::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        endBitPosition += ::zserio::bitSizeOfVarSize(m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>().bitSizeOf(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLinePositionChoice::bitSizeOf(DisplayLinePositionChoice::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().bitSizeOf(context.getValidityPosition(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        endBitPosition += context.getGeometryPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().bitSizeOf(context.getGeometryOffsetPosition(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>().bitSizeOf(context.getPercentagePosition(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().bitSizeOf(context.getCurvedLabelPositioningHint(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t DisplayLinePositionChoice::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        endBitPosition += ::zserio::bitSizeOfVarSize(m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>().initializeOffsets(endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }

    return endBitPosition;
}

size_t DisplayLinePositionChoice::initializeOffsets(DisplayLinePositionChoice::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().initializeOffsets(context.getValidityPosition(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        endBitPosition += context.getGeometryPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().initializeOffsets(context.getGeometryOffsetPosition(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>().initializeOffsets(context.getPercentagePosition(), endBitPosition);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().initializeOffsets(context.getCurvedLabelPositioningHint(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }

    return endBitPosition;
}

bool DisplayLinePositionChoice::operator==(const DisplayLinePositionChoice& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType())||
            !(getShift() == other.getShift()))
        return false;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return true; // empty
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>() == other.m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>());
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>() == other.m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>());
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>() == other.m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>());
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>() == other.m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>());
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>() == other.m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }
}

uint32_t DisplayLinePositionChoice::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getShift());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
            // empty
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>());
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>());
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>());
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>());
            break;
        case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>());
            break;
        default:
            break;
        }
    }

    return result;
}

void DisplayLinePositionChoice::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLinePositionChoice.validityPosition: ") <<
                    m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().write(out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        out.writeVarSize(m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLinePositionChoice.geometryOffsetPosition: ") <<
                    m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().write(out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>().write(out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLinePositionChoice.curvedLabelPositioningHint: ") <<
                    m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }
}

void DisplayLinePositionChoice::write(DisplayLinePositionChoice::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLinePositionChoice.validityPosition: ") <<
                    m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::DisplayLineValidityPosition>().write(context.getValidityPosition(), out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        context.getGeometryPosition().write<::zserio::VarSizeArrayTraits>(out, m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryPosition>());
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLinePositionChoice.geometryOffsetPosition: ") <<
                    m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>().write(context.getGeometryOffsetPosition(), out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        m_objectChoice.get<::nds::display::reference::types::DisplayLinePercentagePosition>().write(context.getPercentagePosition(), out);
        break;
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayLinePositionChoice.curvedLabelPositioningHint: ") <<
                    m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::CurvedLabelPositioningHint>().write(context.getCurvedLabelPositioningHint(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }
}

::zserio::AnyHolder<> DisplayLinePositionChoice::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineValidityPosition(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(static_cast<::nds::display::reference::types::DisplayLineGeometryPosition>(in.readVarSize()), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineGeometryOffsetPosition(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLinePercentagePosition(in, allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::CurvedLabelPositioningHint(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }
}

::zserio::AnyHolder<> DisplayLinePositionChoice::readObject(DisplayLinePositionChoice::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineValidityPosition(context.getValidityPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return ::zserio::AnyHolder<>(context.getGeometryPosition().read<::zserio::VarSizeArrayTraits>(in), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLineGeometryOffsetPosition(context.getGeometryOffsetPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::DisplayLinePercentagePosition(context.getPercentagePosition(), in, allocator), allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::CurvedLabelPositioningHint(context.getCurvedLabelPositioningHint(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }
}

::zserio::AnyHolder<> DisplayLinePositionChoice::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayLineValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::POSITION:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::DisplayLineValidityPosition>(m_objectChoice, allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::DisplayLineGeometryPosition>(m_objectChoice, allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::GEOMETRY_OFFSET:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::DisplayLineGeometryOffsetPosition>(m_objectChoice, allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::PERCENTAGE:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::DisplayLinePercentagePosition>(m_objectChoice, allocator);
    case ::nds::display::reference::types::DisplayLineValidityType::CURVED_LABEL_POSITIONING_HINT:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::CurvedLabelPositioningHint>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayLinePositionChoice!");
    }
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/reference/types/DisplayAreaChoice.h>

namespace nds
{
namespace display
{
namespace reference
{
namespace types
{

DisplayAreaChoice::DisplayAreaChoice(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

DisplayAreaChoice::DisplayAreaChoice(::zserio::BitStreamReader& in,
        ::nds::display::reference::types::DisplayAreaValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

DisplayAreaChoice::DisplayAreaChoice(DisplayAreaChoice::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::display::reference::types::DisplayAreaValidityType type_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_type_(type_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

DisplayAreaChoice::DisplayAreaChoice(const DisplayAreaChoice& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayAreaChoice& DisplayAreaChoice::operator=(const DisplayAreaChoice& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayAreaChoice::DisplayAreaChoice(DisplayAreaChoice&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

DisplayAreaChoice& DisplayAreaChoice::operator=(DisplayAreaChoice&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

DisplayAreaChoice::DisplayAreaChoice(::zserio::PropagateAllocatorT,
        const DisplayAreaChoice& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shift_);
    else
        m_isInitialized = false;
}

void DisplayAreaChoice::initialize(
        ::nds::display::reference::types::DisplayAreaValidityType type_,
        ::nds::core::geometry::CoordShift shift_)
{
    m_type_ = type_;
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool DisplayAreaChoice::isInitialized() const
{
    return m_isInitialized;
}

void DisplayAreaChoice::initializeChildren()
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }
}

::nds::display::reference::types::DisplayAreaValidityType DisplayAreaChoice::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'DisplayAreaChoice' is not initialized!");

    return m_type_;
}

::nds::core::geometry::CoordShift DisplayAreaChoice::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'DisplayAreaChoice' is not initialized!");

    return m_shift_;
}

::nds::display::reference::types::LabelPositioningHint& DisplayAreaChoice::getHint()
{
    return m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>();
}

const ::nds::display::reference::types::LabelPositioningHint& DisplayAreaChoice::getHint() const
{
    return m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>();
}

void DisplayAreaChoice::setHint(const ::nds::display::reference::types::LabelPositioningHint& hint_)
{
    m_objectChoice = hint_;
}

void DisplayAreaChoice::setHint(::nds::display::reference::types::LabelPositioningHint&& hint_)
{
    m_objectChoice = ::std::move(hint_);
}

DisplayAreaChoice::ChoiceTag DisplayAreaChoice::choiceTag() const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        return UNDEFINED_CHOICE;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        return CHOICE_hint;
    default:
        return UNDEFINED_CHOICE;
    }
}

void DisplayAreaChoice::initPackingContext(DisplayAreaChoice::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().initPackingContext(context.getHint());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }
}

size_t DisplayAreaChoice::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t DisplayAreaChoice::bitSizeOf(DisplayAreaChoice::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        endBitPosition += m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().bitSizeOf(context.getHint(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }

    return endBitPosition - bitPosition;
}

size_t DisplayAreaChoice::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }

    return endBitPosition;
}

size_t DisplayAreaChoice::initializeOffsets(DisplayAreaChoice::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        endBitPosition = m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().initializeOffsets(context.getHint(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }

    return endBitPosition;
}

bool DisplayAreaChoice::operator==(const DisplayAreaChoice& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType())||
            !(getShift() == other.getShift()))
        return false;

    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        return true; // empty
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>() == other.m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }
}

uint32_t DisplayAreaChoice::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getShift());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
            // empty
            break;
        case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>());
            break;
        default:
            break;
        }
    }

    return result;
}

void DisplayAreaChoice::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayAreaChoice.hint: ") <<
                    m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }
}

void DisplayAreaChoice::write(DisplayAreaChoice::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        // empty
        break;
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        // check parameters
        if (m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field DisplayAreaChoice.hint: ") <<
                    m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_objectChoice.get<::nds::display::reference::types::LabelPositioningHint>().write(context.getHint(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }
}

::zserio::AnyHolder<> DisplayAreaChoice::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::LabelPositioningHint(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }
}

::zserio::AnyHolder<> DisplayAreaChoice::readObject(DisplayAreaChoice::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        return ::zserio::AnyHolder<>(::nds::display::reference::types::LabelPositioningHint(context.getHint(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }
}

::zserio::AnyHolder<> DisplayAreaChoice::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::display::reference::types::DisplayAreaValidityType::COMPLETE:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::display::reference::types::DisplayAreaValidityType::LABEL_POSITIONING_HINT:
        return ::zserio::allocatorPropagatingCopy<::nds::display::reference::types::LabelPositioningHint>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice DisplayAreaChoice!");
    }
}

} // namespace types
} // namespace reference
} // namespace display
} // namespace nds
